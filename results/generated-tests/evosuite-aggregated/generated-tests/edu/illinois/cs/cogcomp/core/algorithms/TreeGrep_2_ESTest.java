/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 19:39:24 GMT 2025
 */

package edu.illinois.cs.cogcomp.core.algorithms;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrep;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch;
import edu.illinois.cs.cogcomp.core.datastructures.trees.Tree;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.pipeline.QuoteAttributionAnnotator;
import java.time.temporal.ChronoField;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.PriorityQueue;
import java.util.Stack;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class TreeGrep_2_ESTest extends TreeGrep_2_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testFailsToCreateTreeGrepThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Object object1 = new Object();
      tree0.addLeaf(object0, object1);
      Tree<Object> tree1 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      TreeGrep.endOfChildrenString = "java.lang.Integer@0000000004";
      treeGrep0.doesThisTreeMatch(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      Object object2 = new Object();
      treeGrep0.doesThisTreeMatch(tree0);
      tree1.addSubtree(tree0);
      treeGrep0.getMatches();
      treeGrep0.doesNodeMatchPattern(tree0, tree1, list0);
      treeGrep0.getPattern();
      Tree<Integer> tree2 = new Tree<Integer>();
      Tree<Tree<Integer>> tree3 = new Tree<Tree<Integer>>(tree2);
      // Undeclared exception!
      try { 
        tree3.getChild((-1));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
      
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      tree0.addLeaf(object0);
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "T@sI");
      tree0.addLeaf((Object) treeGrep0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testToStringAndDoesNodeMatchPattern()  throws Throwable  {
      System.setCurrentTimeMillis(1024L);
      System.setCurrentTimeMillis(1024L);
      Word word0 = new Word("frig");
      LabeledWord labeledWord0 = new LabeledWord("frig", word0);
      Tree<LabeledWord> tree0 = new Tree<LabeledWord>(labeledWord0);
      TreeGrep<LabeledWord> treeGrep0 = new TreeGrep<LabeledWord>(tree0);
      labeledWord0.setWord("eet");
      TreeGrep.startOfChildrenString = "java.lang.Integer@0000000004";
      treeGrep0.verbose = true;
      tree0.getHeight();
      ArrayList<TreeGrepMatch<LabeledWord>> arrayList0 = new ArrayList<TreeGrepMatch<LabeledWord>>();
      TreeGrepMatch<LabeledWord> treeGrepMatch0 = new TreeGrepMatch<LabeledWord>(tree0);
      arrayList0.add(treeGrepMatch0);
      treeGrep0.doesNodeMatchPattern(tree0, tree0, arrayList0);
      System.setCurrentTimeMillis((-174L));
      treeGrep0.toString();
      Random.setNextRandom(1);
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch1 = new TreeGrepMatch<Object>(tree1);
      Tree<Object> tree2 = treeGrepMatch1.getPattern();
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree2);
      treeGrep1.toString();
      Integer integer0 = new Integer(1);
      Tree<Integer> tree3 = new Tree<Integer>(integer0);
      // Undeclared exception!
      try { 
        tree3.getChild(2204);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 2204, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereHasEdgeLabelsIsFalse()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Tree<Object> tree1 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      TreeGrep.endOfChildrenString = "eet";
      treeGrep0.doesThisTreeMatch(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      Object object1 = new Object();
      treeGrep0.doesThisTreeMatch(tree0);
      tree1.addSubtree(tree0);
      treeGrep0.getMatches();
      treeGrep0.doesNodeMatchPattern(tree0, tree1, list0);
      Tree<Object> tree2 = treeGrep0.getPattern();
      assertSame(tree0, tree2);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      tree0.addLeaf((Object) treeGrep0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      linkedList0.add(treeGrepMatch0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertFalse(list0.contains(treeGrepMatch0));
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      tree0.addLeaf(object0);
      tree0.addLeaf((Object) treeGrep0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Stack<TreeGrepMatch<Object>> stack0 = new Stack<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      stack0.add(treeGrepMatch0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, stack0);
      assertEquals(1, stack0.size());
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse0()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      Integer integer0 = new Integer((-1805));
      Tree<Object> tree1 = new Tree<Object>(integer0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree1);
      Object object0 = new Object();
      tree1.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      boolean boolean0 = treeGrep0.matches(tree1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      tree0.addLeaf((Object) treeGrep0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse2()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Tree<Object> tree1 = new Tree<Object>(object0);
      Object object1 = new Object();
      tree1.addLeaf(object1);
      ChronoField chronoField0 = ChronoField.MONTH_OF_YEAR;
      tree0.addLeaf((Object) chronoField0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndMatches()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      tree0.addLeaf((Object) treeGrep0);
      tree0.addLeaf(object0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse3()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      Integer integer0 = new Integer((-1805));
      Tree<Object> tree1 = new Tree<Object>(integer0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree1);
      Object object0 = new Object();
      Object object1 = new Object();
      tree1.addLeaf(object1);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      boolean boolean0 = treeGrep0.matches(tree1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException2()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.clone();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree0);
      treeGrep1.doesThisTreeMatch(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep1.getMatches();
      int int0 = 3386;
      Integer integer0 = new Integer(3386);
      Integer integer1 = new Integer(2642);
      tree0.addLeaf((Object) integer1);
      TreeGrep<Tree<Object>> treeGrep2 = new TreeGrep<Tree<Object>>((Tree<Tree<Object>>) null);
      // Undeclared exception!
      try { 
        treeGrep1.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndDoesThisTreeMatchAndGetMatches()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
      
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      tree0.addLeaf((Object) list0);
      assertEquals(1, list0.size());
      
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      TreeGrepMatch<Object> treeGrepMatch1 = new TreeGrepMatch<Object>(treeGrepMatch0);
      vector0.add(treeGrepMatch1);
      List<TreeGrepMatch<Object>> list1 = treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertFalse(list1.contains(treeGrepMatch1));
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException3()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      tree0.addLeaf(object0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse4()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      tree0.addLeaf((Object) treeGrep0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse5()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
      
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerException0()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerException()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Tree<Object> tree1 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Object object1 = new Object();
      Object object2 = new Object();
      tree1.addLeaf(object2);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      treeGrep0.matches(tree0);
      Tree<Integer> tree2 = new Tree<Integer>();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree2);
      // Undeclared exception!
      try { 
        treeGrep1.doesThisTreeMatch(tree2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternWithEmptyList()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      Integer integer0 = new Integer(0);
      Tree<Object> tree1 = new Tree<Object>(integer0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree1);
      Object object0 = new Object();
      tree1.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      ArrayList<TreeGrepMatch<Object>> arrayList0 = new ArrayList<TreeGrepMatch<Object>>();
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree1, tree1, arrayList0);
      assertEquals(0, arrayList0.size());
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      Object object0 = new Object();
      Object object1 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object1);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      tree0.clone();
      treeGrep0.doesThisTreeMatch(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      Tree.readTreeFromString("Fj|fIWj{92?tdpU");
      Integer integer0 = new Integer((-1));
      TreeGrep<Tree<Object>> treeGrep1 = new TreeGrep<Tree<Object>>((Tree<Tree<Object>>) null);
      Tree<Tree<Object>> tree1 = new Tree<Tree<Object>>(tree0);
      tree1.addLeaf(tree0, tree0);
      TreeGrep<Tree<Object>> treeGrep2 = new TreeGrep<Tree<Object>>(tree1);
      treeGrep2.getPattern();
      tree0.getParent();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern((Tree<Object>) null, tree0, list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndDoesNodeMatchPattern()  throws Throwable  {
      Object object0 = new Object();
      Integer integer0 = new Integer((-1212));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      Tree<Object> tree1 = new Tree<Object>(tree0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      Object object1 = new Object();
      boolean boolean0 = treeGrep0.verbose;
      tree1.clone();
      Integer integer1 = new Integer((-1574));
      Tree<Object> tree2 = new Tree<Object>(integer1);
      treeGrep0.doesThisTreeMatch(tree2);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      Integer integer2 = new Integer(2101);
      ArrayDeque<Tree<Integer>> arrayDeque0 = new ArrayDeque<Tree<Integer>>();
      arrayDeque0.clone();
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree1);
      List<TreeGrepMatch<Object>> list1 = treeGrep1.doesNodeMatchPattern(tree2, tree2, list0);
      TreeGrep<Tree<Object>> treeGrep2 = new TreeGrep<Tree<Object>>((Tree<Tree<Object>>) null);
      treeGrep2.getPattern();
      // Undeclared exception!
      try { 
        treeGrep1.doesNodeMatchPattern(tree2, tree2, list1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsIndexOutOfBoundsException()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Object object1 = new Object();
      treeGrep0.doesLabelMatchPatternLabel(object1, object0);
      treeGrep0.doesThisTreeMatch(tree0);
      TreeGrep.endOfChildrenString = "eet";
      tree0.clone();
      Tree<CategoryWordTag> tree1 = new Tree<CategoryWordTag>();
      TreeGrep<CategoryWordTag> treeGrep1 = new TreeGrep<CategoryWordTag>(tree1);
      treeGrep1.getMatches();
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      Integer integer0 = new Integer(1);
      ArrayDeque<Tree<Integer>> arrayDeque0 = new ArrayDeque<Tree<Integer>>();
      arrayDeque0.clone();
      PriorityQueue<Integer> priorityQueue0 = new PriorityQueue<Integer>();
      Tree<Object> tree2 = new Tree<Object>();
      treeGrep0.doesNodeMatchPattern(tree0, tree2, list0);
      Tree<CategoryWordTag> tree3 = new Tree<CategoryWordTag>();
      // Undeclared exception!
      try { 
        tree1.getChild(1);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 1, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatch()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Object object1 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object1);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetMatchesReturningListWhereSizeIsZero()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Tree<Object> tree1 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      Object object1 = new Object();
      boolean boolean0 = treeGrep0.verbose;
      tree1.clone();
      treeGrep0.doesThisTreeMatch(tree0);
      TreeGrep<CategoryWordTag> treeGrep1 = new TreeGrep<CategoryWordTag>((Tree<CategoryWordTag>) null);
      TreeGrep<CategoryWordTag> treeGrep2 = new TreeGrep<CategoryWordTag>((Tree<CategoryWordTag>) null);
      treeGrep2.getMatches();
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      Integer integer0 = new Integer((-1));
      ArrayDeque<Tree<Integer>> arrayDeque0 = new ArrayDeque<Tree<Integer>>();
      arrayDeque0.clone();
      PriorityQueue<Integer> priorityQueue0 = new PriorityQueue<Integer>();
      Tree<Object> tree2 = new Tree<Object>();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree2, tree2, list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue1()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Tree<Object> tree1 = new Tree<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningNull()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      ArrayDeque<Tree<Integer>> arrayDeque0 = new ArrayDeque<Tree<Integer>>();
      arrayDeque0.clone();
      PriorityQueue<Integer> priorityQueue0 = new PriorityQueue<Integer>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      Stack<TreeGrepMatch<Object>> stack0 = new Stack<TreeGrepMatch<Object>>();
      List<TreeGrepMatch<Object>> list0 = new LinkedList<TreeGrepMatch<Object>>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("FleiRs", " matches ", "FleiRs");
      Tree<CategoryWordTag> tree1 = new Tree<CategoryWordTag>(categoryWordTag0);
      TreeGrep<CategoryWordTag> treeGrep1 = new TreeGrep<CategoryWordTag>(tree1);
      treeGrep1.doesThisTreeMatch(tree1);
      TreeGrep<Tree<Object>> treeGrep2 = new TreeGrep<Tree<Object>>((Tree<Tree<Object>>) null);
      treeGrep2.getPattern();
      List<TreeGrepMatch<Object>> list1 = treeGrep0.doesNodeMatchPattern(tree0, tree0, stack0);
      assertFalse(stack0.isEmpty());
      assertFalse(list1.equals((Object)list0));
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Tree<Object> tree1 = treeGrepMatch0.getPattern();
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree0);
      treeGrep1.doesThisTreeMatch(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep1.getMatches();
      Stack<List<TreeGrepMatch<Object>>> stack0 = new Stack<List<TreeGrepMatch<Object>>>();
      stack0.add(list0);
      Stack<TreeGrepMatch<Object>> stack1 = new Stack<TreeGrepMatch<Object>>();
      stack1.add(treeGrepMatch0);
      treeGrep0.mergeChildrenMatches(stack0, stack1);
      ArrayDeque<Tree<Integer>> arrayDeque0 = new ArrayDeque<Tree<Integer>>();
      Integer integer0 = new Integer(14);
      Tree<Object> tree2 = treeGrepMatch0.getPattern();
      TreeGrep<Object> treeGrep2 = new TreeGrep<Object>(tree2);
      treeGrep1.getPattern();
      TreeGrep<Object> treeGrep3 = new TreeGrep<Object>(tree0);
      treeGrep0.matches(tree1);
      List<TreeGrepMatch<Object>> list1 = treeGrep3.getMatches();
      assertNull(list1);
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatches()  throws Throwable  {
      ArrayList<Locale.FilteringMode> arrayList0 = new ArrayList<Locale.FilteringMode>();
      Tree<List<Locale.FilteringMode>> tree0 = new Tree<List<Locale.FilteringMode>>(arrayList0);
      TreeGrep<List<Locale.FilteringMode>> treeGrep0 = new TreeGrep<List<Locale.FilteringMode>>(tree0);
      ArrayList<List<TreeGrepMatch<List<Locale.FilteringMode>>>> arrayList1 = new ArrayList<List<TreeGrepMatch<List<Locale.FilteringMode>>>>();
      Stack<TreeGrepMatch<List<Locale.FilteringMode>>> stack0 = new Stack<TreeGrepMatch<List<Locale.FilteringMode>>>();
      arrayList1.add((List<TreeGrepMatch<List<Locale.FilteringMode>>>) stack0);
      Stack<TreeGrepMatch<List<Locale.FilteringMode>>> stack1 = new Stack<TreeGrepMatch<List<Locale.FilteringMode>>>();
      stack1.trimToSize();
      List<TreeGrepMatch<List<Locale.FilteringMode>>> list0 = treeGrep0.mergeChildrenMatches(arrayList1, stack1);
      assertTrue(arrayList1.contains(list0));
      assertNotNull(list0);
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesAndMatches()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Object object1 = new Object();
      boolean boolean0 = treeGrep0.verbose;
      tree0.clone();
      treeGrep0.doesThisTreeMatch(tree0);
      boolean boolean1 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean1);
      
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      Stack<List<TreeGrepMatch<Object>>> stack0 = new Stack<List<TreeGrepMatch<Object>>>();
      stack0.add(list0);
      assertEquals(1, list0.size());
      
      Stack<TreeGrepMatch<Object>> stack1 = new Stack<TreeGrepMatch<Object>>();
      List<TreeGrepMatch<Object>> list1 = treeGrep0.mergeChildrenMatches(stack0, stack1);
      assertEquals(0, list1.size());
      
      ArrayDeque<Tree<Integer>> arrayDeque0 = new ArrayDeque<Tree<Integer>>();
      Integer integer0 = new Integer(0);
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      arrayDeque0.add(tree1);
      arrayDeque0.clone();
      PriorityQueue<Integer> priorityQueue0 = new PriorityQueue<Integer>();
      Tree<CategoryWordTag> tree2 = new Tree<CategoryWordTag>();
      boolean boolean2 = treeGrep0.matches(tree0);
      assertFalse(boolean2 == boolean0);
      assertTrue(boolean2);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse6()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternReturningListWhereSizeIsPositive()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>(195, (-2026568364));
      Tree<Object> tree1 = new Tree<Object>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree1);
      TreeGrepMatch<Object> treeGrepMatch1 = new TreeGrepMatch<Object>(treeGrepMatch0);
      vector0.add(treeGrepMatch1);
      List<TreeGrepMatch<Object>> list1 = treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertEquals(1, vector0.size());
      assertFalse(list1.equals((Object)list0));
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabel()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Object object1 = new Object();
      treeGrep0.doesLabelMatchPatternLabel(object1, object0);
      treeGrep0.doesThisTreeMatch(tree0);
      TreeGrep.endOfChildrenString = "eet";
      tree0.clone();
      treeGrep0.matches(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<CategoryWordTag> tree1 = null;
      TreeGrep<CategoryWordTag> treeGrep1 = new TreeGrep<CategoryWordTag>((Tree<CategoryWordTag>) null);
      treeGrep1.getMatches();
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      Integer integer0 = new Integer((-1));
      Tree<Integer> tree2 = new Tree<Integer>(integer0);
      tree2.addLeaf(integer0);
      Tree<Integer> tree3 = tree2.getChild(0);
      ArrayDeque<Tree<Integer>> arrayDeque0 = new ArrayDeque<Tree<Integer>>();
      ArrayDeque<Tree<Integer>> arrayDeque1 = arrayDeque0.clone();
      PriorityQueue<Integer> priorityQueue0 = new PriorityQueue<Integer>();
      tree3.addSubtrees((Iterable<Tree<Integer>>) arrayDeque1, (Iterable<Integer>) priorityQueue0);
      TreeGrep<Integer> treeGrep2 = new TreeGrep<Integer>(tree3);
      TreeGrep.startOfChildrenString = "eet";
      treeGrep2.toString();
      treeGrep2.doesThisTreeMatch(tree2);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException4()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelReturningTrue()  throws Throwable  {
      Tree<CoreLabel> tree0 = new Tree<CoreLabel>();
      TreeGrep<CoreLabel> treeGrep0 = new TreeGrep<CoreLabel>(tree0);
      TreeGrep.startOfChildrenString = "eet";
      CoreLabel coreLabel0 = CoreLabel.wordFromString((String) null);
      CoreLabel coreLabel1 = new CoreLabel(coreLabel0);
      Class<QuoteAttributionAnnotator.SpeakerSieveAnnotation> class0 = QuoteAttributionAnnotator.SpeakerSieveAnnotation.class;
      String string0 = "EYOS@paI2[],O=";
      coreLabel1.getString(class0, "EYOS@paI2[],O=");
      tree0.clone();
      treeGrep0.doesLabelMatchPatternLabel(coreLabel1, coreLabel1);
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsNullPointerException()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.getPattern();
      TreeGrep<List<Object>> treeGrep1 = new TreeGrep<List<Object>>((Tree<List<Object>>) null);
      LinkedList<TreeGrepMatch<List<Object>>> linkedList0 = new LinkedList<TreeGrepMatch<List<Object>>>();
      // Undeclared exception!
      try { 
        treeGrep1.mergeChildrenMatches((List<List<TreeGrepMatch<List<Object>>>>) null, linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.math.Permutations", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse7()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("", "");
      tree0.addLeaf((Object) wordLemmaTag0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.matches(tree0);
  }

  @Test(timeout = 4000)
  public void testMatchesReturningFalse()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Tree<Object> tree1 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      Object object1 = new Object();
      boolean boolean0 = treeGrep0.verbose;
      tree1.clone();
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<CategoryWordTag> tree2 = null;
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree1);
      treeGrep1.matches(tree0);
      Tree<Object> tree3 = treeGrep0.getPattern();
      // Undeclared exception!
      try { 
        treeGrep1.doesThisTreeMatch(tree3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesAndToString()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      Integer integer0 = new Integer(0);
      Tree<Object> tree1 = new Tree<Object>(integer0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree1);
      Object object0 = new Object();
      tree1.addLeaf(object0);
      Tree<Tree<Integer>> tree2 = new Tree<Tree<Integer>>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      TreeGrep.endOfChildrenString = "eet";
      treeGrep0.toString();
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Tree<Object> tree1 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      treeGrep0.doesThisTreeMatch(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      int int0 = 161;
      tree1.toString();
      Object object1 = new Object();
      tree0.addLeaf(object0, object1);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue2()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsIllegalArgumentException()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Object object1 = new Object();
      treeGrep0.doesLabelMatchPatternLabel(object1, object0);
      treeGrep0.doesThisTreeMatch(tree0);
      TreeGrep.endOfChildrenString = "eet";
      tree0.clone();
      treeGrep0.matches(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<CategoryWordTag> tree1 = null;
      TreeGrep<CategoryWordTag> treeGrep1 = new TreeGrep<CategoryWordTag>((Tree<CategoryWordTag>) null);
      treeGrep1.getMatches();
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      Stack<List<TreeGrepMatch<Object>>> stack0 = new Stack<List<TreeGrepMatch<Object>>>();
      // Undeclared exception!
      try { 
        treeGrep0.mergeChildrenMatches(stack0, list0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // fromIndex(0) > toIndex(-1)
         //
         verifyException("java.util.SubList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesWithNull()  throws Throwable  {
      Tree<IndexedWord> tree0 = null;
      TreeGrep<IndexedWord> treeGrep0 = new TreeGrep<IndexedWord>((Tree<IndexedWord>) null);
      List<TreeGrepMatch<IndexedWord>> list0 = null;
      // Undeclared exception!
      try { 
        treeGrep0.matches((Tree<IndexedWord>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.datastructures.trees.TreeTraversal", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateTreeGrepThrowsIndexOutOfBoundsException()  throws Throwable  {
      Integer integer0 = new Integer((-1446));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      TreeGrep.endOfChildrenString = "eet";
      treeGrep0.toString();
      treeGrep0.toString();
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      tree0.clone();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree1);
      Tree<Object> tree2 = treeGrepMatch0.getPattern();
      tree2.getParent();
      int int0 = (-1);
      // Undeclared exception!
      try { 
        tree1.addSubtreeAt(tree2, 3592);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 3592, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerException1()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      TreeGrep<Tree<Integer>> treeGrep0 = new TreeGrep<Tree<Integer>>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetMatchesAndDoesThisTreeMatchThrowsNullPointerException()  throws Throwable  {
      LabeledWord labeledWord0 = new LabeledWord("Z7fvXg");
      Tree<Object> tree0 = new Tree<Object>(labeledWord0);
      labeledWord0.setBeginPosition(0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.getMatches();
      Tree<Word> tree1 = null;
      TreeGrep<Word> treeGrep1 = new TreeGrep<Word>((Tree<Word>) null);
      // Undeclared exception!
      try { 
        treeGrep1.doesThisTreeMatch((Tree<Word>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetMatches()  throws Throwable  {
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testGetPattern()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      Tree<Integer> tree1 = treeGrep0.getPattern();
      assertTrue(tree1.isRoot());
  }

  @Test(timeout = 4000)
  public void testToStringThrowsNullPointerException()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testToStringAndToStringThrowsNullPointerException()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.getParent();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      // Undeclared exception!
      try { 
        treeGrep0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesTreeGrep()  throws Throwable  {
      Integer integer0 = new Integer((-1101));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      tree0.getHeight();
      Vector<TreeGrepMatch<Integer>> vector0 = null;
      try {
        vector0 = new Vector<TreeGrepMatch<Integer>>((-1101), (-938));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Illegal Capacity: -1101
         //
         verifyException("java.util.Vector", e);
      }
  }
}
