/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 19:39:14 GMT 2025
 */

package edu.illinois.cs.cogcomp.core.algorithms;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrep;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch;
import edu.illinois.cs.cogcomp.core.datastructures.trees.Tree;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordTagFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import java.io.PrintWriter;
import java.lang.reflect.Array;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFileOutputStream;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.evosuite.runtime.mock.java.io.MockPrintWriter;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import org.ojalgo.scalar.RationalNumber;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class TreeGrep_5_ESTest extends TreeGrep_5_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereHasEdgeLabelsIsTrue()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Object object1 = new Object();
      tree0.addLeaf(object0);
      tree0.addLeaf(object0);
      Object object2 = new Object();
      Tree<Object> tree1 = tree0.getChild(0);
      tree1.addLeaf(object2);
      tree0.addLeaf(object1);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      treeGrep0.matches(tree1);
      Tree<Object> tree2 = treeGrep0.getPattern();
      assertSame(tree2, tree1);
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereHasEdgeLabelsIsFalse()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      Object object1 = new Object();
      tree0.addLeaf(object0);
      Tree<Object> tree1 = tree0.getChild(0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      treeGrep0.getPattern();
      int int0 = (-2024296458);
      CoreLabel coreLabel0 = null;
      try {
        coreLabel0 = new CoreLabel((-2024296458));
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.util.ArrayCoreMap", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Vector<List<TreeGrepMatch<Object>>> vector0 = new Vector<List<TreeGrepMatch<Object>>>();
      Stack<TreeGrepMatch<Object>> stack0 = new Stack<TreeGrepMatch<Object>>();
      vector0.add((List<TreeGrepMatch<Object>>) stack0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      stack0.add(treeGrepMatch0);
      stack0.stream();
      treeGrep0.mergeChildrenMatches(vector0, stack0);
      Tree<Integer> tree1 = new Tree<Integer>();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Integer integer0 = new Integer((-735));
      tree1.addLeaf(integer0);
      // Undeclared exception!
      try { 
        tree1.getChild(768);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 768, Size: 1
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Object object1 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      Object object2 = new Object();
      Integer integer0 = new Integer(1);
      tree0.addLeaf((Object) integer0);
      tree1.addLeaf(object2);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesWithTreeWhereSizeIsPositive()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.addLeaf(object0);
      tree0.addLeaf((Object) tree0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      // Undeclared exception!
      treeGrep0.matches(tree0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse1()  throws Throwable  {
      Object object0 = new Object();
      Integer integer0 = new Integer(652);
      Tree<Object> tree0 = new Tree<Object>(integer0);
      Object object1 = new Object();
      tree0.addLeaf(object1);
      Integer integer1 = new Integer(652);
      tree0.addLeaf((Object) integer1);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      TreeGrep.endOfChildrenString = "/vOII81~@bW4";
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse2()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Object object1 = new Object();
      tree0.addLeaf(object1);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Object object1 = new Object();
      Stack<TreeGrepMatch<Object>> stack0 = new Stack<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      stack0.add(treeGrepMatch0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      treeGrep0.doesNodeMatchPattern(tree0, tree0, stack0);
      assertEquals(1, stack0.size());
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerExceptionAndMatches()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Object object1 = new Object();
      tree0.addLeaf(object0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
      
      Stack<List<TreeGrepMatch<TaggedWord>>> stack0 = new Stack<List<TreeGrepMatch<TaggedWord>>>();
      Stack<TreeGrepMatch<TaggedWord>> stack1 = new Stack<TreeGrepMatch<TaggedWord>>();
      Tree<Object> tree1 = null;
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch((Tree<Object>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse3()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.addLeaf(object0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndGetPattern()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Object object1 = new Object();
      tree0.addLeaf(object0);
      LabelFactory labelFactory0 = LabeledWord.factory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      vector0.add(treeGrepMatch0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      Tree<LabeledWord> tree1 = new Tree<LabeledWord>();
      TreeGrep<LabeledWord> treeGrep1 = new TreeGrep<LabeledWord>(tree1);
      Tree<LabeledWord> tree2 = treeGrep1.getPattern();
      assertEquals(0, tree2.getNumberOfChildren());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.addLeaf(object0);
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      vector0.add(treeGrepMatch0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertFalse(list0.isEmpty());
      assertFalse(list0.contains(treeGrepMatch0));
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern2()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Stack<TreeGrepMatch<Object>> stack0 = new Stack<TreeGrepMatch<Object>>();
      stack0.add(treeGrepMatch0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, stack0);
      assertEquals(1, stack0.size());
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerExceptionAndDoesNodeMatchPattern()  throws Throwable  {
      LabeledWord labeledWord0 = new LabeledWord("63d7W,eZ!i}Lc3");
      Tree<LabeledWord> tree0 = new Tree<LabeledWord>(labeledWord0);
      TreeGrep<LabeledWord> treeGrep0 = new TreeGrep<LabeledWord>(tree0);
      ArrayList<TreeGrepMatch<LabeledWord>> arrayList0 = new ArrayList<TreeGrepMatch<LabeledWord>>();
      TreeGrepMatch<LabeledWord> treeGrepMatch0 = new TreeGrepMatch<LabeledWord>(tree0);
      Tree<LabeledWord>[] treeArray0 = (Tree<LabeledWord>[]) Array.newInstance(Tree.class, 3);
      treeArray0[0] = tree0;
      treeArray0[1] = tree0;
      treeArray0[2] = tree0;
      treeGrepMatch0.dfs = treeArray0;
      arrayList0.add(treeGrepMatch0);
      arrayList0.add(treeGrepMatch0);
      treeGrep0.doesNodeMatchPattern(tree0, tree0, arrayList0);
      Integer integer0 = new Integer((-54));
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      tree1.getParent();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>((Tree<Integer>) null);
      // Undeclared exception!
      try { 
        treeGrep1.matches(tree1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsClassCastException0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordTagFactory0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeFactory labeledScoredTreeFactory1 = new LabeledScoredTreeFactory(wordTagFactory0);
      edu.stanford.nlp.trees.Tree tree1 = labeledScoredTreeFactory1.newTreeNode((Label) wordLemmaTag0, (List<edu.stanford.nlp.trees.Tree>) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree1);
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("QUbv|+VUfLhSN", false);
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockPrintStream0);
      PrintWriter printWriter0 = mockPrintWriter0.append('7');
      treeGraphNode0.pennPrint(printWriter0);
      Stack<TreeGrepMatch<Object>> stack0 = new Stack<TreeGrepMatch<Object>>();
      List<TreeGrepMatch<Object>> list0 = treeGraphNode0.yield(stack0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // edu.stanford.nlp.ling.CoreLabel cannot be cast to edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternReturningListWhereIsEmptyIsTrue()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Tree<Object> tree1 = treeGrepMatch0.getPattern();
      treeGrep0.doesThisTreeMatch(tree1);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree0);
      Tree<Object> tree2 = treeGrepMatch0.getPattern();
      treeGrep1.doesThisTreeMatch(tree2);
      LabelFactory labelFactory0 = LabeledWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("#Zw+4RTBV");
      edu.stanford.nlp.trees.Tree tree3 = labeledScoredTreeFactory0.newTreeNode((Label) wordLemmaTag0, (List<edu.stanford.nlp.trees.Tree>) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree3);
      treeGraphNode0.parent();
      treeGraphNode0.dominationPath((edu.stanford.nlp.trees.Tree) null);
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      List<TreeGrepMatch<Object>> list0 = treeGraphNode0.yield(vector0);
      Integer integer0 = new Integer((-2026568364));
      Tree<Object> tree4 = new Tree<Object>(integer0);
      List<TreeGrepMatch<Object>> list1 = treeGrep1.doesNodeMatchPattern(tree0, tree4, vector0);
      assertFalse(list1.equals((Object)list0));
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsClassCastException1()  throws Throwable  {
      Integer integer0 = new Integer((-1131246725));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      Tree<Object> tree1 = new Tree<Object>(integer0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree1);
      Tree<Object> tree2 = treeGrepMatch0.getPattern();
      tree2.addLeaf((Object) integer0);
      LabeledWord.factory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordTagFactory0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      labeledScoredTreeFactory0.newTreeNode((Label) wordLemmaTag0, (List<edu.stanford.nlp.trees.Tree>) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      List<TreeGrepMatch<Object>> list0 = treeGraphNode0.yield(vector0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree2, tree2, list0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // edu.stanford.nlp.ling.CoreLabel cannot be cast to edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsClassCastExceptionAndDoesNodeMatchPattern()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Tree<Object> tree1 = treeGrepMatch0.getPattern();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrepMatch0.getPattern();
      treeGrep0.doesThisTreeMatch(tree0);
      LabelFactory labelFactory0 = LabeledWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      edu.stanford.nlp.trees.Tree tree2 = labeledScoredTreeFactory0.newTreeNode((Label) wordLemmaTag0, (List<edu.stanford.nlp.trees.Tree>) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree2);
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      List<TreeGrepMatch<Object>> list0 = treeGraphNode0.yield(vector0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree1, tree0, list0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // edu.stanford.nlp.ling.CoreLabel cannot be cast to edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndDoesNodeMatchPattern()  throws Throwable  {
      LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
      Tree<LinkedList<Integer>> tree0 = new Tree<LinkedList<Integer>>(linkedList0);
      TreeGrep<LinkedList<Integer>> treeGrep0 = new TreeGrep<LinkedList<Integer>>(tree0);
      Stack<TreeGrepMatch<LinkedList<Integer>>> stack0 = new Stack<TreeGrepMatch<LinkedList<Integer>>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, stack0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, stack0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsClassCastExceptionAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      Integer integer0 = new Integer((-2095360807));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      Tree<Object> tree1 = new Tree<Object>(integer0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree1);
      Tree<Object> tree2 = treeGrepMatch0.getPattern();
      tree2.addLeaf((Object) integer0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree2);
      Tree<Object> tree3 = treeGrepMatch0.getPattern();
      treeGrep0.doesThisTreeMatch(tree3);
      LabelFactory labelFactory0 = LabeledWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      edu.stanford.nlp.trees.Tree tree4 = labeledScoredTreeFactory0.newTreeNode((Label) wordLemmaTag0, (List<edu.stanford.nlp.trees.Tree>) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree4);
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      List<TreeGrepMatch<Object>> list0 = treeGraphNode0.yield(vector0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree1, tree1, list0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // edu.stanford.nlp.ling.CoreLabel cannot be cast to edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Integer integer0 = new Integer((-1131246725));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      Tree<Object> tree1 = new Tree<Object>(integer0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree1);
      Tree<Object> tree2 = treeGrepMatch0.getPattern();
      tree2.addLeaf((Object) integer0);
      LabeledWord.factory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordTagFactory0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      vector0.add(treeGrepMatch0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree2, tree2, vector0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndMatches()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
      
      List<TreeGrepMatch<Object>> list0 = treeGrep0.matchesList;
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse4()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsZero0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Tree<Object> tree1 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchReturningFalse()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Tree<Object> tree1 = treeGrepMatch0.getPattern();
      Object object1 = new Object();
      RationalNumber rationalNumber0 = RationalNumber.MIN_VALUE;
      Tree<Object> tree2 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree2);
      treeGrep0.getPattern();
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetMatchesReturningListWhereIsEmptyIsTrueAndListWhereSizeIsZero()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Object object1 = new Object();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.getPattern();
      Object object2 = new Object();
      Tree<Object> tree1 = new Tree<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree1);
      assertFalse(boolean0);
      
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndMatches()  throws Throwable  {
      Integer integer0 = new Integer((-976));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.addLeaf(integer0, integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree0);
      treeGrep1.matches(tree0);
      treeGrep0.matches(tree0);
      LinkedList<Object> linkedList0 = new LinkedList<Object>();
      Tree<LinkedList<Object>> tree1 = new Tree<LinkedList<Object>>(linkedList0);
      TreeGrep<LinkedList<Object>> treeGrep2 = new TreeGrep<LinkedList<Object>>(tree1);
      ArrayList<TreeGrepMatch<LinkedList<Object>>> arrayList0 = new ArrayList<TreeGrepMatch<LinkedList<Object>>>();
      treeGrep2.doesNodeMatchPattern(tree1, tree1, arrayList0);
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetPatternAndMatches()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Tree<Object> tree1 = treeGrepMatch0.getPattern();
      Object object1 = new Object();
      tree1.addLeaf(object1);
      Tree<Object> tree2 = treeGrepMatch0.getPattern();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree2);
      treeGrep0.getPattern();
      treeGrep0.matches(tree2);
      TreeGrepMatch<IndexedWord> treeGrepMatch1 = null;
      TreeGrepMatch<IndexedWord> treeGrepMatch2 = null;
      try {
        treeGrepMatch2 = new TreeGrepMatch<IndexedWord>((TreeGrepMatch<IndexedWord>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetMatchesReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
      
      Tree<Object> tree1 = treeGrep0.getPattern();
      boolean boolean1 = treeGrep0.matches(tree1);
      assertTrue(boolean1);
      
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      Tree<CategoryWordTag> tree2 = new Tree<CategoryWordTag>(categoryWordTag0);
      TreeGrep<CategoryWordTag> treeGrep1 = new TreeGrep<CategoryWordTag>(tree2);
      boolean boolean2 = treeGrep1.doesThisTreeMatch(tree2);
      assertTrue(boolean2);
      
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelReturningFalse()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Vector<List<TreeGrepMatch<Object>>> vector0 = new Vector<List<TreeGrepMatch<Object>>>();
      tree0.toString();
      Stack<TreeGrepMatch<Object>> stack0 = new Stack<TreeGrepMatch<Object>>();
      vector0.add((List<TreeGrepMatch<Object>>) stack0);
      stack0.stream();
      treeGrep0.mergeChildrenMatches(vector0, stack0);
      Tree<Integer> tree1 = new Tree<Integer>();
      Integer integer0 = new Integer((-735));
      tree1.addLeaf(integer0);
      Object object1 = new Object();
      treeGrep0.doesLabelMatchPatternLabel(integer0, object1);
      // Undeclared exception!
      try { 
        tree1.getChild(768);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 768, Size: 1
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsIndexOutOfBoundsException()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Vector<List<TreeGrepMatch<Object>>> vector0 = new Vector<List<TreeGrepMatch<Object>>>();
      Stack<TreeGrepMatch<Object>> stack0 = new Stack<TreeGrepMatch<Object>>();
      vector0.add((List<TreeGrepMatch<Object>>) stack0);
      stack0.stream();
      treeGrep0.mergeChildrenMatches(vector0, stack0);
      Tree<Integer> tree1 = new Tree<Integer>();
      Integer integer0 = new Integer((-735));
      tree1.addLeaf(integer0);
      // Undeclared exception!
      try { 
        tree1.getChild(768);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 768, Size: 1
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateTreeGrepThrowsNullPointerException()  throws Throwable  {
      TextStyle textStyle0 = TextStyle.FULL_STANDALONE;
      Integer integer0 = new Integer((-2902));
      Tree<Object> tree0 = new Tree<Object>(integer0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Tree<Object> tree1 = treeGrepMatch0.getPattern();
      Object object0 = new Object();
      tree0.addLeaf((Object) tree1);
      Tree<Object> tree2 = new Tree<Object>(tree0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      treeGrep0.getPattern();
      treeGrep0.matches(tree2);
      TreeGrepMatch<IndexedWord> treeGrepMatch1 = null;
      try {
        treeGrepMatch1 = new TreeGrepMatch<IndexedWord>((TreeGrepMatch<IndexedWord>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsZero1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatch0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      treeGrepMatch0.getPattern();
      Object object1 = new Object();
      RationalNumber rationalNumber0 = RationalNumber.NaN;
      Tree<RationalNumber> tree1 = new Tree<RationalNumber>(rationalNumber0);
      TreeGrep<RationalNumber> treeGrep0 = new TreeGrep<RationalNumber>(tree1);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      treeGrep0.doesThisTreeMatch(tree0);
      TaggedWord taggedWord0 = new TaggedWord();
      Tree<TaggedWord> tree1 = new Tree<TaggedWord>(taggedWord0);
      // Undeclared exception!
      try { 
        tree1.getChild(2149);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 2149, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue1()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      Tree<Object> tree1 = new Tree<Object>(tree0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatch1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndGetPatternAndMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZero()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Tree<Object> tree1 = treeGrepMatch0.getPattern();
      Object object1 = new Object();
      tree1.addLeaf(object1);
      Tree<Object> tree2 = new Tree<Object>(tree1);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree2);
      Tree<Object> tree3 = treeGrep0.getPattern();
      treeGrep0.matches(tree3);
      TreeGrepMatch<IndexedWord> treeGrepMatch1 = null;
      try {
        treeGrepMatch1 = new TreeGrepMatch<IndexedWord>((TreeGrepMatch<IndexedWord>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningNull()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      tree0.getParent();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      treeGrep0.getPattern();
      Tree<RationalNumber> tree1 = new Tree<RationalNumber>();
      TreeGrepMatch<RationalNumber> treeGrepMatch0 = new TreeGrepMatch<RationalNumber>(tree1);
      // Undeclared exception!
      try { 
        treeGrepMatch0.getRootMatch();
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerException0()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsIllegalArgumentException()  throws Throwable  {
      TextStyle textStyle0 = TextStyle.FULL_STANDALONE;
      Tree<Object> tree0 = new Tree<Object>(textStyle0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Vector<List<TreeGrepMatch<Object>>> vector0 = new Vector<List<TreeGrepMatch<Object>>>();
      Stack<TreeGrepMatch<Object>> stack0 = new Stack<TreeGrepMatch<Object>>();
      // Undeclared exception!
      try { 
        treeGrep0.mergeChildrenMatches(vector0, stack0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // fromIndex(0) > toIndex(-1)
         //
         verifyException("java.util.SubList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse5()  throws Throwable  {
      TreeGrep<RationalNumber> treeGrep0 = new TreeGrep<RationalNumber>((Tree<RationalNumber>) null);
      Integer integer0 = new Integer((-976));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      Tree<Integer> tree1 = treeGrepMatch0.getCurrentPatternNode();
      Integer integer1 = new Integer((-976));
      tree1.addLeaf(integer0, integer1);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree0);
      boolean boolean0 = treeGrep1.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Tree<Object> tree1 = treeGrepMatch0.getPattern();
      tree1.addLeaf((Object) null);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      Tree<Object> tree2 = treeGrep0.getPattern();
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternAndGetPattern()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.getPattern();
      LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
      Tree<LinkedList<Integer>> tree1 = new Tree<LinkedList<Integer>>(linkedList0);
      TreeGrep<LinkedList<Integer>> treeGrep1 = new TreeGrep<LinkedList<Integer>>(tree1);
      Tree<LinkedList<Integer>> tree2 = treeGrep1.getPattern();
      assertSame(tree2, tree1);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatches()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Object object1 = new Object();
      tree0.addLeaf(object0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerException1()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerExceptionAndMatches()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      tree0.clone();
      tree0.getParent();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndGetPatternAndMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Tree<Object> tree1 = treeGrepMatch0.getPattern();
      Object object1 = new Object();
      tree1.addLeaf(object1);
      Tree<Object> tree2 = treeGrepMatch0.getPattern();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree2);
      treeGrep0.getPattern();
      treeGrep0.matches(tree2);
      TreeGrepMatch<IndexedWord> treeGrepMatch1 = null;
      try {
        treeGrepMatch1 = new TreeGrepMatch<IndexedWord>((TreeGrepMatch<IndexedWord>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testToString()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.toString();
      tree0.toString();
      List<TreeGrepMatch<Object>> list0 = treeGrep0.matchesList;
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, (List<TreeGrepMatch<Object>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetMatchesThrowsTooManyResourcesException()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.getMatches();
      Tree<LabeledWord> tree1 = new Tree<LabeledWord>();
      TreeGrepMatch<LabeledWord> treeGrepMatch0 = new TreeGrepMatch<LabeledWord>(tree1);
      TreeGrepMatch<LabeledWord> treeGrepMatch1 = new TreeGrepMatch<LabeledWord>(treeGrepMatch0);
      Tree<LabeledWord> tree2 = treeGrepMatch1.getCurrentPatternNode();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      edu.stanford.nlp.trees.Tree tree3 = treeGraphNode0.deepCopy();
      LabeledWord labeledWord0 = new LabeledWord("6c[7l]AFXt<)C}vl", treeGraphNode0);
      tree1.addLeaf(labeledWord0, labeledWord0);
      LabeledWord labeledWord1 = new LabeledWord(categoryWordTag0, tree3);
      labeledWord1.setBeginPosition(0);
      // Undeclared exception!
      tree1.addSubtree(tree2, labeledWord1);
  }

  @Test(timeout = 4000)
  public void testGetMatches()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerExceptionAndDoesThisTreeMatchWithNull0()  throws Throwable  {
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      int int0 = 0;
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch((Tree<Integer>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternWithEmptyList()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>((Object) null);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerExceptionAndDoesThisTreeMatchWithNull1()  throws Throwable  {
      TreeGrep<RationalNumber> treeGrep0 = new TreeGrep<RationalNumber>((Tree<RationalNumber>) null);
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch((Tree<RationalNumber>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetPattern()  throws Throwable  {
      TreeGrep<List<Integer>> treeGrep0 = new TreeGrep<List<Integer>>((Tree<List<Integer>>) null);
      Tree<List<Integer>> tree0 = treeGrep0.getPattern();
      assertNull(tree0);
  }

  @Test(timeout = 4000)
  public void testToStringThrowsNullPointerException()  throws Throwable  {
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      // Undeclared exception!
      try { 
        treeGrep0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetMatchesThrowsNullPointerException()  throws Throwable  {
      Integer.getInteger("yWbek2 3");
      Tree<Integer> tree0 = new Tree<Integer>((Integer) null);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsNullPointerException0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      vector0.add((TreeGrepMatch<Object>) null);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerExceptionAndDoesThisTreeMatchWithNull2()  throws Throwable  {
      TreeGrep<RationalNumber> treeGrep0 = new TreeGrep<RationalNumber>((Tree<RationalNumber>) null);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch((Tree<RationalNumber>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsNullPointerException1()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      Tree<Tree<Object>> tree1 = new Tree<Tree<Object>>(tree0);
      TreeGrep<Tree<Object>> treeGrep0 = new TreeGrep<Tree<Object>>(tree1);
      Vector<TreeGrepMatch<Tree<Object>>> vector0 = new Vector<TreeGrepMatch<Tree<Object>>>();
      boolean boolean0 = true;
      treeGrep0.verbose = true;
      TreeGrepMatch<Tree<Object>> treeGrepMatch0 = new TreeGrepMatch<Tree<Object>>(tree1);
      vector0.add(treeGrepMatch0);
      treeGrep0.matchesList = (List<TreeGrepMatch<Tree<Object>>>) vector0;
      vector0.setSize(34);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree1, tree1, vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateTreeGrepThrowsIndexOutOfBoundsException()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      Integer integer1 = new Integer(0);
      treeGrep0.doesLabelMatchPatternLabel(integer1, integer1);
      Tree<Object> tree1 = new Tree<Object>(integer0);
      int int0 = 17;
      // Undeclared exception!
      try { 
        tree1.getChild(17);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 17, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerException()  throws Throwable  {
      Tree<RationalNumber> tree0 = new Tree<RationalNumber>();
      TreeGrep<RationalNumber> treeGrep0 = new TreeGrep<RationalNumber>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }
}
