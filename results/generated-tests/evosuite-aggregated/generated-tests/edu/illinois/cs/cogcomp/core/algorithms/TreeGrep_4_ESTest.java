/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 19:39:23 GMT 2025
 */

package edu.illinois.cs.cogcomp.core.algorithms;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrep;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch;
import edu.illinois.cs.cogcomp.core.datastructures.trees.Tree;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.TreeGraphNode;
import java.time.DayOfWeek;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import org.ojalgo.scalar.Quaternion;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class TreeGrep_4_ESTest extends TreeGrep_4_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndMatches()  throws Throwable  {
      Integer integer0 = new Integer(458);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
      
      treeGrep0.verbose = true;
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      LinkedHashSet<TreeGrepMatch<Integer>> linkedHashSet0 = new LinkedHashSet<TreeGrepMatch<Integer>>();
      linkedHashSet0.add(treeGrepMatch0);
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>(linkedHashSet0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive0()  throws Throwable  {
      Integer integer0 = new Integer(0);
      byte[] byteArray0 = new byte[0];
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      Integer integer1 = new Integer(616);
      Integer integer2 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer2);
      Quaternion quaternion0 = Quaternion.ZERO;
      Tree<Quaternion> tree1 = new Tree<Quaternion>(quaternion0);
      tree1.addLeaf(quaternion0, quaternion0);
      tree1.addLeaf(quaternion0);
      TreeGrep<Quaternion> treeGrep0 = new TreeGrep<Quaternion>(tree1);
      String string0 = TreeGrep.endOfChildrenString;
      treeGrep0.doesThisTreeMatch(tree1);
      System.setCurrentTimeMillis(14L);
      TreeGrep<Quaternion> treeGrep1 = new TreeGrep<Quaternion>(tree1);
      assertFalse(treeGrep1.equals((Object)treeGrep0));
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern0()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.addLeaf(integer0, integer0);
      tree0.addLeaf(integer0, integer0);
      tree0.addLeaf(integer0, (Integer) null);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      LinkedHashSet<TreeGrepMatch<Integer>> linkedHashSet0 = new LinkedHashSet<TreeGrepMatch<Integer>>();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      linkedHashSet0.add(treeGrepMatch0);
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>(linkedHashSet0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertFalse(list0.contains(treeGrepMatch0));
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      Quaternion.Versor quaternion_Versor0 = (Quaternion.Versor)Quaternion.NEG;
      Tree<Quaternion> tree0 = new Tree<Quaternion>(quaternion_Versor0);
      TreeGrep<Quaternion> treeGrep0 = new TreeGrep<Quaternion>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
      
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>((Tree<Integer>) null);
      LinkedList<List<TreeGrepMatch<Integer>>> linkedList0 = new LinkedList<List<TreeGrepMatch<Integer>>>();
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>(803);
      Tree<Integer> tree1 = new Tree<Integer>();
      linkedList0.add((List<TreeGrepMatch<Integer>>) arrayList0);
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree1);
      arrayList0.add(treeGrepMatch0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep1.mergeChildrenMatches(linkedList0, arrayList0);
      assertEquals(1, linkedList0.size());
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereHasEdgeLabelsIsTrue()  throws Throwable  {
      int int0 = 0;
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.getPositionAmongParentsChildren();
      tree0.addLeaf(integer0, integer0);
      tree0.addLeaf(integer0, integer0);
      Tree<Integer> tree1 = tree0.getChild(0);
      tree1.addLeaf(integer0, integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      Tree<Integer> tree2 = treeGrep0.getPattern();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree2);
      treeGrep0.matches(tree2);
      TreeGrep.endOfChildrenString = "az(|#(7+<_  nR";
      treeGrep1.getMatches();
      tree2.toString();
      Object object0 = new Object();
      // Undeclared exception!
      try { 
        treeGrep1.doesNodeMatchPattern(tree0, tree0, (List<TreeGrepMatch<Integer>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive1()  throws Throwable  {
      Quaternion.Versor quaternion_Versor0 = (Quaternion.Versor)Quaternion.NEG;
      Tree<Quaternion> tree0 = new Tree<Quaternion>(quaternion_Versor0);
      tree0.addLeaf((Quaternion) quaternion_Versor0);
      TreeGrep<Quaternion> treeGrep0 = new TreeGrep<Quaternion>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
      
      Tree<Integer> tree1 = new Tree<Integer>();
      Tree<Tree<Integer>> tree2 = new Tree<Tree<Integer>>(tree1);
      TreeGrepMatch<Tree<Integer>> treeGrepMatch0 = new TreeGrepMatch<Tree<Integer>>(tree2);
      Tree<Tree<Integer>> tree3 = treeGrepMatch0.getPattern();
      // Undeclared exception!
      try { 
        tree3.getChild((-2023035948));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereHasEdgeLabelsIsFalse()  throws Throwable  {
      int int0 = 0;
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.getPositionAmongParentsChildren();
      tree0.addLeaf(integer0, integer0);
      tree0.addLeaf(integer0, integer0);
      Tree<Integer> tree1 = tree0.getChild(0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      Tree<Integer> tree2 = treeGrep0.getPattern();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree2);
      treeGrep0.matches(tree2);
      treeGrep1.getMatches();
      tree2.toString();
      Object object0 = new Object();
      // Undeclared exception!
      try { 
        treeGrep1.doesNodeMatchPattern(tree2, tree2, (List<TreeGrepMatch<Integer>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndGetMatchesAndMatches()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.addLeaf(integer0, integer0);
      tree0.addLeaf(integer0, integer0);
      tree0.addLeaf(integer0, (Integer) null);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
      
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      assertEquals(1, list0.size());
      
      LinkedHashSet<TreeGrepMatch<Integer>> linkedHashSet0 = new LinkedHashSet<TreeGrepMatch<Integer>>();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      linkedHashSet0.add(treeGrepMatch0);
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>(linkedHashSet0);
      List<TreeGrepMatch<Integer>> list1 = treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertFalse(list1.contains(treeGrepMatch0));
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndDoesThisTreeMatch()  throws Throwable  {
      Quaternion.Versor quaternion_Versor0 = (Quaternion.Versor)Quaternion.NEG;
      Tree<Quaternion> tree0 = new Tree<Quaternion>(quaternion_Versor0);
      tree0.addLeaf((Quaternion) quaternion_Versor0);
      quaternion_Versor0.rows();
      TreeGrep<Quaternion> treeGrep0 = new TreeGrep<Quaternion>(tree0);
      TreeGrepMatch<Quaternion> treeGrepMatch0 = new TreeGrepMatch<Quaternion>(tree0);
      LinkedList<TreeGrepMatch<Quaternion>> linkedList0 = new LinkedList<TreeGrepMatch<Quaternion>>();
      linkedList0.add(treeGrepMatch0);
      List<TreeGrepMatch<Quaternion>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertFalse(list0.contains(treeGrepMatch0));
      assertEquals(1, list0.size());
      
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternReturningListWhereIsEmptyIsTrue()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
      
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      Integer integer1 = new Integer((-2084533210));
      Tree<Integer> tree1 = new Tree<Integer>(integer1);
      treeGrep0.doesNodeMatchPattern(tree1, tree0, list0);
      Object object0 = new Object();
  }

  @Test(timeout = 4000)
  public void testMatches0()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      Integer integer1 = new Integer(708);
      tree0.addLeaf(integer1, integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.verbose = true;
      treeGrep0.matches(tree0);
      tree0.addLeaf(integer0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.verbose = true;
      treeGrep0.matches(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndDoesNodeMatchPattern0()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      tree0.addLeaf(integer0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
      
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive2()  throws Throwable  {
      Quaternion.Versor quaternion_Versor0 = (Quaternion.Versor)Quaternion.NEG;
      Tree<Quaternion> tree0 = new Tree<Quaternion>(quaternion_Versor0);
      tree0.addLeaf((Quaternion) quaternion_Versor0);
      TreeGrep<Quaternion> treeGrep0 = new TreeGrep<Quaternion>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.matches(tree0);
      treeGrep0.verbose = true;
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsZero0()  throws Throwable  {
      Quaternion.Versor quaternion_Versor0 = (Quaternion.Versor)Quaternion.NEG;
      Tree<Quaternion> tree0 = new Tree<Quaternion>(quaternion_Versor0);
      TreeGrep<Quaternion> treeGrep0 = new TreeGrep<Quaternion>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive3()  throws Throwable  {
      Quaternion.Versor quaternion_Versor0 = (Quaternion.Versor)Quaternion.NEG;
      Tree<Quaternion> tree0 = new Tree<Quaternion>(quaternion_Versor0);
      tree0.addLeaf((Quaternion) quaternion_Versor0);
      quaternion_Versor0.rows();
      TreeGrep<Quaternion> treeGrep0 = new TreeGrep<Quaternion>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchWithNull()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.matches(tree0);
      TreeGrep<Quaternion> treeGrep1 = new TreeGrep<Quaternion>((Tree<Quaternion>) null);
      treeGrep1.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep1.doesThisTreeMatch((Tree<Quaternion>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern1()  throws Throwable  {
      Word word0 = new Word();
      Tree<Word> tree0 = new Tree<Word>(word0);
      TreeGrep<Word> treeGrep0 = new TreeGrep<Word>(tree0);
      Stack<TreeGrepMatch<Word>> stack0 = new Stack<TreeGrepMatch<Word>>();
      TreeGrepMatch<Word> treeGrepMatch0 = new TreeGrepMatch<Word>(tree0);
      stack0.push(treeGrepMatch0);
      List<TreeGrepMatch<Word>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, stack0);
      assertEquals(1, stack0.size());
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternReturningListWhereSizeIsPositive()  throws Throwable  {
      Quaternion quaternion0 = Quaternion.INFINITY;
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      Tree<Object> tree1 = new Tree<Object>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      TreeGrepMatch<Object> treeGrepMatch1 = new TreeGrepMatch<Object>(treeGrepMatch0);
      linkedList0.add(treeGrepMatch1);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree1);
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertEquals(1, linkedList0.size());
      
      LinkedList<WordLemmaTag> linkedList1 = new LinkedList<WordLemmaTag>();
      Tree<LinkedList<WordLemmaTag>> tree2 = new Tree<LinkedList<WordLemmaTag>>(linkedList1);
      TreeGrep<LinkedList<WordLemmaTag>> treeGrep2 = new TreeGrep<LinkedList<WordLemmaTag>>(tree2);
      boolean boolean0 = treeGrep2.matches(tree2);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetMatchesReturningListWhereIsEmptyIsTrueAndListWhereSizeIsZero()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Integer integer0 = new Integer((-2096422583));
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      Integer integer1 = new Integer((-2096422583));
      tree1.addLeaf(integer1, integer1);
      Tree<Integer> tree2 = new Tree<Integer>();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree2);
      treeGrep1.matches(tree1);
      List<TreeGrepMatch<Integer>> list0 = treeGrep1.getMatches();
      // Undeclared exception!
      try { 
        treeGrep1.doesNodeMatchPattern(tree2, tree1, list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndMatchesWithTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.addLeaf(integer0, integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.matches(tree0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelReturningTrue()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.doesLabelMatchPatternLabel(treeGrep0, treeGrep0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndGetPatternAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      Tree<List<Integer>> tree0 = new Tree<List<Integer>>();
      TreeGrep<List<Integer>> treeGrep0 = new TreeGrep<List<Integer>>(tree0);
      treeGrep0.getPattern();
      Quaternion quaternion0 = Quaternion.INFINITY;
      Tree<Quaternion> tree1 = new Tree<Quaternion>(quaternion0);
      treeGrep0.getPattern();
      Quaternion quaternion1 = Quaternion.INFINITY;
      Tree<Quaternion> tree2 = new Tree<Quaternion>(quaternion0);
      tree1.addLeaf(quaternion1, quaternion1);
      Quaternion.Versor quaternion_Versor0 = (Quaternion.Versor)Quaternion.J;
      quaternion_Versor0.add(quaternion0);
      tree2.addLeaf((Quaternion) quaternion_Versor0);
      TreeGrep<Quaternion> treeGrep1 = new TreeGrep<Quaternion>(tree2);
      TreeGrep<Quaternion> treeGrep2 = new TreeGrep<Quaternion>(tree2);
      treeGrep2.doesThisTreeMatch(tree1);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      assertEquals(0, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchWithTreeWhereHasEdgeLabelsIsTrue()  throws Throwable  {
      Quaternion.Versor quaternion_Versor0 = (Quaternion.Versor)Quaternion.NEG;
      Tree<Quaternion> tree0 = new Tree<Quaternion>(quaternion_Versor0);
      tree0.addLeaf((Quaternion) quaternion_Versor0);
      Tree<Quaternion> tree1 = new Tree<Quaternion>(quaternion_Versor0);
      tree1.addSubtree(tree0, (Quaternion) quaternion_Versor0);
      TreeGrep<Quaternion> treeGrep0 = new TreeGrep<Quaternion>(tree1);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      Object object0 = new Object();
      Tree<List<Integer>> tree0 = new Tree<List<Integer>>();
      TreeGrep<List<Integer>> treeGrep0 = new TreeGrep<List<Integer>>(tree0);
      treeGrep0.getPattern();
      Quaternion quaternion0 = Quaternion.INFINITY;
      Tree<Quaternion> tree1 = new Tree<Quaternion>(quaternion0);
      treeGrep0.getPattern();
      Quaternion quaternion1 = Quaternion.INFINITY;
      Tree<Quaternion> tree2 = new Tree<Quaternion>(quaternion0);
      Quaternion.Versor quaternion_Versor0 = (Quaternion.Versor)Quaternion.J;
      tree1.addLeaf((Quaternion) quaternion_Versor0);
      tree1.getHeight();
      TreeGrep<Quaternion> treeGrep1 = new TreeGrep<Quaternion>(tree2);
      TreeGrep<Quaternion> treeGrep2 = new TreeGrep<Quaternion>(tree1);
      treeGrep2.doesThisTreeMatch(tree1);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      Tree<Quaternion> tree3 = treeGrep2.getPattern();
      assertSame(tree1, tree3);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsNullPointerException()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>((Tree<Integer>) null);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      Tree<Object> tree1 = new Tree<Object>();
      TreeGrep<Object> treeGrep2 = new TreeGrep<Object>(tree0);
      treeGrep2.verbose = true;
      Tree<Object> tree2 = new Tree<Object>();
      // Undeclared exception!
      try { 
        treeGrep2.doesNodeMatchPattern(tree0, tree2, linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerException0()  throws Throwable  {
      Tree<Quaternion> tree0 = new Tree<Quaternion>();
      TreeGrep<Quaternion> treeGrep0 = new TreeGrep<Quaternion>(tree0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesReturningFalse()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>((Tree<Integer>) null);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      Tree<Object> tree1 = new Tree<Object>();
      tree0.getPositionAmongParentsChildren();
      TreeGrep<Object> treeGrep2 = new TreeGrep<Object>(tree1);
      LinkedList<TreeGrepMatch<Object>> linkedList1 = new LinkedList<TreeGrepMatch<Object>>();
      boolean boolean1 = treeGrep2.matches(tree0);
      assertFalse(boolean1 == boolean0);
      assertFalse(boolean1);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndGetPatternAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsZero()  throws Throwable  {
      Tree<List<Integer>> tree0 = new Tree<List<Integer>>();
      TreeGrep<List<Integer>> treeGrep0 = new TreeGrep<List<Integer>>(tree0);
      treeGrep0.getPattern();
      Quaternion quaternion0 = Quaternion.INFINITY;
      Tree<Quaternion> tree1 = new Tree<Quaternion>(quaternion0);
      treeGrep0.getPattern();
      Quaternion quaternion1 = Quaternion.INFINITY;
      Tree<Quaternion> tree2 = new Tree<Quaternion>(quaternion0);
      Quaternion.Versor quaternion_Versor0 = (Quaternion.Versor)Quaternion.J;
      tree2.addLeaf((Quaternion) quaternion_Versor0);
      TreeGrep<Quaternion> treeGrep1 = new TreeGrep<Quaternion>(tree2);
      TreeGrep<Quaternion> treeGrep2 = new TreeGrep<Quaternion>(tree2);
      treeGrep2.doesThisTreeMatch(tree1);
      Tree<DayOfWeek> tree3 = new Tree<DayOfWeek>();
      assertTrue(tree3.isLeaf());
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsIllegalArgumentException()  throws Throwable  {
      Tree<List<Integer>> tree0 = new Tree<List<Integer>>();
      TreeGrep<List<Integer>> treeGrep0 = new TreeGrep<List<Integer>>(tree0);
      treeGrep0.getPattern();
      Quaternion quaternion0 = Quaternion.INFINITY;
      Tree<Quaternion> tree1 = new Tree<Quaternion>(quaternion0);
      tree1.addLeaf(quaternion0);
      TreeGrep<Quaternion> treeGrep1 = new TreeGrep<Quaternion>(tree1);
      treeGrep1.matches(tree1);
      treeGrep1.doesThisTreeMatch(tree1);
      Tree<DayOfWeek> tree2 = new Tree<DayOfWeek>();
      TreeGrep<DayOfWeek> treeGrep2 = new TreeGrep<DayOfWeek>(tree2);
      Integer integer0 = Integer.getInteger("org.ojalgo.scalar.Quaternion@0000000006", 2);
      Tree<Integer> tree3 = new Tree<Integer>(integer0);
      TreeGrep<CoreLabel> treeGrep3 = new TreeGrep<CoreLabel>((Tree<CoreLabel>) null);
      treeGrep3.getPattern();
      ArrayList<List<TreeGrepMatch<CoreLabel>>> arrayList0 = new ArrayList<List<TreeGrepMatch<CoreLabel>>>();
      Stack<TreeGrepMatch<CoreLabel>> stack0 = new Stack<TreeGrepMatch<CoreLabel>>();
      // Undeclared exception!
      try { 
        treeGrep3.mergeChildrenMatches(arrayList0, stack0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // fromIndex(0) > toIndex(-1)
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatches1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchReturningFalse()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>((Tree<Integer>) null);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      Tree<Object> tree1 = new Tree<Object>();
      TreeGrep<Object> treeGrep2 = new TreeGrep<Object>(tree1);
      treeGrep0.doesNodeMatchPattern(tree0, tree1, linkedList0);
      Object object1 = new Object();
      assertFalse(object1.equals((Object)object0));
      
      boolean boolean1 = treeGrep2.doesThisTreeMatch(tree0);
      assertFalse(boolean1 == boolean0);
      assertFalse(boolean1);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsZero1()  throws Throwable  {
      Tree<Quaternion> tree0 = new Tree<Quaternion>();
      TreeGrep<Quaternion> treeGrep0 = new TreeGrep<Quaternion>(tree0);
      Quaternion quaternion0 = Quaternion.INFINITY;
      Tree<Quaternion> tree1 = new Tree<Quaternion>(quaternion0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException2()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.matches(tree0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetMatchesReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      TreeGrep.endOfChildrenString = null;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
      
      treeGrep0.getMatches();
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      DayOfWeek dayOfWeek0 = DayOfWeek.SUNDAY;
      Tree<DayOfWeek> tree1 = new Tree<DayOfWeek>(dayOfWeek0);
      TreeGrep<DayOfWeek> treeGrep1 = new TreeGrep<DayOfWeek>(tree1);
      Vector<TreeGrepMatch<DayOfWeek>> vector0 = new Vector<TreeGrepMatch<DayOfWeek>>();
      treeGrep1.doesNodeMatchPattern(tree1, tree1, vector0);
      Integer integer0 = new Integer((-4460));
      tree0.addLeaf((Object) integer0);
      DayOfWeek dayOfWeek1 = DayOfWeek.FRIDAY;
      treeGrep1.doesLabelMatchPatternLabel(dayOfWeek0, dayOfWeek1);
      Tree<Object> tree2 = new Tree<Object>();
      // Undeclared exception!
      try { 
        tree0.getChild((-3164));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetPatternAndDoesNodeMatchPatternThrowsNullPointerException()  throws Throwable  {
      Tree<List<Integer>> tree0 = new Tree<List<Integer>>();
      TreeGrep<List<Integer>> treeGrep0 = new TreeGrep<List<Integer>>(tree0);
      treeGrep0.getPattern();
      Quaternion quaternion0 = Quaternion.INFINITY;
      Tree<Quaternion> tree1 = new Tree<Quaternion>(quaternion0);
      tree1.addLeaf(quaternion0);
      TreeGrep<Quaternion> treeGrep1 = new TreeGrep<Quaternion>(tree1);
      treeGrep1.doesThisTreeMatch(tree1);
      Tree<DayOfWeek> tree2 = new Tree<DayOfWeek>();
      TreeGrep<DayOfWeek> treeGrep2 = new TreeGrep<DayOfWeek>(tree2);
      tree2.clone();
      treeGrep2.matchesList = null;
      DayOfWeek dayOfWeek0 = DayOfWeek.SUNDAY;
      // Undeclared exception!
      try { 
        treeGrep2.doesNodeMatchPattern(tree2, tree2, (List<TreeGrepMatch<DayOfWeek>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelReturningFalse()  throws Throwable  {
      Integer integer0 = new Integer((-828));
      Tree<Object> tree0 = new Tree<Object>(integer0);
      tree0.getParent();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      LabeledWord labeledWord0 = new LabeledWord("\"QW+vO;Y$8|a8'");
      LinkedList<edu.stanford.nlp.trees.Tree> linkedList0 = new LinkedList<edu.stanford.nlp.trees.Tree>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(labeledWord0, linkedList0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      edu.stanford.nlp.trees.Tree tree1 = treeGraphNode0.treeSkeletonConstituentCopy();
      CoreLabel coreLabel0 = new CoreLabel(tree1);
      CoreLabel coreLabel1 = CoreLabel.wordFromString((String) null);
      CoreLabel coreLabel2 = new CoreLabel(coreLabel1);
      boolean boolean0 = treeGrep0.doesLabelMatchPatternLabel(coreLabel0, coreLabel2);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatches()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>((Tree<Integer>) null);
      TreeGrep<Tree<Integer>> treeGrep0 = new TreeGrep<Tree<Integer>>(tree0);
      ArrayList<List<TreeGrepMatch<Tree<Integer>>>> arrayList0 = new ArrayList<List<TreeGrepMatch<Tree<Integer>>>>();
      Stack<TreeGrepMatch<Tree<Integer>>> stack0 = new Stack<TreeGrepMatch<Tree<Integer>>>();
      arrayList0.add((List<TreeGrepMatch<Tree<Integer>>>) stack0);
      arrayList0.add((List<TreeGrepMatch<Tree<Integer>>>) stack0);
      LinkedList<TreeGrepMatch<Tree<Integer>>> linkedList0 = new LinkedList<TreeGrepMatch<Tree<Integer>>>();
      TreeGrepMatch<Tree<Integer>> treeGrepMatch0 = new TreeGrepMatch<Tree<Integer>>(tree0);
      linkedList0.push(treeGrepMatch0);
      treeGrep0.mergeChildrenMatches(arrayList0, linkedList0);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>((Tree<Integer>) null);
      // Undeclared exception!
      try { 
        treeGrep1.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerException()  throws Throwable  {
      Integer integer0 = new Integer(4216);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.getParent();
      Tree<Object> tree1 = new Tree<Object>((Object) null);
      tree1.getParent();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsNullPointerException()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      TreeGrep.endOfChildrenString = null;
      treeGrep0.matches(tree0);
      Tree<Object> tree1 = new Tree<Object>();
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree1);
      LinkedList<List<TreeGrepMatch<Object>>> linkedList0 = new LinkedList<List<TreeGrepMatch<Object>>>();
      ArrayList<TreeGrepMatch<Object>> arrayList0 = new ArrayList<TreeGrepMatch<Object>>(55448359);
      // Undeclared exception!
      try { 
        treeGrep1.doesNodeMatchPattern(tree1, tree1, arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetPattern()  throws Throwable  {
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      Tree<Object> tree0 = treeGrep0.getPattern();
      assertNull(tree0);
  }

  @Test(timeout = 4000)
  public void testToStringThrowsNullPointerException()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testToString()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("f6e}<p#mY>A/8A25j", "f6e}<p#mY>A/8A25j");
      LabeledWord labeledWord0 = new LabeledWord("f6e}<p#mY>A/8A25j", wordLemmaTag0);
      labeledWord0.toString();
      Tree<LabeledWord> tree0 = new Tree<LabeledWord>(labeledWord0);
      TreeGrep<LabeledWord> treeGrep0 = new TreeGrep<LabeledWord>(tree0);
      treeGrep0.toString();
      Tree<Object> tree1 = new Tree<Object>();
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree1);
      // Undeclared exception!
      try { 
        treeGrep1.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.verbose = true;
      treeGrep0.matches(tree0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetMatches()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelThrowsNullPointerException()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>((Tree<Integer>) null);
      treeGrep1.getMatches();
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      // Undeclared exception!
      try { 
        treeGrep0.doesLabelMatchPatternLabel((Object) null, (Object) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndDoesNodeMatchPattern1()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      TreeGrep.endOfChildrenString = null;
      treeGrep0.matches(tree0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesTreeGrep()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      Tree.readTreeFromString("-8oJ<_gcU&*`");
      tree0.clone();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerException1()  throws Throwable  {
      Tree<Quaternion> tree0 = new Tree<Quaternion>();
      TreeGrep<Quaternion> treeGrep0 = new TreeGrep<Quaternion>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }
}
