/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Apr 21 17:44:11 GMT 2025
 */

package edu.stanford.nlp.process;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.NERClassifierCombiner;
import edu.stanford.nlp.ie.PresetSequenceClassifier;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.StringLabel;
import edu.stanford.nlp.ling.StringLabelFactory;
import edu.stanford.nlp.ling.Tag;
import edu.stanford.nlp.ling.TaggedWordFactory;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordFactory;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.ling.tokensregex.ComplexNodePattern;
import edu.stanford.nlp.ling.tokensregex.CoreMapExpressionExtractor;
import edu.stanford.nlp.ling.tokensregex.Env;
import edu.stanford.nlp.ling.tokensregex.MatchedExpression;
import edu.stanford.nlp.ling.tokensregex.SequenceMatchRules;
import edu.stanford.nlp.ling.tokensregex.SequenceMatcher;
import edu.stanford.nlp.ling.tokensregex.SequencePattern;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.WordToSentenceProcessor;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.Pair;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.regex.PatternSyntaxException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.EvoSuiteURL;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.testdata.NetworkHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class WordToSentenceProcessor_2_ESTest extends WordToSentenceProcessor_2_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess0()  throws Throwable  {
      String string0 = "X";
      List<String> list0 = List.of("qF", "encoding", "encoding", "qF", "encoding", "X");
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      Locale locale0 = Locale.CHINA;
      Set<String> set1 = locale0.getUnicodeLocaleAttributes();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("encoding", "encoding", set1, set1, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      wordToSentenceProcessor0.process(list0);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      Set<String> set2 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      CoreMapExpressionExtractor<MatchedExpression> coreMapExpressionExtractor0 = new CoreMapExpressionExtractor<MatchedExpression>();
      coreMapExpressionExtractor0.getEnv();
      // Undeclared exception!
      try { 
        SequencePattern.compile(null, "D{!(");
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Error compiling D{!( using environment null
         //
         verifyException("edu.stanford.nlp.ling.tokensregex.SequencePattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess1()  throws Throwable  {
      List<String> list0 = List.of("O", "O", "O", "O", "O", "O");
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      Set<String> set0 = presetSequenceClassifier0.labels();
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("O", "O", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess2()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List<String> list0 = List.of("z9XW!iMQn]q", "jHY", "'", "jHY", "ner\u0000usePresetNERTags", "'");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("iKy7k/+", "", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(1, list1.size());
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess3()  throws Throwable  {
      List<String> list0 = List.of(":", ":", ":", ":", ":", ":");
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      MapFactory<String, SequenceMatchRules.AnnotationExtractRule<Tag, MatchedExpression>> mapFactory0 = MapFactory.hashMapFactory();
      Set<String> set1 = mapFactory0.newSet((Collection<String>) list0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("advcl", ":", set0, set1, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set1);
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testProcessAndCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      List<String> list0 = List.of("sMp", "sMp", "sMp", "sMp", "m,y", "m,y");
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak1 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(",\"l}e", "m,y", treeSet0, treeSet0, "`.Ph\"", wordToSentenceProcessor_NewlineIsSentenceBreak1, (SequencePattern<? super String>) null, treeSet0, false, false);
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>("`.Ph\"", "discarded", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      List<List<String>> list1 = wordToSentenceProcessor1.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndProcess0()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List<String> list0 = List.of("", "VEtM", "VEtM", "America/Guadeloupe", "America/Argentina/Buenos_Aires", "");
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("I17\"~gP/j", "Europe/Athens", treeSet0, set0, "mis-spel", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0, false, false);
      wordToSentenceProcessor0.process(list0);
      Random.setNextRandom(1);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndProcess1()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      List<String> list0 = List.of("Um,y", "v|P", "sMp", "", "VEtM", "utfIXl%$");
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("utfIXl%$", "utfIXl%$", set0, treeSet0, "utfIXl%$", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0, false, false);
      wordToSentenceProcessor0.process(list0);
      Random.setNextRandom(501);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndProcess2()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      List<String> list0 = List.of("shp", "v|P", "v|P", "shp", "Um,y", "Um,y");
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      TreeSet<String> treeSet1 = new TreeSet<String>();
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("shp", "[.\u3002]|[!?\uFF01\uFF1F]+", treeSet0, treeSet0, "shp", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, treeSet1, false, false);
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(0, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndProcess3()  throws Throwable  {
      List<String> list0 = List.of("sMp", "sMp", "sMp", "sMp", "sMp", "sMp");
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("sMp", "sMp", treeSet0, treeSet0, "sMp", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, treeSet0, false, false);
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess4()  throws Throwable  {
      List<String> list0 = List.of("s+M}", "s+M}", "s+M}", "s+M}", "s+M}", "s+M}");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("s+M}", "s+M}", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testProcess()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      String string0 = "X";
      List<String> list0 = List.of("qF", "encoding", "encoding", "qF", "encoding", "X");
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      Locale locale0 = Locale.CHINA;
      Set<String> set1 = locale0.getUnicodeLocaleAttributes();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>("encoding", "encoding", set1, set1, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      wordToSentenceProcessor1.process(list0);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("dat)V^9fa$[DND6<;C");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.dat)V^9fa$[DND6<;C
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessAndCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      List<String> list0 = List.of("", "", "{Z", "{Z", "", "{Z");
      Locale.IsoCountryCode locale_IsoCountryCode0 = Locale.IsoCountryCode.PART3;
      Set<String> set0 = Locale.getISOCountries(locale_IsoCountryCode0);
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>(set0);
      List<List<String>> list1 = wordToSentenceProcessor1.process(list0);
      assertEquals(3, list1.size());
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak()  throws Throwable  {
      long long0 = 0L;
      System.setCurrentTimeMillis(0L);
      System.setCurrentTimeMillis(0L);
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      Random.setNextRandom(1838);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      System.setCurrentTimeMillis(1838);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      wordToSentenceProcessor0.process(stack0);
      String string0 = "";
      String string1 = null;
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      ComplexNodePattern.StringInSetAnnotationPattern complexNodePattern_StringInSetAnnotationPattern0 = new ComplexNodePattern.StringInSetAnnotationPattern(set0);
      complexNodePattern_StringInSetAnnotationPattern0.getTargets();
      SequencePattern.Parser<CoreLabel> sequencePattern_Parser0 = (SequencePattern.Parser<CoreLabel>) mock(SequencePattern.Parser.class, new ViolatedAssumptionAnswer());
      doReturn((Pair) null).when(sequencePattern_Parser0).parseSequenceWithAction(any(edu.stanford.nlp.ling.tokensregex.Env.class) , anyString());
      Env env0 = new Env(sequencePattern_Parser0);
      // Undeclared exception!
      try { 
        SequencePattern.compile(env0, null);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Error compiling null using environment edu.stanford.nlp.ling.tokensregex.Env@3
         //
         verifyException("edu.stanford.nlp.ling.tokensregex.SequencePattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessDocumentThrowsNullPointerExceptionAndStringToNewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.processDocument(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess0()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\u2029");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      ArrayList<CoreAnnotations.OriginalTextAnnotation> arrayList0 = new ArrayList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(arrayList0);
      List<CoreAnnotations.OriginalTextAnnotation> list1 = treeGraphNode0.yield(list0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list2 = wordToSentenceProcessor0.process(list1);
      assertEquals(2, list2.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking3Arguments()  throws Throwable  {
      List<String> list0 = List.of("O", "O", "O", "O", "O", "O");
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("O", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(6, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess0()  throws Throwable  {
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "Oa}!=Pv#p7CVTb");
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("\u2029", (List<Tree>) linkedList0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0, linkedList0);
      treeGraphNode0.yieldHasWord();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\u2029");
      WordTag wordTag0 = new WordTag(coreLabel0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(coreLabel0);
      Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = treeGraphNode1.yield(vector0);
      Locale locale0 = Locale.US;
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(set0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      treeSet0.add("\u2029");
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor1 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(treeSet0);
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list1 = wordToSentenceProcessor1.process(list0);
      assertFalse(list1.contains(list0));
      assertEquals(1, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndProcess0()  throws Throwable  {
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("\"1C{");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      HashIndex<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> hashIndex0 = new HashIndex<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = hashIndex0.objectsList();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list1 = treeGraphNode0.yield(list0);
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(false);
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list2 = wordToSentenceProcessor0.process(list0);
      assertTrue(list2.contains(list1));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess1()  throws Throwable  {
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "Oa}!=Pv#p7CVTb");
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("\u2029", (List<Tree>) linkedList0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0, linkedList0);
      treeGraphNode0.yieldHasWord();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\u2029");
      WordTag wordTag0 = new WordTag(coreLabel0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(coreLabel0);
      Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = treeGraphNode1.yield(vector0);
      Locale locale0 = Locale.US;
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(set0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor1 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(treeSet0);
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list1 = wordToSentenceProcessor1.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess2()  throws Throwable  {
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\u2029");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = treeGraphNode0.yield(vector0);
      Locale locale0 = Locale.US;
      treeGraphNode0.yield(list0);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("");
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(linkedHashSet0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list1 = wordToSentenceProcessor0.process(vector0);
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndProcess1()  throws Throwable  {
      WordFactory wordFactory0 = new WordFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordFactory0);
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("\"", (List<Tree>) vector0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0, vector0);
      treeGraphNode0.yieldHasWord();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("*NL*");
      WordTag wordTag0 = new WordTag(coreLabel0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0);
      Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> vector1 = new Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = treeGraphNode1.yield(vector1);
      Locale locale0 = Locale.US;
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      treeGraphNode1.yield(vector1);
      Locale locale1 = Locale.US;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(false);
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess3()  throws Throwable  {
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      treeGraphNode0.yield(vector0);
      Locale locale0 = Locale.US;
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = treeGraphNode0.yield(vector0);
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(set0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor1 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(treeSet0);
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list1 = wordToSentenceProcessor1.process(vector0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess4()  throws Throwable  {
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("", (List<Tree>) linkedList0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0, linkedList0);
      treeGraphNode0.yieldHasWord();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      WordTag wordTag0 = new WordTag(coreLabel0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(coreLabel0);
      Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = treeGraphNode1.yield(vector0);
      Locale locale0 = Locale.US;
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(set0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor1 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(treeSet0);
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list1 = wordToSentenceProcessor1.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess5()  throws Throwable  {
      List<String> list0 = List.of("TWO_CONSECUTIVE", "TWO_CONSECUTIVE", "TWO_CONSECUTIVE", "TWO_CONSECUTIVE", "TWO_CONSECUTIVE", "TWO_CONSECUTIVE");
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("TWO_CONSECUTIVE", "TWO_CONSECUTIVE", treeSet0, treeSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, treeSet0);
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess5()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("*NL*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      treeGraphNode0.yield(vector0);
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = treeGraphNode0.yield(vector0);
      coreLabel0.endPosition();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(linkedHashSet0);
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess6()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\u2029");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> stack0 = new Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = treeGraphNode0.yield(stack0);
      treeGraphNode0.yield(stack0);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("\u2029");
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(linkedHashSet0);
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess7()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      CoreLabel coreLabel0 = CoreLabel.wordFromString((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> stack0 = new Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = treeGraphNode0.yield(stack0);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add((String) null);
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(linkedHashSet0);
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list1 = wordToSentenceProcessor0.process(stack0);
      assertFalse(list1.contains(list0));
      assertEquals(1, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess6()  throws Throwable  {
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      List<String> list0 = List.of("inputEncoding", "inputEncoding", "added to current", "added to current", "<?:outputEncoding>", "added to current");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("<?:outputEncoding>", "added to current", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess8()  throws Throwable  {
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = treeGraphNode0.yield(vector0);
      Locale locale0 = Locale.US;
      treeGraphNode0.yield(vector0);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("");
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(linkedHashSet0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      wordToSentenceProcessor0.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess1()  throws Throwable  {
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      List<String> list0 = List.of("composite", "*NL*", "<s%+(j^?:/)?(?3:", "composite", "*NL*", "America/Shiprock");
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(1, list1.size());
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess2()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\u2029");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> stack0 = new Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = treeGraphNode0.yield(stack0);
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list1 = wordToSentenceProcessor0.process(stack0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess7()  throws Throwable  {
      List<String> list0 = List.of("O", "O", "O", "O", "O", "O");
      TreeSet<String> treeSet0 = new TreeSet<String>();
      treeSet0.add("O");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("O", "O", treeSet0, treeSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, treeSet0);
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess3()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = treeGraphNode0.yield(vector0);
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list1 = wordToSentenceProcessor0.process(vector0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTaking7Arguments0()  throws Throwable  {
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(stringLabelFactory0);
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("jOA", (List<Tree>) arrayList0);
      Tag tag0 = new Tag(tree0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("EF<2|tQ,<*LS:89", "AqHS", (Set<String>) null, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, (Set<String>) null);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess8()  throws Throwable  {
      List<String> list0 = List.of("O", "O", "O", "O", "O", "O");
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("O", "O", (Set<String>) null, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, (Set<String>) null);
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess9()  throws Throwable  {
      List<String> list0 = List.of("s+M}", "s+M}", "s+M}", "s+M}", "s+M}", "s+M}");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("s+M}", "s+M}", set0, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("always");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments0()  throws Throwable  {
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>((String) null, (String) null, set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTaking7Arguments1()  throws Throwable  {
      MapFactory.arrayMapFactory();
      Charset charset0 = Charset.defaultCharset();
      Set<String> set0 = charset0.aliases();
      ByteBuffer byteBuffer0 = ByteBuffer.allocateDirect(1);
      charset0.decode(byteBuffer0);
      MapFactory<String, CoreLabel> mapFactory0 = MapFactory.arrayMapFactory();
      Set<String> set1 = mapFactory0.newSet((Collection<String>) set0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("iW%s<Cbc^;<1t", (String) null, set0, set1, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTaking7Arguments2()  throws Throwable  {
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      Charset charset0 = Charset.defaultCharset();
      Set<String> set0 = charset0.aliases();
      ByteBuffer byteBuffer0 = ByteBuffer.allocateDirect(1);
      Charset charset1 = Charset.defaultCharset();
      charset1.decode(byteBuffer0);
      Comparator<String> comparator0 = (Comparator<String>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<String, CoreLabel> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      Vector<String> vector0 = new Vector<String>();
      Set<String> set1 = mapFactory0.newSet((Collection<String>) vector0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("/^([-a-zA-Z|]+)/|/^(?:([-a-zA-Z|]+))/", "/^([-a-zA-Z|]+)/|/^(?:([-a-zA-Z|]+))/", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set1);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      System.setCurrentTimeMillis(0L);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTaking7Arguments3()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      LinkedHashSet<String> linkedHashSet1 = new LinkedHashSet<String>();
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>((String) null, "EF<2|tQ,<*LS:89", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet1);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      MapFactory<String, CoreLabel> mapFactory0 = MapFactory.arrayMapFactory();
      Charset charset0 = Charset.defaultCharset();
      Set<String> set0 = charset0.aliases();
      ByteBuffer byteBuffer0 = ByteBuffer.allocateDirect(1);
      charset0.decode(byteBuffer0);
      Set<String> set1 = mapFactory0.newSet((Collection<String>) set0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>("iW%s<Cbc^;<1t", "leapfrog", set1, set1, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndStringToNewlineIsSentenceBreak()  throws Throwable  {
      String string0 = "$VALUES";
      boolean boolean0 = true;
      String string1 = "two";
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("two");
      String string2 = "outputIterationsToFile";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("outputIterationsToFile");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.outputIterationsToFile
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      LabelFactory labelFactory0 = Word.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("\"", (List<Tree>) vector0);
      Tag tag0 = new Tag(tree0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      taggedWordFactory0.newLabel((Label) tree0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      tag0.setBeginPosition((-2654));
      tag0.setValue("7tT\"9");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0, vector0);
      ArrayList<CoreLabel> arrayList1 = treeGraphNode0.yieldHasWord();
      Tag.factory();
      List.of();
      arrayList1.add((CoreLabel) null);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(false);
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("always");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndStringToNewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor<SequenceMatcher.FindType> wordToSentenceProcessor0 = new WordToSentenceProcessor<SequenceMatcher.FindType>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("two");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeExceptionAndCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak()  throws Throwable  {
      String string0 = "\"";
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      stack0.add(coreAnnotations_OriginalTextAnnotation0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(stack0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessReturningListWhereIsEmptyIsTrueAndListWhereSizeIsZero()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      wordToSentenceProcessor0.process(stack0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf((String) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Name is null
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("sMp", "sMp", treeSet0, treeSet0, "sMp", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, treeSet0, false, false);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTakingNoArgumentsThrowsPatternSyntaxException()  throws Throwable  {
      String string0 = "SM2Yr";
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", "SM2Yr", set0, set0, "SM2Yr", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0, false, false);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Dangling meta character '*' near index 16
         // <\\s*(?:/\\s*)?(?:*NL*)(?:\\s+[^>]+?|\\s*(?:/\\s*)?)>
         //                 ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments1()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("s+M}", "s+M}", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments2()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("EF<2|tQ,<*LS:89", "EF<2|tQ,<*LS:89", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak0()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      List<String> list0 = List.of("rBx", "rBx", "s T~>tR", "s T~>tR", "rBx", "3vAH3\"fm'AY?S[\"a*C<");
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeExceptionAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = List.of(coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess4()  throws Throwable  {
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      List<String> list0 = List.of("<s%+(j^?:/)?(?3:", "<s%+(j^?:/)?(?3:", "<s%+(j^?:/)?(?3:", "<s%+(j^?:/)?(?3:", "<s%+(j^?:/)?(?3:", "<s%+(j^?:/)?(?3:");
      List<List<String>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcessAndProcessWithEmptyList()  throws Throwable  {
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      List<List<CoreAnnotations.OriginalTextAnnotation>> list0 = wordToSentenceProcessor0.process(stack0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException()  throws Throwable  {
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      treeGraphNode0.yield(vector0);
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak1()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(set0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      String string0 = "N5`W/p";
      int int0 = 0;
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      String string0 = "";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      String string0 = null;
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentException()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking3ArgumentsThrowsPatternSyntaxException()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("hE$vQ)E:/\"mwphS`", wordToSentenceProcessor_NewlineIsSentenceBreak0, true);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Unmatched closing ')' near index 4
         // hE$vQ)E:/\"mwphS`
         //     ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreakWithNonEmptyString()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("million");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'million' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndProcessAndProcessWithEmptyList()  throws Throwable  {
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> stack0 = new Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(true);
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list0 = wordToSentenceProcessor0.process(stack0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTakingBooleanThrowsIllegalArgumentException()  throws Throwable  {
      boolean boolean0 = true;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(true);
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      stack0.clear();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List.of(coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0);
      wordToSentenceProcessor0.process(stack0);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessAndCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      StringLabel stringLabel0 = new StringLabel("'#i{QD");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      HashIndex<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> hashIndex0 = new HashIndex<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(735);
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list0 = hashIndex0.objectsList();
      List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> list1 = treeGraphNode0.yield(list0);
      List<List<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>> list2 = wordToSentenceProcessor0.process(list1);
      assertTrue(list2.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      HashSet<String> hashSet0 = new HashSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(hashSet0);
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode((Label) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel$CoreLabelFactory", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(set0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", "\"", linkedHashSet0, linkedHashSet0, "\"", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, linkedHashSet0, true, false);
  }

  @Test(timeout = 4000)
  public void testProcessDocumentThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.processDocument(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndCallsProcessDocument()  throws Throwable  {
      boolean boolean0 = false;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(false);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.processDocument(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }
}
