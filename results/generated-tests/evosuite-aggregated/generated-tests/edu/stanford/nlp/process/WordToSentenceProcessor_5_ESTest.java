/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Apr 21 17:29:11 GMT 2025
 */

package edu.stanford.nlp.process;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.PresetSequenceClassifier;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CategoryWordTagFactory;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.tokensregex.BasicSequenceMatchResult;
import edu.stanford.nlp.ling.tokensregex.CoreMapSequenceMatcher;
import edu.stanford.nlp.ling.tokensregex.MatchedExpression;
import edu.stanford.nlp.ling.tokensregex.SequencePattern;
import edu.stanford.nlp.ling.tokensregex.types.Expressions;
import edu.stanford.nlp.optimization.StochasticCalculateMethods;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.WordToSentenceProcessor;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.util.DeltaIndex;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.HashableCoreMap;
import java.nio.charset.Charset;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.regex.PatternSyntaxException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class WordToSentenceProcessor_5_ESTest extends WordToSentenceProcessor_5_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      presetSequenceClassifier0.classifyWithInlineXML(")(?:s+[^>]+?s*(?'/\u0007*)?)>");
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess0()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("l;$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("ZHM! ", "ZHM! ", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("l;");
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess1()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("  Oo1gAN<");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("h_/uuX", "", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("  Oo1gAN<");
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess0()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List.of(coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0);
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      HashIndex<String> hashIndex0 = new HashIndex<String>(set0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      DeltaIndex<String> deltaIndex1 = new DeltaIndex<String>(deltaIndex0);
      List<String> list0 = deltaIndex1.objectsList();
      wordToSentenceProcessor0.process(list0);
      Random.setNextRandom((-2274));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTaking7Arguments0()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      String string0 = ":-%$";
      linkedHashSet0.add(":-%$");
      SequencePattern<String> sequencePattern0 = null;
      String string1 = "S=l=ADVP";
      Set<String> set0 = null;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      Charset charset0 = Charset.defaultCharset();
      Set<String> set1 = charset0.aliases();
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(":-%$", "S=l=ADVP", (Set<String>) null, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set1);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      LinkedList<String> linkedList1 = null;
      try {
        linkedList1 = new LinkedList<String>((Collection<? extends String>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess2()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add(":-%$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(":-%$", ":-%$", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(":-%$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak1 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>("", ":-%$", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak1, (SequencePattern<? super String>) null, linkedHashSet0);
      linkedList0.add(":-%$");
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testProcessAndCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add(":-%$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(":-%$", ":-%$", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(":-%$");
      HashSet<String> hashSet0 = new HashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak1 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>("J3gZ", "", linkedHashSet0, hashSet0, "DgVfdz?va`7=_t&nvC", wordToSentenceProcessor_NewlineIsSentenceBreak1, (SequencePattern<? super String>) null, linkedHashSet0, false, false);
      List<List<String>> list0 = wordToSentenceProcessor1.process(linkedList0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndProcess()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(":-%$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(":-%$", ":-%$", linkedHashSet0, linkedHashSet0, ":-%$", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0, false, false);
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess1()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("*R$b=DRFH[Bgwrltr", "<?:DNK>", 34070528, (-2141));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList1 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list1 = treeGraphNode0.yield(list0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      wordToSentenceProcessor0.process(list1);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("*R$b=DRFH[Bgwrltr");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.*R$b=DRFH[Bgwrltr
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess2()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("*R$b=DRFH[Bgwrltr", "\u2029", (-2141), (-2141));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList0);
      CoreLabel coreLabel1 = treeGraphNode0.label();
      List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel1, coreLabel0, coreLabel1, coreLabel0, coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList1 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      wordToSentenceProcessor0.process(list0);
      System.setCurrentTimeMillis((-2141));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess3()  throws Throwable  {
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("\u2029", "\u2029", (-2141), (-2141));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess0()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("*R$b=DRFH[Bgwrltr", "*R$b=DRFH[Bgwrltr", 3076, 34070528);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      treeSet0.add("|)d");
      treeGraphNode0.localTrees();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(treeSet0);
      wordToSentenceProcessor0.process(list0);
      String string0 = ",&yW$/O";
      String string1 = "g&|ZS~Gfy^";
      String string2 = "gZXrmaW_+)`Jqa6~k";
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      BasicSequenceMatchResult<String> basicSequenceMatchResult0 = new BasicSequenceMatchResult<String>();
      basicSequenceMatchResult0.pattern();
      // Undeclared exception!
      try { 
        basicSequenceMatchResult0.start();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.tokensregex.BasicSequenceMatchResult", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTaking7Arguments1()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("EL-Df;M");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("EL-Df;M", "EL-Df;M", linkedHashSet0, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("$");
      wordToSentenceProcessor0.process(linkedList0);
      Random.setNextRandom((-1942));
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsPatternSyntaxException0()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = null;
      try {
        wordToSentenceProcessor1 = new WordToSentenceProcessor<String>("=ez", "RjSp)aY#", (Set<String>) null, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, (Set<String>) null);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Unmatched closing ')' near index 3
         // RjSp)aY#
         //    ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndCreatesWordToSentenceProcessorTaking7Arguments()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("$", "_8Cz", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("$");
      wordToSentenceProcessor0.process(linkedList0);
      Random.setNextRandom((-1942));
      WordToSentenceProcessor<BasicSequenceMatchResult<String>> wordToSentenceProcessor1 = new WordToSentenceProcessor<BasicSequenceMatchResult<String>>(true);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess3()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("$", "$", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("$");
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsPatternSyntaxException()  throws Throwable  {
      TreeSet<String> treeSet0 = new TreeSet<String>();
      CategoryWordTagFactory categoryWordTagFactory0 = new CategoryWordTagFactory();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("<egr=JFJ`:S{]OCHg`");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<String>((String) null, "D}", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Illegal repetition near index 26
         // <\\s*(?:/\\s*)?(?:<egr=JFJ`:S{]OCHg`)(?:\\s+[^>]+?|\\s*(?:/\\s*)?)>
         //                           ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments0()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>((String) null, (String) null, linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
  }

  @Test(timeout = 4000)
  public void testProcessAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("$", "_8Cz", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("");
      wordToSentenceProcessor0.process(linkedList0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      wordToSentenceProcessor1.process(stack0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("$");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.$
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess4()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add(":-%$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(":-%", (String) null, linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add(":-%");
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess5()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("J");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("J", "J", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("J");
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess6()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("$", "_8Cz", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("$");
      wordToSentenceProcessor0.process(linkedList0);
      Random.setNextRandom((-1942));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess1()  throws Throwable  {
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      LinkedList<String> linkedList0 = new LinkedList<String>(set0);
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(set0);
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(603, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess7()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("l;$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("ZHM! ", "ZHM! ", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("l;");
      linkedList0.add("ZHM! ");
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess8()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("$", "$", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("$");
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess9()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("$", "$", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("<s*(?:");
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess10()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("$");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("$", "_8Cz", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("\"");
      wordToSentenceProcessor0.process(linkedList0);
      Random.setNextRandom((-1942));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess11()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("2D>i", "2D>i", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("2D>i");
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>>();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>(":lWs98Wk3\"lW>A5vqqv", ":lWs98Wk3\"lW>A5vqqv", set0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      WordToSentenceProcessor<String> wordToSentenceProcessor2 = new WordToSentenceProcessor<String>(":lWs98Wk3\"lW>A5vqqv", ":lWs98Wk3\"lW>A5vqqv", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      List<List<String>> list0 = wordToSentenceProcessor2.process(linkedList0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTaking7Arguments2()  throws Throwable  {
      TaggedWord taggedWord0 = new TaggedWord();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("Bwx-");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("Bwx-", (String) null, linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("!");
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcessAndProcessWithEmptyList()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("#|sJi'NjUd", "vrC?A2xSL1c<}^>", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak1 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>("#|sJi'NjUd", "nB#\"Xz>pPfo&<V", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak1, (SequencePattern<? super String>) null, linkedHashSet0);
      List<List<String>> list0 = wordToSentenceProcessor1.process(linkedList0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsPatternSyntaxException1()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("vrC?A2xSL1c<}^>", "WGH34~wG1;-u^{t8(JW", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Illegal repetition near index 12
         // WGH34~wG1;-u^{t8(JW
         //             ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsPatternSyntaxException2()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("[", "[", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Unclosed character class near index 0
         // [
         // ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      TreeSet<String> treeSet0 = new TreeSet<String>();
      CategoryWordTagFactory categoryWordTagFactory0 = new CategoryWordTagFactory();
      TaggedWord taggedWord0 = new TaggedWord("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList1 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.subTrees();
      treeGraphNode0.yield(list0);
      treeGraphNode0.isLeaf();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(treeSet0);
      wordToSentenceProcessor0.process(list0);
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>();
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess2()  throws Throwable  {
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      LinkedList<String> linkedList0 = new LinkedList<String>(set0);
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(set0);
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0, (List<Tree>) null);
      TreeGraphNode.factory();
      TreeFactory treeFactory0 = SimpleTree.factory();
      treeGraphNode0.deepCopy(treeFactory0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreak0()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("%s [%d] --> %s [%d]", "always", set0, set0, "always", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, set0, false, true);
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("always");
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("always");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.always
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreak1()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("always");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndProcess()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<String>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<String>>(true);
      Stack<WordToSentenceProcessor<String>> stack0 = new Stack<WordToSentenceProcessor<String>>();
      List<List<WordToSentenceProcessor<String>>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testProcessDocument()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>>("", wordToSentenceProcessor_NewlineIsSentenceBreak0, true);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.processDocument(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessDocumentThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.processDocument(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException()  throws Throwable  {
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess4()  throws Throwable  {
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      LinkedList<String> linkedList0 = new LinkedList<String>(set0);
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess12()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("$", "_8Cz", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
      LinkedList<String> linkedList0 = new LinkedList<String>();
      linkedList0.add("\"");
      wordToSentenceProcessor0.process(linkedList0);
      Random.setNextRandom((-1942));
  }

  @Test(timeout = 4000)
  public void testProcessReturningListWhereIsEmptyIsFalseAndListWhereSizeIsPositive()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      Word word0 = new Word("kSM[;l`{$*5zemoF&v", 309, (-3282));
      Vector<Tree> vector0 = new Vector<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0, vector0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      ArrayList<CoreAnnotations.OriginalTextAnnotation> arrayList0 = new ArrayList<CoreAnnotations.OriginalTextAnnotation>();
      List.of();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode1.yield(arrayList0);
      wordToSentenceProcessor0.process(list0);
      String string0 = "'2dqd5i";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("'2dqd5i");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: ''2dqd5i' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess5()  throws Throwable  {
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      LinkedList<String> linkedList0 = new LinkedList<String>(set0);
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      List<List<String>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void test()  throws Throwable  {
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      String string0 = presetSequenceClassifier0.classifyWithInlineXML(")(?:s+[^>]+?|s*(?:/s*)?)>");
      assertEquals("<>)(?</><>:s+[^>]+?</><>|s*(?</><>:/s*)?)></>", string0);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreak2()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("two");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeExceptionAndCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(linkedHashSet0);
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = List.of(coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeExceptionAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = List.of(coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakWithEmptyString()  throws Throwable  {
      TreeSet<String> treeSet0 = new TreeSet<String>();
      treeSet0.iterator();
      WordToSentenceProcessor<CoreLabel.GenericAnnotation<CoreLabel>> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel.GenericAnnotation<CoreLabel>>(treeSet0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreMapSequenceMatcher<CoreLabel>> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreMapSequenceMatcher<CoreLabel>>();
      String string0 = null;
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreakWithNull()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessReturningListWhereIsEmptyIsTrueAndListWhereSizeIsZero()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(false);
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      wordToSentenceProcessor0.process(stack0);
      String string0 = "(yl0cGtR>9F'1<0";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("(yl0cGtR>9F'1<0");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.(yl0cGtR>9F'1<0
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcessAndProcessWithEmptyList()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>>();
      Vector<WordToSentenceProcessor<CoreLabel>> vector0 = new Vector<WordToSentenceProcessor<CoreLabel>>();
      List<List<WordToSentenceProcessor<CoreLabel>>> list0 = wordToSentenceProcessor0.process(vector0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(false);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process((List<? extends CoreAnnotations.OriginalTextAnnotation>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("V15'");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.V15'
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("' (should be one of 'always', 'never', 'two')");
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("s=vQq");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 's=vQq' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking3Arguments()  throws Throwable  {
      String string0 = "";
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", wordToSentenceProcessor_NewlineIsSentenceBreak0, true);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("eFZO3");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'eFZO3' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreakWithNonEmptyString()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("hum");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'hum' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak0()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<WordToSentenceProcessor<HashableCoreMap>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<HashableCoreMap>>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak1()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<MatchedExpression> wordToSentenceProcessor0 = new WordToSentenceProcessor<MatchedExpression>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      String string0 = "";
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak1 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      boolean boolean0 = false;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", wordToSentenceProcessor_NewlineIsSentenceBreak1, false);
      BasicSequenceMatchResult<CoreAnnotations.OriginalTextAnnotation> basicSequenceMatchResult0 = new BasicSequenceMatchResult<CoreAnnotations.OriginalTextAnnotation>();
      // Undeclared exception!
      try { 
        basicSequenceMatchResult0.toBasicSequenceMatchResult();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.tokensregex.BasicSequenceMatchResult", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndCreatesWordToSentenceProcessorTaking10Arguments0()  throws Throwable  {
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      boolean boolean0 = false;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("%s [%d] --> %s [%d]", "", set0, set0, "", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, set0, false, true);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      String string0 = "<\\s*/\\s*(?:";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("<s*/s*(?:");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.<s*_/s*(?:
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments1()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("$", "$", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(":-%$", ":-%$", linkedHashSet0, linkedHashSet0, ":-%$", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0, false, false);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTakingSetThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>((Set<String>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Collections$UnmodifiableCollection", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(treeSet0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndCreatesWordToSentenceProcessorTaking10Arguments1()  throws Throwable  {
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("Qpb}wzTcX`tIW");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode1.yield(linkedList0);
      String[] stringArray0 = new String[7];
      stringArray0[0] = "&omicron;";
      stringArray0[1] = "Jydd<";
      stringArray0[2] = "Qpb}wzTcX`tIW";
      stringArray0[3] = "&omicron;";
      stringArray0[4] = "<[^f>]*>";
      stringArray0[5] = "&omicron;";
      stringArray0[6] = "Qpb}wzTcX`tIW";
      Expressions.CompositeValue expressions_CompositeValue0 = new Expressions.CompositeValue(stringArray0);
      Set<String> set0 = expressions_CompositeValue0.getAttributes();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("Qpb}wzTcX`tIW", "&omicron;", set0, set0, "&omicron;", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, set0, true, false);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndCreatesWordToSentenceProcessorTakingBoolean()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor<StochasticCalculateMethods> wordToSentenceProcessor0 = new WordToSentenceProcessor<StochasticCalculateMethods>(false);
      String string0 = "CPvWus9!bxSR";
      // Undeclared exception!
      try { 
        SemanticGraph.valueOf("CPvWus9!bxSR", 408);
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.international.Language
         //
         verifyException("edu.stanford.nlp.semgraph.SemanticGraph", e);
      }
  }
}
