/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Apr 21 17:17:46 GMT 2025
 */

package edu.stanford.nlp.process;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.NERClassifierCombiner;
import edu.stanford.nlp.ie.PresetSequenceClassifier;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.tokensregex.BasicSequenceMatchResult;
import edu.stanford.nlp.ling.tokensregex.ComplexNodePattern;
import edu.stanford.nlp.ling.tokensregex.Env;
import edu.stanford.nlp.ling.tokensregex.MatchedExpression;
import edu.stanford.nlp.ling.tokensregex.SequencePattern;
import edu.stanford.nlp.ling.tokensregex.types.Expressions;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.WordToSentenceProcessor;
import edu.stanford.nlp.sequences.SeqClassifierFlags;
import edu.stanford.nlp.sequences.TrueCasingForNISTDocumentReaderAndWriter;
import edu.stanford.nlp.stats.IntCounter;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.util.ArrayCoreMap;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.MutableInteger;
import edu.stanford.nlp.util.Pair;
import java.time.ZoneId;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.regex.PatternSyntaxException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class WordToSentenceProcessor_1_ESTest extends WordToSentenceProcessor_1_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess0()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("America/Rosario", (-1721038688), (-1721038688));
      coreLabelTokenFactory0.makeToken();
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      MapFactory.treeMapFactory();
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("America/Guadeloupe", "-splitIN", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, set0);
      wordToSentenceProcessor0.process(list0);
      Random.setNextRandom((-1721038688));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess0()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(linkedHashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("  Ekamle badwr+ot reJres as leaf3");
      wordToSentenceProcessor0.process(list0);
      System.setCurrentTimeMillis((-1L));
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("  Ekamle badwr+ot reJres as leaf3");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.  Ekamle badwr+ot reJres as leaf3
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException0()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("\u2029", 517, (-2161));
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, seqClassifierFlags0.pad, seqClassifierFlags0.pad);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess1()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(linkedHashSet0);
      linkedHashSet0.add("");
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(6, list1.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerExceptionAndCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(linkedHashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("", (-1883818857), (-1883818857));
      Properties properties0 = new Properties();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      CoreLabel coreLabel1 = seqClassifierFlags0.pad;
      CoreLabel.factory();
      CoreLabel coreLabel2 = new CoreLabel(coreLabel0);
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel2, coreLabel1, seqClassifierFlags0.pad, seqClassifierFlags0.pad, seqClassifierFlags0.pad);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess2()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(linkedHashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("  Example bad root rewrites as leaf: ");
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndProcess0()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("@;BI&CF");
      MapFactory<String, WordToSentenceProcessor<CoreLabel>> mapFactory0 = MapFactory.weakHashMapFactory();
      Set<String> set0 = mapFactory0.newSet();
      Locale.IsoCountryCode locale_IsoCountryCode0 = Locale.IsoCountryCode.PART1_ALPHA2;
      Locale.getISOCountries(locale_IsoCountryCode0);
      Set<String> set1 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("@;BI&CF", "<?:LBR>", set1, set0, "\u2029", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, set1, false, true);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess0()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("*NL*");
      ArrayCoreMap.listener = null;
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      CoreLabel coreLabel1 = stack0.push(coreLabel0);
      Stack<CoreLabel> stack1 = new Stack<CoreLabel>();
      stack0.push(coreLabel1);
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>();
      List<List<CoreLabel>> list0 = wordToSentenceProcessor1.process(stack0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException1()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("*NL*", 522, 522);
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, seqClassifierFlags0.pad, seqClassifierFlags0.pad, coreLabel0, seqClassifierFlags0.pad);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndProcess0()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("*NL*");
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      stack0.push(coreLabel0);
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(false);
      List<List<CoreLabel>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess1()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("*NL*");
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      stack0.push(coreLabel0);
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      List<List<CoreLabel>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking3ArgumentsThrowsPatternSyntaxException0()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      List<String> list0 = List.of("=p.$gbB:T1~xFwD^Lk", "@;BI&CF", "@;BI&CF", "SBPoST%U*I;V", "@;BI&CF", "=p.$gbB:T1~xFwD^Lk");
      wordToSentenceProcessor0.process(list0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak1 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<List<String>> wordToSentenceProcessor1 = null;
      try {
        wordToSentenceProcessor1 = new WordToSentenceProcessor<List<String>>("EF]@4(l-p,KT?yqZ", wordToSentenceProcessor_NewlineIsSentenceBreak1, true);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Unclosed group near index 16
         // EF]@4(l-p,KT?yqZ
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>(set0);
      List<String> list0 = List.of(") iT69Oa&36G", ") iT69Oa&36G", "EqGW:&oyA\"LmH3+B5;", "EqGW:&oyA\"LmH3+B5;", "*;#`g`v0oWB", ") iT69Oa&36G");
      List<List<String>> list1 = wordToSentenceProcessor1.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess3()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(linkedHashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      linkedHashSet0.add("");
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("");
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndProcess1()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(false);
      Label label0 = null;
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("never");
      stack0.push(coreLabel0);
      wordToSentenceProcessor0.process(stack0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      WordLemmaTag wordLemmaTag0 = null;
      try {
        wordLemmaTag0 = new WordLemmaTag((Label) null, (Label) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.WordLemmaTag", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess2()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("X3LrRU{EYWx");
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess1()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("<?:AFG>");
      stack0.push(coreLabel0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      Locale.IsoCountryCode locale_IsoCountryCode0 = Locale.IsoCountryCode.PART1_ALPHA3;
      Set<String> set0 = Locale.getISOCountries(locale_IsoCountryCode0);
      ComplexNodePattern.StringInSetAnnotationPattern complexNodePattern_StringInSetAnnotationPattern0 = new ComplexNodePattern.StringInSetAnnotationPattern(set0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("<?:DYBJ>", "<?:DYBJ>", treeSet0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, treeSet0);
      List<List<CoreLabel>> list0 = wordToSentenceProcessor0.process(stack0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndProcess1()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("TWO_CONSECUTIVE");
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("TWO_CONSECUTIVE");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("TWO_CONSECUTIVE", "TWO_CONSECUTIVE", linkedHashSet0, linkedHashSet0, "TWO_CONSECUTIVE", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, linkedHashSet0, false, false);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess2()  throws Throwable  {
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("3", 586, 586);
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("3", "3", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, set0);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakWithEmptyString()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("@;&I:CF");
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("@;&I:CF");
      MapFactory<String, WordToSentenceProcessor<CoreLabel>> mapFactory0 = MapFactory.weakHashMapFactory();
      Set<String> set0 = mapFactory0.newSet();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      String string0 = "";
      Locale.IsoCountryCode locale_IsoCountryCode0 = Locale.IsoCountryCode.PART3;
      Set<String> set1 = Locale.getISOCountries(locale_IsoCountryCode0);
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("@;&I:CF", "", set0, set1, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, set0);
      wordToSentenceProcessor0.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndProcessWithNonEmptyList()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("@;&I:CF");
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("@;&I:CF");
      MapFactory<String, WordToSentenceProcessor<CoreLabel>> mapFactory0 = MapFactory.weakHashMapFactory();
      Set<String> set0 = mapFactory0.newSet();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("@;&I:CF", ", bt7;R", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, set0);
      wordToSentenceProcessor0.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak(", bt7;R");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: ', bt7;R' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndProcess2()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("TWO_CONSECUTIVE");
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("TWO_CONSECUTIVE", "TWO_CONSECUTIVE", linkedHashSet0, linkedHashSet0, "TWO_CONSECUTIVE", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, linkedHashSet0, false, false);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.processDocument(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreak0()  throws Throwable  {
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("0");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '0' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("always");
      WordToSentenceProcessor.NewlineIsSentenceBreak[] wordToSentenceProcessor_NewlineIsSentenceBreakArray0 = WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      assertEquals(3, wordToSentenceProcessor_NewlineIsSentenceBreakArray0.length);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("always");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndStringToNewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("' (should be one of 'always', 'never', 'two')");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments0()  throws Throwable  {
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<MatchedExpression> wordToSentenceProcessor0 = new WordToSentenceProcessor<MatchedExpression>("ekamle", "ekamle", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super MatchedExpression>) null, set0);
      Random.setNextRandom((-1));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      String[] stringArray0 = new String[1];
      stringArray0[0] = "rxhP";
      Expressions.CompositeValue expressions_CompositeValue0 = new Expressions.CompositeValue(stringArray0);
      Set<String> set0 = expressions_CompositeValue0.getAttributes();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      BasicSequenceMatchResult<String> basicSequenceMatchResult0 = new BasicSequenceMatchResult<String>();
      basicSequenceMatchResult0.pattern();
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("O'.8nsNU/7U4e?", "rxhP", set0, set0, "'\"B;+0Tg&", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0, true, false);
      WordToSentenceProcessor.NewlineIsSentenceBreak[] wordToSentenceProcessor_NewlineIsSentenceBreakArray0 = WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      assertEquals(3, wordToSentenceProcessor_NewlineIsSentenceBreakArray0.length);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("TWO_CONSECUTIVE", "TWO_CONSECUTIVE", linkedHashSet0, linkedHashSet0, "TWO_CONSECUTIVE", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, linkedHashSet0, false, false);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking3ArgumentsThrowsPatternSyntaxException1()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(", bt7;R", "Reading weights from ", (Set<String>) null, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, (Set<String>) null);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TaggedWord taggedWord0 = new TaggedWord(categoryWordTag0, categoryWordTag0);
      taggedWord0.equals(wordToSentenceProcessor0);
      taggedWord0.setTag("x}");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak1 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = null;
      try {
        wordToSentenceProcessor1 = new WordToSentenceProcessor<String>("+o|^bSz", wordToSentenceProcessor_NewlineIsSentenceBreak1, true);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Dangling meta character '+' near index 0
         // +o|^bSz
         // ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsPatternSyntaxException()  throws Throwable  {
      List<String> list0 = null;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("*NV*", "*NV*", (Set<String>) null, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, (Set<String>) null);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Dangling meta character '*' near index 0
         // *NV*
         // ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess3()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("!");
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(6, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess4()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\u2029");
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(6, list1.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerExceptionAndCreatesWordToSentenceProcessorTakingBoolean()  throws Throwable  {
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(true);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process((List<? extends String>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentException0()  throws Throwable  {
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("by", "by", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("by");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'by' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsPatternSyntaxException0()  throws Throwable  {
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      String string0 = null;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<String>((String) null, "[p{Pe}p{Pf}\"'>\uFF02\uFF07\uFF1E)}]]|''|\u2019\u2019|-R[CRS]B-", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Dangling meta character '*' near index 16
         // <\\s*(?:/\\s*)?(?:*NL*)(?:\\s+[^>]+?|\\s*(?:/\\s*)?)>
         //                 ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsPatternSyntaxException1()  throws Throwable  {
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<String>((String) null, (String) null, set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Dangling meta character '*' near index 16
         // <\\s*(?:/\\s*)?(?:*NL*)(?:\\s+[^>]+?|\\s*(?:/\\s*)?)>
         //                 ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsPatternSyntaxException2()  throws Throwable  {
      String string0 = "by";
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("by", "by", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Dangling meta character '*' near index 16
         // <\\s*(?:/\\s*)?(?:*NL*)(?:\\s+[^>]+?|\\s*(?:/\\s*)?)>
         //                 ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTaking7Arguments()  throws Throwable  {
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      Properties properties0 = new Properties();
      Set<String> set0 = properties0.stringPropertyNames();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      Set<String> set1 = presetSequenceClassifier0.labels();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>((String) null, (String) null, set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, set1);
      wordToSentenceProcessor0.process(stack0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("?ofQ");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '?ofQ' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments1()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("TWO_CONSECUTIVE", "TWO_CONSECUTIVE", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, linkedHashSet0);
  }

  @Test(timeout = 4000)
  public void testProcessDocument()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.processDocument(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      Locale.IsoCountryCode locale_IsoCountryCode0 = Locale.IsoCountryCode.PART1_ALPHA3;
      Set<String> set0 = Locale.getISOCountries(locale_IsoCountryCode0);
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(set0);
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor1 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      String string0 = null;
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreakWithNull()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak0()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("*NL*");
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      stack0.push(coreLabel0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      List<List<CoreLabel>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess4()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("bad");
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(linkedHashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("  Example bad root rewrites as leaf: ");
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(3, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess5()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("*NL*");
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testProcessReturningListWhereIsEmptyIsFalseAndListWhereSizeIsPositive()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      String string0 = ",%bt7;R";
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply(",%bt7;R");
      List<CoreLabel> list1 = presetSequenceClassifier0.classifyWithGlobalInformation(list0, (CoreMap) null, (CoreMap) null);
      wordToSentenceProcessor0.process(list1);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      String string1 = "mPVsM(?J.FQs^z.yD[`";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("mPVsM(?J.FQs^z.yD[`");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.mPVsM(?J.FQs^z.yD[`
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeException()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = List.of(coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException2()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsIndexOutOfBoundsException()  throws Throwable  {
      String string0 = "";
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>("", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      int int0 = 619;
      // Undeclared exception!
      try { 
        vector0.listIterator(619);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 619
         //
         verifyException("java.util.Vector", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess5()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(linkedHashSet0);
      linkedHashSet0.add("\u2029");
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\u2029");
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(6, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcessAndProcessWithEmptyList()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<List<CoreAnnotations.OriginalTextAnnotation>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerExceptionAndProcessWithNull()  throws Throwable  {
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process((List<? extends String>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessAndProcess()  throws Throwable  {
      TreeSet<String> treeSet0 = new TreeSet<String>();
      treeSet0.add("recognising");
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(treeSet0);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor1 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(treeSet0);
      Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      wordToSentenceProcessor1.process(vector0);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      String string0 = ")_^RYh SK(%i]hIh";
      String string1 = "8";
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      SequencePattern.Parser<CoreAnnotations.OriginalTextAnnotation> sequencePattern_Parser0 = (SequencePattern.Parser<CoreAnnotations.OriginalTextAnnotation>) mock(SequencePattern.Parser.class, new ViolatedAssumptionAnswer());
      doReturn((Pair) null).when(sequencePattern_Parser0).parseSequenceWithAction(any(edu.stanford.nlp.ling.tokensregex.Env.class) , anyString());
      Env env0 = new Env(sequencePattern_Parser0);
      // Undeclared exception!
      try { 
        SequencePattern.compile(env0, "8");
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Error compiling 8 using environment edu.stanford.nlp.ling.tokensregex.Env@3
         //
         verifyException("edu.stanford.nlp.ling.tokensregex.SequencePattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBoolean()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(false);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak(";H");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: ';H' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak1()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      String string0 = "Zux";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("Zux");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.Zux
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak2()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTakingNoArgumentsThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>((Set<String>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Collections$UnmodifiableCollection", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentException1()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      Set<String> set0 = presetSequenceClassifier0.labels();
      MapFactory<String, MutableInteger> mapFactory0 = MapFactory.identityHashMapFactory();
      IntCounter<String> intCounter0 = new IntCounter<String>(mapFactory0);
      Set<String> set1 = intCounter0.keysAt(3);
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("C4;Bip\"", "IS_NUM", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set1);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("IS_NUM");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'IS_NUM' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<LabeledWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<LabeledWord>();
      LinkedList<LabeledWord> linkedList0 = new LinkedList<LabeledWord>();
      String string0 = "underpin";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("IXr>Tl{bpD=(U7'7");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'IXr>Tl{bpD=(U7'7' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreak1()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("added to current");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'added to current' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }
}
