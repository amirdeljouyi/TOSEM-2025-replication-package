/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Apr 21 19:08:33 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.international.morph.MorphoFeatureSpecification;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.StringLabel;
import edu.stanford.nlp.ling.StringLabelFactory;
import edu.stanford.nlp.ling.Tag;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordFactory;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.ling.WordTagFactory;
import edu.stanford.nlp.objectbank.IdentityFunction;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HungarianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ItalianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.NegraPennTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.SpanishUnknownWordModelTrainer;
import edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor;
import edu.stanford.nlp.parser.lexparser.TestOptions;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.trees.ConstituentFactory;
import edu.stanford.nlp.trees.CoordinationTransformer;
import edu.stanford.nlp.trees.DiskTreebank;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.MemoryTreebank;
import edu.stanford.nlp.trees.NPTmpRetainingTreeNormalizer;
import edu.stanford.nlp.trees.RightHeadFinder;
import edu.stanford.nlp.trees.SimpleConstituentFactory;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.SynchronizedTreeTransformer;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeGraphNodeFactory;
import edu.stanford.nlp.util.DeltaIndex;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.ThreeDimensionalMap;
import edu.stanford.nlp.util.Triple;
import edu.stanford.nlp.util.TwoDimensionalMap;
import edu.stanford.nlp.util.logging.Redwood;
import java.time.ZoneId;
import java.util.ArrayDeque;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.function.UnaryOperator;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.util.SystemInUtil;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class SplittingGrammarExtractor_4_ESTest extends SplittingGrammarExtractor_4_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testNeginfDoublesReturningEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.neginfDoubles(0);
      TwoDimensionalMap.hashMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(splittingGrammarExtractor1.equals((Object)splittingGrammarExtractor0));
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[8][4][7];
      double[][] doubleArray1 = new double[3][6];
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray2 = new double[6][8];
      doubleArray0[7] = doubleArray2;
      doubleArray0[2] = doubleArray1;
      double[][] doubleArray3 = new double[0][6];
      doubleArray0[3] = doubleArray3;
      double[] doubleArray4 = new double[8];
      doubleArray4[1] = 0.0;
      doubleArray4[2] = 0.0;
      doubleArray4[3] = (double) 100;
      doubleArray4[5] = 0.0;
      doubleArray4[7] = 0.0;
      doubleArray0[6] = doubleArray2;
      double[][] doubleArray5 = new double[1][0];
      doubleArray0[5] = doubleArray5;
      double[][] doubleArray6 = new double[9][1];
      doubleArray6[1] = doubleArray4;
      twoDimensionalMap0.put("#hi-eu", "#hi-eu", doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap1, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap0, identityHashMap3, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer.getInteger("#hi-eu", 100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[0][2];
      identityHashMap1.put(treeGraphNode0, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray1 = new double[7];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.001208650973866179;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = (double) 100;
      doubleArray1[4] = (double) 100;
      doubleArray1[5] = 0.0;
      doubleArray1[6] = 0.0;
      MapFactory<Object, Object> mapFactory0 = MapFactory.linkedHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray1, 1597, identityHashMap1, identityHashMap2, map0, twoDimensionalMap0, threeDimensionalMap1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndMergeStates0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag();
      WordTag wordTag0 = new WordTag(tag0, tag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode3 = treeGraphNode2.highestNodeWithSameHead();
      Vector<Tree> vector0 = new Vector<Tree>();
      treeGraphNode2.addChild((Tree) treeGraphNode3);
      Vector<Tree> vector1 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[1][7];
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = 0.0;
      doubleArray0[0] = doubleArray1;
      identityHashMap2.put(treeGraphNode2, doubleArray0);
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 964, identityHashMap2, identityHashMap3);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndUseNewBetas0()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = new LinkedList<Tree>();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      double[][] doubleArray0 = new double[2][7];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      doubleArray0[0] = doubleArray2;
      twoDimensionalMap0.put("#hi-eu", "#hi-eu", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      double[][] doubleArray0 = new double[2][7];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      doubleArray0[1] = doubleArray2;
      twoDimensionalMap0.put("#hi-eu", "#hi-eu", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndUseNewBetas1()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[][] doubleArray0 = new double[2][7];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      doubleArray0[1] = doubleArray2;
      twoDimensionalMap0.put("#hi-eu", "#hi-eu", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNonEmptyMapAndNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("^100");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Stack<Tree> stack0 = new Stack<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = 2055.2456693980857;
      doubleArray0[6] = (double) 100;
      doubleArray0[7] = (double) 100;
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray1 = new double[0];
      hashMap0.put("^100", doubleArray1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStateThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = "^100";
      LabeledWord labeledWord0 = new LabeledWord("^100");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      SystemInUtil.addInputLine((String) null);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Stack<Tree> stack0 = new Stack<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 1685.661;
      doubleArray0[3] = 0.0;
      doubleArray0[5] = (double) 100;
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray1 = new double[0];
      hashMap0.put("^100", doubleArray1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndOutputTransitionsTaking4ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.postOrderNodeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[8][4][7];
      double[][] doubleArray1 = new double[2][6];
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray2 = new double[6][8];
      doubleArray0[7] = doubleArray1;
      doubleArray0[2] = doubleArray1;
      doubleArray0[3] = doubleArray1;
      double[] doubleArray3 = new double[8];
      doubleArray3[1] = 0.0;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = (double) 100;
      doubleArray3[5] = 0.0;
      doubleArray3[7] = 0.0;
      doubleArray0[6] = doubleArray2;
      doubleArray0[5] = doubleArray1;
      doubleArray2[1] = doubleArray3;
      identityHashMap2.put(treeGraphNode0, doubleArray0);
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndOutputTransitionsTaking4ArgumentsWithNonEmptyMap0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[8][4][7];
      double[][] doubleArray1 = new double[3][6];
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray2 = new double[6][8];
      doubleArray0[7] = doubleArray2;
      doubleArray0[2] = doubleArray1;
      double[][] doubleArray3 = new double[0][6];
      doubleArray0[3] = doubleArray3;
      double[] doubleArray4 = new double[8];
      doubleArray4[2] = 0.0;
      doubleArray4[3] = (double) 100;
      doubleArray4[5] = 0.0;
      doubleArray4[7] = 0.0;
      doubleArray0[6] = doubleArray2;
      doubleArray0[5] = doubleArray1;
      doubleArray2[1] = doubleArray4;
      identityHashMap2.put(treeGraphNode0, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap2);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndMergeStates1()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.identityHashMap();
      double[][] doubleArray0 = new double[13][0];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Word word0 = new Word();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode3 = treeGraphNode2.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode4 = treeGraphNode3.highestNodeWithSameHead();
      treeGraphNode4.subTreeList();
      treeGraphNode3.addChild((Tree) treeGraphNode2);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer.getInteger((String) null, 100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = splittingGrammarExtractor0.binaryBetas;
      identityHashMap1.put(treeGraphNode0, doubleArray0);
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode4, 100, identityHashMap1, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndOutputTransitionsTaking4ArgumentsWithNonEmptyMap1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[1][2];
      identityHashMap1.put(treeGraphNode0, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      vector0.addAll((Collection<? extends Tree>) list0);
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndMergeStates2()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer.getInteger("#hi-eu", 100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[0][2];
      identityHashMap1.put(treeGraphNode0, doubleArray0);
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsTooManyResourcesException()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[0][2];
      identityHashMap1.put(treeGraphNode0, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      vector0.addAll((Collection<? extends Tree>) list0);
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsAndRecountTreeTaking6ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("o` &S1|3q]=z4");
      WordTag wordTag0 = WordTag.valueOf("o` &S1|3q]=z4");
      wordTag0.setTag("TW0'Z");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      wordTag0.toString();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeFactory treeFactory0 = TreeGraphNode.factory();
      treeGraphNode0.deepCopy(treeFactory0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountTree((Tree) treeGraphNode1, true, identityHashMap1, identityHashMap0, identityHashMap2, identityHashMap3);
      assertFalse(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4Arguments0()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.parent();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer.getInteger("`tZ^DV(%F>b6dpV|", 100);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.outputTransitions((Tree) treeGraphNode1, 350, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      IdentityHashMap<String, double[][]> identityHashMap0 = new IdentityHashMap<String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.parent();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, (-2422), identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndCountOriginalStates0()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(1203700733, false, (-706), true, false);
      SynchronizedTreeTransformer synchronizedTreeTransformer0 = new SynchronizedTreeTransformer(nPTmpRetainingTreeNormalizer0);
      Tree tree0 = treeGraphNode0.skipRoot();
      treeGraphNode0.addChild(tree0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(1203700733);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.countOriginalStates();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndRecountWeightsWithEmptyMap0()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, CoreLabel> twoDimensionalMap1 = TwoDimensionalMap.identityHashMap();
      Morphology morphology0 = new Morphology();
      twoDimensionalMap0.addAll(twoDimensionalMap1, morphology0);
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      options0.rerankerKBest = 46;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecountWeightsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap5 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap3, identityHashMap4, identityHashMap5, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecountInsideWithNonEmptyMap0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag();
      WordTag wordTag0 = new WordTag(tag0, tag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(wordTag0, list1);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      int int0 = 172;
      Integer integer0 = new Integer(172);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap6 = new IdentityHashMap<Tree, double[]>();
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      treeGraphNode0.constituents((ConstituentFactory) simpleConstituentFactory0, 100);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(simpleTree0, false, 100, identityHashMap6);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndRecountInsideWithNonEmptyMap()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.getMap("Cannot compute precision and recall on unlabelled dataset. Offending datum: ");
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("MDd9f?0/{d/HeT[re");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      LabelFactory labelFactory0 = WordTag.factory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      Tree tree0 = treeGraphNode0.deepCopy((TreeFactory) treeGraphNodeFactory0);
      treeGraphNode0.addChild(tree0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer((-1100));
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 1, identityHashMap1, identityHashMap2);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      SimpleTree simpleTree0 = new SimpleTree(tree0, list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(simpleTree0, true, 100, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4Arguments1()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      options0.rerankerKBest = 46;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      int int0 = (-1073741824);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 46, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor0()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecurseOutsideWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      WordTag wordTag0 = WordTag.valueOf("\"!-ls2byj");
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      wordTag1.toString();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledWord0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("#'i-u");
      WordTag wordTag0 = new WordTag(tag0, tag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      treeGraphNode0.subTreeList();
      Morphology.stemStatic("#'i-u", "#'i-u");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("#'i-u", "#'i-u");
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(wordLemmaTag0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>(100, 100);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      hashMap0.put("#'i-u", doubleArray0);
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap2, identityHashMap2);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode2, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap1, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Stack<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      hashMap0.put("#hi-eu", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecountOutsideTaking3ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, identityHashMap3, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndCountOriginalStates1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.countOriginalStates();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningNegative()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      options0.doDep = false;
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      WordTag wordTag0 = WordTag.valueOf("g4\"]B+k9/R9.");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      wordTag0.toString();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor1.recountInside(treeGraphNode1, false, (-3093), identityHashMap0);
      assertEquals((-3092), int0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      int int0 = (-1073741824);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.recountInside(treeGraphNode0, options0.directional, int0, identityHashMap3);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecountInside0()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      int int0 = (-1073741824);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(treeGraphNode0, options0.directional, int0, identityHashMap3);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Stack<Tree> stack0 = new Stack<Tree>();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      double[] doubleArray0 = new double[6];
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(identityHashMap1);
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>(100);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap2, doubleArray0, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8Arguments0()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordTag wordTag0 = Morphology.stemStatic("#hi-eu", "#hi-eu");
      WordLemmaTag wordLemmaTag0 = Morphology.lemmatizeStatic(wordTag0);
      LabeledWord labeledWord0 = new LabeledWord(wordLemmaTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      wordLemmaTag0.toString();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      double[] doubleArray0 = new double[1];
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.getStateSplitCount((Tree) treeGraphNode0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) null, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningZero()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      Tag tag0 = new Tag("ER{an(=G$x~f|?vfil{");
      WordTag wordTag0 = new WordTag(tag0, tag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      wordTag0.toString();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.recountInside(treeGraphNode1, false, (-1), identityHashMap0);
      boolean boolean0 = splittingGrammarExtractor1.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8Arguments1()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordTag wordTag0 = Morphology.stemStatic("#hi-eu", "#hi-eu");
      WordLemmaTag wordLemmaTag0 = Morphology.lemmatizeStatic(wordTag0);
      LabeledWord labeledWord0 = new LabeledWord(wordLemmaTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledWord0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      wordLemmaTag0.toString();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      double[] doubleArray0 = new double[1];
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.getStateSplitCount((Tree) treeGraphNode1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) null, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag();
      WordTag wordTag0 = new WordTag(tag0, tag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(wordTag0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.getStateSplitCount((Tree) treeGraphNode1);
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, (double[]) null, 0, identityHashMap1, identityHashMap4, (Map<String, double[]>) null, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecalculateTemporaryBetasTaking8ArgumentsWithEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) null, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecurseOutside()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("~~");
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      WordTag wordTag0 = new WordTag(tag0, tag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      wordTag0.toString();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.recurseOutside(treeGraphNode1, identityHashMap0, identityHashMap0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      int int0 = splittingGrammarExtractor0.recountInside(tree0, false, 18, identityHashMap0);
      assertEquals(19, int0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("PM]GiT(_.s(2Lqq", "PM]GiT(_.s(2Lqq", "PM]GiT(_.s(2Lqq");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("PM]GiT(_.s(2Lqq");
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      WordTag wordTag0 = new WordTag(tag0, tag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      wordTag0.toString();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recurseOutside(treeGraphNode1, identityHashMap0, identityHashMap0);
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode1, true, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndCountMergeEffectsTaking3Arguments0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("#'i-u");
      WordTag wordTag0 = new WordTag(tag0, tag0);
      LabeledWord labeledWord0 = new LabeledWord(wordTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(wordTag0, list1);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode1, list1);
      Tree tree0 = treeGraphNode2.treeSkeletonCopy();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1);
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = 0.0;
      doubleArray0[7] = (-1.0);
      doubleArray0[8] = (-32.7336878643);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, Integer.MAX_VALUE, identityHashMap2, identityHashMap3, (Map<String, double[]>) identityHashMap1, twoDimensionalMap2, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNullAndRecurseOutsideAndSaveTrees()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      WordTag wordTag0 = Morphology.stemStatic("#Ci-u", "#Ci-u");
      WordLemmaTag wordLemmaTag0 = Morphology.lemmatizeStatic(wordTag0);
      LabeledWord labeledWord0 = new LabeledWord(wordLemmaTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledWord0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      wordLemmaTag0.toString();
      Integer integer0 = new Integer(3363);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recurseOutside(treeGraphNode1, identityHashMap2, identityHashMap2);
      treeGraphNode1.ancestor(100, treeGraphNode0);
      Tree.valueOf("#Ci-u");
      splittingGrammarExtractor1.saveTrees(treeGraphNode1, (-2831.759), (Collection<Tree>) null, 3363);
      assertFalse(treeGraphNode1.equals((Object)treeGraphNode0));
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsAndBuildMergeCorrespondenceAndMergeStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("#Ci-u", "#Ci-u", "#Ci-u");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("#Ci-u");
      WordTag wordTag0 = new WordTag(tag0, tag0);
      LabeledWord labeledWord0 = new LabeledWord(wordTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      splittingGrammarExtractor1.buildMergeCorrespondence(stack0);
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) treeGraphNode0, true, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStateWithNull()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[2][9];
      double[] doubleArray1 = new double[1];
      doubleArray0[0] = doubleArray1;
      options0.forceCNF = false;
      twoDimensionalMap0.put("e0'Z", "e0'Z", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.state((String) null, 80);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      WordTag wordTag0 = Morphology.stemStatic("#Ci-u", "#Ci-u");
      WordLemmaTag wordLemmaTag0 = Morphology.lemmatizeStatic(wordTag0);
      LabeledWord labeledWord0 = new LabeledWord(wordLemmaTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledWord0, list0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      wordLemmaTag0.toString();
      Integer integer0 = new Integer(3363);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recurseOutside(treeGraphNode1, identityHashMap2, identityHashMap2);
      assertFalse(treeGraphNode0.equals((Object)treeGraphNode1));
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndSaveTrees0()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      WordTag wordTag0 = Morphology.stemStatic("#Ci-u", "#Ci-u");
      WordLemmaTag wordLemmaTag0 = Morphology.lemmatizeStatic(wordTag0);
      LabeledWord labeledWord0 = new LabeledWord(wordLemmaTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledWord0, list0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      wordLemmaTag0.toString();
      Integer integer0 = new Integer(3363);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.saveTrees(treeGraphNode1, 0.0, treeGraphNode1, 100);
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideWithTrue()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("o`6&S1|3q]=z4");
      WordTag wordTag0 = new WordTag("o`6&S1|3q]=z4", "o`6&S1|3q]=z4");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode1, true, 100, identityHashMap0);
      assertEquals(101, int0);
      
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>(101);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode1, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, doubleArray0, map0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndGetStateSplitCountTakingTree()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      hashMap0.put("#hi-eu", doubleArray0);
      splittingGrammarExtractor0.getStateSplitCount((Tree) treeGraphNode0);
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = (double) 0;
      doubleArray1[4] = 0.0;
      doubleArray1[5] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray1, 1, identityHashMap1, identityHashMap2, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRescaleTemporaryBetas()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      double[][] doubleArray0 = new double[1][0];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      threeDimensionalMap0.contains((String) null, (String) null, "9^4Ibpy[}x4Q98nPc");
      double[][][] doubleArray2 = new double[8][4][4];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      doubleArray2[2] = doubleArray0;
      doubleArray2[3] = doubleArray0;
      doubleArray2[4] = doubleArray0;
      doubleArray2[5] = doubleArray0;
      doubleArray2[6] = doubleArray0;
      doubleArray2[7] = doubleArray0;
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray2);
      twoDimensionalMap0.isEmpty();
      TestOptions testOptions0 = new TestOptions();
      options0.testOptions = testOptions0;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
      assertTrue(twoDimensionalMap1.equals((Object)twoDimensionalMap0));
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newLeaf("#Ci-u");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      List<Tree> list0 = treeGraphNode0.subTreeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("#Ci-u", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tree1, list0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      MapFactory<String, double[][]> mapFactory1 = MapFactory.weakHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, false, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap1);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.identityHashMap();
      tree0.deepCopy();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, true, (Map<String, double[]>) identityHashMap0, twoDimensionalMap2, threeDimensionalMap0);
      assertTrue(twoDimensionalMap2.equals((Object)twoDimensionalMap1));
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecalculateTemporaryBetasTaking8ArgumentsWithNonEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledWord0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer((-109));
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      MapFactory<Object, String> mapFactory0 = MapFactory.arrayMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 100, identityHashMap1, identityHashMap2, map0, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testMergeStatesAndGetStateSplitCountTakingTreeAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      WordTag wordTag0 = Morphology.stemStatic("#hi-eu", "#hi-eu");
      WordLemmaTag wordLemmaTag0 = Morphology.lemmatizeStatic(wordTag0);
      LabeledWord labeledWord0 = new LabeledWord(wordLemmaTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledWord0, list0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      wordLemmaTag0.toString();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = splittingGrammarExtractor1.binaryBetas;
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) null, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap2);
      splittingGrammarExtractor0.getStateSplitCount((Tree) treeGraphNode1);
      splittingGrammarExtractor1.mergeStates();
      assertFalse(splittingGrammarExtractor1.equals((Object)splittingGrammarExtractor0));
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<String, double[][]> identityHashMap0 = new IdentityHashMap<String, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      options0.nodePrune = true;
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newLeaf("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("    ", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tree0, list0);
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      Comparator<String> comparator0 = (Comparator<String>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      MapFactory<String, double[][]> mapFactory1 = MapFactory.weakHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, true, (Map<String, double[]>) identityHashMap2, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      splittingGrammarExtractor0.outputTransitions(tree0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1);
      splittingGrammarExtractor0.getStateSplitCount("    ");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) tree1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityFunction<double[][]> identityFunction0 = new IdentityFunction<double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][][]>();
      splittingGrammarExtractor0.getStateSplitCount((Tree) treeGraphNode0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, (double[]) null, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      twoDimensionalMap0.getMap("#Ci-u");
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("<~Kel2%_Fuj", "<~Kel2%_Fuj", "#Ci-u");
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      StringLabel stringLabel0 = new StringLabel();
      WordTag wordTag0 = Morphology.stemStatic("zaDJ", "#Ci-u");
      LabeledWord labeledWord0 = new LabeledWord(wordTag0, stringLabel0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      Morphology morphology0 = new Morphology();
      WordLemmaTag wordLemmaTag0 = morphology0.lemmatize(wordTag0);
      SimpleTree simpleTree0 = new SimpleTree(wordLemmaTag0, list1);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1);
      assertEquals(Double.NaN, treeGraphNode1.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndCountMergeEffectsTaking3Arguments1()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("PM]GiT(_.s(2Lqq");
      WordTag wordTag0 = new WordTag(tag0, tag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      wordTag0.toString();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(tag0, list0);
      treeGraphNode2.treeSkeletonCopy();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode2, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1);
      assertFalse(treeGraphNode2.equals((Object)treeGraphNode0));
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("<~Kel2%_Fuj", "<~Kel2%_Fuj", "#Ci-u");
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateBetas(true);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      StringLabel stringLabel0 = new StringLabel();
      WordTag wordTag0 = Morphology.stemStatic("<~Kel2%_Fuj", "<~Kel2%_Fuj");
      LabeledWord labeledWord0 = new LabeledWord(wordTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(labeledWord0, list1);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      treeGraphNode0.treeFactory();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(treeGraphNode1, identityHashMap0, identityHashMap0, identityHashMap2, identityHashMap3);
      assertTrue(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("<~Kel2%_Fuj", "<~Kel2%_Fuj", "#Ci-u");
      splittingGrammarExtractor0.recalculateBetas(true);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      StringLabel stringLabel0 = new StringLabel();
      WordTag wordTag0 = Morphology.stemStatic("<~Kel2%_Fuj", "<~Kel2%_Fuj");
      LabeledWord labeledWord0 = new LabeledWord(wordTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      treeGraphNode1.subTreeList();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, identityHashMap2, (IdentityHashMap<Tree, double[][][]>) null);
      assertEquals(Double.NaN, treeGraphNode1.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndSaveTrees()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      DiskTreebank diskTreebank0 = negraPennTreebankParserParams0.diskTreebank();
      splittingGrammarExtractor0.saveTrees(diskTreebank0, (-962.0), diskTreebank0, 100);
      double[][] doubleArray0 = new double[1][0];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      threeDimensionalMap0.contains((String) null, (String) null, "9^4Ibpy[}x4Q98nPc");
      double[][][] doubleArray2 = new double[8][6][4];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      doubleArray2[2] = doubleArray0;
      doubleArray2[3] = doubleArray0;
      doubleArray2[4] = doubleArray0;
      doubleArray2[5] = doubleArray0;
      doubleArray2[6] = doubleArray0;
      doubleArray2[7] = doubleArray0;
      threeDimensionalMap0.put((String) null, (String) null, "UNARY:", doubleArray2);
      threeDimensionalMap0.remove("6", "W|Rb5ELtPx(a2*VtW|Rb5ELtPx(a2*Vt", (String) null);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[][] doubleArray0 = new double[9][0];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray1 = new double[28][0][9];
      doubleArray1[0] = doubleArray0;
      threeDimensionalMap0.put("output", "output", "output", doubleArray1);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.neginfDoubles(100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      WordTag wordTag0 = Morphology.stemStatic("#Ci-u", "tsv");
      WordLemmaTag wordLemmaTag0 = Morphology.lemmatizeStatic(wordTag0);
      LabeledWord labeledWord0 = new LabeledWord(wordLemmaTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledWord0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      Vector<Tree> vector0 = new Vector<Tree>();
      SimpleTree simpleTree0 = new SimpleTree(treeGraphNode1, vector0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode1, identityHashMap0, identityHashMap0);
      labeledWord0.setEndPosition(998);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0, 1320.3631, (Collection<Tree>) list1, (double) 998);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithNegativeAndPositive()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      Map<String, double[][]> map0 = new HashMap<String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordTag wordTag0 = Morphology.stemStatic("#Ci-u", "tsv");
      WordLemmaTag wordLemmaTag0 = Morphology.lemmatizeStatic(wordTag0);
      LabeledWord labeledWord0 = new LabeledWord(wordLemmaTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Tree tree0 = chineseTreebankParserParams0.transformTree(treeGraphNode0, treeGraphNode0);
      Tree tree1 = italianTreebankParserParams0.transformTree(treeGraphNode0, tree0);
      List<Tree> list0 = treeGraphNode0.dominationPath(tree1);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      CoreLabel coreLabel0 = treeGraphNode1.label();
      SimpleTree simpleTree0 = new SimpleTree(coreLabel0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
      Integer integer0 = new Integer(998);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) treeGraphNode1, (-2846.3345406), (Collection<Tree>) treeGraphNode1, (double) 998);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      WordTag wordTag0 = Morphology.stemStatic("#Ci-u", "tsv");
      WordLemmaTag wordLemmaTag0 = Morphology.lemmatizeStatic(wordTag0);
      LabeledWord labeledWord0 = new LabeledWord(wordLemmaTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledWord0, list0);
      treeGraphNode1.subTreeList();
      Vector<Tree> vector0 = new Vector<Tree>();
      SimpleTree simpleTree0 = new SimpleTree(treeGraphNode1, vector0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode1, identityHashMap0, identityHashMap0);
      Integer integer0 = new Integer((-1622));
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (-2109.9631);
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 1.0E16;
      doubleArray0[4] = (double) 998;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, (-1622), identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecountInside1()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("PM]GiT(_.s(2Lqq");
      WordTag wordTag0 = new WordTag(tag0, tag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      wordTag0.toString();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode1, false, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("<~Kel2%_Fuj", "<~Kel2%_Fuj", "#Ci-u");
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateBetas(true);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      StringLabel stringLabel0 = new StringLabel();
      WordTag wordTag0 = Morphology.stemStatic("<~Kel2%_Fuj", "<~Kel2%_Fuj");
      LabeledWord labeledWord0 = new LabeledWord(wordTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(labeledWord0, list1);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) null);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecountInsideWithNonEmptyMap1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("#Ci-u");
      WordTag wordTag0 = new WordTag(tag0, tag0);
      LabeledWord labeledWord0 = new LabeledWord("#Ci-u");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(labeledWord0, list1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(simpleTree0, false, 100, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndUseNewBetasAndUseNewBetasWithFalse0()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][4][3];
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndUseNewBetasWithTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.put("ib%Q", "ib%Q", "ib%Q", (double[][][]) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNonEmptyMapAndRecountOutsideTaking3Arguments()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordTagFactory wordTagFactory0 = new WordTagFactory('B');
      Label label0 = wordTagFactory0.newLabel("Lexicon log prob ");
      LabeledWord labeledWord0 = new LabeledWord(label0, label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledWord0, list0);
      List<Tree> list1 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(labeledWord0, list1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
      labeledWord0.setEndPosition(100);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>(Integer.MAX_VALUE, 93.0F);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap1, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsAndRecountOutsideTaking3Arguments()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordTagFactory wordTagFactory0 = new WordTagFactory('i');
      Label label0 = wordTagFactory0.newLabel("Lexicon log prob ");
      LabeledWord labeledWord0 = new LabeledWord(label0, label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      treeGraphNode0.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(treeGraphNode1, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, identityHashMap0, identityHashMap0);
      labeledWord0.setEndPosition(Integer.MAX_VALUE);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>(972, 20.0F);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndCountMergeEffectsTaking5ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("o` &S1|3q]=z4");
      WordTag wordTag0 = WordTag.valueOf("o` &S1|3q]=z4");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      wordTag0.toString();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>(100, 100);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndOutputTransitionsTaking3Arguments0()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledWord labeledWord0 = new LabeledWord("W|Rb5ELtPx(a2*Vt", simpleTree0);
      LabelFactory labelFactory0 = labeledWord0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory1 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory1.newTreeNode("    ", list0);
      splittingGrammarExtractor1.outputTransitions((Tree) treeGraphNode0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseUnknownWordModel", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecountOutsideTaking3Arguments0()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordTagFactory wordTagFactory0 = new WordTagFactory('i');
      Label label0 = wordTagFactory0.newLabel("Lexicon log prob ");
      LabeledWord labeledWord0 = new LabeledWord(label0, label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      treeGraphNode0.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(treeGraphNode1, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, identityHashMap0, identityHashMap0);
      labeledWord0.setEndPosition(Integer.MAX_VALUE);
      MapFactory<CoreLabel, CoreLabel.GenericAnnotation<String>> mapFactory0 = MapFactory.weakHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0, 392);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, map0, map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      twoDimensionalMap0.getMap("#Ci-u");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("<~Kel2%_Fuj", "<~Kel2%_Fuj", "#Ci-u");
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateBetas(true);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      StringLabel stringLabel0 = new StringLabel();
      WordTag wordTag0 = new WordTag(stringLabel0, stringLabel0);
      LabeledWord labeledWord0 = new LabeledWord(wordTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(labeledWord0, list1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecountOutsideTaking3Arguments1()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("o`6&S1|3q]=z4");
      WordTag wordTag0 = new WordTag("o`6&S1|3q]=z4", "o`6&S1|3q]=z4");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode1, identityHashMap0, identityHashMap0);
      assertEquals(1, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecountOutsideTaking3ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("#Ci-u");
      WordTag wordTag0 = new WordTag(tag0, tag0);
      LabeledWord labeledWord0 = new LabeledWord(wordTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(labeledWord0, list1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, 100, simpleTree0, 1893.0860651699481);
      splittingGrammarExtractor0.getStateSplitCount("d;g3m& %L>_?Hm*");
      double[][] doubleArray0 = new double[2][4];
      doubleArray0[1] = doubleArray0[0];
      twoDimensionalMap0.put((String) null, "E!>&(^,*~I:", doubleArray0);
      UnaryOperator.identity();
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      boolean boolean1 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.getStateSplitCount("d;g3m& %L>_?Hm*");
      double[][] doubleArray0 = new double[2][4];
      doubleArray0[1] = doubleArray0[0];
      twoDimensionalMap0.put((String) null, "E!>&(^,*~I:", doubleArray0);
      UnaryOperator.identity();
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.DEBUG();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      RightHeadFinder rightHeadFinder0 = new RightHeadFinder();
      // Undeclared exception!
      try { 
        rightHeadFinder0.determineHead((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.trees.RightHeadFinder", e);
      }
  }

  @Test(timeout = 4000)
  public void testDEBUGAndOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, 100, simpleTree0, 1893.0860651699481);
      splittingGrammarExtractor0.getStateSplitCount("d;g3m& %L>_?Hm*");
      double[][] doubleArray0 = new double[2][4];
      doubleArray0[1] = doubleArray0[0];
      twoDimensionalMap0.put((String) null, "E!>&(^,*~I:", doubleArray0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      splittingGrammarExtractor0.outputBetas();
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndBuildStateIndexAndOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[1][1];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("TW0'Z", "TW0'Z", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
      boolean boolean1 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean1 == boolean0);
      
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      assertFalse(threeDimensionalMap1.equals((Object)threeDimensionalMap0));
  }

  @Test(timeout = 4000)
  public void testOutputBetasThrowsNullPointerException()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      FileSystemHandling.shouldAllThrowIOExceptions();
      StringLabel stringLabel0 = new StringLabel("a%2a)#L");
      Tag tag0 = new Tag(stringLabel0);
      CoreLabel coreLabel0 = new CoreLabel(tag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode2.postOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(coreLabel0, list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newLeaf("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("    ", list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, 100, simpleTree0, 1894.437653507);
      splittingGrammarExtractor0.getStateSplitCount("d;g3m& %L>_?Hm*");
      double[][] doubleArray0 = new double[2][4];
      doubleArray0[1] = doubleArray0[0];
      twoDimensionalMap0.put((String) null, "E!>&(^,*~I:", doubleArray0);
      UnaryOperator.identity();
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.DEBUG();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndOutputTransitionsTaking3Arguments()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("    ", list0);
      splittingGrammarExtractor1.outputTransitions(tree0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndOutputTransitionsTaking3Arguments1()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("    ", list0);
      splittingGrammarExtractor1.outputTransitions(tree0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) simpleTree0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsWithTreeWhereScoreIsPositive()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor1.unaryBetas;
      twoDimensionalMap0.getMap("2Qs/FE]h7/");
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.values();
      threeDimensionalMap0.remove((String) null, (String) null, "T8UfP*P");
      splittingGrammarExtractor1.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor2.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor2.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TaggedWord taggedWord0 = new TaggedWord(categoryWordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode1.upperMostUnary(treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recountOutside(tree0, (Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndBuildStateIndexAndSplitBetas()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[1][9];
      double[] doubleArray1 = new double[1];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("0'Z", "0'Z", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsWithEmptyMap()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      StringLabel stringLabel0 = new StringLabel();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      Tree tree0 = treeGraphNode0.treeSkeletonConstituentCopy();
      List<Tree> list0 = List.of(treeGraphNode0, tree0, treeGraphNode0, treeGraphNode0, treeGraphNode0, treeGraphNode0, tree0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(tree0, list0);
      treeGraphNode1.parent(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor2()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[3][0];
      double[] doubleArray1 = new double[1];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndSaveTreesWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      double[] doubleArray0 = new double[7];
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, (-1638.8), simpleTree0, 1894.437653507);
      double[][] doubleArray1 = new double[1][7];
      doubleArray1[0] = doubleArray0;
      twoDimensionalMap0.put("0", "TW0'Z", doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.splitBetas();
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 478, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesAndRecalculateTemporaryBetasTaking4ArgumentsWithTrueAndRecalculateTemporaryBetasTaking4ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      double[] doubleArray0 = new double[7];
      doubleArray0[1] = (double) 100;
      options0.genStop = true;
      doubleArray0[2] = (double) 100;
      options0.baseParserWeight = (double) 100;
      doubleArray0[4] = 100.0;
      doubleArray0[5] = 100.0;
      doubleArray0[6] = (double) 100;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, 100, simpleTree0, 1515.867);
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.treeMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap1, threeDimensionalMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      options0.genStop = true;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) 100;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, 100, simpleTree0, 1515.867);
      double[][] doubleArray1 = new double[8][3];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[3] = doubleArray0;
      doubleArray1[4] = doubleArray0;
      doubleArray1[5] = doubleArray0;
      doubleArray1[6] = doubleArray0;
      doubleArray1[7] = doubleArray0;
      twoDimensionalMap0.put((String) null, (String) null, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = splittingGrammarExtractor0.binaryBetas;
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap1, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(simpleTree0, identityHashMap2, identityHashMap2);
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor3()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("?BF4iMs,Cfvp");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Integer integer0 = new Integer(Integer.MAX_VALUE);
      Double double0 = new Double(0.0);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("^@D!o|gu+soxDLXJ", integer0, double0);
      Triple<String, Integer, Double> triple1 = Triple.makeTriple(".$$.", integer0, 0.0);
      Double double1 = new Double(0.0);
      Triple<String, Integer, Double> triple2 = new Triple<String, Integer, Double>("ztEnW\"-~CBdDS0/Ku", (Integer) 100, double1);
      Object[] objectArray0 = new Object[2];
      objectArray0[0] = (Object) twoDimensionalMap0;
      Object object0 = new Object();
      objectArray0[1] = object0;
      Redwood.RedwoodChannels redwood_RedwoodChannels0 = new Redwood.RedwoodChannels(objectArray0);
      Redwood.RedwoodChannels redwood_RedwoodChannels1 = redwood_RedwoodChannels0.channels(objectArray0);
      triple0.prettyLog(redwood_RedwoodChannels1, "7bM{a[zjX;/8D&`{_");
      List<Triple<String, Integer, Double>> list0 = List.of(triple1, triple0, triple1, triple1, triple1, triple0, triple2, triple0, triple1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndBuildMergeCorrespondenceWithNonEmptyList()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      chineseTreebankParserParams0.penaltyType = (-289);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple(null, (-289), 0.0);
      triple0.first = "Q+>;^!e.(G3V";
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.binaryBetas = threeDimensionalMap0;
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple0, triple0, triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndCountOriginalStates2()  throws Throwable  {
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Tree> stack0 = new Stack<Tree>();
      splittingGrammarExtractor0.trees = (List<Tree>) stack0;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      stack0.add((Tree) simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      twoDimensionalMap0.getMap("jk=L3A=");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap1.remove("", "nx+tr@PA-Qx<mW", ":['Rtx,(F~:Wu ");
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor1.mergeStates();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      hungarianTreebankParserParams0.display();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor1.outputBetas();
      splittingGrammarExtractor1.recalculateBetas(false);
      splittingGrammarExtractor2.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      Tree tree0 = null;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) null, false, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor4()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][4][3];
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[9][8][4];
      threeDimensionalMap0.put(";Ry#.u^4_XS3Lqt-M", ";Ry#.u^4_XS3Lqt-M", ";Ry#.u^4_XS3Lqt-M", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndOutputBetasAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      twoDimensionalMap0.getMap("jk=L3A=");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap1.remove("C#1CW=T?dRi@yc", (String) null, "");
      splittingGrammarExtractor1.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor1.mergeStates();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      hungarianTreebankParserParams0.display();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap2);
      splittingGrammarExtractor1.outputBetas();
      splittingGrammarExtractor0.recalculateBetas(true);
      boolean boolean0 = splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, threeDimensionalMap2);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5Arguments()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateBetas(true);
      TwoDimensionalMap.identityHashMap();
      HungarianTreebankParserParams hungarianTreebankParserParams1 = new HungarianTreebankParserParams();
      hungarianTreebankParserParams1.display();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap2, identityHashMap2);
      assertEquals(0, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap2, identityHashMap2);
      assertEquals(0, identityHashMap2.size());
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[9][8][4];
      double[] doubleArray1 = new double[4];
      doubleArray1[0] = (double) 942;
      threeDimensionalMap0.put(";Ry#.u^4_XS3Lqt-M", " | ", " | ", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndDEBUGAndSplitBetas()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[3][0];
      twoDimensionalMap0.put("})K", "})K", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor1.DEBUG();
      splittingGrammarExtractor0.outputBetas();
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndRescaleTemporaryBetas()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor1.unaryBetas;
      twoDimensionalMap0.getMap("2Qs/FE]h7/");
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove((String) null, (String) null, "T8UfP*P");
      splittingGrammarExtractor1.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.mergeStates();
      hungarianTreebankParserParams0.display();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor2.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      boolean boolean0 = splittingGrammarExtractor2.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testStateWithNegative()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(".$$.", (-848));
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      assertTrue(identityHashMap3.equals((Object)identityHashMap2));
  }

  @Test(timeout = 4000)
  public void testStateAndCountOriginalStatesAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      HashMap<LabeledScoredTreeNode, double[]> hashMap0 = new HashMap<LabeledScoredTreeNode, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>(hashMap0);
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 129.34763975081;
      splittingGrammarExtractor0.countOriginalStates();
      String string0 = splittingGrammarExtractor0.state(" 4_lD5U{", 2815);
      assertEquals(" 4_lD5U{^2815", string0);
  }

  @Test(timeout = 4000)
  public void testState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = splittingGrammarExtractor0.state("OeS", 100);
      assertEquals("OeS^100", string0);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor5()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      HashIndex<Tree> hashIndex0 = new HashIndex<Tree>();
      DeltaIndex<Tree> deltaIndex0 = new DeltaIndex<Tree>(hashIndex0);
      DeltaIndex<Tree> deltaIndex1 = new DeltaIndex<Tree>(deltaIndex0, hashIndex0);
      Options.LexOptions options_LexOptions0 = null;
      try {  
      options_LexOptions0 = options0.lexOptions;
      } catch(IllegalArgumentException e) {}
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasAndBuildStateIndexAndSaveTrees()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      options0.genStop = true;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) 100;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, 100, simpleTree0, 1515.867);
      double[][] doubleArray1 = new double[8][3];
      doubleArray1[0] = doubleArray0;
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndSaveTrees1()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.saveTrees(simpleTree0, 0.0, simpleTree0, 100);
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(100);
      assertEquals(100, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testNeginfDoubles()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      splittingGrammarExtractor0.neginfDoubles(100);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, 0.0, simpleTree0, 1515.867);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      // Undeclared exception!
      try { 
        CoordinationTransformer.CCtransform(simpleTree0);
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndMergeStatesAndUseNewBetas()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor1.unaryBetas;
      twoDimensionalMap0.getMap("2Qs/FE]h7/");
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove((String) null, (String) null, "T8UfP*P");
      splittingGrammarExtractor1.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.mergeStates();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      // Undeclared exception!
      try { 
        treeGraphNodeFactory0.newLeaf((Label) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecalculateBetasAndBuildMergeCorrespondenceWithNonEmptyList()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      FileSystemHandling.shouldAllThrowIOExceptions();
      byte[] byteArray0 = new byte[5];
      byteArray0[0] = (byte)125;
      byteArray0[1] = (byte) (-107);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("+Jtl&DA", (Integer) null, (Double) 0.0);
      vector0.add(triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndOutputTransitionsTaking4ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      options0.genStop = true;
      doubleArray0[2] = (double) 100;
      options0.baseParserWeight = (double) 100;
      doubleArray0[4] = 100.0;
      doubleArray0[5] = 100.0;
      doubleArray0[6] = (double) 100;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, 100, simpleTree0, 1515.867);
      double[][] doubleArray1 = new double[8][3];
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.treeMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      twoDimensionalMap1.put("Iteration ", "< 5~&i>M<qt,1g", doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 7, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor6()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[3][0];
      double[] doubleArray1 = new double[1];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndSplitBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][0];
      twoDimensionalMap0.put("})K", "})K", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      WordTag wordTag0 = Morphology.stemStatic("#Ci-u", "#Ci-u");
      WordLemmaTag wordLemmaTag0 = Morphology.lemmatizeStatic(wordTag0);
      LabeledWord labeledWord0 = new LabeledWord(wordLemmaTag0, wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledWord0, list0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      wordLemmaTag0.toString();
      Integer integer0 = new Integer(3363);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 3363;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 3363;
      doubleArray0[5] = 0.0;
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode1, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, doubleArray0, identityHashMap3);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      assertEquals(0, identityHashMap4.size());
  }

  @Test(timeout = 4000)
  public void testMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#hi-eu");
      twoDimensionalMap0.getMap("#hi-eu");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledWord labeledWord0 = new LabeledWord("#hi-eu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Integer integer0 = new Integer(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      double[] doubleArray0 = new double[8];
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>(identityHashMap2);
      IdentityHashMap<String, int[]> identityHashMap4 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode0, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap3, doubleArray0, identityHashMap4);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsWithFalseAndNull()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.weakHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.arrayMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      hungarianTreebankParserParams0.display();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      WordTag wordTag0 = WordTag.valueOf("-unaryIP", "EC>n");
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordTag0, (-1397.02994));
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.mergeTransitions(simpleTree0, identityHashMap0, identityHashMap3, identityHashMap0, identityHashMap1, (double[]) null, identityHashMap2);
      assertTrue(identityHashMap3.isEmpty());
  }

  @Test(timeout = 4000)
  public void testSaveTreesAndSaveTreesWithZeroAndSaveTreesWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, 0.0, simpleTree0, (-1874.6850573));
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndSaveTreesAndSaveTreesWithNegative()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.saveTrees(simpleTree0, (-1875.4194), simpleTree0, (-1875.4194));
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndRecalculateMergedBetasAndRecountOutsideTaking3Arguments()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, identityHashMap3, identityHashMap2);
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap1);
      Double double0 = new Double(100);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("wn[DhHr<%", (Integer) 100, double0);
      Triple<String, Integer, Double> triple1 = Triple.makeTriple(" 4_lD5U{", 100, 0.0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple0, triple0, triple1, triple0, triple0, triple0, triple1, triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(list0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndBuildMergeCorrespondenceAndBuildMergeCorrespondenceWithNonEmptyList()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("^@D!o|gu+soxDLXJ", 100, 0.0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple0, triple0, triple0, triple0, triple0, triple0, triple0, triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(list0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningNegative()  throws Throwable  {
      Options options0 = new Options();
      options0.dcTags = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      Options options1 = new Options();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      Options options2 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      MapFactory<Object, SplittingGrammarExtractor> mapFactory0 = MapFactory.weakHashMapFactory();
      MapFactory.hashMapFactory();
      MapFactory<MorphoFeatureSpecification.MorphoFeatureType, Object> mapFactory1 = MapFactory.arrayMapFactory();
      Map<String, double[]> map0 = mapFactory1.setMap(null, 100);
      mapFactory1.setMap(map0, 517);
      Map<String, double[]> map1 = mapFactory0.setMap(map0);
      mapFactory0.setMap(map1);
      IdentityHashMap<Tree, double[][]> identityHashMap5 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
  }

  @Test(timeout = 4000)
  public void testSaveTreesAndCountMergeEffectsTaking3ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      options0.genStop = true;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) 100;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, 100, simpleTree0, 1515.867);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Tree tree0 = negraPennTreebankParserParams0.transformTree(simpleTree0, simpleTree0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndBuildStateIndexAndSaveTrees()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      options0.genStop = true;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) 100;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, 100, simpleTree0, 1515.867);
      double[][] doubleArray1 = new double[8][3];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[3] = doubleArray0;
      doubleArray1[4] = doubleArray0;
      doubleArray1[5] = doubleArray0;
      doubleArray1[6] = doubleArray0;
      doubleArray1[7] = doubleArray0;
      twoDimensionalMap0.put((String) null, (String) null, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndUseNewBetasAndUseNewBetasWithFalse1()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][2];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put(" | ", " | ", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<Object, SplittingGrammarExtractor> mapFactory0 = MapFactory.weakHashMapFactory();
      MapFactory.hashMapFactory();
      MapFactory<MorphoFeatureSpecification.MorphoFeatureType, Object> mapFactory1 = MapFactory.arrayMapFactory();
      Map<String, double[]> map0 = mapFactory1.setMap(null, 878);
      Map<String, double[]> map1 = mapFactory1.setMap(map0, 878);
      mapFactory0.setMap(map1);
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 878;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 878;
      IdentityHashMap<edu.stanford.nlp.trees.Tree, double[][]> identityHashMap3 = new IdentityHashMap<edu.stanford.nlp.trees.Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 721, identityHashMap3, identityHashMap1, map0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, (Tree) simpleTree0, (Tree) simpleTree0, identityHashMap4, identityHashMap4);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideAndGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      options0.freeDependencies = false;
      splittingGrammarExtractor0.getStateSplitCount("d");
      Tree tree0 = null;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside((Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[9][8][4];
      double[] doubleArray1 = new double[17];
      doubleArray1[8] = (double) 100;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = (double) 100;
      threeDimensionalMap0.put(";Ry#.u^4_XS3Liqt-M", ";Ry#.u^4_XS3Liqt-M", ";Ry#.u^4_XS3Liqt-M", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndUseNewBetasAndUseNewBetasWithFalse2()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.getMap("#Ci-u");
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("<~Kel2%_Fuj", "<~Kel2%_Fuj", "#Ci-u");
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndUseNewBetasAndUseNewBetasWithTrue0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[8][0];
      twoDimensionalMap0.put("E)0", "E)0", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.getTwoDimensionalMap("E)0");
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasWithNullAndTestConvergenceWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("<~Kel2%_Fuj", "<~Kel2%_Fuj", "#Ci-u");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsAndRecountOutsideTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.thirdKeySet();
      threeDimensionalMap0.isEmpty();
      splittingGrammarExtractor0.countOriginalStates();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateBetas(true);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap3);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, identityHashMap4, identityHashMap4);
      assertFalse(identityHashMap4.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsAndRecalculateBetasWithFalse()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, identityHashMap0, identityHashMap0);
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammars()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      hashMap0.entrySet();
      hungarianTreebankParserParams0.display();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndRecountWeightsWithEmptyMap1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Tag tag0 = new Tag("#Ci-u");
      WordTag wordTag0 = new WordTag(tag0, tag0);
      LabeledWord labeledWord0 = new LabeledWord("#Ci-u");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(labeledWord0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNull()  throws Throwable  {
      Options options0 = new Options();
      options0.dcTags = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(simpleTree0, (IdentityHashMap<Tree, double[]>) null, identityHashMap4, identityHashMap2, identityHashMap3);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap.hashMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap1, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      assertFalse(splittingGrammarExtractor0.equals((Object)splittingGrammarExtractor2));
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecountWeights()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      hungarianTreebankParserParams0.display();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap1, identityHashMap1, identityHashMap0, identityHashMap2);
      assertTrue(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndSplitBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.getMap("#Ci-u");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      MapFactory.weakHashMapFactory();
      MapFactory.arrayMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor1.splitBetas();
      ArrayDeque<Tree> arrayDeque0 = new ArrayDeque<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) arrayDeque0);
      assertFalse(splittingGrammarExtractor0.equals((Object)splittingGrammarExtractor1));
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithZero()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0, (-2846.3345406), (Collection<Tree>) simpleTree0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 100;
      options0.forceCNF = false;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) 100;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.saveTrees(simpleTree0, 100, simpleTree0, 1515.867);
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      splittingGrammarExtractor0.saveTrees(linkedList0, 1074.6424121, linkedList0, 0.0);
      assertEquals(0, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNullAndSaveTrees()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
      
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.saveTrees((Collection<Tree>) null, 0.0, (Collection<Tree>) null, 0.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      options0.freeDependencies = false;
      splittingGrammarExtractor0.getStateSplitCount("d");
      Tree tree0 = null;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>(identityHashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) null, identityHashMap1, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor7()  throws Throwable  {
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.weakHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.arrayMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = null;
      try {  
      threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      } catch(IllegalArgumentException e) {}
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      hungarianTreebankParserParams0.display();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(hashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningPositive()  throws Throwable  {
      Options options0 = new Options();
      options0.dcTags = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) 100;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningZero()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.size();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, (double[]) null, 0, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsWithEmptyMap()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      MemoryTreebank memoryTreebank0 = negraPennTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0, memoryTreebank0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode1.localTree();
      IdentityHashMap<edu.stanford.nlp.trees.Tree, double[][]> identityHashMap0 = new IdentityHashMap<edu.stanford.nlp.trees.Tree, double[][]>();
      IdentityHashMap<edu.stanford.nlp.trees.Tree, double[][][]> identityHashMap1 = new IdentityHashMap<edu.stanford.nlp.trees.Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
      assertEquals(0, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndUseNewBetasAndUseNewBetasReturningFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      IdentityFunction<double[][]> identityFunction0 = new IdentityFunction<double[][]>();
      twoDimensionalMap0.transform(identityFunction0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode((Label) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      assertEquals(0, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasAndRecalculateBetasAndRecalculateMergedBetas()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndSaveTreesWithPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, 100, simpleTree0, 1894.437653507);
      double[][] doubleArray0 = new double[1][1];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("TW0'Z", "TW0'Z", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndUseNewBetasAndUseNewBetasWithTrue1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[12][0];
      twoDimensionalMap0.put("})K", "})K", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndGetStateSplitCountTakingTreeWithTreeWhereScoreIsPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) simpleTree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTree()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      WordFactory wordFactory0 = new WordFactory();
      Label label0 = wordFactory0.newLabelFromString("yourselves");
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, 0.0);
      // Undeclared exception!
      try { 
        ((SplittingGrammarExtractor) splittingGrammarExtractor0).getStateSplitCount((Tree) labeledScoredTreeNode0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceWithEmptyListAndRecalculateBetasWithTrue()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndBuildMergeCorrespondenceAndBuildMergeCorrespondenceWithEmptyList()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      String string0 = "-charLex";
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      options0.dcTags = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      double[][] doubleArray0 = new double[9][2];
      double[] doubleArray1 = new double[9];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = (double) 100;
      doubleArray1[5] = 0.0;
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(simpleTree0, false, 100, identityHashMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor8()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildStateIndex();
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = null;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      boolean boolean0 = false;
      options0.doPCFG = false;
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (double) 100;
      splittingGrammarExtractor0.splitBetas();
      identityHashMap0.put((Tree) null, doubleArray0);
      doubleArray0[1] = (double) 100;
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      threeDimensionalMap0.isEmpty();
      splittingGrammarExtractor1.countOriginalStates();
      identityHashMap1.put("d3-1t&Ptn+t1\"~w%(s(", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) null, false, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndCountOriginalStates3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor9()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) treeSet0);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollection()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Tree.valueOf("}");
      ZoneId.getAvailableZoneIds();
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasReturningTrue()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      IdentityFunction<double[][]> identityFunction0 = new IdentityFunction<double[][]>();
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndCountMergeEffectsTaking5ArgumentsAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.buildStateIndex();
      double[] doubleArray0 = new double[7];
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.saveTrees(simpleTree0, (-1641.2842223317807), simpleTree0, 1894.437653507);
      double[][] doubleArray1 = new double[1][7];
      doubleArray1[0] = doubleArray0;
      twoDimensionalMap0.put("0", "TW0'Z", doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.splitBetas();
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      identityHashMap2.clear();
      splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap2, identityHashMap2);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap2);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      boolean boolean0 = true;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = null;
      try {  
      threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      } catch(IllegalArgumentException e) {}
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount("Using EnglishTreebankParserParams splitIN=");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndUseNewBetas()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[3][0];
      twoDimensionalMap0.put((String) null, ".$$.", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor2.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsAndSplitBetas()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      Tree tree0 = null;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      boolean boolean0 = false;
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[9][8][4];
      double[] doubleArray1 = new double[4];
      doubleArray1[3] = (double) 100;
      options0.rerankerKBest = 943;
      threeDimensionalMap0.put(";Ry#.u^4_XS3Liqt-M", " | ", " | ", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor10()  throws Throwable  {
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.arrayMapFactory();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStates()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      String string0 = "{=[k|";
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("{=[k|");
      Stack<Tree> stack0 = new Stack<Tree>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeStates();
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndMergeStates()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndSplitBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor11()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndRecalculateBetas()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndTestConvergenceReturningTrue()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[9][8][4];
      double[] doubleArray1 = new double[4];
      doubleArray1[0] = (double) 942;
      threeDimensionalMap0.put(";Ry#.u^4_XS3Liqt-M", " | ", " | ", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor12()  throws Throwable  {
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 100, identityHashMap3, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4Arguments2()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      WordFactory wordFactory0 = new WordFactory();
      wordFactory0.newLabelFromString("0x{q3qS0");
  }

  @Test(timeout = 4000)
  public void testOutputBetas()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputBetas();
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractorAndDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDEBUGAndDEBUG()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      options0.doDep = false;
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      String[] stringArray0 = new String[1];
      stringArray0[0] = "+9_";
      edu.stanford.nlp.ling.CoreLabel coreLabel0 = null;
      try {
        coreLabel0 = new edu.stanford.nlp.ling.CoreLabel(stringArray0, stringArray0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Unknown key +9_
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor13()  throws Throwable  {
      edu.stanford.nlp.parser.lexparser.Options options0 = new edu.stanford.nlp.parser.lexparser.Options();
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor(options0);
      edu.stanford.nlp.trees.SimpleTree simpleTree0 = new edu.stanford.nlp.trees.SimpleTree();
      // Undeclared exception!
      try { 
        simpleTree0.parent();
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.trees.Tree", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateSplittingGrammarExtractorThrowsNullPointerException()  throws Throwable  {
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      edu.stanford.nlp.parser.lexparser.Options options0 = spanishUnknownWordModelTrainer0.op;
      edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor splittingGrammarExtractor0 = null;
      try {
        splittingGrammarExtractor0 = new edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor((edu.stanford.nlp.parser.lexparser.Options) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }
}
