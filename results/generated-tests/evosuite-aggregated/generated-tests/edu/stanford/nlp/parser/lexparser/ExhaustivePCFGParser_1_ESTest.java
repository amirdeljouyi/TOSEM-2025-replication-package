/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Apr 21 18:37:50 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.international.french.FrenchMorphoFeatureSpecification;
import edu.stanford.nlp.international.morph.MorphoFeatureSpecification;
import edu.stanford.nlp.ling.BasicDocument;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.StringLabelFactory;
import edu.stanford.nlp.ling.Tag;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.parser.common.ParserConstraint;
import edu.stanford.nlp.parser.lexparser.BaseLexicon;
import edu.stanford.nlp.parser.lexparser.BinaryGrammar;
import edu.stanford.nlp.parser.lexparser.BinaryRule;
import edu.stanford.nlp.parser.lexparser.ChineseCharacterBasedLexicon;
import edu.stanford.nlp.parser.lexparser.ChineseLexiconAndWordSegmenter;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Edge;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser;
import edu.stanford.nlp.parser.lexparser.FactoredLexicon;
import edu.stanford.nlp.parser.lexparser.HTKLatticeReader;
import edu.stanford.nlp.parser.lexparser.HebrewTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Hook;
import edu.stanford.nlp.parser.lexparser.IntTaggedWord;
import edu.stanford.nlp.parser.lexparser.ItalianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Lattice;
import edu.stanford.nlp.parser.lexparser.Lexicon;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.OutsideRuleFilter;
import edu.stanford.nlp.parser.lexparser.SpanishUnknownWordModelTrainer;
import edu.stanford.nlp.parser.lexparser.UnaryGrammar;
import edu.stanford.nlp.parser.lexparser.UnknownWordModelTrainer;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.sequences.SeqClassifierFlags;
import edu.stanford.nlp.sequences.TrueCasingForNISTDocumentReaderAndWriter;
import edu.stanford.nlp.trees.CompositeTreeTransformer;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.PennTreebankLanguagePack;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeReaderFactory;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.DeltaIndex;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.ScoredObject;
import java.io.BufferedReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;
import java.util.Vector;
import java.util.function.Consumer;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.util.SystemInUtil;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class ExhaustivePCFGParser_1_ESTest extends ExhaustivePCFGParser_1_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testNudgeDownArraySizeAndCreateArraysAndGetBestScoreTakingString()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("E[ @neNZP#?hY'VC");
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex1);
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(2);
      exhaustivePCFGParser0.arraySize = (-2494);
      double double0 = exhaustivePCFGParser0.getBestScore("E[ @neNZP#?hY'VC");
      assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
      
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      Lattice lattice0 = new Lattice();
      lattice0.addBoundary();
      lattice0.addBoundary();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      lattice0.getConstraints();
      lattice0.addBoundary();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTreeThrowsUnsupportedOperationException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("done.", "F/x<g");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      Options options1 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(hashIndex0);
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Lexicon lexicon0 = spanishUnknownWordModelTrainer0.lex;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar1, (Lexicon) null, options1, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreBinarizedTree(treeGraphNode1, 100);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // You must use a tree type that implements scoring in order call setScore()
         //
         verifyException("edu.stanford.nlp.trees.Tree", e);
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      pennTreebankLanguagePack0.morphFeatureSpec();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(options0, (MorphoFeatureSpecification) null, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(2);
      Vector<TaggedWord> vector0 = new Vector<TaggedWord>();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      TreeReaderFactory treeReaderFactory0 = hebrewTreebankParserParams0.treeReaderFactory();
      Tree tree0 = Tree.valueOf(" words (incl. stop) iScore ", treeReaderFactory0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(tree0, 87);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 87 out of bounds for length 2
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreateArraysWithZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Options options0 = new Options();
      hashIndex0.add("");
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(0);
      unaryGrammar0.closedRuleIteratorByChild(100);
      exhaustivePCFGParser0.getBestScore("");
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testGetConstraintsReturningListWhereIsEmptyIsTrue()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>(100);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      hashIndex0.add("");
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      List<ParserConstraint> list0 = new Vector<ParserConstraint>();
      exhaustivePCFGParser0.setConstraints(list0);
      List<ParserConstraint> list1 = exhaustivePCFGParser0.getConstraints();
      exhaustivePCFGParser0.setConstraints(list1);
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testBuildOFilterAndBuildOFilterThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      binaryGrammar0.iterator();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      System.setCurrentTimeMillis(100);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      pennTreebankLanguagePack0.morphFeatureSpec();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon((MorphoFeatureSpecification) null, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      OutsideRuleFilter outsideRuleFilter0 = new OutsideRuleFilter(binaryGrammar0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.orf = outsideRuleFilter0;
      unaryGrammar0.ruleIteratorByParent(100);
      exhaustivePCFGParser0.length = 1210;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.buildOFilter();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Options options0 = new Options();
      hashIndex0.add("");
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestScore("");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOScoreWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Hook hook0 = new Hook(false);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      System.setCurrentTimeMillis(100);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      pennTreebankLanguagePack0.morphFeatureSpec();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon((MorphoFeatureSpecification) null, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      OutsideRuleFilter outsideRuleFilter0 = new OutsideRuleFilter(binaryGrammar0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.orf = outsideRuleFilter0;
      exhaustivePCFGParser0.buildOFilter();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oScore((Edge) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildOFilter()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      pennTreebankLanguagePack0.morphFeatureSpec();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon((MorphoFeatureSpecification) null, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      OutsideRuleFilter outsideRuleFilter0 = new OutsideRuleFilter(binaryGrammar0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.orf = outsideRuleFilter0;
      exhaustivePCFGParser0.buildOFilter();
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySizeAndScoreBinarizedTree()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Tag tag0 = new Tag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      treeGraphNode0.postOrderNodeList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.scoreBinarizedTree(treeGraphNode0, options0.rerankerKBest);
      exhaustivePCFGParser0.nudgeDownArraySize();
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsExceptionAndParseTakingLattice0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("~Ca^d>S)g%NULgCh?H");
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      HashIndex<String> hashIndex1 = new HashIndex<String>(100);
      options0.doDep = false;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex1);
      Lattice lattice0 = new Lattice();
      hashIndex0.add("~Ca^d>S)g%NULgCh?H");
      lattice0.getConstraints();
      lattice0.addBoundary();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 2
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreateArraysAndNudgeDownArraySize()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Options options0 = new Options();
      options0.doDep = false;
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      Options options1 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.nudgeDownArraySize();
      exhaustivePCFGParser0.createArrays(1);
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListAndCreateArrays0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      Vector<TaggedWord> vector0 = new Vector<TaggedWord>();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      TreeReaderFactory treeReaderFactory0 = hebrewTreebankParserParams0.treeReaderFactory();
      Tree.valueOf(" words (incl. stop) iScore ", treeReaderFactory0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      WordTag wordTag0 = new WordTag(" words (incl. stop) iScore ", " words (incl. stop) iScore ");
      WordLemmaTag wordLemmaTag0 = Morphology.lemmatizeStatic(wordTag0);
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag(" words (incl. stop) iScore ", "");
      StringReader stringReader0 = new StringReader("X(g'&Y`iB+A?[bsM");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      Morphology morphology0 = new Morphology(bufferedReader0, 100);
      WordLemmaTag wordLemmaTag2 = morphology0.lemmatize(wordTag0);
      List<WordLemmaTag> list0 = List.of(wordLemmaTag0, wordLemmaTag0, wordLemmaTag1, wordLemmaTag2, wordLemmaTag2);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndCreateArrays0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      Vector<TaggedWord> vector0 = new Vector<TaggedWord>();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      TreeReaderFactory treeReaderFactory0 = hebrewTreebankParserParams0.treeReaderFactory();
      Tree.valueOf(" words (incl. stop) iScore ", treeReaderFactory0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      WordTag wordTag0 = Morphology.stemStatic(" words (incl. stop) iScore ", " words (incl. stop) iScore ");
      WordLemmaTag wordLemmaTag0 = Morphology.lemmatizeStatic(wordTag0);
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag(" words (incl. stop) iScore ", "");
      StringReader stringReader0 = new StringReader("X(g'&Y`iB+A?[bsM");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      Morphology morphology0 = new Morphology(bufferedReader0, 100);
      List<WordLemmaTag> list0 = List.of(wordLemmaTag0, wordLemmaTag0, wordLemmaTag1, wordLemmaTag1, wordLemmaTag1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySizeThrowsUnsupportedOperationException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Tag tag0 = new Tag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      FrenchMorphoFeatureSpecification frenchMorphoFeatureSpecification0 = new FrenchMorphoFeatureSpecification();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(frenchMorphoFeatureSpecification0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar1, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreBinarizedTree(treeGraphNode1, (-1130));
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // You must use a tree type that implements scoring in order call setScore()
         //
         verifyException("edu.stanford.nlp.trees.Tree", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsOutOfMemoryError0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      Tag tag0 = new Tag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      Options options0 = new Options();
      hashIndex0.add((String) null);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ChineseCharacterBasedLexicon chineseCharacterBasedLexicon0 = new ChineseCharacterBasedLexicon(chineseTreebankParserParams0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, chineseCharacterBasedLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      lattice0.getConstraints();
      lattice0.addBoundary();
      exhaustivePCFGParser0.myMaxLength = (-2748);
      lattice0.addBoundary();
      // Undeclared exception!
      exhaustivePCFGParser0.parse(lattice0);
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsOutOfMemoryError1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      Options options0 = new Options();
      hashIndex0.add((String) null);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ChineseCharacterBasedLexicon chineseCharacterBasedLexicon0 = new ChineseCharacterBasedLexicon(chineseTreebankParserParams0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, chineseCharacterBasedLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      lattice0.getConstraints();
      lattice0.addBoundary();
      exhaustivePCFGParser0.myMaxLength = (-2748);
      lattice0.addBoundary();
      // Undeclared exception!
      exhaustivePCFGParser0.parse(lattice0);
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("~Ca^d>S)g%NUgCh?H");
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex1);
      Lattice lattice0 = new Lattice();
      lattice0.getConstraints();
      lattice0.addBoundary();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 2
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsException2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      hashIndex0.add("");
      Options options0 = new Options();
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar1, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex1);
      Lattice lattice0 = new Lattice();
      lattice0.getConstraints();
      lattice0.addBoundary();
      lattice0.addBoundary();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 3
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndNudgeDownArraySize()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      int int0 = 65;
      HashIndex<String> hashIndex1 = new HashIndex<String>(65);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex1);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex1);
      Options options0 = new Options();
      String string0 = "7Jzv6@C7.-C]{c\\9l";
      hashIndex0.add("7Jzv6@C7.-C]{c9l");
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex1, hashIndex0);
      Lattice lattice0 = new Lattice();
      lattice0.addBoundary();
      lattice0.addBoundary();
      exhaustivePCFGParser0.nudgeDownArraySize();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeWithLatticeWhereGetNumEdgesIsPositive()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("~Ca^d>S)g%NUgCh?H");
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      Lattice lattice0 = new Lattice();
      lattice0.addBoundary();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySizeThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      lattice0.addBoundary();
      lattice0.addBoundary();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsExceptionAndParseTakingLattice1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
      
      Lattice lattice0 = new Lattice();
      lattice0.addBoundary();
      exhaustivePCFGParser0.nudgeDownArraySize();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsException3()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      lattice0.addBoundary();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testHasParse0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      options0.display();
      binaryGrammar0.ruleIteratorByParent(32);
      exhaustivePCFGParser0.length = 3733;
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testHasParse1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.arraySize = (-1276);
      exhaustivePCFGParser0.hasParse();
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeThrowsNullPointerException0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "RFU}oL&fEI");
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Tag tag0 = new Tag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Stack<Tree> stack0 = new Stack<Tree>();
      hashIndex0.add("_y]");
      List<Tree> list0 = treeGraphNode1.getLeaves(stack0);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(tag0, list0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.scoreNonBinarizedTree(treeGraphNode2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndCreateArrays1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      assertFalse(exhaustivePCFGParser0.hasParse());
      
      Stack<TaggedWord> stack0 = new Stack<TaggedWord>();
      IntTaggedWord intTaggedWord0 = UnknownWordModelTrainer.NULL_ITW;
      TaggedWord taggedWord0 = intTaggedWord0.toTaggedWord(hashIndex0, hashIndex0);
      stack0.add(taggedWord0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) stack0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListAndCreateArrays1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      Stack<TaggedWord> stack0 = new Stack<TaggedWord>();
      TaggedWord taggedWord0 = new TaggedWord("", "");
      stack0.push(taggedWord0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) stack0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleWithHookWhereIsPreHookIsTrue()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(true);
      hook0.start = 100;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTreeThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("-BEGIxN-SENT", 758);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Stack<Tree> stack0 = new Stack<Tree>();
      List<Tree> list0 = treeGraphNode1.getLeaves(stack0);
      treeGraphNode0.yieldWords();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(label0, list0);
      List<Tree> list1 = treeGraphNode2.pathNodeToNode(treeGraphNode1, treeGraphNode1);
      TreeGraphNode treeGraphNode3 = new TreeGraphNode(label0, list1);
      treeGraphNode0.deepCopy();
      int int0 = 1154;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreBinarizedTree(treeGraphNode3, 962);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeThrowsNullPointerException1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      Tag tag0 = new Tag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree(treeGraphNode1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsNullPointerExceptionAndValidateBinarizedTree()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("-BEGIN-SENT", 758);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Stack<Tree> stack0 = new Stack<Tree>();
      List<Tree> list0 = treeGraphNode1.getLeaves(stack0);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(label0, list0);
      List<Tree> list1 = treeGraphNode2.pathNodeToNode(treeGraphNode1, treeGraphNode1);
      TreeGraphNode treeGraphNode3 = new TreeGraphNode(label0, list1);
      treeGraphNode0.deepCopy();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(treeGraphNode3, 1154);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Vector<TaggedWord> vector0 = new Vector<TaggedWord>();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      TreeReaderFactory treeReaderFactory0 = hebrewTreebankParserParams0.treeReaderFactory();
      Tree tree0 = Tree.valueOf(" words (incl. stop) iScore ", treeReaderFactory0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(tree0, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingList0()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      Lexicon lexicon0 = null;
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      FrenchMorphoFeatureSpecification frenchMorphoFeatureSpecification0 = new FrenchMorphoFeatureSpecification();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(frenchMorphoFeatureSpecification0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ArrayList<Word> arrayList0 = chineseTreebankParserParams0.defaultTestSentence();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(false);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossible()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ChineseLexiconAndWordSegmenter.getSegmenterDataFromSerializedFile((String) null);
      Options options0 = new Options(chineseTreebankParserParams0);
      hashIndex0.add((String) null);
      boolean boolean0 = ExhaustivePCFGParser.dumpTagging;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.hasParse();
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser1.getBestScore("");
      Hook hook0 = new Hook(false);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndInitializePossibles()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.initializePossibles();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
      
      BasicDocument<Object> basicDocument0 = BasicDocument.init("C_T80u!e*+H; x'", "C_T80u!e*+H; x'");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) basicDocument0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleThrowsNullPointerExceptionAndOPossibleWithHookWhereIsPreHookIsTrue()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(true);
      hook0.start = 100;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList0()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      CoreLabel coreLabel0 = seqClassifierFlags0.pad;
      CoreLabel coreLabel1 = new CoreLabel((CoreMap) seqClassifierFlags0.pad);
      List<CoreLabel> list0 = List.of(coreLabel0, seqClassifierFlags0.pad, seqClassifierFlags0.pad, seqClassifierFlags0.pad, coreLabel0, coreLabel1, coreLabel0, seqClassifierFlags0.pad, coreLabel1, coreLabel1);
      FrenchMorphoFeatureSpecification frenchMorphoFeatureSpecification0 = new FrenchMorphoFeatureSpecification();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(frenchMorphoFeatureSpecification0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingHTKLatticeReader()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      boolean boolean0 = exhaustivePCFGParser0.parse((HTKLatticeReader) null);
      assertFalse(boolean0);
      
      boolean boolean1 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean1);
  }

  @Test(timeout = 4000)
  public void testParseTakingHTKLatticeReaderAndGetBestScoreTakingStringAndParseTakingHTKLatticeReader()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser1.getBestScore("PCFG parsing ");
      boolean boolean1 = exhaustivePCFGParser0.parse((HTKLatticeReader) null);
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNull()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("Y");
      coreLabelTokenFactory0.makeToken(coreLabel0);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      Vector<TaggedWord> vector0 = new Vector<TaggedWord>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndHasParse()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.hasParse();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("X(g'&Y`iB+A?[bsM");
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      FrenchMorphoFeatureSpecification frenchMorphoFeatureSpecification0 = new FrenchMorphoFeatureSpecification();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(frenchMorphoFeatureSpecification0, hashIndex0, hashIndex0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySize0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.arraySize = 100;
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingList1()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      CoreLabel coreLabel1 = coreLabelTokenFactory0.makeToken(coreLabel0);
      CoreLabel coreLabel2 = new CoreLabel(coreLabel0);
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      CoreLabel coreLabel3 = seqClassifierFlags0.pad;
      List<CoreLabel> list0 = List.of(coreLabel1, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel1, coreLabel2, coreLabel3, coreLabel0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("\"R$t*+0f9f&Gzw3mv");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringAndHasParse()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ChineseLexiconAndWordSegmenter.getSegmenterDataFromSerializedFile((String) null);
      Options options0 = new Options(chineseTreebankParserParams0);
      hashIndex0.add((String) null);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
      
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      double double0 = exhaustivePCFGParser0.getBestScore((String) null);
      assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingString()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      hashIndex0.add((String) null);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      double double0 = exhaustivePCFGParser0.getBestScore((String) null);
      assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySizeThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Tag tag0 = new Tag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      Tree tree0 = treeGraphNode0.localTree();
      treeGraphNode0.addChild(tree0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(tag0, list0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreBinarizedTree(treeGraphNode1, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTreeReturningZero()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>(100);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      System.setCurrentTimeMillis(100);
      exhaustivePCFGParser0.nudgeDownArraySize();
      CompositeTreeTransformer compositeTreeTransformer0 = new CompositeTreeTransformer();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      SimpleTree simpleTree0 = new SimpleTree(labeledScoredTreeNode0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, arrayList0);
      Tree tree0 = treeGraphNode0.deepCopy();
      Tree tree1 = compositeTreeTransformer0.transformTree(tree0);
      double double0 = exhaustivePCFGParser0.scoreBinarizedTree(tree1, 882);
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testInitializePossibles()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, (String) null);
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Lexicon lexicon0 = chineseTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.nudgeDownArraySize();
      exhaustivePCFGParser0.doInsideScores();
      exhaustivePCFGParser0.getKGoodParses(0);
      exhaustivePCFGParser0.createArrays(3);
      assertFalse(exhaustivePCFGParser0.hasParse());
      
      Vector<TaggedWord> vector0 = new Vector<TaggedWord>();
      exhaustivePCFGParser0.initializePossibles();
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListAndCreateArrays2()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      Vector<TaggedWord> vector0 = new Vector<TaggedWord>();
      TaggedWord taggedWord0 = new TaggedWord();
      vector0.add(taggedWord0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndCreateArraysAndParseTakingListWithEmptyList()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      Stack<TaggedWord> stack0 = new Stack<TaggedWord>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) stack0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndGetKGoodParses()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, (String) null);
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Lexicon lexicon0 = chineseTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.nudgeDownArraySize();
      exhaustivePCFGParser0.doInsideScores();
      exhaustivePCFGParser0.getKGoodParses(0);
      exhaustivePCFGParser0.createArrays(3);
      Vector<TaggedWord> vector0 = new Vector<TaggedWord>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithEmptyList()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Vector<TaggedWord> vector0 = new Vector<TaggedWord>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testHasParseAndSetConstraints()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      ArrayList<ParserConstraint> arrayList0 = new ArrayList<ParserConstraint>();
      exhaustivePCFGParser0.setConstraints(arrayList0);
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeWithLatticeWhereGetNumEdgesIsZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingNoArgumentsAndGetBestScoreTakingNoArguments()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, deltaIndex0, hashIndex0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      SimpleTree simpleTree0 = new SimpleTree(labeledScoredTreeNode0, (List<Tree>) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      Tree tree0 = treeGraphNode0.deepCopy();
      double double0 = exhaustivePCFGParser0.validateBinarizedTree(tree0, 100);
      assertEquals(0.0, double0, 0.01);
      
      hashIndex0.unmodifiableView();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      exhaustivePCFGParser0.doInsideScores();
      double double1 = exhaustivePCFGParser0.getBestScore();
      assertEquals(Double.NEGATIVE_INFINITY, double1, 0.01);
  }

  @Test(timeout = 4000)
  public void testSetConstraintsAndGetConstraints()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>(100);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      hashIndex0.add("");
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      List<ParserConstraint> list0 = exhaustivePCFGParser0.constraints;
      exhaustivePCFGParser0.setConstraints((List<ParserConstraint>) null);
      List<ParserConstraint> list1 = exhaustivePCFGParser0.getConstraints();
      exhaustivePCFGParser0.setConstraints(list1);
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testSetConstraints()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>(100);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      List<ParserConstraint> list0 = exhaustivePCFGParser0.constraints;
      exhaustivePCFGParser0.setConstraints((List<ParserConstraint>) null);
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testSetConstraintsAndNudgeDownArraySizeAndValidateBinarizedTree()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, deltaIndex0, hashIndex0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      SimpleTree simpleTree0 = new SimpleTree(labeledScoredTreeNode0, (List<Tree>) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      Tree tree0 = treeGraphNode0.deepCopy();
      exhaustivePCFGParser0.validateBinarizedTree(tree0, 100);
      hashIndex0.unmodifiableView();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      assertEquals(0, linkedList0.size());
      
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
      
      List<ParserConstraint> list0 = exhaustivePCFGParser0.constraints;
      exhaustivePCFGParser0.setConstraints((List<ParserConstraint>) null);
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testGetConstraints()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>(100);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      System.setCurrentTimeMillis(100);
      exhaustivePCFGParser0.nudgeDownArraySize();
      exhaustivePCFGParser0.doInsideScores();
      List<ParserConstraint> list0 = exhaustivePCFGParser0.getConstraints();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testGetConstraintsAndHasParse()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
      
      exhaustivePCFGParser0.getConstraints();
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testTickAndTick()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.diskTreebank();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.tick("MNM=TK$E+G~9_Gph2[");
      assertFalse(hashIndex0.contains("MNM=TK$E+G~9_Gph2["));
  }

  @Test(timeout = 4000)
  public void testTickAndHasParse()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.tick("z6Rm");
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTree()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      SimpleTree simpleTree0 = new SimpleTree();
      double double0 = exhaustivePCFGParser0.scoreBinarizedTree(simpleTree0, 100);
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeWithNull()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>(100);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.TreeAnnotator", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTree()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, deltaIndex0, hashIndex0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      SimpleTree simpleTree0 = new SimpleTree(labeledScoredTreeNode0, (List<Tree>) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      simpleTree0.postOrderNodeList();
      Tree tree0 = treeGraphNode0.deepCopy();
      exhaustivePCFGParser0.validateBinarizedTree(tree0, 100);
      hashIndex0.unmodifiableView();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree(treeGraphNode0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BoundaryRemover", e);
      }
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySizeThrowsTooManyResourcesException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.arraySize = 1036;
      // Undeclared exception!
      exhaustivePCFGParser0.nudgeDownArraySize();
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySize1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testIScoreWithEdgeWhereScoreIsNegative()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Edge edge0 = new Edge(false);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iScore(edge0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIScore()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      HashIndex<String> hashIndex1 = new HashIndex<String>(206);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser((BinaryGrammar) null, unaryGrammar0, lexicon0, options0, hashIndex1, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(false);
      Edge edge0 = hook0.backEdge;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iScore((Edge) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKBestParsesReturningListWhereIsEmptyIsTrue()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(false);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      exhaustivePCFGParser0.getKBestParses(0);
      System.setCurrentTimeMillis(100);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      pennTreebankLanguagePack0.morphFeatureSpec();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon((MorphoFeatureSpecification) null, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.buildOFilter();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeAndParseTakingLatticeWithLatticeWhereGetNumEdgesIsZero()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ChineseLexiconAndWordSegmenter.getSegmenterDataFromSerializedFile((String) null);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeAndParseTakingLatticeWithNull()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = exhaustivePCFGParser0.lr;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((Lattice) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = exhaustivePCFGParser0.lr;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((Lattice) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsExceptionAndNudgeDownArraySize()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      lattice0.addBoundary();
      lattice0.addBoundary();
      exhaustivePCFGParser0.nudgeDownArraySize();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresAndDoInsideScoresAndHasParse()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.doInsideScores();
      exhaustivePCFGParser0.hasParse();
      // Undeclared exception!
      try { 
        binaryGrammar0.forEach((Consumer<? super BinaryRule>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Objects", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoInsideScores()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.doInsideScores();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testGetKBestParses()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>(100);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      int[][] intArray0 = new int[2][5];
      int[] intArray1 = new int[4];
      intArray1[0] = 100;
      intArray1[1] = 100;
      intArray1[2] = 100;
      intArray1[3] = 100;
      intArray0[0] = intArray1;
      int[] intArray2 = new int[4];
      intArray2[0] = 100;
      intArray2[1] = 100;
      intArray2[2] = 100;
      intArray2[3] = 100;
      intArray0[1] = intArray2;
      exhaustivePCFGParser0.wideLExtent = intArray0;
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKBestParses(1073736455);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKGoodParsesThrowsArrayIndexOutOfBoundsExceptionAndValidateBinarizedTree()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, deltaIndex0, deltaIndex0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "F,\u0002UYYSiLW");
      SimpleTree simpleTree0 = new SimpleTree(labeledScoredTreeNode0, (List<Tree>) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0, (List<Tree>) null);
      Tree tree0 = treeGraphNode0.deepCopy();
      exhaustivePCFGParser0.validateBinarizedTree(tree0, 100);
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      hashIndex1.unmodifiableView();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKGoodParses(100);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKGoodParsesThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKGoodParses(100);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKBestParsesWithNegative()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      List<ScoredObject<Tree>> list0 = exhaustivePCFGParser0.getKBestParses((-2041));
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetKBestParsesThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKBestParses(100);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKGoodParses()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, deltaIndex0, hashIndex0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "<Cx)luJQcK223*");
      SimpleTree simpleTree0 = new SimpleTree(labeledScoredTreeNode0, (List<Tree>) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      Tree tree0 = treeGraphNode0.deepCopy();
      exhaustivePCFGParser0.validateBinarizedTree(tree0, 100);
      hashIndex0.unmodifiableView();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      List<ScoredObject<Tree>> list0 = exhaustivePCFGParser0.getKGoodParses((-490));
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOPossibleR()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      String string0 = "A2wMlW*)@%xqoU";
      hashIndex0.add("A2wMlW*)@%xqoU");
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex1);
      italianTreebankParserParams0.display();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleR(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleRThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleR(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsNullPointerExceptionAndCreateArraysAndInitializePossibles()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      SystemInUtil.addInputLine(" words (incl. stop) iScore ");
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      Vector<TaggedWord> vector0 = new Vector<TaggedWord>();
      exhaustivePCFGParser0.initializePossibles();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      TreeReaderFactory treeReaderFactory0 = hebrewTreebankParserParams0.treeReaderFactory();
      Tree tree0 = Tree.valueOf(" words (incl. stop) iScore ", treeReaderFactory0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(tree0, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTreeAndValidateBinarizedTree()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Tag tag0 = new Tag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      double double0 = exhaustivePCFGParser0.scoreBinarizedTree(treeGraphNode0, 100);
      double double1 = exhaustivePCFGParser0.validateBinarizedTree(treeGraphNode0, 100);
      assertEquals(double1, double0, 0.01);
      assertEquals(0.0, double1, 0.01);
  }

  @Test(timeout = 4000)
  public void testInitializePossiblesThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.initializePossibles();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testInitializePossiblesThrowsNullPointerExceptionAndInitializePossibles()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>(3829);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Index<? extends String>) hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex1);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options();
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      chineseTreebankParserParams0.transformTree((Tree) null, (Tree) null);
      hashIndex0.unmodifiableView();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(hashIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser((BinaryGrammar) null, unaryGrammar1, lexicon0, options0, hashIndex1, hashIndex1, hashIndex1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.initializePossibles();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleRThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleR(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleR()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      italianTreebankParserParams0.display();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleR(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildOFilterThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      Edge edge0 = new Edge(false);
      Edge edge1 = new Edge(edge0);
      Edge edge2 = new Edge(edge1);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      chineseTreebankParserParams0.transformTree((Tree) null, (Tree) null);
      chineseTreebankParserParams0.transformTree((Tree) null, (Tree) null);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.buildOFilter();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractBestParseThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>(3829);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Index<? extends String>) hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex1);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex1);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options();
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      Tree tree0 = null;
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex1, hashIndex1, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.extractBestParse((String) null, (-1), 3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySize2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("~Ca^d>S)g%NUgCh?H");
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex1, hashIndex1, hashIndex0);
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testHasParse2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateExhaustivePCFGParserThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      HashSet<Object> hashSet0 = new HashSet<Object>();
      hashIndex0.retainAll(hashSet0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      hashIndex0.add("$ )j/rYp*r>rw");
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.hasParse();
      // Undeclared exception!
      try { 
        HashIndex.loadFromFilename("?w?zO)r");
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // org.evosuite.runtime.mock.java.lang.MockThrowable: Unable to open \"?w?zO)r\" as class path, filename or URL
         //
         verifyException("edu.stanford.nlp.util.HashIndex", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingNoArguments()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      double double0 = exhaustivePCFGParser0.getBestScore();
      assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringAndGetBestScoreTakingStringWithNonEmptyString()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      double double0 = exhaustivePCFGParser0.getBestScore("-hasCOORD");
      assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeWithNullAndZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>(3829);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Index<? extends String>) hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex1);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex1);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options();
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      chineseTreebankParserParams0.transformTree((Tree) null, (Tree) null);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex1, hashIndex1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree((Tree) null, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleLAndGetBestParseThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Edge edge0 = new Edge(false);
      Edge edge1 = new Edge(edge0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ChineseLexiconAndWordSegmenter.getSegmenterDataFromSerializedFile((String) null);
      Options options0 = new Options();
      HashIndex<String> hashIndex1 = new HashIndex<String>(0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex1, hashIndex1);
      options0.useUnigramWordSmoothing = true;
      boolean[][] booleanArray0 = new boolean[8][2];
      boolean[] booleanArray1 = new boolean[7];
      booleanArray1[0] = false;
      booleanArray1[1] = false;
      booleanArray1[2] = false;
      booleanArray1[3] = false;
      booleanArray1[4] = true;
      booleanArray1[5] = true;
      booleanArray1[6] = false;
      booleanArray0[0] = booleanArray1;
      boolean[] booleanArray2 = new boolean[3];
      booleanArray2[0] = false;
      booleanArray2[1] = false;
      booleanArray2[2] = true;
      booleanArray0[1] = booleanArray2;
      boolean[] booleanArray3 = new boolean[1];
      booleanArray3[0] = true;
      booleanArray0[2] = booleanArray3;
      boolean[] booleanArray4 = new boolean[5];
      booleanArray4[0] = false;
      booleanArray4[1] = true;
      booleanArray4[2] = false;
      booleanArray4[3] = true;
      booleanArray4[4] = true;
      booleanArray0[3] = booleanArray4;
      boolean[] booleanArray5 = new boolean[9];
      booleanArray5[0] = false;
      booleanArray5[1] = false;
      booleanArray5[2] = false;
      booleanArray5[3] = true;
      booleanArray5[4] = true;
      booleanArray5[5] = true;
      booleanArray5[6] = true;
      booleanArray5[7] = true;
      booleanArray5[8] = false;
      booleanArray0[4] = booleanArray5;
      boolean[] booleanArray6 = new boolean[7];
      booleanArray6[0] = true;
      booleanArray6[1] = false;
      booleanArray6[2] = true;
      booleanArray6[3] = true;
      booleanArray6[4] = false;
      booleanArray6[5] = true;
      booleanArray6[6] = false;
      booleanArray0[5] = booleanArray6;
      boolean[] booleanArray7 = new boolean[0];
      booleanArray0[6] = booleanArray7;
      boolean[] booleanArray8 = new boolean[2];
      booleanArray8[0] = true;
      booleanArray8[1] = true;
      booleanArray0[7] = booleanArray8;
      exhaustivePCFGParser0.oPossibleByL = booleanArray0;
      exhaustivePCFGParser0.oPossibleL(0, 3);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestParse();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestParsesThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = null;
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      BaseLexicon baseLexicon0 = (BaseLexicon)italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      options0.useSmoothTagProjection = false;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      int int0 = 2157;
      double[][] doubleArray0 = new double[5][4];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 2157;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[0];
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[5];
      doubleArray3[0] = 0.0;
      doubleArray3[1] = (double) 2157;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = (double) 337;
      doubleArray3[4] = 0.0;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[5];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = (double) 2157;
      doubleArray4[3] = (double) 337;
      doubleArray4[4] = (double) 100;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[6];
      doubleArray5[0] = (double) 337;
      doubleArray5[1] = (double) 2157;
      doubleArray5[2] = 0.0;
      doubleArray5[3] = (double) 337;
      doubleArray5[4] = 0.0;
      doubleArray5[5] = (double) 337;
      doubleArray0[4] = doubleArray5;
      baseLexicon0.m_TT = doubleArray0;
      int int1 = (-2625);
      List<Tree> list0 = new LinkedList<Tree>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestParses();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleThrowsNullPointerExceptionAndOPossibleAndOPossibleWithHookWhereIsPreHookIsTrue()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(true);
      hook0.start = 100;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleThrowsNullPointerExceptionAndOPossibleWithHookWhereIsPreHookIsFalse()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(true);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleThrowsNullPointerExceptionAndOPossibleAndOPossibleWithHookWhereIsPreHookIsFalse()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = null;
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      hashIndex0.add("");
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      int int0 = 1796;
      int int1 = 2771;
      int int2 = (-2101);
      Hook hook0 = new Hook(true);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleL()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>(3829);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Index<? extends String>) hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex1);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex1);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options();
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      HashIndex<String> hashIndex2 = new HashIndex<String>();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex1, hashIndex1, hashIndex2);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleL(53, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleLThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleL(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleLWithPositive()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleL(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleLAndOPossibleLThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      hashIndex0.add("F4Jq<neav` 7<Z;Q");
      UnaryGrammar unaryGrammar0 = null;
      Edge edge0 = new Edge(true);
      Edge edge1 = new Edge(edge0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      edge0.end = 0;
      ChineseLexiconAndWordSegmenter.getSegmenterDataFromSerializedFile((String) null);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.oPossibleL(0, 1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOScoreThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      Edge edge0 = new Edge(false);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oScore(edge0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOScore()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = null;
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Edge edge0 = new Edge(false);
      Edge edge1 = new Edge(edge0);
      Edge edge2 = new Edge(edge1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oScore(edge0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestParseThrowsNullPointerExceptionAndCreatesExhaustivePCFGParser0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      binaryGrammar0.ruleIteratorByParent(1073736455);
      Options options0 = new Options(italianTreebankParserParams0);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Index<? extends String>) hashIndex0);
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, lexicon0, options0, hashIndex0, hashIndex1, hashIndex0);
      hashIndex1.add("(+@P+98!yM");
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ChineseLexiconAndWordSegmenter.getSegmenterDataFromSerializedFile((String) null);
      Options options1 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, lexicon0, options0, hashIndex0, hashIndex0, hashIndex1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.getBestParse();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestParseThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestParse();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestParseThrowsNullPointerExceptionAndCreatesExhaustivePCFGParser1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      hashIndex0.add("F4Jq<neav` 7<Z;Q");
      Edge edge0 = new Edge(true);
      Edge edge1 = new Edge(edge0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      edge0.end = 0;
      ChineseLexiconAndWordSegmenter.getSegmenterDataFromSerializedFile((String) null);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestParse();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesExhaustivePCFGParser()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      hashIndex0.add("X(g'&Y`iB+A?[bsM");
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testMatchesWithPositive()  throws Throwable  {
      ExhaustivePCFGParser.matches(2906.3029164, 2906.3029164);
      Options options0 = new Options();
      assertFalse(options0.coarseDistance);
  }

  @Test(timeout = 4000)
  public void testExtractBestParsesThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.extractBestParses(337, 2157, 1796);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKSampledParses()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>(3829);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Index<? extends String>) hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex1);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex1);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options();
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      HashIndex<String> hashIndex2 = new HashIndex<String>();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex1, hashIndex1, hashIndex2);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKSampledParses((-129));
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // ExhaustivePCFGParser doesn't sample.
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKSampledParsesWithPositive()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKSampledParses(100);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // ExhaustivePCFGParser doesn't sample.
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateExhaustivePCFGParserThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      hashIndex0.add("F4Jq<neav` 7<Z;Q");
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Lexicon lexicon0 = spanishUnknownWordModelTrainer0.lex;
      Options options0 = spanishUnknownWordModelTrainer0.op;
      ExhaustivePCFGParser exhaustivePCFGParser0 = null;
      try {
        exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, (Lexicon) null, (Options) null, hashIndex0, hashIndex0, hashIndex0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testMatchesReturningTrue()  throws Throwable  {
      ExhaustivePCFGParser.matches(2906.3029164, 2906.3029164);
      // Undeclared exception!
      try { 
        HashIndex.loadFromReader((BufferedReader) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.util.HashIndex", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesWithZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      boolean boolean0 = ExhaustivePCFGParser.matches(0.0, 100);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesReturningFalse()  throws Throwable  {
      ExhaustivePCFGParser.matches(0.0, 1.0);
      String string0 = "-markPl3";
      // Undeclared exception!
      try { 
        HashIndex.loadFromFilename("-markPl3");
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // org.evosuite.runtime.mock.java.lang.MockThrowable: Unable to open \"-markPl3\" as class path, filename or URL
         //
         verifyException("edu.stanford.nlp.util.HashIndex", e);
      }
  }
}
