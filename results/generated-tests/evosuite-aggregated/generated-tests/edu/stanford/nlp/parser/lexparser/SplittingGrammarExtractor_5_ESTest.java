/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Apr 21 20:36:25 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.international.Language;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CategoryWordTagFactory;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.TaggedWordFactory;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordLemmaTagFactory;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.objectbank.ObjectBank;
import edu.stanford.nlp.parser.lexparser.BaseLexicon;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HebrewTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.IntTaggedWord;
import edu.stanford.nlp.parser.lexparser.ItalianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.NegraPennTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.trees.BasicCategoryTreeTransformer;
import edu.stanford.nlp.trees.BobChrisTreeNormalizer;
import edu.stanford.nlp.trees.DiskTreebank;
import edu.stanford.nlp.trees.HeadFinder;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.MemoryTreebank;
import edu.stanford.nlp.trees.NPTmpRetainingTreeNormalizer;
import edu.stanford.nlp.trees.PennTreebankLanguagePack;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.SimpleTreeFactory;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeGraphNodeFactory;
import edu.stanford.nlp.trees.TreeTransformer;
import edu.stanford.nlp.trees.TreebankLanguagePack;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.Filters;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.ThreeDimensionalMap;
import edu.stanford.nlp.util.Triple;
import edu.stanford.nlp.util.TwoDimensionalMap;
import java.io.Reader;
import java.time.temporal.ChronoField;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.Vector;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class SplittingGrammarExtractor_5_ESTest extends SplittingGrammarExtractor_5_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, true, 100, identityHashMap2);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Tree tree2 = labeledScoredTreeFactory0.newTreeNode((Label) tree0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree2, true, Integer.MAX_VALUE, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeReturningPositive()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.getStateSplitCount(tree1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.values();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      System.setCurrentTimeMillis(0L);
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(identityHashMap1);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerExceptionAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      assertEquals(5, list0.size());
      
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence((List<Triple<String, Integer, Double>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringReturningPositive()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      byte[] byteArray0 = new byte[0];
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(identityHashMap1);
      MapFactory<Triple<Object, Object, CoreLabel>, Object> mapFactory0 = MapFactory.hashMapFactory();
      mapFactory0.setMap(hashMap0, 2722);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countOriginalStates();
      int int0 = splittingGrammarExtractor0.getStateSplitCount("_=)!");
      assertEquals(3, int0);
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(identityHashMap1);
      MapFactory<Triple<Object, Object, CoreLabel>, Object> mapFactory0 = MapFactory.hashMapFactory();
      mapFactory0.setMap(hashMap0, 2722);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndExtractTakingCollectionAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(identityHashMap1);
      MapFactory<Triple<Object, Object, CoreLabel>, Object> mapFactory0 = MapFactory.hashMapFactory();
      mapFactory0.setMap(hashMap0, 2722);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, false, 100, identityHashMap3);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(identityHashMap1);
      MapFactory<Triple<Object, Object, CoreLabel>, Object> mapFactory0 = MapFactory.hashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0, 2722);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      TwoDimensionalMap<String, String, CoreLabel> twoDimensionalMap2 = TwoDimensionalMap.identityHashMap();
      Morphology morphology0 = new Morphology();
      twoDimensionalMap1.addAll(twoDimensionalMap2, morphology0);
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap2, map0, twoDimensionalMap1, threeDimensionalMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsTooManyResourcesException0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      double[] doubleArray0 = new double[5];
      tree0.addChild(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][] doubleArray1 = new double[4][5];
      doubleArray1[0] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[3] = doubleArray0;
      identityHashMap0.put(tree0, doubleArray1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.put("_%=)!", "_%=)!", doubleArray1);
      FileSystemHandling.shouldAllThrowIOExceptions();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitions0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      tree0.addChild(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tree0, 0.0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Double.valueOf(0.0);
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      int[] intArray0 = new int[8];
      intArray0[0] = 22;
      intArray0[1] = 100;
      intArray0[2] = 100;
      intArray0[3] = 100;
      intArray0[4] = (-1045);
      intArray0[5] = 41;
      intArray0[6] = 3954;
      intArray0[1] = 100;
      identityHashMap1.put("_%=)!", intArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap3, identityHashMap0, identityHashMap3, (double[]) null, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitions1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      tree0.addChild(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tree0, 0.0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Double.valueOf(0.0);
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      int[] intArray0 = new int[8];
      intArray0[0] = 2;
      intArray0[1] = 100;
      intArray0[2] = 100;
      intArray0[3] = 100;
      intArray0[4] = (-1045);
      intArray0[5] = 41;
      intArray0[6] = 3954;
      intArray0[7] = 100;
      identityHashMap1.put("_%=)!", intArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap2, identityHashMap5, identityHashMap0, identityHashMap5, (double[]) null, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      tree0.addChild(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tree0, 0.0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Double.valueOf(0.0);
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      int[] intArray0 = new int[8];
      intArray0[0] = 2;
      intArray0[1] = 100;
      intArray0[2] = 100;
      intArray0[3] = 100;
      intArray0[4] = (-1045);
      intArray0[5] = 41;
      intArray0[6] = 3954;
      intArray0[7] = 100;
      identityHashMap1.put("_%=)!", intArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap3, identityHashMap0, identityHashMap3, (double[]) null, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsAndRecountOutsideTaking5ArgumentsAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("_=)!", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray1 = new double[1][4][7];
      double[][] doubleArray2 = new double[8][3];
      double[] doubleArray3 = new double[0];
      doubleArray2[0] = doubleArray3;
      doubleArray2[1] = doubleArray0;
      doubleArray2[2] = doubleArray0;
      doubleArray2[3] = doubleArray0;
      doubleArray2[4] = doubleArray0;
      doubleArray2[5] = doubleArray0;
      doubleArray2[6] = doubleArray0;
      doubleArray2[7] = doubleArray0;
      doubleArray1[0] = doubleArray2;
      identityHashMap1.put(tree1, doubleArray1);
      Options options1 = new Options();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(tree1, identityHashMap2, identityHashMap2, identityHashMap0, identityHashMap1);
      splittingGrammarExtractor0.recountOutside(tree0, tree0, tree1, identityHashMap2, identityHashMap2);
      splittingGrammarExtractor0.mergeStates();
      int int1 = splittingGrammarExtractor0.getStateSplitCount(tree0);
      assertFalse(int1 == int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_C*");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("_C*", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray0 = new double[1][4][7];
      double[][] doubleArray1 = new double[16][3];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      identityHashMap1.put(tree1, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray1[2], 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(tree1, identityHashMap2, identityHashMap2, identityHashMap0, identityHashMap1);
      assertNotSame(tree0, tree1);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      options0.genStop = false;
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("_=)!", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray0 = new double[1][4][7];
      double[][] doubleArray1 = new double[8][3];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      doubleArray1[2] = doubleArray1[1];
      doubleArray0[0] = doubleArray1;
      identityHashMap1.put(tree1, doubleArray0);
      Options options1 = new Options();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      FileSystemHandling.shouldAllThrowIOExceptions();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray1[2], 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.countOriginalStates();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(tree1, identityHashMap2, identityHashMap2);
      assertEquals(1, identityHashMap2.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsTooManyResourcesException1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      List.of(tree0, tree0, tree0, tree0, tree0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      tree0.addChild(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][] doubleArray1 = new double[4][5];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[3] = doubleArray0;
      identityHashMap0.put(tree0, doubleArray1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      twoDimensionalMap0.isEmpty();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsTooManyResourcesException2()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      double[] doubleArray0 = new double[5];
      tree0.addChild(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][] doubleArray1 = new double[4][5];
      doubleArray1[0] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[3] = doubleArray0;
      identityHashMap0.put(tree0, doubleArray1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      twoDimensionalMap0.isEmpty();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("Ld>");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[1];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) null, twoDimensionalMap1, threeDimensionalMap1);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("_=)!", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray1 = new double[1][4][7];
      double[][] doubleArray2 = new double[8][3];
      double[] doubleArray3 = new double[0];
      doubleArray2[0] = doubleArray3;
      doubleArray2[1] = doubleArray0;
      double[] doubleArray4 = new double[5];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = 0.0;
      doubleArray4[3] = (double) 100;
      doubleArray4[4] = (double) 100;
      doubleArray2[2] = doubleArray4;
      doubleArray2[3] = doubleArray0;
      doubleArray2[4] = doubleArray0;
      doubleArray2[5] = doubleArray0;
      doubleArray2[6] = doubleArray0;
      doubleArray2[7] = doubleArray0;
      doubleArray1[0] = doubleArray2;
      identityHashMap1.put(tree1, doubleArray1);
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor1.recalculateTemporaryBetas(tree1, doubleArray4, 100, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_C*");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("_C*", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray0 = new double[1][4][7];
      double[][] doubleArray1 = new double[3][3];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      identityHashMap1.put(tree1, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray1[2], 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      List.of(tree0, tree0, tree0, tree0, tree0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      tree0.addChild(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[0][5];
      identityHashMap0.put(tree0, doubleArray1);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("Post-split etas", "Post-split etas");
      Stack<Tree> stack0 = new Stack<Tree>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Random.setNextRandom(618);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SimpleTree simpleTree0 = new SimpleTree(wordLemmaTag0);
      SimpleTree simpleTree1 = new SimpleTree(wordLemmaTag0, stack0);
      Tree tree0 = italianTreebankParserParams0.transformTree(simpleTree0, simpleTree1);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = (double) 618;
      doubleArray0[1] = (double) 0;
      doubleArray0[2] = (double) 3;
      doubleArray0[3] = (double) 0;
      doubleArray0[4] = (double) 0;
      doubleArray0[5] = (double) 618;
      splittingGrammarExtractor0.saveTrees(simpleTree0, 681.74, tree0, 681.74);
      doubleArray0[6] = (double) 100;
      doubleArray0[7] = (double) 3;
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, doubleArray0, hashMap0);
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap1, twoDimensionalMap1, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("{@P}H(#");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("{@P}H(#", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[7];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray1 = new double[1][1][1];
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      identityHashMap2.put(tree1, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree1, tree1, identityHashMap2, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerExceptionAndGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(" ");
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      Stack<String> stack0 = new Stack<String>();
      double[][] doubleArray0 = new double[4][3];
      double[] doubleArray1 = new double[1];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 1927.9625280604816;
      doubleArray0[1] = doubleArray1;
      double[] doubleArray3 = new double[2];
      doubleArray3[0] = 1927.9625280604816;
      doubleArray3[1] = (double) 100;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[5];
      doubleArray4[0] = (double) 100;
      doubleArray4[1] = 0.0;
      doubleArray4[3] = 1927.9625280604816;
      doubleArray4[4] = (double) 100;
      doubleArray0[3] = doubleArray4;
      twoDimensionalMap0.put(" ", " ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.getStateSplitCount(" ");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(" =| ");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      Stack<String> stack0 = new Stack<String>();
      double[][] doubleArray0 = new double[4][3];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 1927.9625280604816;
      doubleArray0[1] = doubleArray2;
      doubleArray0[2] = doubleArray2;
      double[] doubleArray3 = new double[5];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = 0.0;
      doubleArray3[3] = 1927.9625280604816;
      doubleArray0[3] = doubleArray3;
      twoDimensionalMap0.put(" =| ", " =| ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.getStateSplitCount(" =| ");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap0, identityHashMap0);
      assertFalse(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsAndRecountOutsideTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(" =| ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      labeledScoredTreeFactory0.newTreeNode(" =| ", list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      Stack<String> stack0 = new Stack<String>();
      double[][] doubleArray0 = new double[4][3];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 1927.9625280604816;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[2];
      doubleArray3[0] = 1927.9625280604816;
      doubleArray3[1] = (double) 100;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[5];
      doubleArray4[0] = (double) 100;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = (double) 100;
      doubleArray4[3] = 1927.9625280604816;
      doubleArray4[4] = (double) 100;
      doubleArray0[3] = doubleArray4;
      twoDimensionalMap0.put(" =| ", " =| ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      int int0 = splittingGrammarExtractor0.getStateSplitCount(" =| ");
      assertEquals(0, int0);
      
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap2, identityHashMap2);
      System.setCurrentTimeMillis(100);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsTooManyResourcesExceptionAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, true);
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      List.of(tree0, tree0, tree0, tree0, tree0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      tree0.addChild(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[][] doubleArray0 = new double[7][1];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = (double) 100;
      double[] doubleArray2 = new double[7];
      doubleArray2[0] = 0.0;
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = 0.0;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[14];
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[2];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 0.0;
      double[] doubleArray5 = new double[5];
      doubleArray5[0] = 0.0;
      doubleArray5[1] = 0.0;
      doubleArray5[2] = (double) 100;
      doubleArray5[3] = (double) 100;
      doubleArray5[4] = (double) 100;
      doubleArray0[4] = doubleArray5;
      doubleArray0[6] = doubleArray2;
      double[] doubleArray6 = new double[6];
      doubleArray6[0] = 0.0;
      doubleArray6[1] = 0.0;
      doubleArray6[2] = 0.0;
      doubleArray6[3] = (double) 100;
      doubleArray4[0] = 100.0;
      doubleArray6[5] = 0.0;
      double[] doubleArray7 = new double[10];
      doubleArray7[0] = 0.9999000099990001;
      doubleArray7[1] = 0.0;
      doubleArray7[3] = 0.0;
      doubleArray7[0] = (double) 100;
      doubleArray7[7] = (double) 100;
      doubleArray7[8] = (double) 100;
      identityHashMap0.put(tree0, doubleArray0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray8 = new double[4][1][1];
      identityHashMap1.put(tree0, doubleArray8);
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap0, identityHashMap1);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsTooManyResourcesException()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, true);
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      List.of(tree0, tree0, tree0, tree0, tree0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      tree0.addChild(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[][] doubleArray0 = new double[7][1];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = (double) 100;
      double[] doubleArray2 = new double[7];
      doubleArray2[0] = 0.0;
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = 0.0;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[14];
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[2];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 0.0;
      double[] doubleArray5 = new double[5];
      doubleArray5[1] = 0.0;
      doubleArray5[2] = (double) 100;
      doubleArray5[3] = (double) 100;
      doubleArray5[4] = (double) 100;
      doubleArray0[4] = doubleArray5;
      doubleArray0[6] = doubleArray2;
      double[] doubleArray6 = new double[6];
      doubleArray6[0] = 0.0;
      doubleArray6[1] = 0.0;
      doubleArray6[2] = 0.0;
      doubleArray6[3] = (double) 100;
      doubleArray4[0] = 100.0;
      doubleArray6[5] = 0.0;
      double[] doubleArray7 = new double[10];
      doubleArray7[1] = 0.0;
      doubleArray7[3] = 0.0;
      doubleArray7[0] = (double) 100;
      doubleArray7[7] = (double) 100;
      doubleArray7[8] = (double) 100;
      identityHashMap0.put(tree0, doubleArray0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray8 = new double[4][1][1];
      identityHashMap1.put(tree0, doubleArray8);
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap0, identityHashMap1);
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningZero()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("@04aG6Y=WC`9R(.KPn|'", "@04aG6Y=WC`9R(.KPn|'");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      IndexedWord indexedWord0 = new IndexedWord("@04aG6Y=WC`9R(.KPn|'", (-1), 100);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) indexedWord0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, false, (-1), identityHashMap0);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithTreeWhereScoreIsZero()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")wp%", ")wp%", ")wp%");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordLemmaTagFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("Post-split betas", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0, 0.0);
      labeledScoredTreeNode0.addChild(tree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory1 = new LabeledScoredTreeFactory();
      labeledScoredTreeFactory1.newTreeNode((Label) treeGraphNode0, (List<Tree>) stack0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, 100, identityHashMap2, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("_%=)!", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      tree0.addChild(tree1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray0 = new double[1][1][1];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")wp%", ")wp%", ")wp%");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordLemmaTagFactory0);
      stack0.add((Tree) treeGraphNode0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("Post-split betas", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0, 0.0);
      labeledScoredTreeNode0.addChild(tree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory1 = new LabeledScoredTreeFactory();
      labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0, 0.0, (Collection<Tree>) labeledScoredTreeNode0, 0.0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndExtractTaking4ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("c8>9;}?j|]~JEA5", "c8>9;}?j|]~JEA5", "c8>9;}?j|]~JEA5");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      treeGraphNode0.pathNodeToNode((Tree) null, treeGraphNode0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("c8>9;}?j|]~JEA5", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0, 0.0);
      labeledScoredTreeNode0.addChild(tree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0, 983.22426473863, (Collection<Tree>) labeledScoredTreeNode0, 0.0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideWithTreeWhereScoreIsZero()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")wp%", ")wp%", ")wp%");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordLemmaTagFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("Post-split betas", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0, 0.0);
      labeledScoredTreeNode0.addChild(tree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer((TreebankLanguagePack) null);
      basicCategoryTreeTransformer0.transformHelper(treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountInside(labeledScoredTreeNode0, true, 234, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceWithNull()  throws Throwable  {
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Options options0 = new Options(negraPennTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[5][6];
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = (double) 100;
      twoDimensionalMap0.get("&larr;");
      doubleArray1[4] = (double) 100;
      doubleArray0[2] = doubleArray1;
      double[] doubleArray2 = new double[8];
      doubleArray2[0] = (double) 100;
      doubleArray2[3] = 0.0;
      options0.newTrainOptions();
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = (double) 100;
      doubleArray0[2] = doubleArray0[0];
      twoDimensionalMap0.put((String) null, "&larr;", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerExceptionAndRecountOutsideTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0, stack0);
      treeGraphNode0.getLeaves(stack0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(" ;-i", (List<Tree>) stack0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recountInside(tree0, true, 100, identityHashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, (Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndExtractTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")wp%", ")wp%", ")wp%");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordLemmaTagFactory0);
      stack0.add((Tree) treeGraphNode0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("Post-split betas", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0, 0.0);
      labeledScoredTreeNode0.addChild(tree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory1 = new LabeledScoredTreeFactory();
      labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0, 0.0, (Collection<Tree>) labeledScoredTreeNode0, (-120.8));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("c8>9;}?j|]~JEA5", "c8>9;}?j|]~JEA5", "c8>9;}?j|]~JEA5");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("c8>9;}?j|]~JEA5", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0, 0.0);
      labeledScoredTreeNode0.addChild(tree0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0, (double) 100, (Collection<Tree>) treeGraphNode0, 0.0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")wp%", ")wp%", ")wp%");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordLemmaTagFactory0);
      stack0.add((Tree) treeGraphNode0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("Post-split betas", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0, 0.0);
      labeledScoredTreeNode0.addChild(tree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer((TreebankLanguagePack) null);
      basicCategoryTreeTransformer0.transformHelper(treeGraphNode0);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 100;
      double double0 = (-1049.599);
      doubleArray0[1] = (-1049.599);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInside()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      tree0.addChild(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.recountInside(tree0, options0.freeDependencies, options0.rerankerKBest, identityHashMap1);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithTreeWhereScoreIsZero()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")wp%", ")wp%", ")wp%");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordLemmaTagFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("Post-split betas", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0, 0.0);
      labeledScoredTreeNode0.addChild(tree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][2];
      double[] doubleArray1 = new double[4];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = (double) 100;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[9];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = (double) 100;
      doubleArray2[4] = (double) 100;
      doubleArray2[5] = 0.0;
      doubleArray2[6] = 0.0;
      doubleArray2[7] = 0.0;
      doubleArray2[8] = (double) 100;
      doubleArray0[1] = doubleArray2;
      twoDimensionalMap0.put("''saF}CFLI9A`7Q", ")wp%", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode0, identityHashMap2, identityHashMap0, identityHashMap1, identityHashMap0, doubleArray1, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithTreeWhereScoreIsZero()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")wp%", ")wp%", ")wp%");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordLemmaTagFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("Post-split betas", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0, 0.0);
      labeledScoredTreeNode0.addChild(tree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer((TreebankLanguagePack) null);
      basicCategoryTreeTransformer0.transformHelper(treeGraphNode0);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (-1049.599);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, doubleArray0, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndRecalculateTemporaryBetasTaking8ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")wp%", ")wp%", ")wp%");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordLemmaTagFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("Post-split betas", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0, 0.0);
      labeledScoredTreeNode0.addChild(tree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer((TreebankLanguagePack) null);
      Tree tree1 = basicCategoryTreeTransformer0.transformHelper(treeGraphNode0);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (-1049.599);
      doubleArray0[2] = 0.0;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 22, identityHashMap1, identityHashMap2, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree1, 2.3457102, (Collection<Tree>) labeledScoredTreeNode0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("son", list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0, 0.0);
      labeledScoredTreeNode0.addChild(tree0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0, (double) 100, (Collection<Tree>) treeGraphNode0, 0.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecountWeights0()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("eo/hcBi)q%", "@04a16Y=WC`9R(.KPn_'", "");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      labeledScoredTreeNode0.insertDtr(tree0, (-803));
      stack0.parallelStream();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(labeledScoredTreeNode0, identityHashMap0, identityHashMap3, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0, stack0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(".$$.", list0);
      tree0.remove(labeledScoredTreeFactory0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recountInside(tree0, true, 100, identityHashMap0);
      splittingGrammarExtractor0.splitBetas();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
      assertEquals(Double.NaN, tree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndBuildStateIndex()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")wp%", ")wp%", ")wp%");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TaggedWord taggedWord0 = new TaggedWord(")wp%");
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      tree0.insertDtr(treeGraphNode0, (-830));
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.iteration = (-830);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.buildStateIndex();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) treeGraphNode0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.iteration = (-1305);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerExceptionAndExtractTaking4ArgumentsWithZero()  throws Throwable  {
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("1Xj0s", list0);
      tree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap.hashMap();
      labeledScoredTreeFactory0.newLeaf((Label) tree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) tree0, 0.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("c8>;}?j|]3JEA5", "c8>;}?j|]3JEA5");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newLeaf((Label) wordLemmaTag0);
      stack0.add(tree0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("c8>;}?j|]3JEA5", list0);
      tree1.treeSkeletonConstituentCopy();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0, 0.0);
      labeledScoredTreeNode0.addChild(tree1);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0, (double) 100, (Collection<Tree>) treeGraphNode0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndRecurseOutside0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(" | ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      LabeledScoredTreeFactory labeledScoredTreeFactory1 = new LabeledScoredTreeFactory();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((Label) tree0, list0);
      tree0.insertDtr(tree1, (-696));
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(" | ", " | ", "Trees should have been binarized, expected 1 or 2 children");
      wordLemmaTag0.setWord("s,2E T7*fJK{{UvUs");
      options0.directional = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recurseOutside(tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      tree0.addChild(tree0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Double double0 = new Double(0.0);
      labeledScoredTreeFactory0.newTreeNode("_%=)!", list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments0()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("@04a16Y=WC`9R(.KPn_'", "@04a16Y=WC`9R(.KPn_'", "@04a16Y=WC`9R(.KPn_'");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.0;
      ThreeDimensionalMap<ChronoField, String, String, String> threeDimensionalMap0 = new ThreeDimensionalMap<ChronoField, String, String, String>();
      Set<String> set0 = threeDimensionalMap0.secondKeySet();
      splittingGrammarExtractor0.originalStates = set0;
      identityHashMap0.put("@04a16Y=WC`9R(.KPn_'", doubleArray0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      identityHashMap1.put(tree0, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) hashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("Iteration ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((Label) tree0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[10];
      identityHashMap0.put("Iteration ", doubleArray0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      identityHashMap1.put(tree1, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) hashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndTestConvergenceAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      options0.newTrainOptions();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      double[][] doubleArray0 = new double[1][6];
      double[] doubleArray1 = new double[3];
      doubleArray1[0] = 1.0E-4;
      doubleArray1[1] = Double.POSITIVE_INFINITY;
      doubleArray1[2] = (double) 0L;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("  ", "*UNK*", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testStateThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      String string0 = "@04a16Y=WC`9R(.KPn_'";
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("@04a16Y=WC`9R(.KPn_'", "@04a16Y=WC`9R(.KPn_'", "@04a16Y=WC`9R(.KPn_'");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TaggedWord taggedWord0 = new TaggedWord("@04a16Y=WC`9R(.KPn_'");
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      tree0.insertDtr(treeGraphNode0, (-830));
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) treeGraphNode0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf((String) null);
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((String) null, list0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 98, identityHashMap0, identityHashMap1, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.spliterator();
      double[][] doubleArray0 = new double[1][1];
      double[] doubleArray1 = new double[3];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = (double) 100;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("T:N-H?AU@F?50kn1#a2", "T:N-H?AU@F?50kn1#a2", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      Stack<Tree> stack0 = new Stack<Tree>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][9];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("fu_b?T{", ".$$.", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordTag wordTag0 = WordTag.valueOf("PF<#|qH^be(OpA");
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag(wordTag1);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      splittingGrammarExtractor0.trees = list0;
      double[][] doubleArray0 = new double[2][0];
      twoDimensionalMap0.put("-markInf", "-markInf", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.get("-markInf");
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Tree tree2 = labeledScoredTreeFactory0.newTreeNode("!;mU", list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Trees should have been binarized, expected 1 or 2 children
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesReturningEmptyArray()  throws Throwable  {
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("slip");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("slip", list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      identityHashMap0.keySet();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recountInside(tree1, true, 100, identityHashMap0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(0);
      assertEquals(0, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndRescaleTemporaryBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4a16L=WC:9R(.Kn_");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@4a16L=WC:9R(.Kn_", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][2][1];
      double[][] doubleArray2 = new double[2][6];
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.put("Neither element of pair comparable", "ZO(", doubleArray2);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap1.isEmpty();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap2.values();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap2);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4a16L=WC:9R(.Kn_");
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@4a16L=WC:9R(.Kn_", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][2][1];
      double[][] doubleArray2 = new double[2][6];
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      double[] doubleArray3 = new double[5];
      doubleArray3[0] = 0.0;
      doubleArray3[1] = 0.0;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = 0.0;
      doubleArray3[4] = 0.0;
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray3, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap1, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(tree1, identityHashMap2, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndOutputTransitionsTaking4ArgumentsAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4a16L=WC:9R(.Kn_");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@4a16L=WC:9R(.Kn_", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][2][1];
      double[][] doubleArray2 = new double[2][6];
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(100, int0);
      
      double[] doubleArray3 = new double[5];
      doubleArray3[0] = 0.0;
      doubleArray3[1] = 0.0;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = 0.0;
      doubleArray3[4] = 0.0;
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.outputTransitions(tree0, 100, identityHashMap0, identityHashMap4);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndSplitBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      options0.freeDependencies = false;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][5];
      twoDimensionalMap0.put((String) null, "T:)N-H?A@F?50kn1^a2", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
      
      boolean boolean1 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean1);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndRecalculateTemporaryBetasTaking8ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4a16L=WC:9R(.Kn_");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@4a16L=WC:9R(.Kn_", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][2][1];
      double[][] doubleArray2 = new double[2][6];
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      double[] doubleArray3 = new double[5];
      doubleArray3[0] = 0.0;
      doubleArray3[1] = 0.0;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = 0.0;
      doubleArray3[4] = 0.0;
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray3, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap1, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap1);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap2, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndBuildMergeCorrespondenceAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray1 = new double[2][5];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      twoDimensionalMap0.put((String) null, "T:N-H?AU@F?50kn1#a2", doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.values();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Double double1 = new Double(0.0);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("T:N-H?AU@F?50kn1#a2", 100, double1);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple0, triple0, triple0, triple0, triple0, triple0);
      splittingGrammarExtractor1.buildMergeCorrespondence(list0);
      splittingGrammarExtractor1.splitBetas();
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[5][5];
      twoDimensionalMap0.put("XTp", "XTp", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasWithFalse()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      labeledScoredTreeFactory0.newLeaf("@4a16L=WC:9R(.Kn_");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray1 = new double[2][5];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      twoDimensionalMap0.put((String) null, "T:N-H?AU@F?50kn1#a2", doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor1.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
      
      splittingGrammarExtractor1.splitBetas();
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean1 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void testTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][0];
      twoDimensionalMap0.put("R*~]1", "R*~]1", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4aL=WC:9R(.Kn_");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@4aL=WC:9R(.Kn_", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[3] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][5][1];
      double[][] doubleArray2 = new double[2][6];
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputTransitions(tree0, 3371, identityHashMap0, identityHashMap1);
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      MapFactory<LinkedList<Object>, CoreLabel> mapFactory0 = MapFactory.arrayMapFactory();
      mapFactory0.setMap(identityHashMap2, 100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.identityHashMap();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateTemporaryBetas(tree1, doubleArray0, (-405), identityHashMap0, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor1.outputTransitions(tree0, (-405), identityHashMap0, identityHashMap1);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(" =| ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode(" =| ", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][2][1];
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (double) 100, (Collection<Tree>) list0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      options0.newTestOptions();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("Pre-split betas", list0);
      Double double0 = new Double(111.09570326083357);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("O8_w0X9se@%8Zv7", (Integer) 100, double0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap1, identityHashMap2);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountTree(tree0, false, identityHashMap3, identityHashMap3, identityHashMap1, identityHashMap2);
      assertEquals(0, identityHashMap2.size());
      assertTrue(identityHashMap1.isEmpty());
      assertTrue(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testTestConvergenceThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[5][2][1];
      double[][] doubleArray1 = new double[3][2];
      double[] doubleArray2 = new double[8];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = 0.0;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = (double) 100;
      doubleArray2[4] = (double) 100;
      doubleArray2[5] = 0.0;
      doubleArray2[6] = (double) 100;
      doubleArray2[7] = (double) 100;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[6];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = 0.0;
      doubleArray3[2] = (double) 100;
      doubleArray3[3] = 1311.6985;
      doubleArray3[4] = 0.0;
      doubleArray3[5] = (-4656.02171462933);
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[2];
      doubleArray4[0] = (double) 100;
      doubleArray4[1] = 1311.6985;
      doubleArray1[2] = doubleArray4;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray5 = new double[5][3];
      doubleArray5[0] = doubleArray3;
      doubleArray5[1] = doubleArray2;
      doubleArray5[2] = doubleArray3;
      doubleArray5[3] = doubleArray3;
      doubleArray5[4] = doubleArray3;
      doubleArray0[1] = doubleArray5;
      double[][] doubleArray6 = new double[4][0];
      doubleArray6[0] = doubleArray2;
      doubleArray6[1] = doubleArray3;
      doubleArray6[2] = doubleArray3;
      doubleArray6[3] = doubleArray4;
      doubleArray0[2] = doubleArray6;
      double[][] doubleArray7 = new double[9][5];
      doubleArray7[0] = doubleArray4;
      doubleArray7[1] = doubleArray3;
      doubleArray7[2] = doubleArray2;
      doubleArray7[3] = doubleArray3;
      doubleArray7[4] = doubleArray2;
      doubleArray7[5] = doubleArray3;
      doubleArray7[6] = doubleArray3;
      doubleArray7[7] = doubleArray4;
      doubleArray7[8] = doubleArray3;
      doubleArray0[3] = doubleArray7;
      double[][] doubleArray8 = new double[4][1];
      doubleArray8[0] = doubleArray2;
      double[] doubleArray9 = new double[1];
      doubleArray9[0] = (-4656.02171462933);
      doubleArray8[1] = doubleArray9;
      doubleArray8[2] = doubleArray3;
      double[] doubleArray10 = new double[5];
      doubleArray10[0] = 1311.6985;
      doubleArray10[1] = 0.0;
      doubleArray10[2] = (double) 100;
      doubleArray10[3] = (double) 100;
      doubleArray10[4] = (double) 100;
      doubleArray8[3] = doubleArray10;
      doubleArray0[4] = doubleArray8;
      threeDimensionalMap0.put("e^sQ{S(X(}1(Ik#", "G.", "j*w|(HxJiqN,Wh", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 6 out of bounds for length 6
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(" =| ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode(" =| ", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][2][1];
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.countOriginalStates();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4a16L=WC:9R(.Kn_");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@4a16L=WC:9R(.Kn_", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][5][1];
      double[][] doubleArray2 = new double[2][6];
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(" | ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode(" | ", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][1][1];
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("slip");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("slip", list0);
      Double double0 = new Double(111.09570326083357);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("O8_w0Xse%8Zv7", (Integer) 100, double0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.recountInside(tree1, true, 100, identityHashMap0);
      splittingGrammarExtractor0.recurseOutside(tree1, identityHashMap0, identityHashMap0);
      splittingGrammarExtractor0.outputBetas();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, false, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 111.09570326083357;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 101;
      doubleArray0[4] = (double) 101;
      doubleArray0[5] = (double) 101;
      doubleArray0[6] = 111.09570326083357;
      MapFactory<Triple<String, String, Object>, List<String>> mapFactory0 = MapFactory.hashMapFactory();
      IdentityHashMap<String, int[]> identityHashMap4 = new IdentityHashMap<String, int[]>();
      Map<String, int[]> map0 = mapFactory0.setMap(identityHashMap4, 100);
      splittingGrammarExtractor0.mergeTransitions(tree1, identityHashMap2, identityHashMap3, (IdentityHashMap<Tree, double[][]>) null, identityHashMap3, doubleArray0, map0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("_%=)!", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[4];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray1 = new double[1][1][1];
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree1, identityHashMap2, identityHashMap2, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4a16L=WC:9R(.Kn_");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@4a16L=WC:9R(.Kn_", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][5][1];
      double[][] doubleArray2 = new double[2][6];
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputTransitions(tree0, 3371, identityHashMap0, identityHashMap1);
      HashSet<Tree> hashSet0 = new HashSet<Tree>();
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree1, identityHashMap2, identityHashMap2, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndOutputBetasAndUseNewBetas0()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      double[][] doubleArray0 = new double[1][0];
      double[] doubleArray1 = new double[7];
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = (double) 100;
      doubleArray1[4] = 0.0;
      doubleArray1[5] = (double) 100;
      doubleArray1[6] = (double) 100;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("ssplit", "(d`^!Pf{b0:dbW\"8", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4a16Y=WC9R(.Kn_'");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      labeledScoredTreeFactory0.newTreeNode("@4a16Y=WC9R(.Kn_'", list0);
      Double double0 = new Double(0.0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      TwoDimensionalMap.identityHashMap();
      options0.rerankerKBest = 37669027;
      double[][] doubleArray0 = new double[1][1];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = 0.0;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("G", "Z(B]m", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      double[] doubleArray0 = new double[7];
      options0.baseParserWeight = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 100.0;
      doubleArray0[4] = 100.0;
      doubleArray0[5] = 100.0;
      doubleArray0[6] = (double) 100;
      splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode0, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, doubleArray0, identityHashMap3);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<LinkedList<Object>, CoreLabel> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap4 = new IdentityHashMap<String, double[]>();
      mapFactory0.setMap(identityHashMap4, 1269275176);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.memoryTreebank();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("", (List<Tree>) memoryTreebank0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 0, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap4, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, 3337, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC`9R(.En_'");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(labeledWord0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.testMemoryTreebank();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      IntTaggedWord intTaggedWord0 = BaseLexicon.NULL_ITW;
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = intTaggedWord0.toTaggedWord(hashIndex0, hashIndex0);
      LabelFactory labelFactory0 = taggedWord0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("@04a16Y=WC`9R(.En_'", "@04a16Y=WC`9R(.En_'");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[3];
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor1.mergeTransitions(treeGraphNode0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, identityHashMap2);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<LinkedList<Object>, CoreLabel> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap3, 100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, map0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndSplitBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4a16L=WC9R(.Kn_");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      labeledScoredTreeFactory0.newTreeNode("@4a16L=WC9R(.Kn_", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      double[][] doubleArray1 = new double[5][7];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[3] = doubleArray0;
      doubleArray1[4] = doubleArray0;
      twoDimensionalMap0.put("@4a16L=WC9R(.Kn_", "ssplit", doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[][] doubleArray0 = new double[9][3];
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.put("2u,JF", "2u,JF", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][0];
      twoDimensionalMap0.put("Ro*~]1", "Ro*~]1", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recalculateBetas(true);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray1 = new double[6][7];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[3] = doubleArray0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      doubleArray1[4] = doubleArray0;
      doubleArray1[5] = doubleArray0;
      twoDimensionalMap0.put("&sup1;", ".$$.", doubleArray1);
      double[][] doubleArray2 = new double[2][5];
      twoDimensionalMap0.spliterator();
      doubleArray2[0] = doubleArray0;
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][5];
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      Stack<String> stack0 = new Stack<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) stack0;
      double[][] doubleArray0 = new double[3][0];
      twoDimensionalMap0.put(" =| ", "W5{KF]2k7v4qg^", doubleArray0);
      stack0.add(" =| ");
      splittingGrammarExtractor0.splitBetas();
      int int0 = splittingGrammarExtractor0.getStateSplitCount(" =| ");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[0][8];
      twoDimensionalMap0.put("0t>H\"ddu<6h4KoM", "0t>H\"ddu<6h4KoM", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndSplitBetasAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4a16Y=WC9R(.Kn_'");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@4a16Y=WC9R(.Kn_'", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray1 = new double[1][5][1];
      double[][] doubleArray2 = new double[3][6];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.splitBetas();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertNotSame(splittingGrammarExtractor2, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testUseNewBetas0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4a16L=WC9R(.Kn_");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      labeledScoredTreeFactory0.newTreeNode("@4a16L=WC9R(.Kn_", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      double[][] doubleArray1 = new double[5][7];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[3] = doubleArray0;
      doubleArray1[4] = doubleArray0;
      twoDimensionalMap0.put("@4a16L=WC9R(.Kn_", "ssplit", doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean1 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[4][5];
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndCountOriginalStates()  throws Throwable  {
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.memoryTreebank();
      englishTreebankParserParams0.memoryTreebank();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      double[][] doubleArray0 = new double[2][8];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = Double.NEGATIVE_INFINITY;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[5];
      doubleArray2[0] = Double.NEGATIVE_INFINITY;
      doubleArray2[1] = Double.NEGATIVE_INFINITY;
      doubleArray2[2] = Double.NEGATIVE_INFINITY;
      doubleArray2[3] = 707.7;
      doubleArray2[4] = Double.NEGATIVE_INFINITY;
      doubleArray0[1] = doubleArray2;
      twoDimensionalMap0.put("2u,JF", "2u,JF", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndGetStateSplitCountTakingTree()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC`9R(.Kn_'");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(labeledWord0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.testMemoryTreebank();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      IntTaggedWord intTaggedWord0 = BaseLexicon.NULL_ITW;
      HashIndex<String> hashIndex0 = new HashIndex<String>(100);
      TaggedWord taggedWord0 = intTaggedWord0.toTaggedWord(hashIndex0, hashIndex0);
      taggedWord0.labelFactory();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[1][1][1];
      double[][] doubleArray1 = new double[2][2];
      double[] doubleArray2 = new double[3];
      doubleArray2[0] = (-4127.1);
      doubleArray2[1] = 0.0;
      doubleArray2[2] = 0.0;
      doubleArray1[0] = doubleArray2;
      doubleArray1[1] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("@04a16Y=WC`9R(.Kn_'", "@04a16Y=WC`9R(.Kn_'", "azyx^|,4BT+", doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount((Tree) treeGraphNode0);
      assertEquals(0, int0);
      
      splittingGrammarExtractor0.outputBetas();
      int int1 = splittingGrammarExtractor0.getStateSplitCount((Tree) treeGraphNode0);
      assertEquals(0, int1);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4a16L=WC:9R(.Kn_");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@4a16L=WC:9R(.Kn_", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][5][1];
      double[][] doubleArray2 = new double[2][6];
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningNegative()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("slip", list0);
      Double double0 = new Double(111.09570326083357);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("O8_w0X9se@%8Zv7", (Integer) 100, double0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0);
      LabeledScoredTreeNode labeledScoredTreeNode1 = new LabeledScoredTreeNode(treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, true, (-3595), identityHashMap1);
      assertEquals((-3594), int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4a16Y=WC9R(.Kn_'");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@4a16Y=WC9R(.Kn_'", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray1 = new double[1][5][1];
      double[][] doubleArray2 = new double[3][6];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputTransitions(tree0, 3371, identityHashMap0, identityHashMap1);
      HashSet<Tree> hashSet0 = new HashSet<Tree>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndRecountInsideAndRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC`9R(.Kn_'");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(labeledWord0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.testMemoryTreebank();
      englishTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("@04a16Y=WC`9R(.Kn_'", list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Double double0 = new Double(7.5);
      Integer integer0 = new Integer(100);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("O8_w0X9se@%8Zv7", integer0, (Double) null);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      Options options1 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      Tree tree1 = treeGraphNode0.upperMostUnary(tree0);
      splittingGrammarExtractor0.recountInside(tree1, false, 977, identityHashMap1);
      splittingGrammarExtractor0.recurseOutside(tree1, identityHashMap1, identityHashMap1);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsAndRecountOutsideTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC9R(.Kn_'");
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@04a16Y=WC9R(.Kn_'");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@04a16Y=WC9R(.Kn_'", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray1 = new double[1][5][1];
      double[][] doubleArray2 = new double[3][6];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tree1);
      Tree tree2 = englishTreebankParserParams0.transformTree(labeledScoredTreeNode0, tree1);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree2, tree0, identityHashMap2, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("{@P}H(#");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("{@P}H(#", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[7];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][1][1];
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree1, tree0, identityHashMap2, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("Iteration ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((Label) tree0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(85);
      double[] doubleArray0 = new double[0];
      identityHashMap1.put("Iteration ", doubleArray0);
      MapFactory<String, List<Object>> mapFactory0 = MapFactory.arrayMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap1);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects(tree1, (Map<String, double[]>) identityHashMap1, map0, identityHashMap2, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4Arguments0()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC`9R(.En_'");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(labeledWord0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.testMemoryTreebank();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      IntTaggedWord intTaggedWord0 = BaseLexicon.NULL_ITW;
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = intTaggedWord0.toTaggedWord(hashIndex0, hashIndex0);
      LabelFactory labelFactory0 = taggedWord0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("@04a16Y=WC`9R(.En_'", "@04a16Y=WC`9R(.En_'");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      splittingGrammarExtractor1.recalculateBetas(false);
      Random.setNextRandom(100);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap5 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<String, int[]> identityHashMap6 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap7 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap8 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode0, identityHashMap7, identityHashMap8, identityHashMap7, identityHashMap4, doubleArray0, identityHashMap6);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<LinkedList<Object>, CoreLabel> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap9 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap9, 1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      Tree tree1 = treeGraphNode0.skipRoot();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 1, identityHashMap3, identityHashMap4, map0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 1, identityHashMap3, identityHashMap4);
      assertNotSame(identityHashMap3, identityHashMap7);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRescaleTemporaryBetas1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("y =| ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("y =| ", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][1][1];
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException1()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("c8>;}?j|]3JEA5", "c8>;}?j|]3JEA5");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("c8>;}?j|]3JEA5", list0);
      tree0.addChild((Tree) treeGraphNode0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndOutputTransitionsTaking4ArgumentsAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC9R(.Kn_'");
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@04a16Y=WC9R(.Kn_'");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@04a16Y=WC9R(.Kn_'", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray1 = new double[1][5][1];
      double[][] doubleArray2 = new double[3][6];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputTransitions(tree0, 3371, identityHashMap0, identityHashMap1);
      HashSet<Tree> hashSet0 = new HashSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) hashSet0, (-910.938), (Collection<Tree>) hashSet0, 0.0);
      assertEquals(0, hashSet0.size());
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("|");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode(" =| ", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Stack<String> stack0 = new Stack<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) stack0;
      double[][][] doubleArray1 = new double[1][2][1];
      identityHashMap1.put(tree1, doubleArray1);
      twoDimensionalMap0.replaceAll((Function<double[][], ? extends double[][]>) null);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      stack0.add(" =| ");
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode(tree1, list0);
        fail("Expecting exception: ArrayStoreException");
      
      } catch(ArrayStoreException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerExceptionAndExtractTaking4ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      tree0.addChild((Tree) treeGraphNode0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list0, (double) 100, (Collection<Tree>) tree0, (double) 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningPositive()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("slip");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("slip", list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Double double0 = new Double(80.793538937048);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("O8_w0X9se@%8Zv7", (Integer) 100, double0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.recountInside(tree1, true, 100, identityHashMap1);
      Random.setNextRandom(74);
      splittingGrammarExtractor0.recurseOutside(tree1, identityHashMap1, identityHashMap1);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC`9R(.Kn_'");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(labeledWord0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.testMemoryTreebank();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      IntTaggedWord intTaggedWord0 = BaseLexicon.NULL_ITW;
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = intTaggedWord0.toTaggedWord(hashIndex0, hashIndex0);
      LabelFactory labelFactory0 = taggedWord0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(100);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap0, identityHashMap2);
      splittingGrammarExtractor0.outputBetas();
      Random.setNextRandom(100);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 610.63612998;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      IdentityHashMap<String, int[]> identityHashMap5 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap3, identityHashMap4, identityHashMap3, identityHashMap4, doubleArray0, identityHashMap5);
      assertEquals(0, identityHashMap3.size());
  }

  @Test(timeout = 4000)
  public void testMergeTransitions0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%O<!");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tree0, 100);
      labeledScoredTreeNode0.addChild(tree0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode0, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, (double[]) null, identityHashMap0);
      assertNotSame(labeledScoredTreeNode0, tree0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(" =| ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode(" =| ", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      identityHashMap0.put(" =| ", doubleArray0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("sl");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((Label) tree0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      int int0 = 3059;
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(3059);
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 3059;
      doubleArray0[1] = (double) 3059;
      doubleArray0[2] = (double) 3059;
      doubleArray0[3] = (double) 3059;
      identityHashMap1.put("sl", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree1, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("Iteration ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((Label) tree0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[10];
      identityHashMap0.put("Iteration ", doubleArray0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) hashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndUseNewBetasWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.remove("\" entity=\"", "\" entity=\"");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("\" entity=\"", "&p]iK5^_U");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC9R(.Kn_'");
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@04a16Y=WC9R(.Kn_'");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@04a16Y=WC9R(.Kn_'", list0);
      Integer integer0 = new Integer(100);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray1 = new double[1][5][1];
      double[][] doubleArray2 = new double[3][6];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      doubleArray2[2] = doubleArray0;
      doubleArray1[0] = doubleArray2;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputTransitions(tree1, 100, identityHashMap0, identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list0, 0.0, (Collection<Tree>) tree1, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Trees should have been binarized, expected 1 or 2 children
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndOutputTransitionsTaking4ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(" =| ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode(" =| ", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray0 = new double[1][2][1];
      identityHashMap1.put(tree1, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.outputTransitions(tree1, 100, identityHashMap0, identityHashMap1);
      assertFalse(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC9R(.Kn_'");
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@04a16Y=WC9R(.Kn_'");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@04a16Y=WC9R(.Kn_'", list0);
      Integer integer0 = new Integer(100);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[2] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray1 = new double[1][5][1];
      double[][] doubleArray2 = new double[3][6];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      doubleArray2[2] = doubleArray0;
      doubleArray1[0] = doubleArray2;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      Random.setNextRandom((-3519));
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecalculateTemporaryBetasTaking8ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(" | ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode(" | ", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>(100);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][2][1];
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(1, hashMap0.size());
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC`9R(.Kn_'");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(labeledWord0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      IntTaggedWord intTaggedWord0 = BaseLexicon.NULL_ITW;
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = intTaggedWord0.toTaggedWord(hashIndex0, hashIndex0);
      LabelFactory labelFactory0 = taggedWord0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("@04a16Y=WC`9R(.Kn_'", "@VPpart < (V < /(es|\u00E9s)$/)");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateBetas(false);
      Random.setNextRandom(100);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor1.mergeTransitions(treeGraphNode0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap1, doubleArray0, identityHashMap3);
      splittingGrammarExtractor0.recalculateBetas(false);
      Random.setNextRandom(Integer.MAX_VALUE);
      MapFactory<Object, Object> mapFactory0 = MapFactory.identityHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap4 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap4);
      splittingGrammarExtractor1.countMergeEffects(tree0, map0, (Map<String, double[]>) identityHashMap4);
      splittingGrammarExtractor1.countOriginalStates();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("Pre-spl&P5t betas", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0);
      assertEquals(Double.NaN, tree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideWithNullAndNull()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC`9R(.Kn_'");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(labeledWord0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.testMemoryTreebank();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      IntTaggedWord intTaggedWord0 = BaseLexicon.NULL_ITW;
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = intTaggedWord0.toTaggedWord(hashIndex0, hashIndex0);
      LabelFactory labelFactory0 = taggedWord0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("@VPpart < (V < /(es|\u00E9s)$/)", "@VPpart < (V < /(es|\u00E9s)$/)");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateBetas(false);
      Random.setNextRandom(100);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor1.mergeTransitions(treeGraphNode0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap1, doubleArray0, identityHashMap3);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<LinkedList<Object>, CoreLabel> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap4 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap4, 100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap2, identityHashMap1, map0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recurseOutside(treeGraphNode0, (IdentityHashMap<Tree, double[]>) null, (IdentityHashMap<Tree, double[]>) null);
      assertEquals(Double.NaN, treeGraphNode0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC`9R(.Kn_'");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(labeledWord0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.testMemoryTreebank();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      IntTaggedWord intTaggedWord0 = BaseLexicon.NULL_ITW;
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = intTaggedWord0.toTaggedWord(hashIndex0, hashIndex0);
      LabelFactory labelFactory0 = taggedWord0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(100);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap0, identityHashMap2);
      splittingGrammarExtractor0.outputBetas();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) treeGraphNode0, 1.0E16);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithZero0()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("@04aG6Y=WC`9R(.KPn|'", "@04aG6Y=WC`9R(.KPn|'", "@04aG6Y=WC`9R(.KPn|'");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) treeGraphNode0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsAndRecountTreeTaking6ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC`9R(.Kn_'");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("@04a16Y=WC`9R(.Kn_'", "@04a16Y=WC`9R(.Kn_'", "@04a16Y=WC`9R(.Kn_'");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.testMemoryTreebank();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      IntTaggedWord intTaggedWord0 = BaseLexicon.NULL_ITW;
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = intTaggedWord0.toTaggedWord(hashIndex0, hashIndex0);
      LabelFactory labelFactory0 = taggedWord0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(100);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap0, identityHashMap2);
      splittingGrammarExtractor0.outputBetas();
      Integer integer0 = new Integer(100);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("I[1|?X&h%-V", integer0, (Double) null);
      ArrayList<Label> arrayList0 = treeGraphNode0.yield();
      treeGraphNode0.yield(arrayList0);
      labelFactory0.newLabelFromString("G,i1f~07kp{=(6Hp'4|");
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, false, 100, false, (HeadFinder) null);
      Tree tree0 = treeGraphNode0.transform((TreeTransformer) nPTmpRetainingTreeNormalizer0, (TreeFactory) labeledScoredTreeFactory0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap5 = new IdentityHashMap<Tree, double[][]>();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<double[][][], CoreLabel.GenericAnnotation<Object>> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      MapFactory<CoreLabel.GenericAnnotation<Object>, double[][][]> mapFactory1 = MapFactory.arrayMapFactory();
      Map<SimpleTree, double[][][]> map0 = mapFactory1.setMap(null);
      Map<SimpleTree, double[][][]> map1 = mapFactory0.setMap(map0, 100);
      IdentityHashMap<Tree, double[][][]> identityHashMap6 = new IdentityHashMap<Tree, double[][][]>(map1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) treeGraphNode1, true, identityHashMap3, identityHashMap4, identityHashMap5, identityHashMap6);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC`9R(.Kn_'");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(labeledWord0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.testMemoryTreebank();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      IntTaggedWord intTaggedWord0 = BaseLexicon.NULL_ITW;
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = intTaggedWord0.toTaggedWord(hashIndex0, hashIndex0);
      LabelFactory labelFactory0 = taggedWord0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(100);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap0, identityHashMap2);
      splittingGrammarExtractor0.outputBetas();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 2390, identityHashMap4, identityHashMap5);
      assertTrue(identityHashMap4.isEmpty());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC`9R(.Kn_'");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("@04a16Y=WC`9R(.Kn_'", "@04a16Y=WC`9R(.Kn_'", "@04a16Y=WC`9R(.Kn_'");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.testMemoryTreebank();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      IntTaggedWord intTaggedWord0 = BaseLexicon.NULL_ITW;
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = intTaggedWord0.toTaggedWord(hashIndex0, hashIndex0);
      LabelFactory labelFactory0 = taggedWord0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(100);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap0, identityHashMap2);
      splittingGrammarExtractor0.outputBetas();
      Integer integer0 = new Integer(100);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("I[1|?X&h%-V", integer0, (Double) null);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recurseOutside(treeGraphNode0, identityHashMap3, identityHashMap3);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) tree0, (-4058.94495), (Collection<Tree>) list0, (-3807.671114767663));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      Double double0 = new Double(100);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("#U!e9DpchgBEB?qoI\"o", (Integer) 100, double0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple0, triple0, triple0);
      splittingGrammarExtractor0.buildMergeCorrespondence(list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.testMemoryTreebank();
      List<Tree> list1 = treeGraphNode0.getLeaves(memoryTreebank0);
      SimpleTree simpleTree0 = new SimpleTree(wordLemmaTag0, list1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 77, identityHashMap0, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.get("4p)7%v\")-RZX");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      Random.setNextRandom(100);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      List<Tree> list0 = List.of(treeGraphNode0, treeGraphNode0, treeGraphNode0, treeGraphNode0, treeGraphNode0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((String) null, list0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Double double0 = new Double(100);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("discoloring", (Integer) 100, double0);
      Double double1 = new Double(1.0E-4);
      Integer integer0 = new Integer(100);
      Double double2 = new Double(100);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, (-1209), identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf((String) null);
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((String) null, list0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.outputTransitions(tree1, 83, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4Arguments1()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap1, identityHashMap0);
      assertEquals(Double.NaN, tree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInsideWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, false, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("@04a16Y=WC`9R(.Kn_'");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(labeledWord0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.testMemoryTreebank();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      IntTaggedWord intTaggedWord0 = BaseLexicon.NULL_ITW;
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = intTaggedWord0.toTaggedWord(hashIndex0, hashIndex0);
      LabelFactory labelFactory0 = taggedWord0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(100);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap0, identityHashMap2);
      splittingGrammarExtractor0.outputBetas();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recountTree(tree0, false, identityHashMap3, (IdentityHashMap<Tree, double[][][]>) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndRecurseOutside1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.remove("LVP=l=VBi", "LVP=l=VBi");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("slip");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("LVP=l=VBi", list0);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("discoloring", (Integer) 100, (Double) 0.0);
      Double double0 = new Double(0.0);
      Triple<String, Integer, Double> triple1 = new Triple<String, Integer, Double>("discoloring", (Integer) 100, (Double) 0.0);
      triple0.compareTo(triple1);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(tree1, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      List<Tree> list0 = List.of(labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("Il.r", list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecalculateTemporaryBetasTaking4ArgumentsAndRecalculateBetasWithFalse()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.remove("LVP=l=VBi", "LVP=l=VBi");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) identityHashMap0, twoDimensionalMap1, threeDimensionalMap0);
      assertNotSame(threeDimensionalMap0, threeDimensionalMap2);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.remove(",", ",");
      splittingGrammarExtractor0.recalculateBetas(false);
      Random.setNextRandom(100);
  }

  @Test(timeout = 4000)
  public void testOutputBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.remove(",", ",");
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("slip");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("slip", list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>(" iterations", (Integer) 100, (Double) 0.0);
      Double double0 = new Double(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      MapFactory<String, LinkedList<String>> mapFactory0 = MapFactory.arrayMapFactory();
      MapFactory<Language, String> mapFactory1 = MapFactory.weakHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(989);
      Map<String, double[]> map0 = mapFactory1.setMap(identityHashMap1, 100);
      mapFactory0.setMap(map0);
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 989;
      doubleArray0[1] = (-2970.554);
      doubleArray0[2] = (double) 1651;
      doubleArray0[3] = (double) 354;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 0, identityHashMap2, identityHashMap0, map0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeExceptionAndRecountInsideWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.remove("LVP=l=VBi", "LVP=l=VBi");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("slip");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("LVP=l=VBi", list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("discoloring", (Integer) 100, (Double) 0.0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree1, false, 100, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetas3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.remove(",", ",");
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("Iteration ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((Label) tree0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(85);
      double[] doubleArray0 = new double[0];
      identityHashMap1.put("Iteration ", doubleArray0);
      MapFactory.arrayMapFactory();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.hashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.weakHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 1, identityHashMap3, identityHashMap4, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(" =| ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode(" =| ", list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.remove("LVP=l=VBi", "LVP=l=VBi");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("slip");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("LVP=l=VBi", list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("discoloring", (Integer) 100, (Double) 0.0);
      Double double0 = new Double(0.0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      MapFactory<String, LinkedList<String>> mapFactory0 = MapFactory.arrayMapFactory();
      MapFactory<Language, String> mapFactory1 = MapFactory.weakHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>(100);
      int int0 = 354;
      Map<String, double[]> map0 = mapFactory1.setMap(identityHashMap3, 354);
      Map<String, double[]> map1 = mapFactory0.setMap(map0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 1651, identityHashMap1, identityHashMap2, map1, twoDimensionalMap1, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException4()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_%=)!");
      double[] doubleArray0 = new double[2];
      tree0.addChild(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithNegative0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("Iteration ");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((Label) tree0, list0);
      labeledScoredTreeFactory0.newLeaf(">");
      List<Tree> list1 = List.of(tree1, tree1, tree0, tree0, tree1);
      List.of(tree0, tree1, tree1, tree0, tree1);
      Tree tree2 = labeledScoredTreeFactory0.newTreeNode("Iteration ", list1);
      Integer integer0 = new Integer(252);
      Double double0 = Double.valueOf((double) 100);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("0*0dOGQ;Ezz9", integer0, double0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list0, (-100.0), (Collection<Tree>) tree2, 912.2783452);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Trees should have been binarized, expected 1 or 2 children
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithZero1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.remove("LVP=l=VBi", "LVP=l=VBi");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("slip");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("LVP=l=VBi", list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("discoloring", (Integer) 100, (Double) 0.0);
      Double double0 = new Double(0.0);
      Triple<String, Integer, Double> triple1 = new Triple<String, Integer, Double>("discoloring", (Integer) 100, (Double) 0.0);
      triple0.compareTo(triple1);
      Triple<String, Integer, Double> triple2 = Triple.makeTriple("LVP=l=VBi", 100, double0);
      List.of(triple0, triple0, triple2);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree1, (double) 0, (Collection<Tree>) tree1, 2107.358529915565);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Trees should have been binarized, expected 1 or 2 children
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      List<Tree> list0 = List.of(labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((String) null, list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (double) 100, (Collection<Tree>) list0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Trees should have been binarized, expected 1 or 2 children
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsNullPointerException()  throws Throwable  {
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.put("]m", "]m", (double[][]) null);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.remove("LVP=l=VBi", "LVP=l=VBi");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("slip");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("LVP=l=VBi", list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("discoloring", (Integer) 100, (Double) 0.0);
      Double double0 = new Double(0.0);
      Triple<String, Integer, Double> triple1 = Triple.makeTriple("LVP=l=VBi", 100, double0);
      tree1.getChildrenAsList();
      List<Triple<String, Integer, Double>> list1 = List.of(triple0, triple0, triple1);
      splittingGrammarExtractor0.buildMergeCorrespondence(list1);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree(tree1, false, identityHashMap3, identityHashMap4);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      List<Tree> list0 = List.of(labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((String) null, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree0, true, 776, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.remove("LVP=l=VBi", "LVP=l=VBi");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("slip");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("LVP=l=VBi", list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("discoloring", (Integer) 100, (Double) 0.0);
      Double double0 = new Double(0.0);
      Triple<String, Integer, Double> triple1 = Triple.makeTriple("LVP=l=VBi", 100, double0);
      List<Triple<String, Integer, Double>> list1 = List.of(triple0, triple0, triple1);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(list1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree1, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, doubleArray0, map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf((String) null);
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((String) null, list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree1, identityHashMap2, identityHashMap0, identityHashMap2, identityHashMap0, (double[]) null, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitionsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      labeledScoredTreeNode0.addChild((Tree) labeledScoredTreeNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode0, identityHashMap0, identityHashMap2, identityHashMap0, identityHashMap2, (double[]) null, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecountWeights1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.remove("LVP=l=VBi", "LVP=l=VBi");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("slip");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("LVP=l=VBi", list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree1, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecountWeightsWithNullAndRecountWeightsWithNull0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      List<Tree> list0 = List.of(labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0);
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Tree tree0 = simpleTreeFactory0.newTreeNode(" MB/+hP70lC+Yd=:L", list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, (IdentityHashMap<Tree, double[]>) null, (IdentityHashMap<Tree, double[]>) null, identityHashMap1, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecountWeightsWithNullAndRecountWeightsWithNull1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      labeledScoredTreeNode0.addChild((Tree) labeledScoredTreeNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(labeledScoredTreeNode0, (IdentityHashMap<Tree, double[]>) null, (IdentityHashMap<Tree, double[]>) null, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashSet<String> hashSet0 = new HashSet<String>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      String string0 = "A%l>+Zm52";
      threeDimensionalMap0.get("C'pK", "A%l>+Zm52");
      splittingGrammarExtractor0.mergeStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[0][7];
      twoDimensionalMap0.put("C'pK", "LEXICON", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasThrowsNullPointerException()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledWord labeledWord0 = new LabeledWord("N=i%1*6P<!q+_A?F=ch");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(labeledWord0);
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.testMemoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) wordLemmaTag0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerExceptionAndBuildMergeCorrespondenceWithNonEmptyList0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Integer integer0 = new Integer((-608));
      Double double0 = new Double(0.0);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("F%;B@I<F2kO", integer0, double0);
      vector0.add(triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.trainSize = (double) 100;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Set<String> set0 = options0.trainOptions.deleteSplitters;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      threeDimensionalMap1.get("O8_w0Xse@%8Zv7", "O8_w0Xse@%8Zv7");
      TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap3 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor1.outputBetas();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndRecalculateTemporaryBetasTaking4ArgumentsAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("O8_w0Xse@%8Zv7", "");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.state("O8_w0Xse@%8Zv7", 100);
      Random.setNextRandom((-1073741824));
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Random.setNextRandom(100);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<Triple<CoreLabel, Object, Object>, String> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap1, (-1073741824));
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map0, twoDimensionalMap0, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceReturningFalse()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@4aL=WC:9R(.Kn_");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode("@4aL=WC:9R(.Kn_", list0);
      Double double0 = new Double(0.0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[10];
      doubleArray0[3] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][][] doubleArray1 = new double[1][5][1];
      double[][] doubleArray2 = new double[2][6];
      doubleArray2[1] = doubleArray0;
      identityHashMap1.put(tree1, doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputTransitions(tree0, 3371, identityHashMap0, identityHashMap1);
      HashSet<Tree> hashSet0 = new HashSet<Tree>();
      splittingGrammarExtractor0.splitBetas();
      threeDimensionalMap0.put("BMGv", "YeJM", "G", (double[][][]) null);
      boolean boolean1 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.state("]Rgdy%j", 100);
      Random.setNextRandom(100);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("]Rgdy%j");
      CoreLabel coreLabel1 = new CoreLabel(coreLabel0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel1);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode1.treeSkeletonCopy();
      splittingGrammarExtractor1.recountOutside(tree0, identityHashMap0, identityHashMap0);
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Set<String> set0 = options0.trainOptions.deleteSplitters;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      threeDimensionalMap0.get((String) null);
      threeDimensionalMap1.get("O8_w0Xse@%8Zv7", "O8_w0Xse@%8Zv7");
      TwoDimensionalMap.identityHashMap();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor1.splitBetas();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeException1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (double) 100, (Collection<Tree>) tree0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments4()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      List<Tree> list0 = treeGraphNode0.getLeaves();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      List<Tree> list0 = List.of(labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("    ", list0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetas1()  throws Throwable  {
      Options options0 = new Options();
      options0.trainOptions = options0.trainOptions;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("*UNK*", "*UNK*");
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      hebrewTreebankParserParams0.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      splittingGrammarExtractor0.saveTrees(labeledScoredTreeNode0, 0.0, labeledScoredTreeNode0, (-108.9));
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(false);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecalculateTemporaryBetasTaking4ArgumentsAndRecalculateBetasWithTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.remove("LVP=l=VBi", "LVP=l=VBi");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("LVP=l=VBi", "&p]iK5^_U");
      splittingGrammarExtractor0.recalculateBetas(true);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap2);
      assertNotSame(threeDimensionalMap2, threeDimensionalMap1);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("aHA", "aHA");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
      
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      labeledScoredTreeNode0.indexSpans();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.saveTrees(labeledScoredTreeNode0, 0.0, (Collection<Tree>) null, 0.0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(identityHashMap1);
      MapFactory<Triple<Object, Object, CoreLabel>, Object> mapFactory0 = MapFactory.hashMapFactory();
      mapFactory0.setMap(hashMap0, 2722);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      assertFalse(map0.isEmpty());
      assertEquals(1, map0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      assertEquals(0, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      options0.forceCNF = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      splittingGrammarExtractor0.unaryBetas = twoDimensionalMap1;
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.buildStateIndex();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.state("_<8MeSa", 451);
      Random.setNextRandom((-1771));
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      assertTrue(hashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerExceptionAndBuildMergeCorrespondence0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Integer integer0 = new Integer(59);
      Double double0 = new Double((-1318.45));
      Integer integer1 = new Integer((-1260));
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("(wzo(K0sJ8bX", integer1, double0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      arrayList0.add(triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndRescaleTemporaryBetas()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Double double0 = new Double(0.1);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("QI", 100, double0);
      arrayList0.add(triple0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.remove("}1", "}1");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertNotSame(twoDimensionalMap0, twoDimensionalMap1);
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerExceptionAndBuildMergeCorrespondenceWithNonEmptyList1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("&lt;", (Integer) null, (Double) 0.0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple0, triple0, triple0, triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceWithNonEmptyList()  throws Throwable  {
      Options options0 = new Options();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = Triple.makeTriple(null, 100, 0.0);
      linkedList0.add(triple0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(782);
      double[] doubleArray0 = new double[5];
      doubleArray0[1] = 1.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = (double) 100;
      MapFactory<CategoryWordTag, Object> mapFactory0 = MapFactory.identityHashMapFactory();
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      Map<String, int[]> map1 = mapFactory0.setMap(map0, 100);
      splittingGrammarExtractor1.mergeTransitions(treeGraphNode0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, map1);
      splittingGrammarExtractor0.getStateSplitCount((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      int int0 = splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, (-1716), identityHashMap0, identityHashMap2, (Map<String, double[]>) hashMap0, twoDimensionalMap1, threeDimensionalMap0);
      assertEquals((-1716), int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      options0.forceCNF = true;
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      Tree tree0 = hebrewTreebankParserParams0.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Random.setNextRandom(3635);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(782);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[0];
      splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap1, doubleArray0, (Map<String, int[]>) null);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsAndRecountTreeTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = (double) 66;
      doubleArray1[1] = (double) 100;
      splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray1, 66, identityHashMap2, identityHashMap1, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      TreeFactory treeFactory0 = LabeledScoredTreeNode.factory();
      Tree tree0 = treeGraphNode0.treeSkeletonCopy(treeFactory0);
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap2, identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree(tree0, false, identityHashMap2, identityHashMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsAndGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTagFactory categoryWordTagFactory0 = new CategoryWordTagFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(categoryWordTagFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("[0j)C");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
      int int0 = splittingGrammarExtractor0.getStateSplitCount("[0j)C");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNullAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      Tree tree0 = hebrewTreebankParserParams0.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Random.setNextRandom(100);
      TwoDimensionalMap.treeMap();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(782);
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, (Map<String, int[]>) null);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testMergeTransitions1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode0, identityHashMap0, identityHashMap2, identityHashMap0, identityHashMap2, (double[]) null, identityHashMap1);
      assertEquals(Double.NaN, labeledScoredTreeNode0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndBuildStateIndexAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory.identityHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.buildStateIndex();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      splittingGrammarExtractor2.extract((Collection<Tree>) linkedList0);
      assertEquals(0, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testUseNewBetas1()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.secondKeySet();
      threeDimensionalMap0.get("O8_w0Xse@%8Zv7", "O8_w0Xse@%8Zv7");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode((Label) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndState()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      HebrewTreebankParserParams hebrewTreebankParserParams1 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode((Label) null);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(".$$.");
      MemoryTreebank memoryTreebank0 = hebrewTreebankParserParams1.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, memoryTreebank0);
      hebrewTreebankParserParams1.transformTree(tree0, labeledScoredTreeNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(".$$.", 100);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, (-210), identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testState0()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = splittingGrammarExtractor0.state(".$$.", 780);
      assertEquals(".$$.", string0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNullAndMergeTransitionsThrowsNullPointerException()  throws Throwable  {
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Options options0 = new Options(negraPennTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) 100;
      doubleArray0[7] = (double) 100;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions((Tree) null, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap1, doubleArray0, (Map<String, int[]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testDEBUGAndDEBUG()  throws Throwable  {
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "K/oBafooMozXzQ");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      BiFunction<Object, Object, double[]> biFunction0 = (BiFunction<Object, Object, double[]>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      identityHashMap0.computeIfPresent((Tree) null, biFunction0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.recalculateBetas(false);
      splittingGrammarExtractor0.recurseOutside(labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedHashSet<Tree> linkedHashSet0 = new LinkedHashSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) linkedHashSet0, 0.0, (Collection<Tree>) linkedHashSet0, (-1.0));
      assertTrue(linkedHashSet0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideAndRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      List<Tree> list0 = treeGraphNode0.getLeaves();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap1, identityHashMap1);
      assertEquals(0, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesAndRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      assertEquals(Double.NaN, labeledScoredTreeNode0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testMergeStates()  throws Throwable  {
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "K/oBafooMozXzQ");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.recalculateBetas(false);
      splittingGrammarExtractor0.recurseOutside(labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      Tree tree0 = hebrewTreebankParserParams0.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Random.setNextRandom(100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecalculateTemporaryBetasTaking8ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[1];
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, doubleArray0, 787, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(787, int0);
  }

  @Test(timeout = 4000)
  public void testSaveTrees()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      pennTreebankLanguagePack0.treeTokenizerFactory();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams1 = new HebrewTreebankParserParams();
      HebrewTreebankParserParams hebrewTreebankParserParams2 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("wqLRqfuS[MkN'Q^");
      MemoryTreebank memoryTreebank0 = hebrewTreebankParserParams1.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0, memoryTreebank0);
      Tree tree1 = hebrewTreebankParserParams1.transformTree(treeGraphNode0, tree0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.state("RB", (-210));
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree1, (-210), identityHashMap1, identityHashMap2);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, memoryTreebank0);
      Tree tree2 = treeGraphNode1.skipRoot();
      splittingGrammarExtractor0.getStateSplitCount(tree2);
      splittingGrammarExtractor0.saveTrees(tree1, 3190.03426, tree2, 100);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree1, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTree()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      Tree tree0 = null;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<Triple<Object, SplittingGrammarExtractor, Object>, SplittingGrammarExtractor> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory.treeMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      mapFactory0.setMap(hashMap0);
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap1);
      mapFactory0.setMap(map0);
      TwoDimensionalMap.treeMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerException()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      pennTreebankLanguagePack0.treeTokenizerFactory();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams1 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      Tree tree0 = hebrewTreebankParserParams1.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.state("pp", 2);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 685, identityHashMap2, (IdentityHashMap<Tree, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      threeDimensionalMap0.get("ancestor: height cannot be negative", "ancestor: height cannot be negative");
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.buildMergeCorrespondence((List<Triple<String, Integer, Double>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsRuntimeException()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      pennTreebankLanguagePack0.treeTokenizerFactory();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams1 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      Tree tree0 = hebrewTreebankParserParams1.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      hebrewTreebankParserParams0.diskTreebank();
      splittingGrammarExtractor0.state("pp", 2);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, 0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceReturningMapWhereIsEmptyIsFalse()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("_=)!");
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("_=)!");
      tree0.addChild(tree1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(identityHashMap1);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      assertFalse(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      splittingGrammarExtractor0.buildStateIndex();
      String string0 = splittingGrammarExtractor0.state("", 66);
      assertEquals("^66", string0);
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceWithEmptyList()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerExceptionAndBuildMergeCorrespondence1()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      pennTreebankLanguagePack0.treeTokenizerFactory();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams1 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      Tree tree0 = hebrewTreebankParserParams1.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.state("pp", 2);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 685, identityHashMap2, (IdentityHashMap<Tree, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.buildMergeCorrespondence((List<Triple<String, Integer, Double>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      pennTreebankLanguagePack0.treeTokenizerFactory();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams1 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      hebrewTreebankParserParams1.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.state("pp", 2);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, 0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(hashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringAndGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.arrayMapFactory();
      MapFactory.hashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      DiskTreebank diskTreebank0 = negraPennTreebankParserParams0.diskTreebank();
      negraPennTreebankParserParams0.setOutputEncoding(" iterations");
      splittingGrammarExtractor0.extract((Collection<Tree>) diskTreebank0, (double) 100, (Collection<Tree>) diskTreebank0, (double) 100);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.outputBetas();
      System.setCurrentTimeMillis(50L);
      int int0 = splittingGrammarExtractor0.getStateSplitCount(" iterations");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount("3DtX.1L~=G|W");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[8][8];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      splittingGrammarExtractor0.recountWeights(labeledScoredTreeNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      splittingGrammarExtractor0.recountWeights(labeledScoredTreeNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      assertTrue(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[6][9][7];
      double[][] doubleArray1 = new double[6][0];
      double[] doubleArray2 = new double[8];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = 0.0;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      doubleArray2[4] = (double) 100;
      doubleArray2[5] = 0.0;
      doubleArray2[6] = (double) 100;
      doubleArray2[7] = 0.0;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[0];
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[2];
      doubleArray4[0] = (double) 100;
      doubleArray4[1] = 0.0;
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[9];
      doubleArray5[0] = (double) 100;
      doubleArray5[1] = (-2904.6);
      doubleArray5[2] = (double) 100;
      doubleArray5[3] = 0.0;
      doubleArray5[4] = 0.0;
      doubleArray5[5] = 0.0;
      doubleArray5[6] = (double) 100;
      doubleArray5[7] = 0.0;
      doubleArray5[8] = 4389.302818463652;
      doubleArray1[3] = doubleArray5;
      double[] doubleArray6 = new double[7];
      doubleArray6[0] = 0.0;
      doubleArray6[1] = (-2705.72);
      doubleArray6[2] = 0.0;
      doubleArray6[3] = 0.0;
      doubleArray6[4] = 0.0;
      doubleArray6[5] = 4389.302818463652;
      doubleArray6[6] = 24.01409824083091;
      doubleArray1[4] = doubleArray6;
      double[] doubleArray7 = new double[0];
      doubleArray1[5] = doubleArray7;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray8 = new double[2][1];
      doubleArray8[0] = doubleArray7;
      doubleArray8[1] = doubleArray3;
      doubleArray0[1] = doubleArray8;
      double[][] doubleArray9 = new double[7][4];
      doubleArray9[0] = doubleArray4;
      doubleArray9[1] = doubleArray5;
      doubleArray9[2] = doubleArray3;
      doubleArray9[3] = doubleArray6;
      doubleArray9[4] = doubleArray2;
      doubleArray9[5] = doubleArray3;
      doubleArray9[6] = doubleArray7;
      doubleArray0[2] = doubleArray9;
      double[][] doubleArray10 = new double[0][7];
      doubleArray0[3] = doubleArray10;
      double[][] doubleArray11 = new double[9][9];
      doubleArray11[0] = doubleArray4;
      doubleArray11[1] = doubleArray2;
      doubleArray11[2] = doubleArray4;
      double[] doubleArray12 = new double[8];
      doubleArray12[0] = 24.01409824083091;
      doubleArray12[1] = 4389.302818463652;
      doubleArray12[2] = 24.01409824083091;
      doubleArray12[3] = (-2705.72);
      doubleArray12[4] = 175.9661;
      doubleArray12[5] = (double) 100;
      doubleArray12[6] = 24.01409824083091;
      doubleArray12[7] = 0.0;
      doubleArray11[3] = doubleArray12;
      doubleArray11[4] = doubleArray4;
      doubleArray11[5] = doubleArray5;
      doubleArray11[6] = doubleArray4;
      doubleArray11[7] = doubleArray4;
      double[] doubleArray13 = new double[9];
      doubleArray13[0] = 4389.302818463652;
      doubleArray13[1] = 0.0;
      doubleArray13[2] = 24.01409824083091;
      doubleArray13[3] = (-3498.977);
      doubleArray13[4] = 24.01409824083091;
      doubleArray13[5] = (-86.50532032941678);
      doubleArray13[6] = 0.0;
      doubleArray13[7] = 0.0;
      doubleArray13[8] = (-2904.6);
      doubleArray11[8] = doubleArray13;
      doubleArray0[4] = doubleArray11;
      double[][] doubleArray14 = new double[8][5];
      doubleArray14[0] = doubleArray13;
      doubleArray14[1] = doubleArray5;
      doubleArray14[2] = doubleArray2;
      doubleArray14[3] = doubleArray13;
      doubleArray14[4] = doubleArray2;
      doubleArray14[5] = doubleArray5;
      doubleArray14[6] = doubleArray3;
      doubleArray14[7] = doubleArray7;
      doubleArray0[5] = doubleArray14;
      identityHashMap1.put((Tree) null, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) null, true, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      ArrayDeque<Tree> arrayDeque0 = new ArrayDeque<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) arrayDeque0);
      assertTrue(arrayDeque0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeExceptionAndExtractTakingCollection()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String[] stringArray0 = new String[1];
      stringArray0[0] = "RhBHP#tCmiQx*/Z";
      int int0 = 0;
      options0.setOptionsOrWarn(stringArray0, 0, 0);
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.arrayMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      twoDimensionalMap0.remove(".$$.", "lVZ@O#rBQ");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      MockFile mockFile0 = new MockFile("Sc%wHhq", ".$$.");
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(91, false);
      Reader reader0 = Reader.nullReader();
      Morphology morphology0 = new Morphology(reader0);
      Function<String, Tree> function0 = nPTmpRetainingTreeNormalizer0.compose(morphology0);
      ObjectBank<Tree> objectBank0 = ObjectBank.getLineIterator(mockFile0, function0, ".$$.");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) objectBank0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // java.io.FileNotFoundException
         //
         verifyException("edu.stanford.nlp.io.IOUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void testDEBUGAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0, stack0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(".$$.", list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recountInside(tree0, true, 100, identityHashMap0);
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInsideThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[8][8];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[0];
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[6];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = (double) 100;
      doubleArray3[3] = 0.0;
      doubleArray3[4] = 0.0;
      doubleArray3[5] = 0.0;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[5];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = (double) 100;
      doubleArray4[3] = (double) 100;
      doubleArray4[4] = 0.0;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[9];
      doubleArray5[0] = 0.0;
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.recalculateBetas(false);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      int int0 = 1;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(labeledScoredTreeNode0, true, 1, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndState()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      Tree tree0 = hebrewTreebankParserParams0.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.state("", 100);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 109, identityHashMap2, (IdentityHashMap<Tree, double[][][]>) null);
      assertEquals(0, identityHashMap2.size());
  }

  @Test(timeout = 4000)
  public void testTestConvergenceReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      hebrewTreebankParserParams0.memoryTreebank();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      hebrewTreebankParserParams0.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.state("", 100);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, 0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      hebrewTreebankParserParams0.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0, (double) 100, (Collection<Tree>) labeledScoredTreeNode0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeException2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      List<Tree> list0 = List.of(labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0, (double) 100, (Collection<Tree>) list0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][0];
      twoDimensionalMap0.put("Ro*~]1", "Ro*~]1", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndOutputBetasAndUseNewBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.remove("LVP=l=VBi", "LVP=l=VBi");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      threeDimensionalMap0.get("usewebfreqdict", "+tATWq");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = splittingGrammarExtractor0.unaryBetas;
      TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap.identityHashMap();
      threeDimensionalMap0.getTwoDimensionalMap("QI");
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndExtractTaking4ArgumentsAndNeginfDoubles()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      pennTreebankLanguagePack0.treeTokenizerFactory();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      options0.doPCFG = true;
      String[] stringArray0 = new String[0];
      options0.setOptionsOrWarn(stringArray0);
      splittingGrammarExtractor0.neginfDoubles(781);
      pennTreebankLanguagePack0.getBasicCategoryFunction();
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      DiskTreebank diskTreebank0 = negraPennTreebankParserParams0.diskTreebank();
      negraPennTreebankParserParams0.setOutputEncoding("");
      negraPennTreebankParserParams0.inputEncoding = " iterations";
      splittingGrammarExtractor0.extract((Collection<Tree>) diskTreebank0, 0.0, (Collection<Tree>) diskTreebank0, 0.0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.outputBetas();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testOutputBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithNegative1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      List<Tree> list0 = List.of(labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0, labeledScoredTreeNode0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0, (double) 100, (Collection<Tree>) list0, (-11.907932452816745));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndNeginfDoubles()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = new CoreLabel();
      CoreLabel coreLabel1 = new CoreLabel(100);
      int int0 = 781;
      splittingGrammarExtractor0.neginfDoubles(100);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      pennTreebankLanguagePack0.getBasicCategoryFunction();
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      DiskTreebank diskTreebank0 = negraPennTreebankParserParams0.diskTreebank();
      negraPennTreebankParserParams0.setOutputEncoding("{D}7");
      List<Tree> list0 = splittingGrammarExtractor0.trees;
      SimpleTree simpleTree0 = new SimpleTree(coreLabel0, list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0, 100.0, (Collection<Tree>) diskTreebank0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.arrayMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      twoDimensionalMap0.remove("", "SBARQ < (WHNP $++ (/^VB/ < ");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertNotSame(twoDimensionalMap0, twoDimensionalMap1);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasReturningFalse()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("MWCL", "MWCL");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      Label label0 = null;
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode((Label) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsWithEmptyMapAndEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      Tree tree0 = hebrewTreebankParserParams0.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
      assertSame(tree0, labeledScoredTreeNode0);
      
      splittingGrammarExtractor0.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, (Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testState1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = splittingGrammarExtractor0.state(")GWw[", 100);
      assertEquals(")GWw[^100", string0);
  }

  @Test(timeout = 4000)
  public void testStateAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      arrayList0.add("@0Sa16Y=C`9R(.KPn_'");
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      String string0 = splittingGrammarExtractor0.state("@0Sa16Y=C`9R(.KPn_'", 100);
      assertEquals("@0Sa16Y=C`9R(.KPn_'", string0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) null, 100, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordLemmaTag0);
      hebrewTreebankParserParams0.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.state("", 100);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, 0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      assertEquals(Double.NaN, labeledScoredTreeNode0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, 100, identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testStateThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.state((String) null, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<Triple<Object, SplittingGrammarExtractor, Object>, SplittingGrammarExtractor> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory.treeMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      mapFactory0.setMap(hashMap0);
      Map<String, double[]> map0 = new HashMap<String, double[]>();
      Map<String, double[]> map1 = mapFactory0.setMap(map0);
      Map<String, double[]> map2 = mapFactory0.setMap(map1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) null, doubleArray0, (-1510), identityHashMap0, identityHashMap1, map2, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasReturningTrue()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String[] stringArray0 = new String[1];
      options0.setOptionsOrWarn(stringArray0, 0, 0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.mergeStates();
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(100);
      assertEquals(100, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedHashSet<Tree> linkedHashSet0 = new LinkedHashSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) linkedHashSet0, 0.0, (Collection<Tree>) linkedHashSet0, (double) 100);
      assertTrue(linkedHashSet0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testBuildGrammars()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      pennTreebankLanguagePack0.treeTokenizerFactory();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      options0.doPCFG = true;
      String[] stringArray0 = new String[0];
      options0.setOptionsOrWarn(stringArray0);
      splittingGrammarExtractor0.neginfDoubles(781);
      pennTreebankLanguagePack0.getBasicCategoryFunction();
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      DiskTreebank diskTreebank0 = negraPennTreebankParserParams0.diskTreebank();
      negraPennTreebankParserParams0.setOutputEncoding("");
      negraPennTreebankParserParams0.inputEncoding = " iterations";
      splittingGrammarExtractor0.extract((Collection<Tree>) diskTreebank0, 0.0, (Collection<Tree>) diskTreebank0, 0.0);
      splittingGrammarExtractor0.buildGrammars();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer(pennTreebankLanguagePack0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.getChildrenAsList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      // Undeclared exception!
      try { 
        treeGraphNode1.getChild(100);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 100 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.trees.Tree", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNullAndNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = null;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[8][8];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[0];
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[6];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = (double) 100;
      doubleArray3[3] = 0.0;
      doubleArray3[4] = 0.0;
      doubleArray3[5] = 0.0;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[5];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = (double) 100;
      doubleArray4[3] = (double) 100;
      doubleArray4[4] = 0.0;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[9];
      doubleArray5[0] = 0.0;
      doubleArray5[1] = 0.0;
      doubleArray5[2] = 0.0;
      doubleArray5[3] = (double) 100;
      doubleArray5[4] = 0.1;
      doubleArray5[5] = (double) 100;
      doubleArray5[6] = (double) 100;
      doubleArray5[7] = (double) 100;
      doubleArray5[8] = 0.0;
      doubleArray0[4] = doubleArray5;
      double[] doubleArray6 = new double[5];
      doubleArray6[0] = 0.1;
      doubleArray6[1] = (-458.6833865716494);
      doubleArray6[2] = 0.0;
      doubleArray6[3] = 0.9999000099990001;
      doubleArray6[4] = (double) 100;
      doubleArray0[5] = doubleArray6;
      double[] doubleArray7 = new double[8];
      doubleArray7[0] = (double) 100;
      doubleArray7[1] = 0.0;
      doubleArray7[2] = 0.1;
      doubleArray7[3] = 0.1;
      doubleArray7[4] = (-458.6833865716494);
      doubleArray7[5] = (-458.6833865716494);
      doubleArray7[6] = (-458.6833865716494);
      doubleArray7[7] = (double) 100;
      doubleArray0[6] = doubleArray7;
      double[] doubleArray8 = new double[1];
      doubleArray8[0] = (-458.6833865716494);
      doubleArray0[7] = doubleArray8;
      identityHashMap1.put((Tree) null, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights((Tree) null, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas2()  throws Throwable  {
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options0 = new Options();
      threeDimensionalMap0.remove("3HHW)9BD>r?}NR?2jt^", "3HHW)9BD>r?}NR?2jt^", "3HHW)9BD>r?}NR?2jt^");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.secondKeySet();
      threeDimensionalMap0.get("O8_w0Xse@%8Zv7", "O8_w0Xse@%8Zv7");
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode((Label) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetas4()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testBuildStateIndex()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndBuildStateIndexAndMergeStates()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String[] stringArray0 = new String[1];
      stringArray0[0] = "RhBHP#tCmiQx*/Z";
      options0.setOptionsOrWarn(stringArray0, 0, 0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.mergeStates();
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecalculateBetasWithTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(labeledScoredTreeNode0, true, 100, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsThrowsRuntimeException()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = new CoreLabel();
      CoreLabel coreLabel1 = new CoreLabel((CoreMap) coreLabel0);
      WordTag wordTag0 = new WordTag(coreLabel1);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      BobChrisTreeNormalizer.EmptyFilter bobChrisTreeNormalizer_EmptyFilter0 = new BobChrisTreeNormalizer.EmptyFilter();
      Filters.RandomFilter<Object> filters_RandomFilter0 = new Filters.RandomFilter<Object>();
      Predicate<Tree> predicate0 = bobChrisTreeNormalizer_EmptyFilter0.and(filters_RandomFilter0);
      Tree tree0 = treeGraphNode0.spliceOut(predicate0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>(0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree(tree0, true, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsAndCountMergeEffectsTaking5ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      Tree tree0 = null;
      double[] doubleArray0 = new double[0];
      int int0 = (-1510);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<Triple<Object, SplittingGrammarExtractor, Object>, SplittingGrammarExtractor> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory<Object, SplittingGrammarExtractor> mapFactory1 = MapFactory.treeMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      // Undeclared exception!
      try { 
        mapFactory1.setMap(map0, (-1510));
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.util.MapFactory$TreeMapFactory", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateSplittingGrammarExtractorThrowsNullPointerException()  throws Throwable  {
      SplittingGrammarExtractor splittingGrammarExtractor0 = null;
      try {
        splittingGrammarExtractor0 = new SplittingGrammarExtractor((Options) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }
}
