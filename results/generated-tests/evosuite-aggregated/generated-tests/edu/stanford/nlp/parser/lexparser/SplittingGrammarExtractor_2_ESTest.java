/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Apr 21 19:15:43 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ling.BasicDocument;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CategoryWordTagFactory;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Document;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.StringLabelFactory;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordFactory;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordLemmaTagFactory;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.ling.WordTagFactory;
import edu.stanford.nlp.objectbank.IdentityFunction;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HebrewTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HungarianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ItalianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.NegraPennTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.SpanishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.SpanishUnknownWordModelTrainer;
import edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.trees.BobChrisTreeNormalizer;
import edu.stanford.nlp.trees.DiskTreebank;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.MemoryTreebank;
import edu.stanford.nlp.trees.NPTmpRetainingTreeNormalizer;
import edu.stanford.nlp.trees.PennTreebankLanguagePack;
import edu.stanford.nlp.trees.QPTreeTransformer;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeGraphNodeFactory;
import edu.stanford.nlp.trees.TreeTransformer;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.DeltaIndex;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.ThreeDimensionalMap;
import edu.stanford.nlp.util.Triple;
import edu.stanford.nlp.util.TwoDimensionalMap;
import java.io.BufferedReader;
import java.io.CharArrayWriter;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Vector;
import java.util.function.Function;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class SplittingGrammarExtractor_2_ESTest extends SplittingGrammarExtractor_2_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testRecountInsideReturningZero()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      WordTag wordTag0 = new WordTag("Wmt&:T", "neighborhood");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      Tree tree0 = treeGraphNode1.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("=5$-", "Wmt&:T", "Wmt&:T");
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(treeGraphNode0, true, (-1), identityHashMap0);
      Options options1 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor1.splitBetas();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testMergeStatesThrowsTooManyResourcesException()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("kHa\"c[B", "kHa\"c[B");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[12];
      hashMap0.put("kHa\"c[B", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      MapFactory<Object, String> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      // Undeclared exception!
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, map0, identityHashMap0, identityHashMap0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsTooManyResourcesException()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("kHa\"c[B", "kHa\"c[B");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[19];
      hashMap0.put("kHa\"c[B", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      MapFactory<Object, String> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      // Undeclared exception!
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, map0, identityHashMap0, identityHashMap0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithEmptyMap0()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("kHa\"c[B", "kHa\"c[B");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      hashMap0.put("kHa\"c[B", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<Object, String> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, map0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("kHa\"c[B", "kHa\"c[B");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      hashMap0.put("kHa\"c[B", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      MapFactory<Object, String> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, map0, identityHashMap0, identityHashMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[4][9][7];
      identityHashMap0.put(treeGraphNode2, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      double[] doubleArray1 = new double[8];
      doubleArray1[0] = 103.7783658029462;
      doubleArray1[1] = 103.7783658029462;
      doubleArray1[2] = 100.0;
      doubleArray1[3] = (double) 100;
      doubleArray1[4] = (double) 100;
      doubleArray1[5] = 3.0;
      doubleArray1[6] = 1000.0;
      doubleArray1[7] = 103.7783658029462;
      int int0 = splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray1, (-1968526675), identityHashMap1, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertArrayEquals(new double[] {103.7783658029462, 103.7783658029462, 100.0, 100.0, 100.0, 3.0, 1000.0, 103.7783658029462}, doubleArray1, 0.01);
      assertEquals((-1968526675), int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[4][9][7];
      double[][] doubleArray1 = new double[5][1];
      double[] doubleArray2 = new double[9];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = (double) 100;
      doubleArray2[4] = (double) 100;
      doubleArray2[5] = 3.0;
      doubleArray2[6] = 0.0;
      doubleArray2[7] = 0.0;
      doubleArray2[8] = 103.7783658029462;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[8];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = 3.0;
      doubleArray3[3] = (-1041.1103763);
      doubleArray3[4] = 103.7783658029462;
      doubleArray3[5] = 103.7783658029462;
      doubleArray3[6] = 0.0;
      doubleArray3[7] = 0.0;
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[1];
      doubleArray4[0] = 3.0;
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[5];
      doubleArray5[0] = 103.7783658029462;
      doubleArray5[1] = 0.0;
      doubleArray5[2] = 103.7783658029462;
      doubleArray5[3] = (double) 100;
      doubleArray5[4] = (double) 100;
      doubleArray1[3] = doubleArray5;
      double[] doubleArray6 = new double[1];
      doubleArray6[0] = (double) 100;
      doubleArray1[4] = doubleArray6;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray7 = new double[3][0];
      doubleArray7[0] = doubleArray5;
      doubleArray7[1] = doubleArray2;
      doubleArray7[2] = doubleArray3;
      doubleArray0[1] = doubleArray7;
      double[][] doubleArray8 = new double[3][6];
      doubleArray8[0] = doubleArray5;
      doubleArray8[1] = doubleArray2;
      double[] doubleArray9 = new double[8];
      doubleArray9[0] = 103.7783658029462;
      doubleArray9[1] = (-1041.1103763);
      doubleArray9[2] = 103.7783658029462;
      doubleArray9[3] = 103.7783658029462;
      doubleArray9[4] = 1000.0;
      doubleArray9[5] = 3.0;
      doubleArray9[6] = 0.0;
      doubleArray9[7] = 3.0;
      doubleArray8[2] = doubleArray9;
      doubleArray0[2] = doubleArray8;
      double[][] doubleArray10 = new double[8][9];
      doubleArray10[0] = doubleArray2;
      doubleArray10[1] = doubleArray9;
      doubleArray10[2] = doubleArray2;
      doubleArray10[3] = doubleArray4;
      doubleArray10[4] = doubleArray4;
      doubleArray10[5] = doubleArray6;
      doubleArray10[6] = doubleArray3;
      double[] doubleArray11 = new double[9];
      doubleArray11[0] = 0.0;
      doubleArray11[1] = (double) 100;
      doubleArray11[2] = 1000.0;
      doubleArray11[3] = (-1041.1103763);
      doubleArray11[4] = 3.0;
      doubleArray11[5] = 3.0;
      doubleArray11[6] = (-1041.1103763);
      doubleArray11[7] = 0.0;
      doubleArray11[8] = 0.0;
      doubleArray10[7] = doubleArray11;
      doubleArray0[3] = doubleArray10;
      identityHashMap0.put(treeGraphNode2, doubleArray0);
      double[] doubleArray12 = new double[1];
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode2, doubleArray12, 100, identityHashMap1, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      TreeGraphNode treeGraphNode2 = treeGraphNode0.parent();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[4][9][7];
      identityHashMap0.put(treeGraphNode2, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      double[] doubleArray1 = new double[8];
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray1, 100, identityHashMap1, identityHashMap0, (Map<String, double[]>) hashMap1, twoDimensionalMap0, threeDimensionalMap0);
      assertArrayEquals(new double[] {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, doubleArray1, 0.01);
      assertEquals(100, int0);
      
      splittingGrammarExtractor0.getStateSplitCount("[$!");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray1, (-308), identityHashMap1, identityHashMap0, (Map<String, double[]>) hashMap1, twoDimensionalMap1, threeDimensionalMap0);
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Morphology morphology0 = new Morphology();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(" Gn ", " Gn ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = 0.0;
      hashMap0.put(" Gn ", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(" G5bn ", " G5bn ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      hashMap0.put(" G5bn ", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("", "");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      hashMap0.put("", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndUseNewBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[2][3];
      twoDimensionalMap0.put(".$$.", ".$$.", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException0()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      double[][][] doubleArray1 = new double[9][5][4];
      double[][] doubleArray2 = new double[1][9];
      doubleArray2[0] = doubleArray0;
      doubleArray1[0] = doubleArray2;
      double[][] doubleArray3 = new double[5][6];
      doubleArray3[0] = doubleArray0;
      doubleArray3[1] = doubleArray0;
      doubleArray3[2] = doubleArray0;
      doubleArray3[3] = doubleArray0;
      doubleArray3[4] = doubleArray0;
      doubleArray1[1] = doubleArray3;
      double[][] doubleArray4 = new double[8][3];
      double[] doubleArray5 = new double[3];
      doubleArray5[0] = (double) 100;
      doubleArray5[1] = (double) 100;
      doubleArray5[2] = 0.0;
      doubleArray4[0] = doubleArray5;
      doubleArray4[1] = doubleArray0;
      double[] doubleArray6 = new double[1];
      doubleArray6[0] = 0.0;
      doubleArray4[2] = doubleArray6;
      doubleArray4[3] = doubleArray0;
      doubleArray4[4] = doubleArray0;
      doubleArray4[5] = doubleArray0;
      doubleArray4[6] = doubleArray0;
      doubleArray4[7] = doubleArray0;
      doubleArray1[2] = doubleArray4;
      double[][] doubleArray7 = new double[8][6];
      doubleArray7[0] = doubleArray6;
      doubleArray7[1] = doubleArray6;
      doubleArray7[2] = doubleArray5;
      doubleArray7[3] = doubleArray5;
      double[] doubleArray8 = new double[0];
      doubleArray7[4] = doubleArray8;
      doubleArray7[5] = doubleArray0;
      doubleArray7[6] = doubleArray0;
      doubleArray7[7] = doubleArray5;
      doubleArray1[3] = doubleArray7;
      double[][] doubleArray9 = new double[5][7];
      double[] doubleArray10 = new double[4];
      doubleArray10[0] = (double) 3644;
      doubleArray10[1] = (double) 100;
      doubleArray10[2] = (-1411.726870535);
      doubleArray10[3] = 0.0;
      doubleArray9[0] = doubleArray10;
      doubleArray9[1] = doubleArray6;
      doubleArray9[2] = doubleArray0;
      doubleArray9[3] = doubleArray8;
      doubleArray9[4] = doubleArray6;
      doubleArray1[4] = doubleArray9;
      double[][] doubleArray11 = new double[4][9];
      doubleArray11[0] = doubleArray6;
      doubleArray11[1] = doubleArray5;
      doubleArray11[2] = doubleArray8;
      doubleArray11[3] = doubleArray0;
      doubleArray1[5] = doubleArray11;
      double[][] doubleArray12 = new double[1][1];
      doubleArray12[0] = doubleArray0;
      doubleArray1[6] = doubleArray12;
      double[][] doubleArray13 = new double[3][4];
      doubleArray13[0] = doubleArray0;
      double[] doubleArray14 = new double[5];
      doubleArray14[0] = (-1.0);
      doubleArray14[1] = (double) 100;
      doubleArray14[2] = (double) 100;
      doubleArray14[3] = (double) 100;
      doubleArray14[4] = 0.0;
      doubleArray13[1] = doubleArray14;
      doubleArray13[2] = doubleArray10;
      doubleArray1[7] = doubleArray13;
      double[][] doubleArray15 = new double[7][3];
      double[] doubleArray16 = new double[5];
      doubleArray16[0] = (-1.0);
      doubleArray16[1] = (double) 100;
      doubleArray16[2] = (-1.0);
      doubleArray16[3] = 0.0;
      doubleArray16[4] = (double) 100;
      doubleArray15[0] = doubleArray16;
      doubleArray15[1] = doubleArray6;
      doubleArray15[2] = doubleArray10;
      doubleArray15[3] = doubleArray6;
      doubleArray15[4] = doubleArray6;
      doubleArray15[5] = doubleArray10;
      doubleArray15[6] = doubleArray14;
      doubleArray1[8] = doubleArray15;
      identityHashMap1.put(treeGraphNode1, doubleArray1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 3644, identityHashMap0, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesReturningEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][2][7];
      double[][] doubleArray1 = new double[3][3];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      threeDimensionalMap0.put("<7<ZKn", "cy<n", "cy<n", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.getStateSplitCount("<7<ZKn");
      splittingGrammarExtractor1.neginfDoubles(0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[3][2][7];
      threeDimensionalMap0.put("c7<{n", "c7<{n", "c7<{n", doubleArray0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("c7<{n", (List<Tree>) linkedList0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 336.168684;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = 300.0;
      doubleArray1[5] = 0.0;
      identityHashMap0.put(tree0, doubleArray1);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 6 out of bounds for length 6
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testDEBUGAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("Found ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode1.postOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(label0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      splittingGrammarExtractor0.countOriginalStates();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(treeGraphNode1, true, 1197707410, identityHashMap0);
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testMergeStatesAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[2][3];
      twoDimensionalMap0.put("m M6*m#w", "m M6*m#w", doubleArray0);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringReturningPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("GibW_|");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount("GibW_|");
      assertEquals(2, int0);
  }

  @Test(timeout = 4000)
  public void testSplitBetas0()  throws Throwable  {
      Options options0 = new Options();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[3][3];
      twoDimensionalMap0.put("Iteration ", "Iteration ", doubleArray0);
      Word word0 = Word.EMPTY;
      IdentityHashMap<String, double[][]> identityHashMap0 = new IdentityHashMap<String, double[][]>();
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeThrowsNullPointerExceptionAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, true);
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[3][3];
      doubleArray0[1] = doubleArray0[0];
      twoDimensionalMap0.put("ma M61*m#w", "ma M61*m#w", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      SimpleTree simpleTree0 = new SimpleTree();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) simpleTree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerExceptionAndRecountOutsideTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[8][2][7];
      IdentityHashMap<String, double[][][]> identityHashMap0 = new IdentityHashMap<String, double[][][]>();
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = 0.0;
      IdentityHashMap<String, double[][]> identityHashMap1 = new IdentityHashMap<String, double[][]>();
      threeDimensionalMap0.put("c7<n", "c7<n", "c7<n", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("c7<n", (List<Tree>) linkedList0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, tree0, identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[8][2][7];
      double[][] doubleArray1 = new double[3][3];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      doubleArray1[1] = doubleArray2;
      IdentityHashMap<String, double[][][]> identityHashMap0 = new IdentityHashMap<String, double[][][]>();
      double[] doubleArray3 = new double[2];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = 0.0;
      IdentityHashMap<String, double[][]> identityHashMap1 = new IdentityHashMap<String, double[][]>();
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("c7<n", "c7<n", "c7<n", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("c7<n", (List<Tree>) linkedList0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, tree0, tree0, identityHashMap2, identityHashMap3);
      assertEquals(0, identityHashMap2.size());
      assertTrue(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerExceptionAndRecountOutsideTaking5ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[3][2][7];
      threeDimensionalMap0.put("c7<{n", "c7<{n", "c7<{n", doubleArray0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("c7<{n", (List<Tree>) linkedList0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[8][2][7];
      double[][] doubleArray1 = new double[3][3];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      IdentityHashMap<String, double[][][]> identityHashMap0 = new IdentityHashMap<String, double[][][]>();
      double[] doubleArray3 = new double[2];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = 0.0;
      IdentityHashMap<String, double[][]> identityHashMap1 = new IdentityHashMap<String, double[][]>();
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("c7<n", "c7<n", "c7<n", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("c7<n", (List<Tree>) linkedList0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, tree0, tree0, identityHashMap2, identityHashMap2);
      assertEquals(Double.NaN, tree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[3][3];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      doubleArray0[1] = doubleArray1;
      twoDimensionalMap0.put("Iteration ", "Iteration ", doubleArray0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      Word word0 = Word.EMPTY;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      WordTag wordTag0 = new WordTag(treeGraphNode0, treeGraphNode0);
      double[][][] doubleArray2 = new double[7][4][2];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      doubleArray2[2] = null;
      doubleArray2[3] = doubleArray0;
      doubleArray2[4] = null;
      doubleArray2[5] = doubleArray0;
      doubleArray2[6] = null;
      threeDimensionalMap0.put("Iteration ", "LEXICON", "yqs;w8(F^mh", doubleArray2);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasWithFalse0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[13][0];
      twoDimensionalMap0.put("s\"L$>5i9o", "s\"L$>5i9o", doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndBuildStateIndexAndMergeTransitions()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(".$$.", ".$$.", ".$$.");
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      WordFactory wordFactory0 = new WordFactory();
      wordFactory0.newLabelFromString(".$$.");
      splittingGrammarExtractor0.buildStateIndex();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      HashMap<String, int[]> hashMap1 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode0, identityHashMap1, identityHashMap0, identityHashMap1, identityHashMap0, doubleArray0, hashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode2, identityHashMap1, identityHashMap0, identityHashMap1, identityHashMap0, doubleArray0, hashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerException()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[7];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode1, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Morphology morphology0 = new Morphology();
      WordTag wordTag0 = new WordTag(" Gn ", " Gn ");
      WordLemmaTag wordLemmaTag0 = morphology0.lemmatize(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNode0.treeSkeletonCopy((TreeFactory) treeGraphNodeFactory0);
      treeGraphNode1.addChild(tree0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[5][5];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      double[] doubleArray2 = new double[9];
      doubleArray2[0] = 356.56984;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      doubleArray2[4] = 0.001;
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = (double) 100;
      doubleArray2[7] = 0.0;
      doubleArray2[8] = (double) 100;
      doubleArray1[3] = doubleArray2;
      doubleArray1[4] = doubleArray0;
      identityHashMap2.put(treeGraphNode0, doubleArray1);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 100, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.TreeMap", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexAndExtractTakingCollectionAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, (String) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("Found ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode1.postOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(label0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("ib_h|");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      assertEquals(1, map0.size());
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("Gitt_|");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode0, false, 1908, identityHashMap0);
      assertEquals(1909, int0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Morphology morphology0 = new Morphology();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[1][2][9];
      double[][] doubleArray1 = new double[3][5];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[6];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = (double) 100;
      doubleArray3[3] = 0.0;
      doubleArray3[4] = (double) 100;
      doubleArray3[5] = (double) 100;
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[3];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = (double) 100;
      doubleArray4[2] = 0.0;
      doubleArray1[2] = doubleArray4;
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put(",^_%", "{+6N2UgL%=l\u0001Z", "UNARY:", doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      StringReader stringReader0 = new StringReader("-^");
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor1.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsTooManyResourcesExceptionAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.binaryBetas = threeDimensionalMap0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      categoryWordTag0.toString();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      TwoDimensionalMap.treeMap();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[6][8];
      double[] doubleArray1 = new double[8];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = (-2472.655215085633);
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 0.0;
      doubleArray1[5] = 0.0;
      doubleArray1[7] = (double) 100;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[0];
      double[] doubleArray3 = new double[7];
      doubleArray3[0] = (-2472.655215085633);
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = (-2472.655215085633);
      doubleArray3[4] = 0.0;
      doubleArray3[5] = 0.0;
      identityHashMap1.put(treeGraphNode0, doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      splittingGrammarExtractor1.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsTooManyResourcesException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.binaryBetas = threeDimensionalMap0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      categoryWordTag0.toString();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      TwoDimensionalMap.treeMap();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[6][8];
      double[] doubleArray1 = new double[8];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = (-2472.655215085633);
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 0.0;
      doubleArray1[5] = 0.0;
      doubleArray1[7] = (double) 100;
      double[] doubleArray2 = new double[0];
      double[] doubleArray3 = new double[7];
      doubleArray3[0] = (-2472.655215085633);
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = (-2472.655215085633);
      doubleArray3[4] = 0.0;
      doubleArray3[5] = 0.0;
      identityHashMap1.put(treeGraphNode0, doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      splittingGrammarExtractor1.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerExceptionAndRescaleTemporaryBetas()  throws Throwable  {
      Random.setNextRandom(948);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      doReturn(0, 0, 0).when(comparator0).compare(any() , any());
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      MapFactory<String, double[][]> mapFactory1 = MapFactory.weakHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      double[][] doubleArray0 = new double[1][7];
      hebrewTreebankParserParams0.treeTokenizerFactory();
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 948;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap1.put("BINARY:", "BINARY:", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateBetas(false);
      WordFactory wordFactory0 = new WordFactory();
      Label label0 = wordFactory0.newLabelFromString("BINARY:");
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0);
      HashMap<Tree, double[]> hashMap0 = new HashMap<Tree, double[]>();
      BasicDocument<double[]> basicDocument0 = BasicDocument.init("k&gQ?c7QF!ISj3ME", false);
      BasicDocument<double[]> basicDocument1 = new BasicDocument<double[]>((Document<double[], Word, Word>) basicDocument0);
      Reader reader0 = Reader.nullReader();
      BasicDocument<double[]> basicDocument2 = basicDocument1.init(reader0, "&apos;|[\u0082\u008B\u0091\u00B4\u2018\u0092\u2019\u009B\u201A\u201B\u2039\u203A']");
      labeledScoredTreeNode0.yieldWords((ArrayList<Word>) basicDocument2);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>(hashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[0][7];
      twoDimensionalMap0.put("5$3w", "5$3w", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("Found ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode1.postOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(label0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 415.486545;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap1);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndRescaleTemporaryBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      double[][][] doubleArray0 = new double[1][8][3];
      double[][] doubleArray1 = new double[19][6];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      doubleArray1[1] = doubleArray2;
      threeDimensionalMap0.get("_?xV`;{UV,R;P{2");
      threeDimensionalMap0.put("*dv", "averagePerceptron", ";D<Lh^9_rFO%q$Y+9", doubleArray0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      threeDimensionalMap0.getTwoDimensionalMap("_?xV`;{UV,R;P{2");
      MapFactory.arrayMapFactory();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Reader reader0 = Reader.nullReader();
      Morphology morphology0 = new Morphology(reader0, (-1938387115));
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap1);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor1.useNewBetas(false, twoDimensionalMap1, threeDimensionalMap0);
      assertFalse(boolean0);
      
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.splitBetas();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsWithTrueAndNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("Found ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode1.postOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(label0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      Morphology morphology0 = new Morphology();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = twoDimensionalMap1.transform(morphology0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap2, threeDimensionalMap1);
      assertSame(threeDimensionalMap1, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
      
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (double) 100;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) null, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeReturningPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
      
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("Found ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode1.postOrderNodeList();
      TreeGraphNode treeGraphNode2 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount((Tree) treeGraphNode2);
      assertEquals(2, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(".$$.");
      wordLemmaTag0.labelFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[0][6][7];
      identityHashMap0.put(treeGraphNode1, doubleArray0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray1 = new double[8];
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = (double) 100;
      doubleArray1[4] = 0.0;
      doubleArray1[5] = (double) 100;
      doubleArray1[6] = (double) 100;
      doubleArray1[7] = 0.0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray1, 65, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndRecalculateBetasAndRecalculateBetasWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Label label0 = stringLabelFactory0.newLabel("Found ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode1.postOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(label0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      splittingGrammarExtractor1.extract((Collection<Tree>) list0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsAndGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, false, 100, true);
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      TwoDimensionalMap.treeMap();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SimpleTree simpleTree1 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.getStateSplitCount("UNARY:");
      splittingGrammarExtractor0.recountTree((Tree) treeGraphNode0, false, identityHashMap2, identityHashMap2, identityHashMap3, (IdentityHashMap<Tree, double[][][]>) null);
      assertTrue(identityHashMap3.isEmpty());
      assertTrue(identityHashMap3.equals((Object)identityHashMap1));
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndMergeStatesAndUseNewBetas0()  throws Throwable  {
      Options options0 = new Options();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0, memoryTreebank0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Tree tree0 = negraPennTreebankParserParams0.transformTree(treeGraphNode0, treeGraphNode0);
      treeGraphNode0.parent(tree0);
      SimpleTree simpleTree0 = new SimpleTree((Label) null);
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(tree0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.getMap("D`>G");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[8][3][7];
      double[][] doubleArray1 = new double[5][3];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[0];
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[7];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = 0.0;
      doubleArray4[3] = 0.0;
      doubleArray4[4] = 0.0;
      doubleArray4[5] = (double) 100;
      doubleArray4[6] = (double) 100;
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[3];
      doubleArray5[0] = (double) 100;
      doubleArray5[1] = 0.0;
      doubleArray5[2] = (double) 100;
      doubleArray1[3] = doubleArray5;
      double[] doubleArray6 = new double[6];
      doubleArray6[0] = 0.0;
      doubleArray6[1] = 0.0;
      doubleArray6[2] = 0.0;
      doubleArray6[3] = 0.0;
      doubleArray6[4] = (double) 100;
      doubleArray6[5] = (double) 100;
      doubleArray1[4] = doubleArray6;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray7 = new double[6][3];
      doubleArray7[0] = doubleArray2;
      doubleArray7[1] = doubleArray3;
      doubleArray7[2] = doubleArray4;
      doubleArray7[3] = doubleArray2;
      doubleArray7[4] = doubleArray4;
      doubleArray7[5] = doubleArray4;
      doubleArray0[1] = doubleArray7;
      double[][] doubleArray8 = new double[7][1];
      doubleArray8[0] = doubleArray6;
      doubleArray8[1] = doubleArray3;
      doubleArray8[2] = doubleArray3;
      doubleArray8[3] = doubleArray3;
      doubleArray8[4] = doubleArray3;
      doubleArray8[5] = doubleArray6;
      doubleArray8[6] = doubleArray3;
      doubleArray0[2] = doubleArray8;
      double[][] doubleArray9 = new double[2][3];
      doubleArray9[0] = doubleArray2;
      doubleArray9[1] = doubleArray2;
      doubleArray0[3] = doubleArray9;
      double[][] doubleArray10 = new double[1][6];
      doubleArray10[0] = doubleArray6;
      doubleArray0[4] = doubleArray10;
      double[][] doubleArray11 = new double[5][1];
      doubleArray11[0] = doubleArray6;
      doubleArray11[1] = doubleArray6;
      doubleArray11[2] = doubleArray3;
      doubleArray11[3] = doubleArray5;
      doubleArray11[4] = doubleArray6;
      doubleArray0[5] = doubleArray11;
      double[][] doubleArray12 = new double[1][5];
      doubleArray12[0] = doubleArray4;
      doubleArray0[6] = doubleArray12;
      double[][] doubleArray13 = new double[7][5];
      doubleArray13[0] = doubleArray5;
      doubleArray13[1] = doubleArray4;
      doubleArray13[2] = doubleArray4;
      doubleArray13[3] = doubleArray2;
      doubleArray13[4] = doubleArray3;
      doubleArray13[5] = doubleArray5;
      doubleArray13[6] = doubleArray6;
      doubleArray0[7] = doubleArray13;
      threeDimensionalMap0.put("bR*$ 7)kwL>", "T24ZHdEv~NF?", "P>", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap1, threeDimensionalMap0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode1);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasWithTrue0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][2][7];
      double[][] doubleArray1 = new double[2][3];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("cy<n", "cy<n", "cy<n", doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndRecalculateTemporaryBetasTaking8ArgumentsWithNegativeAndRecalculateTemporaryBetasTaking8ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("", "");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      hashMap0.put("", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, (double[]) null, (-1387), identityHashMap1, identityHashMap2, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsNullPointerExceptionAndRecalculateBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(".$$.", ".$$.");
      wordLemmaTag0.labelFactory();
      TwoDimensionalMap.treeMap();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(categoryWordTag0, list0);
      treeGraphNode2.addChild((Tree) treeGraphNode1);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      splittingGrammarExtractor0.mergeStates();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, (Tree) simpleTree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][] doubleArray0 = new double[2][3];
      twoDimensionalMap0.put("YB", "YB", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[9][3];
      twoDimensionalMap0.put(".$$.", ".$$.", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap4 = new IdentityHashMap<String, double[]>(hashMap1);
      MapFactory<Triple<Object, String, String>, String> mapFactory0 = MapFactory.weakHashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap4);
      IdentityHashMap<String, double[]> identityHashMap5 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, map0, (Map<String, double[]>) identityHashMap5, identityHashMap2, identityHashMap2);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1, 0.0, (Collection<Tree>) list0, 6.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Trees should have been binarized, expected 1 or 2 children
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException0()  throws Throwable  {
      Options options0 = new Options();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Trees should have been binarized, expected 1 or 2 children
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode1);
      treeGraphNode2.addChild((Tree) treeGraphNode1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) treeGraphNode2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsAndDEBUG()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      ItalianTreebankParserParams italianTreebankParserParams1 = new ItalianTreebankParserParams();
      Reader.nullReader();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.recalculateBetas(true);
      splittingGrammarExtractor0.DEBUG();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, false, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap1);
      assertNotSame(treeGraphNode0, treeGraphNode1);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndMergeStatesAndUseNewBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.memoryTreebank();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      threeDimensionalMap0.remove("*VVokWPQ3-LC", "95J(36xs$3m01>", "Recalculating temporary betas for tree ");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.getMap("*VVokWPQ3-LC");
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testMergeStatesAndOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[2][3];
      twoDimensionalMap0.put("m M6*m#w", "m M6*m#w", doubleArray0);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndCountOriginalStates()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("CFb g&WTH");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap1.remove("lKed3", "__ < ((@PUNC < \") !$ (@PUNC < \"))", (String) null);
      threeDimensionalMap0.secondKeySet();
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap1);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(true);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecalculateTemporaryBetasTaking8ArgumentsWithNull()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      treeGraphNode1.contains(options0);
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 3644, identityHashMap0, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      assertEquals(3645, int0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      threeDimensionalMap0.size();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[1][6][7];
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      identityHashMap0.put(treeGraphNode1, doubleArray0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = 0.0;
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray1, 2047, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0, 2.776603063849818E180, (Collection<Tree>) treeGraphNode0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndOutputTransitionsTaking4ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[0][6][7];
      identityHashMap0.put(treeGraphNode1, doubleArray0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerExceptionAndRecountInsideWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("@yugoq,wNg");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove((String) null, "@yugoq,wNg", "th4@xz7'>Eh<Nq[<$M");
      threeDimensionalMap0.secondKeySet();
      Tree tree1 = tree0.deepCopy();
      tree0.addChild(tree1);
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag("9J-(^W?");
      wordLemmaTag1.labelFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      int int0 = 2052;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(treeGraphNode0, false, 2052, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      double[][][] doubleArray0 = new double[1][7][3];
      double[][] doubleArray1 = new double[31][6];
      doubleArray1[1] = doubleArray1[0];
      TwoDimensionalMap<String, String, double[][][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][][]>();
      threeDimensionalMap0.put("*dv", "averagePerceptron", ";D<Lh^9_rFO%q$Y+9", doubleArray0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      threeDimensionalMap0.getTwoDimensionalMap("_?xV`;{UV,R;P{2");
      MapFactory.arrayMapFactory();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode1.deepCopy();
      treeGraphNode1.addChild(tree0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SimpleTree simpleTree1 = new SimpleTree();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>(100);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) simpleTree1, false, identityHashMap1, identityHashMap1, identityHashMap2, identityHashMap3);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      BobChrisTreeNormalizer bobChrisTreeNormalizer1 = new BobChrisTreeNormalizer();
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      TwoDimensionalMap.treeMap();
      TreeGraphNode treeGraphNode1 = (TreeGraphNode)treeGraphNode0.deepCopy();
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      MemoryTreebank memoryTreebank0 = negraPennTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode1, memoryTreebank0);
      treeGraphNode1.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode3 = new TreeGraphNode(treeGraphNode0, memoryTreebank0);
      TreeGraphNode treeGraphNode4 = treeGraphNode3.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode5 = (TreeGraphNode)treeGraphNode4.deepCopy();
      treeGraphNode3.addChild((Tree) treeGraphNode5);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("l*qx5y(tL-q)d0).U");
      splittingGrammarExtractor0.DEBUG();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      double[] doubleArray0 = new double[0];
      splittingGrammarExtractor1.mergeTransitions(treeGraphNode4, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, doubleArray0, hashMap0);
      assertArrayEquals(new double[] {}, doubleArray0, 0.01);
  }

  @Test(timeout = 4000)
  public void testMergeTransitions0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Morphology morphology0 = new Morphology();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(" _FGn ", " _FGn ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode0, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, (double[]) null, hashMap0);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsAndRecountTreeTaking6ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<SimpleTree, double[][][]> identityHashMap3 = new IdentityHashMap<SimpleTree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>(identityHashMap3);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) simpleTree0, false, identityHashMap2, identityHashMap2, identityHashMap0, identityHashMap4);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithNegativeAndExtractTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("CFb g&WTH");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap1.remove("lKed3", "__ < ((@PUNC < \") !$ (@PUNC < \"))", (String) null);
      threeDimensionalMap0.secondKeySet();
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag((String) null);
      wordLemmaTag0.labelFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0, (double) 100, (Collection<Tree>) treeGraphNode0, (-1257.0533101271508));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 2658, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitionsWithNull()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0, (List<Tree>) null);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode0, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, (double[]) null, hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode2, doubleArray0, 100, identityHashMap1, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[4];
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 100, identityHashMap1, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecountWeights()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(".$$.");
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode2.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag(".$$.");
      splittingGrammarExtractor0.DEBUG();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recountWeights(treeGraphNode2, identityHashMap3, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStatesThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode2);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("j");
      wordLemmaTag0.labelFactory();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.outputTransitions((Tree) treeGraphNode1, 0, identityHashMap1, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("bh|");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString("\u1CF0");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      identityHashMap0.put("\u1CF0", doubleArray0);
      double[] doubleArray1 = new double[0];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray1, (-1), identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException4()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      BobChrisTreeNormalizer bobChrisTreeNormalizer1 = new BobChrisTreeNormalizer();
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", "@yu.oq,wNg", "@yu.oq,wNg");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SimpleTree simpleTree1 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.9999000099990001;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 749, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesThrowsNullPointerException()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashIndex<Tree> hashIndex0 = new HashIndex<Tree>(100);
      DeltaIndex<Tree> deltaIndex0 = new DeltaIndex<Tree>(hashIndex0);
      Tree tree0 = null;
      hashIndex0.add((Tree) null);
      hashIndex0.add((Tree) null);
      double double0 = (-597.3861);
      splittingGrammarExtractor0.saveTrees(deltaIndex0, 0.0, deltaIndex0, (-597.3861));
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countOriginalStates();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(".$$.");
      wordLemmaTag0.labelFactory();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.mergeStates();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      System.setCurrentTimeMillis(87543875943265L);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(treeGraphNode1, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      StringReader stringReader0 = new StringReader("@PP > (@__=p1 > __=p2)");
      Morphology morphology0 = new Morphology(stringReader0);
      WordTag.valueOf("@PP > (@__=p1 > __=p2)", "@PP > (@__=p1 > __=p2)");
      treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      Tree tree0 = treeGraphNode1.treeSkeletonConstituentCopy();
      treeGraphNode0.addChild(tree0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) treeGraphNode1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsNullPointerExceptionAndRecalculateBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(".$$.");
      wordLemmaTag0.setTag("IFpVQV>\"#-R$");
      wordLemmaTag0.labelFactory();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[8][2][7];
      IdentityHashMap<String, double[][][]> identityHashMap0 = new IdentityHashMap<String, double[][][]>();
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = 0.0;
      IdentityHashMap<String, double[][]> identityHashMap1 = new IdentityHashMap<String, double[][]>();
      threeDimensionalMap0.put("c7<n", "c7<n", "c7<n", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      splittingGrammarExtractor0.outputBetas();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(".$$.");
      wordLemmaTag0.labelFactory();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 2, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4ArgumentsWithTreeWhereScoreIsPositive0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("Hh", "Hh");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNode1.treeSkeletonCopy((TreeFactory) treeGraphNodeFactory0);
      treeGraphNode0.addChild(tree0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(treeGraphNode1, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4Arguments0()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      Vector<Tree> vector0 = new Vector<Tree>();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, vector0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      treeGraphNode2.addChild((Tree) treeGraphNode0);
      TwoDimensionalMap.treeMap();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode2, 100, identityHashMap2, identityHashMap1);
      SimpleTree simpleTree0 = new SimpleTree();
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndMergeStatesAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, false, 100, true);
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", (String) null, (String) null);
      threeDimensionalMap0.secondKeySet();
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("@yu.oq,wNg");
      wordLemmaTag0.labelFactory();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, (-1), (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
      splittingGrammarExtractor0.recalculateBetas(true);
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4ArgumentsWithTreeWhereScoreIsPositive1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      TwoDimensionalMap.treeMap();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      double[][][] doubleArray0 = new double[0][0][3];
      threeDimensionalMap0.put(",", ",", "hy0(+LcI", doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputBetas();
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      BobChrisTreeNormalizer bobChrisTreeNormalizer1 = new BobChrisTreeNormalizer();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", "@yu.oq,wNg", "@yu.oq,wNg");
      options0.dcTags = true;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("]$ ");
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[6];
      intArray0[0] = 100;
      intArray0[1] = 100;
      intArray0[2] = 100;
      intArray0[3] = 100;
      intArray0[4] = 100;
      intArray0[5] = 100;
      hashMap0.put("@yu.oq,wNg", intArray0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      Integer integer0 = new Integer(Integer.MAX_VALUE);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple(null, integer0, 0.0);
      Integer integer1 = new Integer(100);
      Triple<String, Integer, Double> triple1 = new Triple<String, Integer, Double>("/u/scr/nlp/deeplearning/datasets/turian/embeddings-scaled.EMBEDDING_SIZE=25.txt", integer1, (Double) 0.0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple1, triple0, triple0, triple1, triple1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.thirdKeySet();
      String string0 = "Fuzzy Equality";
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("cK+Z*gz,F?O", (Integer) 100, (Double) 0.0);
      Integer integer0 = new Integer((-2587));
      Double double0 = new Double(0.0);
      Triple<String, Integer, Double> triple1 = Triple.makeTriple("Rfq-3meMl!`G]DOct_w", integer0, double0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple1, triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.memoryTreebank();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      threeDimensionalMap0.remove("*VVokWPQ3-LC", "95J(36xs$3m01>", "Recalculating temporary betas for tree ");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      boolean boolean0 = twoDimensionalMap0.isEmpty();
      twoDimensionalMap0.getMap("*VVokWPQ3-LC");
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      boolean boolean1 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap1);
      assertTrue(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, false);
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", (String) null, (String) null);
      threeDimensionalMap0.secondKeySet();
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(": ");
      wordLemmaTag0.labelFactory();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, true);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor1.recountInside(treeGraphNode0, false, 84772, identityHashMap0);
      Random.setNextRandom(1);
      int int1 = splittingGrammarExtractor0.recountInside(treeGraphNode0, false, (-3213), identityHashMap1);
      assertFalse(int1 == int0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasWithTrue1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[9][3];
      twoDimensionalMap0.put(".$$.", ".$$.", doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndUseNewBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[9][1][9];
      threeDimensionalMap0.put(">6MA", ">6MA", ">6MA", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountWeightsAndRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, false, 100, true);
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", (String) null, (String) null);
      threeDimensionalMap0.secondKeySet();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(": ");
      wordLemmaTag0.labelFactory();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      int int0 = 1947;
      splittingGrammarExtractor0.recountInside(treeGraphNode0, options0.freeDependencies, int0, identityHashMap1);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[0][6][3];
      identityHashMap3.put(treeGraphNode0, doubleArray0);
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap1, identityHashMap1, identityHashMap2, identityHashMap3);
      splittingGrammarExtractor0.recurseOutside(treeGraphNode0, identityHashMap1, identityHashMap1);
  }

  @Test(timeout = 4000)
  public void testRecountInside()  throws Throwable  {
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      treeGraphNode0.getChildrenAsList();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(treeGraphNode0, categoryWordTag0.printWordTag, options0.rerankerKBest, identityHashMap0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasThrowsNullPointerException()  throws Throwable  {
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      twoDimensionalMap1.remove("i2", "i2");
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor1.splitBetas();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetas3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.get("altAnswerFile", "altAnswerFile");
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithZero()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding("*VVokWPQ3-LC");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.remove((String) null, (String) null, "*VVokWPQ3-LC");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap1, threeDimensionalMap0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, memoryTreebank0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode1.deepCopy();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("*VVokWPQ3-LC");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor1.saveTrees(memoryTreebank0, 100, tree0, 0.0);
      splittingGrammarExtractor0.DEBUG();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor3.recountWeights(treeGraphNode1, identityHashMap3, identityHashMap3, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>(100);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(treeGraphNode1, identityHashMap0, identityHashMap0, identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(treeGraphNode1, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, false, 100, true);
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", (String) null, (String) null);
      threeDimensionalMap0.secondKeySet();
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(": ");
      wordLemmaTag0.labelFactory();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(treeGraphNode0, false, 1947, identityHashMap1);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[0][6][3];
      identityHashMap3.put(tree0, doubleArray0);
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap1, identityHashMap1, identityHashMap2, identityHashMap3);
      splittingGrammarExtractor0.recurseOutside(treeGraphNode0, identityHashMap0, identityHashMap0);
      Tree tree1 = treeGraphNode0.flatten();
      splittingGrammarExtractor0.recurseOutside(tree1, identityHashMap1, identityHashMap1);
      assertNotSame(identityHashMap1, identityHashMap0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerExceptionAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding("*VVokWPQ3-LC");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      threeDimensionalMap0.remove(" trees with total weight ", "Pre-split betas", " trees with total weight ");
      threeDimensionalMap0.secondKeySet();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("AFTER_KEY");
      wordLemmaTag0.labelFactory();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.treeMap();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "Pre-split betas");
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(treeGraphNode0, true, 100, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerExceptionAndDEBUGAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", (String) null, (String) null);
      threeDimensionalMap0.secondKeySet();
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("]$ ");
      splittingGrammarExtractor0.DEBUG();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      Reader reader0 = Reader.nullReader();
      BufferedReader bufferedReader0 = new BufferedReader(reader0);
      Morphology morphology0 = new Morphology(bufferedReader0, 1071);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap1.transform(morphology0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountOutside(tree0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", (String) null, (String) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("@yu.oq,wNg");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.DEBUG();
      TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor1.saveTrees(simpleTree0, 0.1, (Collection<Tree>) null, 0.9999000099990001);
      splittingGrammarExtractor0.DEBUG();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor2.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      BobChrisTreeNormalizer bobChrisTreeNormalizer1 = new BobChrisTreeNormalizer();
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", (String) null, (String) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("@yu.oq,wNg");
      wordLemmaTag0.labelFactory();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>(hashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) identityHashMap3, (Map<String, double[]>) identityHashMap3, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithEmptyMap1()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("", "");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeReturningZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      BobChrisTreeNormalizer bobChrisTreeNormalizer1 = new BobChrisTreeNormalizer();
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", (String) null, (String) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("]$ ");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      splittingGrammarExtractor0.saveTrees(tree0, 0.0, simpleTree0, 0.9999000099990001);
      splittingGrammarExtractor1.DEBUG();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor2.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap3, identityHashMap1, identityHashMap2);
      int int0 = splittingGrammarExtractor2.getStateSplitCount((Tree) treeGraphNode0);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsArrayIndexOutOfBoundsException2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory('B');
      Label label0 = wordTagFactory0.newLabel(">NVH1S");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('B');
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label1 = stringLabelFactory0.newLabel(".$$.");
      Label label2 = wordLemmaTagFactory0.newLabel(label1);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label2);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNode1.treeSkeletonCopy((TreeFactory) treeGraphNodeFactory0);
      treeGraphNode0.addChild(tree0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      BobChrisTreeNormalizer bobChrisTreeNormalizer1 = new BobChrisTreeNormalizer();
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", (String) null, (String) null);
      threeDimensionalMap0.secondKeySet();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Tree tree0 = treeGraphNode0.deepCopy();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("]$ ");
      wordLemmaTag0.labelFactory();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(treeGraphNode0, false, 1947, identityHashMap1);
      Random.setNextRandom(1);
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInsideWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode1, false, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecalculateBetas()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("CFb g&WTH");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap1.remove("lKed3", "__ < ((@PUNC < \") !$ (@PUNC < \"))", (String) null);
      threeDimensionalMap0.secondKeySet();
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag((String) null);
      wordLemmaTag0.labelFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(treeGraphNode0, true, 100, identityHashMap0);
      Random.setNextRandom(1889);
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsWithTrueAndEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding("*VVokWPQ3-LC");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      double[][][] doubleArray0 = new double[1][8][3];
      double[][] doubleArray1 = new double[19][6];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = 0.0;
      doubleArray1[1] = doubleArray3;
      threeDimensionalMap0.put("*dv", "averagePerceptron", ";D<Lh^9_rFO%q$Y+9", doubleArray0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      threeDimensionalMap0.getTwoDimensionalMap("_?xV`;{UV,R;P{2");
      MapFactory.arrayMapFactory();
      ItalianTreebankParserParams italianTreebankParserParams1 = new ItalianTreebankParserParams();
      italianTreebankParserParams1.treeReaderFactory();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      threeDimensionalMap0.secondKeySet();
      splittingGrammarExtractor0.extract((Collection<Tree>) memoryTreebank0, 30.0, (Collection<Tree>) memoryTreebank0, 1128.9426282);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap2, identityHashMap3, identityHashMap0, identityHashMap4);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) simpleTree0, true, identityHashMap0, identityHashMap4);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Morphology morphology0 = new Morphology();
      WordTag wordTag0 = new WordTag(" Gn ", " Gn ");
      WordLemmaTag wordLemmaTag0 = morphology0.lemmatize(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[1][8];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("`Fbd^LTHW", "ma M61*m#w", doubleArray0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateBetas(true);
      WordFactory wordFactory0 = new WordFactory();
      wordFactory0.newLabelFromString(" Gn ");
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasWithFalse1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.get("altAnswerFile", "altAnswerFile");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsArrayIndexOutOfBoundsExceptionAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("CFb g&WTH");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      List<Tree> list0 = treeGraphNode1.postOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode1, list0);
      treeGraphNode0.addChild((Tree) treeGraphNode2);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(true);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) treeGraphNode0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      BobChrisTreeNormalizer bobChrisTreeNormalizer1 = new BobChrisTreeNormalizer();
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", (String) null, (String) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.addChild(tree0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("]$ ");
      wordLemmaTag0.labelFactory();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      threeDimensionalMap0.secondKeySet();
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0, 30.0, (Collection<Tree>) treeGraphNode0, 0.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsNullPointerException3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNonEmptyMapAndSaveTreesWithNegative()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap1.put("%ICC&vjF4", "%ICC&vjF4", "BLt<Qm#,", (double[][][]) null);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.outputBetas();
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.DEBUG();
      TwoDimensionalMap.identityHashMap();
      SplittingGrammarExtractor splittingGrammarExtractor4 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor4.saveTrees(simpleTree0, (-2769.945), simpleTree0, 0.9999000099990001);
      splittingGrammarExtractor1.DEBUG();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      identityHashMap4.put(simpleTree0, (double[][][]) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) simpleTree0, list0);
      splittingGrammarExtractor3.recountWeights(tree0, identityHashMap2, identityHashMap2, identityHashMap3, identityHashMap4);
      Tree tree1 = treeGraphNode0.flatten((TreeFactory) treeGraphNodeFactory0);
      splittingGrammarExtractor0.outputTransitions(tree1, (-1581), identityHashMap3, identityHashMap4);
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor2);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException2()  throws Throwable  {
      Options options0 = new Options();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(".$$.", ".$$.");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNode0.treeSkeletonCopy((TreeFactory) treeGraphNodeFactory0);
      treeGraphNode0.addChild(tree0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[17][11][2];
      threeDimensionalMap0.put("bR9$ 7)kwL>", "bR9$ 7)kwL>", "bR9$ 7)kwL>", doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding("*VVokWPQ3-LC");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      double[][][] doubleArray0 = new double[1][6][3];
      double[][] doubleArray1 = new double[2][6];
      double[] doubleArray2 = new double[1];
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = 0.0;
      doubleArray1[1] = doubleArray3;
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("K", "averagePerceptron", "_?xV`;{U,R;P{2", doubleArray0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      threeDimensionalMap0.getTwoDimensionalMap("_?xV`;{U,R;P{2");
      MapFactory.arrayMapFactory();
      ItalianTreebankParserParams italianTreebankParserParams1 = new ItalianTreebankParserParams();
      italianTreebankParserParams1.treeReaderFactory();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountInside(simpleTree0, false, 9994, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStateWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding("3P");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.size();
      SimpleTree simpleTree0 = new SimpleTree();
      threeDimensionalMap0.thirdKeySet();
      SimpleTree simpleTree1 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.state("3P", (-113));
      splittingGrammarExtractor1.saveTrees(simpleTree1, (-31.4), simpleTree1, 100);
      splittingGrammarExtractor0.DEBUG();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.DEBUG();
      TwoDimensionalMap.identityHashMap();
      Reader.nullReader();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      identityHashMap3.put(simpleTree0, (double[]) null);
      splittingGrammarExtractor1.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) identityHashMap2, (Map<String, double[]>) identityHashMap2, identityHashMap3, identityHashMap3);
      assertEquals(1, identityHashMap3.size());
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding("*VVokWPQ3-LC");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      double[][][] doubleArray0 = new double[1][6][3];
      double[][] doubleArray1 = new double[2][6];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = 0.0;
      doubleArray1[1] = doubleArray3;
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("K", "averagePerceptron", "_?xV`;{U,R;P{2", doubleArray0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      threeDimensionalMap0.getTwoDimensionalMap("_?xV`;{U,R;P{2");
      MapFactory.arrayMapFactory();
      ItalianTreebankParserParams italianTreebankParserParams1 = new ItalianTreebankParserParams();
      italianTreebankParserParams1.treeReaderFactory();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountInside(simpleTree0, false, 9994, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceReturningFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      double[][][] doubleArray0 = new double[1][8][3];
      double[][] doubleArray1 = new double[31][6];
      doubleArray1[1] = doubleArray1[0];
      TwoDimensionalMap<String, String, double[][][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][][]>();
      threeDimensionalMap0.put("*dv", "averagePerceptron", ";D<Lh^9_rFO%q$Y+9", doubleArray0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      threeDimensionalMap0.getTwoDimensionalMap("_?xV`;{UV,R;P{2");
      MapFactory.arrayMapFactory();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Reader reader0 = Reader.nullReader();
      Morphology morphology0 = new Morphology(reader0, (-1938387115));
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap2, threeDimensionalMap1);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndMergeStatesAndOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      double[][][] doubleArray0 = new double[1][7][3];
      double[][] doubleArray1 = new double[31][6];
      doubleArray1[1] = doubleArray1[0];
      TwoDimensionalMap<String, String, double[][][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][][]>();
      threeDimensionalMap0.put("*dv", "averagePerceptron", ";D<Lh^9_rFO%q$Y+9", doubleArray0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      threeDimensionalMap0.getTwoDimensionalMap("|`T:fSi}");
      MapFactory.arrayMapFactory();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Reader reader0 = Reader.nullReader();
      Morphology morphology0 = new Morphology(reader0, (-1938387115));
      splittingGrammarExtractor0.outputBetas();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testOutputBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[8][2][7];
      double[][] doubleArray1 = new double[3][3];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      doubleArray1[1] = doubleArray2;
      IdentityHashMap<String, double[][][]> identityHashMap0 = new IdentityHashMap<String, double[][][]>();
      IdentityHashMap<String, double[][]> identityHashMap1 = new IdentityHashMap<String, double[][]>();
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("c7<n", "c7<n", "c7<n", doubleArray0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndBuildMergeCorrespondenceAndUseNewBetas()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[1];
      intArray0[0] = 100;
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.countOriginalStates();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.setGenerateOriginalDependencies(true);
      List<Tree> list0 = splittingGrammarExtractor0.trees;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("w@%iV", "2gOsD,pR%%`;oG[", "w@%iV");
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("T8F/9pY_:");
      wordLemmaTag0.labelFactory();
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap3 = new TwoDimensionalMap<String, String, double[][]>();
      IdentityFunction<double[][]> identityFunction0 = new IdentityFunction<double[][]>();
      twoDimensionalMap3.transform(identityFunction0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap4 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap4, threeDimensionalMap0);
      assertNotSame(twoDimensionalMap4, twoDimensionalMap1);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      List<Tree> list0 = splittingGrammarExtractor0.trees;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap3 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("` 2k^100", "J8t4", "` 2k^100");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap4 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap4, threeDimensionalMap0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("w@%iV");
      CoreLabel.factory();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.outputBetas();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.DEBUG();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>(368);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor2.recountWeights(simpleTree0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      assertEquals(0, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4Arguments()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabel("");
      SimpleTree simpleTree0 = new SimpleTree(label0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) simpleTree0, false, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.getStateSplitCount("2gOsD,pR%%`;oG[");
      splittingGrammarExtractor0.getStateSplitCount(":p$<tTep");
      splittingGrammarExtractor1.countOriginalStates();
      SimpleTree simpleTree0 = new SimpleTree();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.put("Q5KN&FXJ.", "2gOsD,pR%%`;oG[", "UxLwr#P<", (double[][][]) null);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      threeDimensionalMap0.getTwoDimensionalMap((String) null);
      MapFactory.arrayMapFactory();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.treeReaderFactory();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.recountWeights(simpleTree0, identityHashMap1, identityHashMap1, identityHashMap0, identityHashMap3);
      assertTrue(identityHashMap3.equals((Object)identityHashMap2));
  }

  @Test(timeout = 4000)
  public void testRecountWeights()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      assertTrue(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      SimpleTree simpleTree1 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabelFactory labelFactory0 = LabeledWord.factory();
      Tree tree0 = treeGraphNode0.deepCopy((TreeFactory) labeledScoredTreeFactory0, labelFactory0);
      treeGraphNode0.highestNodeWithSameHead();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, identityHashMap1, identityHashMap0);
      splittingGrammarExtractor0.buildStateIndex();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode0, (List<Tree>) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, tree0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.getStateSplitCount("2gOsD,pR%%`;oG[");
      splittingGrammarExtractor0.getStateSplitCount("V=w{WY\"7>#j2.9r+X|");
      splittingGrammarExtractor1.countOriginalStates();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor3.binaryBetas;
      TwoDimensionalMap<String, String, double[][][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][][]>();
      threeDimensionalMap0.contains("69v5;s<\"", "I]x<d", ":p$<tTep");
      MapFactory.arrayMapFactory();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor3.DEBUG();
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor3.getStateSplitCount(" trees with total weight ");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor2.unaryBetas;
      Function<double[][], double[][]> function0 = Function.identity();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = twoDimensionalMap1.transform(function0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap2, threeDimensionalMap0);
      Tree tree0 = null;
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>(0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recountWeights((Tree) null, identityHashMap2, identityHashMap2, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("-PL", 100, 0.0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(list0);
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndSaveTrees()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor1.buildStateIndex();
      System.setCurrentTimeMillis(100);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      MemoryTreebank memoryTreebank0 = hebrewTreebankParserParams0.memoryTreebank();
      splittingGrammarExtractor0.extract((Collection<Tree>) memoryTreebank0, (double) 100, (Collection<Tree>) memoryTreebank0, (-11.0));
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank1 = englishTreebankParserParams0.memoryTreebank();
      splittingGrammarExtractor1.saveTrees(memoryTreebank1, 100, memoryTreebank0, 400.0);
      QPTreeTransformer qPTreeTransformer0 = null;
      try {
        qPTreeTransformer0 = new QPTreeTransformer(false);
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.memoryTreebank();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      threeDimensionalMap0.remove("*VVokWPQ3-LC", "95J(36xs$3m01>", "Recalculating temporary betas for tree ");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.getMap("*VVokWPQ3-LC");
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndTestConvergenceAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.remove("auZ,p`8=/',", "UNARY:", "auZ,p`8=/',");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.getMap("r0-!a@k");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithZeroAndNegative()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      System.setCurrentTimeMillis(100);
      MemoryTreebank memoryTreebank0 = hebrewTreebankParserParams0.memoryTreebank();
      splittingGrammarExtractor0.extract((Collection<Tree>) memoryTreebank0, 0.0, (Collection<Tree>) memoryTreebank0, (-627.76472));
      splittingGrammarExtractor0.saveTrees(memoryTreebank0, 0.0, memoryTreebank0, (-1535.807629398312));
      QPTreeTransformer qPTreeTransformer0 = null;
      try {
        qPTreeTransformer0 = new QPTreeTransformer(false);
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) simpleTree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTree()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount((String) null);
      splittingGrammarExtractor0.getStateSplitCount((String) null);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      MapFactory.arrayMapFactory();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      simpleTree0.subTrees();
      double[] doubleArray0 = new double[0];
      splittingGrammarExtractor1.mergeTransitions(simpleTree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, (Map<String, int[]>) null);
      splittingGrammarExtractor1.recalculateBetas(false);
      splittingGrammarExtractor1.outputBetas();
      splittingGrammarExtractor1.getStateSplitCount("ufM_#B9%");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor1.unaryBetas;
      Function<double[][], double[][]> function0 = Function.identity();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = twoDimensionalMap1.transform(function0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor2.binaryBetas;
      splittingGrammarExtractor2.rescaleTemporaryBetas(twoDimensionalMap2, threeDimensionalMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.getStateSplitCount((Tree) simpleTree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 100;
      intArray0[1] = 100;
      hashMap0.put("2gOsD,pR%%`;oG[", intArray0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.countOriginalStates();
      Word word0 = new Word();
      List<Tree> list0 = splittingGrammarExtractor0.trees;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0, list0);
      Tree tree0 = treeGraphNode0.deepCopy();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      double[] doubleArray0 = new double[0];
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 9973, identityHashMap0, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Tree tree1 = chineseTreebankParserParams0.transformTree(tree0, treeGraphNode0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects(tree1, (Map<String, double[]>) identityHashMap2, (Map<String, double[]>) identityHashMap2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergence()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      italianTreebankParserParams0.treeTokenizerFactory();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding(";D<Lh^9_rFO%q$Y+9");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      options0.doPCFG = false;
      threeDimensionalMap0.getTwoDimensionalMap("rt");
      MapFactory.arrayMapFactory();
      italianTreebankParserParams0.treeReaderFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsNullPointerException()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      options0.lexOptions = options0.lexOptions;
      italianTreebankParserParams0.treeTokenizerFactory();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding(";D<Lh^9_rFO%q$Y+9");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      threeDimensionalMap0.thirdKeySet();
      threeDimensionalMap0.put("/u/scr/nlp/deeplearning/datasets/turian/embeddings-scaled.EMBEDDING_SIZE=25.txt", (String) null, (String) null, (double[][][]) null);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.op = options0;
      splittingGrammarExtractor1.DEBUG();
      splittingGrammarExtractor1.outputBetas();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.DEBUG();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      Reader reader0 = Reader.nullReader();
      BufferedReader bufferedReader0 = new BufferedReader(reader0);
      Morphology morphology0 = new Morphology(bufferedReader0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(morphology0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding("*VVokWPQ3-LC");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      double[][][] doubleArray0 = new double[1][6][3];
      double[][] doubleArray1 = new double[2][6];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap1.put((String) null, (String) null, "*VVokWPQ3-LC", doubleArray0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.DEBUG();
      splittingGrammarExtractor2.outputBetas();
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.identityHashMap();
      Reader reader0 = Reader.nullReader();
      BufferedReader bufferedReader0 = new BufferedReader(reader0);
      Morphology morphology0 = new Morphology(reader0);
      twoDimensionalMap0.transform(morphology0);
      SplittingGrammarExtractor splittingGrammarExtractor4 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor4.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap1);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeExceptionAndRecalculateBetas()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(".$$.");
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = 720;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(treeGraphNode1, true, 720, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeExceptionAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 100;
      intArray0[1] = 100;
      hashMap0.put("2gOsD,pR%%`;oG[", intArray0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.countOriginalStates();
      Word word0 = new Word();
      List<Tree> list0 = splittingGrammarExtractor0.trees;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0, list0);
      Tree tree0 = treeGraphNode0.deepCopy();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      double[] doubleArray0 = new double[0];
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 9973, identityHashMap0, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree0, true, 582, identityHashMap3);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStatesAndMergeStates()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      italianTreebankParserParams0.memoryTreebank();
      splittingGrammarExtractor0.getStateSplitCount((String) null);
      splittingGrammarExtractor0.getStateSplitCount((String) null);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      MapFactory<List<String>, List<Object>> mapFactory0 = MapFactory.arrayMapFactory();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      mapFactory0.setMap(null, 0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      splittingGrammarExtractor0.recalculateBetas(true);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.getStateSplitCount("/u/scr/nlp/deeplearning/datasets/turian/embeddings-scaled.EMBEDDING_SIZE=25.txt");
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor1.mergeStates();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 100;
      intArray0[1] = 100;
      hashMap0.put("2gOsD,pR%%`;oG[", intArray0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.countOriginalStates();
      Word word0 = new Word();
      List<Tree> list0 = splittingGrammarExtractor0.trees;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0, list0);
      treeGraphNode0.deepCopy();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.getStateSplitCount("ll[9&~");
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (-677.836391003);
      doubleArray0[4] = (-874.8);
      doubleArray0[5] = (double) 0;
      doubleArray0[6] = 0.0;
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.treeMapFactory();
      Comparator<String> comparator0 = (Comparator<String>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<String, double[][]> mapFactory1 = MapFactory.treeMapFactory(comparator0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 0, identityHashMap0, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding("*VVokWPQ3-LC");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.remove((String) null, (String) null, "*VVokWPQ3-LC");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, memoryTreebank0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      threeDimensionalMap0.remove((String) null, ",", "`zfv%");
      twoDimensionalMap0.getMap("*VVokWPQ3-LC");
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag((String) null, "`zfv%", "*VVokWPQ3-LC");
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(wordLemmaTag0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
      splittingGrammarExtractor0.recalculateBetas(true);
      TreeGraphNode treeGraphNode3 = treeGraphNode1.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode4 = treeGraphNode3.highestNodeWithSameHead();
      treeGraphNode4.parent();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) null, true, identityHashMap1, identityHashMap1, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStatesAndCountMergeEffectsTaking5ArgumentsAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      BobChrisTreeNormalizer bobChrisTreeNormalizer1 = new BobChrisTreeNormalizer();
      simpleTree0.isPrePreTerminal();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("@yu.oq,wNg", (String) null, (String) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.getMap("\"S");
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer2 = new BobChrisTreeNormalizer();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(simpleTree0);
      MapFactory.identityHashMapFactory();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor1.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
      splittingGrammarExtractor0.mergeStates();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasWithTrue2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[3][2][7];
      double[] doubleArray1 = new double[0];
      threeDimensionalMap0.put("cy<n", "cy<n", "cy<n", doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[3][1][7];
      threeDimensionalMap0.put("<7<n", "<7<n", "<7<n", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[11][1][9];
      threeDimensionalMap0.put(">6MA", ">6MA", ">6MA", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testDEBUGThrowsRuntimeException()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      italianTreebankParserParams0.treeTokenizerFactory();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding(";D<Lh^9_rFO%q$Y+9");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount("");
      splittingGrammarExtractor0.getStateSplitCount("-xepIoG{4sI");
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      italianTreebankParserParams0.setInputEncoding("rt");
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.lastChild();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, (IdentityHashMap<Tree, double[]>) null, identityHashMap0);
      String string0 = ".$$.";
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, identityHashMap1, identityHashMap2);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      SimpleTree simpleTree0 = new SimpleTree();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsWithNullAndEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 100;
      intArray0[1] = 100;
      hashMap0.put("2gOsD,pR%%`;oG[", intArray0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.countOriginalStates();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.setGenerateOriginalDependencies(false);
      List<Tree> list0 = splittingGrammarExtractor0.trees;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap1, threeDimensionalMap0);
      Word word0 = Word.EMPTY;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0, list0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      word0.setBeginPosition(9963);
      treeGraphNode1.firstChild();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, (Tree) null, (Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesThrowsNullPointerException()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      twoDimensionalMap0.iterator();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.saveTrees((Collection<Tree>) null, (-1.0), (Collection<Tree>) null, 232.75797);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 100;
      intArray0[1] = 100;
      hashMap0.put("2gOsD,pR%%`;oG[", intArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.treeMap();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateBetas(true);
      splittingGrammarExtractor1.testConvergence(twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("");
      LabelFactory labelFactory0 = wordLemmaTag0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndRecurseOutside()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      italianTreebankParserParams0.treeTokenizerFactory();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding(";D<Lh^9_rFO%q$Y+9");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount("");
      splittingGrammarExtractor0.getStateSplitCount("-xepIoG{4sI");
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      LabelFactory labelFactory0 = IndexedWord.factory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      String string0 = ": ";
      Tree tree0 = treeGraphNodeFactory0.newLeaf(": ");
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tree0, 1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, memoryTreebank0);
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, (String) null);
      CategoryWordTagFactory categoryWordTagFactory0 = new CategoryWordTagFactory();
      categoryWordTagFactory0.newLabel((Label) treeGraphNode0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(simpleTree0);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(simpleTree0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode2.postOrderNodeList();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode2, 420.91978853488024, (Collection<Tree>) list0, 1.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndDEBUG()  throws Throwable  {
      Options options0 = new Options();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding("*VVokWPQ3-LC");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.remove((String) null, (String) null, "*VVokWPQ3-LC");
      TwoDimensionalMap.treeMap();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, memoryTreebank0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.deepCopy();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("*VVokWPQ3-LC");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor3.mergeStates();
      System.setCurrentTimeMillis((-114L));
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recurseOutside(treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 100;
      intArray0[1] = 100;
      hashMap0.put("2gOsD,pR%%`;oG[", intArray0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory<List<String>, List<Object>> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory.arrayMapFactory();
      mapFactory0.setMap(null, 100);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.9;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = (double) 100;
      doubleArray0[6] = (double) 100;
      doubleArray0[7] = Double.POSITIVE_INFINITY;
      doubleArray0[8] = (double) 100;
      splittingGrammarExtractor0.mergeTransitions(simpleTree0, identityHashMap0, identityHashMap1, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, hashMap0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
      
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.getStateSplitCount(".$$.");
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecalculateTemporaryBetasTaking8ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 100, identityHashMap1, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndUseNewBetasWithTrue()  throws Throwable  {
      Options options0 = new Options();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[2][3];
      doubleArray0[1] = doubleArray0[0];
      twoDimensionalMap0.put("ma M61*m#w", "ma M61*m#w", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      SimpleTree simpleTree0 = new SimpleTree();
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringWithNull()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount((String) null);
      splittingGrammarExtractor0.getStateSplitCount((String) null);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      MapFactory<List<String>, List<Object>> mapFactory0 = MapFactory.arrayMapFactory();
      mapFactory0.setMap(null, 0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      splittingGrammarExtractor0.mergeTransitions(simpleTree0, identityHashMap0, identityHashMap1, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, (Map<String, int[]>) null);
      splittingGrammarExtractor0.recalculateBetas(true);
      splittingGrammarExtractor0.outputBetas();
      int int0 = splittingGrammarExtractor0.getStateSplitCount("/u/scr/nlp/deeplearning/datasets/turian/embeddings-scaled.EMBEDDING_SIZE=25.txt");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testOutputBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 100;
      intArray0[1] = 100;
      hashMap0.put("2gOsD,pR%%`;oG[", intArray0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.countOriginalStates();
      Word word0 = new Word();
      List<Tree> list0 = splittingGrammarExtractor0.trees;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0, list0);
      Tree tree0 = treeGraphNode0.deepCopy();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, (-1731), identityHashMap0, identityHashMap1);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4Arguments1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap0);
      SimpleTree simpleTree0 = new SimpleTree();
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 100;
      intArray0[1] = 100;
      hashMap0.put("2gOsD,pR%%`;oG[", intArray0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.countOriginalStates();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.setGenerateOriginalDependencies(true);
      List<Tree> list0 = splittingGrammarExtractor0.trees;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Word word0 = Word.EMPTY;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0, list0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      word0.setBeginPosition(100);
      treeGraphNode1.firstChild();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) null, (Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetas()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap1, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 100;
      intArray0[1] = 100;
      hashMap0.put("2gOsD,pR%%`;oG[", intArray0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.countOriginalStates();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.setGenerateOriginalDependencies(true);
      List<Tree> list0 = splittingGrammarExtractor0.trees;
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      CoreLabel coreLabel0 = new CoreLabel(100);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(true);
      coreLabelTokenFactory0.makeToken(coreLabel0);
      CategoryWordTagFactory categoryWordTagFactory0 = new CategoryWordTagFactory();
      Label label0 = categoryWordTagFactory0.newLabel((Label) coreLabel0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list1 = treeGraphNode0.postOrderNodeList();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list1, (double) 100, (Collection<Tree>) list1, 1.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3Arguments()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      italianTreebankParserParams0.treeTokenizerFactory();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding(";D<Lh^9_rFO%q$Y+9");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount("");
      splittingGrammarExtractor0.getStateSplitCount("-xepIoG{4sI");
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.lastChild();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, (IdentityHashMap<Tree, double[]>) null, identityHashMap0);
      splittingGrammarExtractor0.state(".$$.", 1);
      SpanishTreebankParserParams spanishTreebankParserParams0 = null;
      try {
        spanishTreebankParserParams0 = new SpanishTreebankParserParams();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.trees.tregex.TregexParser
         //
         verifyException("edu.stanford.nlp.trees.tregex.TregexPatternCompiler", e);
      }
  }

  @Test(timeout = 4000)
  public void testDEBUGAndRecurseOutside()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      treeGraphNode0.postOrderNodeList();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(treeGraphNode0, identityHashMap0, identityHashMap0);
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateSplittingGrammarExtractorThrowsNoClassDefFoundError()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.state(".$$.", 100);
      SpanishTreebankParserParams spanishTreebankParserParams0 = null;
      try {
        spanishTreebankParserParams0 = new SpanishTreebankParserParams();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.trees.tregex.TregexParser
         //
         verifyException("edu.stanford.nlp.trees.tregex.TregexPatternCompiler", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammars()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      italianTreebankParserParams0.treeTokenizerFactory();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.memoryTreebank();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      englishTreebankParserParams0.setGenerateOriginalDependencies(false);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.extract((Collection<Tree>) memoryTreebank0);
      CoreLabel coreLabel0 = new CoreLabel(62);
      coreLabelTokenFactory0.makeToken(coreLabel0);
      CategoryWordTagFactory categoryWordTagFactory0 = new CategoryWordTagFactory();
      categoryWordTagFactory0.newLabel((Label) coreLabel0);
      Class<CoreAnnotations.FirstChildAnnotation> class0 = CoreAnnotations.FirstChildAnnotation.class;
      coreLabel0.getString(class0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      treeGraphNode0.postOrderNodeList();
      ArrayDeque<Tree> arrayDeque0 = new ArrayDeque<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) arrayDeque0, (double) 0, (Collection<Tree>) arrayDeque0, (double) 1);
      splittingGrammarExtractor0.buildGrammars();
  }

  @Test(timeout = 4000)
  public void testTestConvergenceThrowsNullPointerException()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      italianTreebankParserParams0.treeTokenizerFactory();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding(";D<Lh^9_rFO%q$Y+9");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      threeDimensionalMap0.put("/u/scr/nlp/deeplearning/datasets/turian/embeddings-scaled.EMBEDDING_SIZE=25.txt", (String) null, (String) null, (double[][][]) null);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory.identityHashMapFactory();
      options0.doPCFG = false;
      threeDimensionalMap0.getTwoDimensionalMap("rt");
      MapFactory.arrayMapFactory();
      italianTreebankParserParams0.treeReaderFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap.treeMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndTestConvergence()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      options0.directional = true;
      CoreLabel coreLabel0 = null;
      try {
        coreLabel0 = new CoreLabel((CoreMap) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(hashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0, 0.0, (Collection<Tree>) simpleTree0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithNegativeAndExtractTaking4ArgumentsAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      DiskTreebank diskTreebank0 = negraPennTreebankParserParams0.diskTreebank();
      splittingGrammarExtractor0.extract((Collection<Tree>) diskTreebank0, (-1876.0), (Collection<Tree>) diskTreebank0, (-1876.0));
      splittingGrammarExtractor0.recalculateMergedBetas((Map<String, int[]>) null);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("` 2k", 100);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("", "` 2k", "");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      Tree tree0 = treeGraphNode0.treeSkeletonCopy();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) treeGraphNode0, (-1.0));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceReturningMapWhereIsEmptyIsFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
      
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("Gitt_|");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      treeGraphNode0.getSpan();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      assertEquals(1, map0.size());
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceWithEmptyList()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 100;
      intArray0[1] = 100;
      hashMap0.put("2gOsD,pR%%`;oG[", intArray0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.countOriginalStates();
      Word word0 = new Word();
      List<Tree> list0 = splittingGrammarExtractor0.trees;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0, list0);
      Tree tree0 = treeGraphNode0.deepCopy();
      treeGraphNode0.parent(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollection0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("ib_h|", "ib_h|", "ib_h|");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceReturningMapWhereIsEmptyIsTrueAndMapWhereSizeIsZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[9];
      intArray0[0] = 100;
      intArray0[1] = 100;
      intArray0[2] = 100;
      intArray0[3] = 100;
      intArray0[4] = 100;
      intArray0[5] = 100;
      intArray0[6] = 100;
      intArray0[7] = 100;
      intArray0[8] = 100;
      hashMap0.put("v87TL<7,w,}MFDu=1OF", intArray0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("v87TL<7,w,}MFDu=1OF", 100, 0.0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple0, triple0, triple0, triple0, triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(list0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndGetStateSplitCountTakingString()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      italianTreebankParserParams0.treeTokenizerFactory();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding(";D<Lh^9_rFO%q$Y+9");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount("");
      splittingGrammarExtractor0.getStateSplitCount("");
      options0.dcTags = true;
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.buildStateIndex();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      assertTrue(hashMap0.isEmpty());
      
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("CFb g&WTH");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      List<Tree> list0 = treeGraphNode1.postOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode1, list0);
      treeGraphNode0.addChild((Tree) treeGraphNode2);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(true);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects((Tree) treeGraphNode2, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, (IdentityHashMap<Tree, double[]>) null, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNullAndNull()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      italianTreebankParserParams0.treeTokenizerFactory();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding(";D<Lh^9_rFO%q$Y+9");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount("");
      splittingGrammarExtractor0.getStateSplitCount("");
      options0.dcTags = true;
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, memoryTreebank0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      Tree tree0 = treeGraphNode0.transform((TreeTransformer) bobChrisTreeNormalizer0);
      MapFactory.identityHashMapFactory();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) null, (Map<String, double[]>) null, identityHashMap0, identityHashMap0);
      assertNotSame(treeGraphNode0, tree0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
      assertTrue(hashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasReturningTrue()  throws Throwable  {
      StringReader stringReader0 = new StringReader("RS");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      CharArrayWriter charArrayWriter0 = new CharArrayWriter(76);
      bufferedReader0.transferTo(charArrayWriter0);
      HashIndex.loadFromReader(bufferedReader0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      System.setCurrentTimeMillis(3199L);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.memoryTreebank();
      double double0 = 0.0;
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      // Undeclared exception!
      try { 
        coreLabelTokenFactory0.makeToken((CoreLabel) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexAndRescaleTemporaryBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[3][3];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      doubleArray0[1] = doubleArray1;
      twoDimensionalMap0.put("ma M61*m#w", "ma M61*m#w", doubleArray0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      Word word0 = Word.EMPTY;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndRecalculateBetasAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      StringReader stringReader0 = new StringReader("V=w{WY\"7>#j2.9r+X|");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      CharArrayWriter charArrayWriter0 = new CharArrayWriter(1099);
      bufferedReader0.transferTo(charArrayWriter0);
      Index<String> index0 = HashIndex.loadFromReader(bufferedReader0);
      splittingGrammarExtractor0.tempWordIndex = index0;
      splittingGrammarExtractor0.recalculateBetas(true);
      System.setCurrentTimeMillis(19L);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.memoryTreebank();
      double double0 = 0.0;
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      englishTreebankParserParams0.setGenerateOriginalDependencies(true);
      splittingGrammarExtractor0.extract((Collection<Tree>) memoryTreebank0);
      coreLabelTokenFactory0.makeToken("V=w{WY\"7>#j2.9r+X|", "X)4/zgNLIF!7mNy!", 100, 1099);
      // Undeclared exception!
      try { 
        coreLabelTokenFactory0.makeToken((CoreLabel) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollection1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayDeque<Tree> arrayDeque0 = new ArrayDeque<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) arrayDeque0);
      assertEquals(0, arrayDeque0.size());
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndDEBUG()  throws Throwable  {
      Options options0 = new Options();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.remove((String) null, (String) null, "*VVokWPQ3-LC");
      TwoDimensionalMap.treeMap();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, memoryTreebank0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.deepCopy();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("*VVokWPQ3-LC");
      splittingGrammarExtractor0.DEBUG();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.0;
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.mergeTransitions(treeGraphNode1, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, doubleArray0, hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNull()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      italianTreebankParserParams0.treeTokenizerFactory();
      italianTreebankParserParams0.setInputEncoding(";D<Lh^9_rFO%q$Y+9");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount("");
      splittingGrammarExtractor0.getStateSplitCount("");
      options0.dcTags = true;
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      MapFactory<List<String>, List<Object>> mapFactory0 = MapFactory.identityHashMapFactory();
      mapFactory0.setMap(null, 56);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = (double) 0;
      splittingGrammarExtractor0.mergeTransitions(simpleTree0, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, (Map<String, int[]>) null);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testMergeTransitions1()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0, (List<Tree>) null);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode0, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, (double[]) null, hashMap0);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexAndCountMergeEffectsTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      italianTreebankParserParams0.treeTokenizerFactory();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding(";D<Lh^9_rFO%q$Y+9");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount("");
      splittingGrammarExtractor0.getStateSplitCount("");
      options0.dcTags = true;
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.buildStateIndex();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) null, (Map<String, double[]>) null, (Map<String, double[]>) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) null, 100, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, true);
      FileSystemHandling.shouldAllThrowIOExceptions();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) null, 100, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsAndRecalculateTemporaryBetasTaking5ArgumentsThrowsRuntimeException()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      italianTreebankParserParams0.treeTokenizerFactory();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding(";D<Lh^9_rFO%q$Y+9");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount("");
      splittingGrammarExtractor0.getStateSplitCount("");
      options0.dcTags = true;
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, memoryTreebank0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      Tree tree0 = treeGraphNode0.transform((TreeTransformer) bobChrisTreeNormalizer0);
      MapFactory<List<String>, List<Object>> mapFactory0 = MapFactory.identityHashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(null, 56);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, true, map0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException3()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecalculateBetas()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      italianTreebankParserParams0.treeTokenizerFactory();
      italianTreebankParserParams0.memoryTreebank();
      italianTreebankParserParams0.setInputEncoding(";D<Lh^9_rFO%q$Y+9");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount("");
      splittingGrammarExtractor0.getStateSplitCount("");
      options0.dcTags = true;
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.buildStateIndex();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[4];
      intArray0[0] = 0;
      intArray0[1] = 73;
      intArray0[2] = 0;
      intArray0[3] = 0;
      hashMap0.put((String) null, intArray0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(100);
      assertEquals(100, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testSplitBetas4()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsIllegalArgumentException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.size();
      TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      splittingGrammarExtractor0.splitBetas();
      String[] stringArray0 = new String[7];
      stringArray0[0] = "D9dwgRh";
      stringArray0[1] = "9)&~J0QZD*";
      stringArray0[2] = "  ";
      stringArray0[3] = "->";
      stringArray0[4] = "INwYV$RWc(1";
      stringArray0[5] = "";
      stringArray0[6] = "";
      // Undeclared exception!
      try { 
        options0.setOptions(stringArray0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Unknown option: D9dwgRh
         //
         verifyException("edu.stanford.nlp.parser.lexparser.Options", e);
      }
  }

  @Test(timeout = 4000)
  public void testState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = splittingGrammarExtractor0.state("kSeqf|>(~uKIFC\"", 100);
      assertEquals("kSeqf|>(~uKIFC\"^100", string0);
  }

  @Test(timeout = 4000)
  public void testStateAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = "\\` 2k";
      splittingGrammarExtractor0.state("` 2k", 100);
      splittingGrammarExtractor0.state("` 2k^100", 100);
      SpanishTreebankParserParams spanishTreebankParserParams0 = null;
      try {
        spanishTreebankParserParams0 = new SpanishTreebankParserParams();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.trees.tregex.TregexParser
         //
         verifyException("edu.stanford.nlp.trees.tregex.TregexPatternCompiler", e);
      }
  }

  @Test(timeout = 4000)
  public void testStateThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.state((String) null, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("ib_h|");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      CoreLabel.OutputFormat coreLabel_OutputFormat0 = CoreLabel.OutputFormat.VALUE_TAG_INDEX;
      treeGraphNode1.toString(coreLabel_OutputFormat0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      assertTrue(hashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount("altAnswerFile");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testDEBUGAndDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateMergedBetas((Map<String, int[]>) null);
  }

  @Test(timeout = 4000)
  public void testBuildStateIndex()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor()  throws Throwable  {
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = null;
      SpanishTreebankParserParams spanishTreebankParserParams0 = null;
      try {
        spanishTreebankParserParams0 = new SpanishTreebankParserParams();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.trees.tregex.TregexParser
         //
         verifyException("edu.stanford.nlp.trees.tregex.TregexPatternCompiler", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateSplittingGrammarExtractorThrowsNullPointerException()  throws Throwable  {
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Options options0 = spanishUnknownWordModelTrainer0.op;
      SplittingGrammarExtractor splittingGrammarExtractor0 = null;
      try {
        splittingGrammarExtractor0 = new SplittingGrammarExtractor((Options) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }
}
