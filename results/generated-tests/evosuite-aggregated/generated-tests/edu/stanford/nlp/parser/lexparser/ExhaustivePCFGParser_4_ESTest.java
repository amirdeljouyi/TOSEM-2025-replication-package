/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Apr 21 18:50:41 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.PresetSequenceClassifier;
import edu.stanford.nlp.international.french.FrenchMorphoFeatureSpecification;
import edu.stanford.nlp.international.morph.MorphoFeatureSpecification;
import edu.stanford.nlp.ling.BasicDocument;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.StringLabel;
import edu.stanford.nlp.ling.Tag;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.TaggedWordFactory;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordTagFactory;
import edu.stanford.nlp.parser.common.ParserConstraint;
import edu.stanford.nlp.parser.lexparser.ArabicUnknownWordModelTrainer;
import edu.stanford.nlp.parser.lexparser.BaseLexicon;
import edu.stanford.nlp.parser.lexparser.BinaryGrammar;
import edu.stanford.nlp.parser.lexparser.ChineseLexicon;
import edu.stanford.nlp.parser.lexparser.ChineseLexiconAndWordSegmenter;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Edge;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser;
import edu.stanford.nlp.parser.lexparser.FactoredLexicon;
import edu.stanford.nlp.parser.lexparser.HTKLatticeReader;
import edu.stanford.nlp.parser.lexparser.Hook;
import edu.stanford.nlp.parser.lexparser.IntTaggedWord;
import edu.stanford.nlp.parser.lexparser.ItalianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Lattice;
import edu.stanford.nlp.parser.lexparser.Lexicon;
import edu.stanford.nlp.parser.lexparser.NegraPennTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.OutsideRuleFilter;
import edu.stanford.nlp.parser.lexparser.SpanishUnknownWordModelTrainer;
import edu.stanford.nlp.parser.lexparser.TestOptions;
import edu.stanford.nlp.parser.lexparser.UnaryGrammar;
import edu.stanford.nlp.parser.lexparser.UnaryRule;
import edu.stanford.nlp.parser.lexparser.UnknownWordModelTrainer;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.sequences.TrueCasingForNISTDocumentReaderAndWriter;
import edu.stanford.nlp.trees.CompositeTreeTransformer;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.MemoryTreebank;
import edu.stanford.nlp.trees.PennTreebankLanguagePack;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeGraphNodeFactory;
import edu.stanford.nlp.util.DeltaIndex;
import edu.stanford.nlp.util.FixedPrioritiesPriorityQueue;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.ScoredObject;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Stack;
import java.util.Vector;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.io.MockPrintWriter;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class ExhaustivePCFGParser_4_ESTest extends ExhaustivePCFGParser_4_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsTooManyResourcesException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("398*@,'n", "398*@,'n", "398*@,'n");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree[] treeArray0 = new Tree[5];
      treeArray0[0] = (Tree) treeGraphNode0;
      treeArray0[1] = (Tree) treeGraphNode0;
      treeArray0[2] = (Tree) treeGraphNode0;
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNode0.deepCopy((TreeFactory) treeGraphNodeFactory0);
      treeGraphNode0.taggedYield();
      treeArray0[3] = tree0;
      treeArray0[4] = (Tree) treeGraphNode0;
      treeGraphNode0.setChildren(treeArray0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      exhaustivePCFGParser0.validateBinarizedTree(treeGraphNode1, 100);
  }

  @Test(timeout = 4000)
  public void testBuildOFilterThrowsUnsupportedOperationException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("398*@,'n", "398*@,'n");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      TreeGraphNodeFactory treeGraphNodeFactory1 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNode1.deepCopy((TreeFactory) treeGraphNodeFactory1);
      Tree[] treeArray0 = new Tree[8];
      treeArray0[0] = (Tree) treeGraphNode1;
      treeArray0[1] = (Tree) treeGraphNode0;
      treeArray0[2] = (Tree) treeGraphNode0;
      treeArray0[3] = tree0;
      treeArray0[4] = tree0;
      treeArray0[5] = (Tree) treeGraphNode1;
      treeArray0[6] = tree0;
      treeArray0[7] = (Tree) treeGraphNode0;
      treeGraphNode1.setChildren(treeArray0);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list0);
      FrenchMorphoFeatureSpecification frenchMorphoFeatureSpecification0 = new FrenchMorphoFeatureSpecification();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(frenchMorphoFeatureSpecification0, hashIndex0, hashIndex0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreBinarizedTree(tree0, 100);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // You must use a tree type that implements scoring in order call setScore()
         //
         verifyException("edu.stanford.nlp.trees.Tree", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildOFilter()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
      
      OutsideRuleFilter outsideRuleFilter0 = new OutsideRuleFilter(binaryGrammar0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.orf = outsideRuleFilter0;
      exhaustivePCFGParser0.buildOFilter();
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySizeAndInitializePossibles()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      options0.forceCNF = true;
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon1 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options1 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar1, baseLexicon1, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.arraySize = 100;
      exhaustivePCFGParser0.nudgeDownArraySize();
      exhaustivePCFGParser0.initializePossibles();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testIScoreAndCreateArraysAndInitializePossibles()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.initializePossibles();
      float[][][] floatArray0 = new float[2][2][4];
      float[][] floatArray1 = new float[4][3];
      float[] floatArray2 = new float[7];
      floatArray2[0] = (float) 100;
      floatArray2[1] = (float) 100;
      floatArray2[2] = (float) 100;
      floatArray2[3] = (float) 100;
      floatArray2[4] = (float) 100;
      floatArray2[5] = Float.NEGATIVE_INFINITY;
      floatArray2[6] = (float) 100;
      floatArray1[0] = floatArray2;
      float[] floatArray3 = new float[6];
      floatArray3[0] = Float.NEGATIVE_INFINITY;
      floatArray3[1] = (float) 100;
      floatArray3[2] = (float) 100;
      floatArray3[3] = (-4639.23F);
      floatArray3[4] = Float.NEGATIVE_INFINITY;
      floatArray3[5] = (float) 100;
      floatArray1[1] = floatArray3;
      float[] floatArray4 = new float[7];
      floatArray4[0] = Float.NEGATIVE_INFINITY;
      floatArray4[1] = (float) 100;
      floatArray4[2] = (float) 100;
      floatArray4[3] = (float) 100;
      floatArray4[4] = (-2987.0F);
      floatArray4[5] = (float) 100;
      floatArray4[6] = Float.NEGATIVE_INFINITY;
      floatArray1[2] = floatArray4;
      float[] floatArray5 = new float[7];
      floatArray5[0] = (float) 100;
      floatArray5[1] = (-2987.0F);
      floatArray5[2] = (-4639.23F);
      floatArray5[3] = (float) 100;
      floatArray5[4] = (float) 100;
      floatArray5[5] = (-4639.23F);
      floatArray5[6] = (-2987.0F);
      floatArray1[3] = floatArray5;
      floatArray0[0] = floatArray1;
      float[][] floatArray6 = new float[4][5];
      floatArray6[0] = floatArray5;
      floatArray6[1] = floatArray3;
      floatArray6[2] = floatArray5;
      floatArray6[3] = floatArray4;
      floatArray0[1] = floatArray6;
      exhaustivePCFGParser0.iScore = floatArray0;
      exhaustivePCFGParser0.doInsideScores();
      Edge edge0 = new Edge(true);
      Edge edge1 = new Edge(edge0);
      double double0 = exhaustivePCFGParser0.iScore(edge1);
      assertEquals(100.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsNullPointerException0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      Stack<Tree> stack0 = new Stack<Tree>();
      CoreLabel coreLabel0 = new CoreLabel();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LabelFactory labelFactory0 = StringLabel.factory();
      TreeFactory treeFactory0 = LabeledScoredTreeNode.factory(labelFactory0);
      Tree tree0 = treeGraphNode0.treeSkeletonConstituentCopy(treeFactory0, labelFactory0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(tree0, stack0);
      treeGraphNode1.subTreeList();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNode0.deepCopy((TreeFactory) treeGraphNodeFactory0);
      Tree[] treeArray0 = new Tree[2];
      treeArray0[0] = tree1;
      treeArray0[1] = (Tree) treeGraphNode1;
      treeGraphNode0.setChildren(treeArray0);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(coreLabel0, stack0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, deltaIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(treeGraphNode0, 95);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeWithNegative()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("398*@,'n", "398*@,'n");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree[] treeArray0 = new Tree[5];
      treeArray0[0] = (Tree) treeGraphNode0;
      treeArray0[1] = (Tree) treeGraphNode0;
      treeArray0[2] = (Tree) treeGraphNode0;
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNode0.deepCopy((TreeFactory) treeGraphNodeFactory0);
      treeArray0[3] = tree0;
      treeArray0[4] = (Tree) treeGraphNode0;
      treeGraphNode0.setChildren(treeArray0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      exhaustivePCFGParser0.validateBinarizedTree(treeGraphNode0, (-885));
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsNullPointerException1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      Stack<Tree> stack0 = new Stack<Tree>();
      CoreLabel coreLabel0 = new CoreLabel();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LabelFactory labelFactory0 = StringLabel.factory();
      TreeFactory treeFactory0 = LabeledScoredTreeNode.factory(labelFactory0);
      Tree tree0 = treeGraphNode0.treeSkeletonConstituentCopy(treeFactory0, labelFactory0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(tree0, stack0);
      treeGraphNode1.subTreeList();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNode0.deepCopy((TreeFactory) treeGraphNodeFactory0);
      Tree[] treeArray0 = new Tree[2];
      treeArray0[0] = tree1;
      treeArray0[1] = (Tree) treeGraphNode1;
      treeGraphNode0.setChildren(treeArray0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, deltaIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(treeGraphNode0, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeWithZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      hashIndex0.add("-bSfw$lU6eidN+8[d");
      Stack<Tree> stack0 = new Stack<Tree>();
      int int0 = 0;
      StringLabel stringLabel0 = new StringLabel("Pa_&FIu", 0, 285);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(deltaIndex0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      pennTreebankLanguagePack0.morphFeatureSpec();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon((MorphoFeatureSpecification) null, hashIndex0, deltaIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar1, unaryGrammar0, factoredLexicon0, options0, deltaIndex0, hashIndex0, deltaIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(treeGraphNode1, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringAndGetBestScoreTakingStringThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      assertFalse(exhaustivePCFGParser0.hasParse());
      
      IntTaggedWord intTaggedWord0 = new IntTaggedWord("`>9WmZOZIk9,[';`S", "`>9WmZOZIk9,[';`S", hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestScore("`>9WmZOZIk9,[';`S");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, deltaIndex0, deltaIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      IntTaggedWord intTaggedWord0 = new IntTaggedWord("h", "h", deltaIndex0, deltaIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestScore("h");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTreeThrowsUnsupportedOperationException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("398*;i@N,'n", "398*;i@N,'n");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      treeGraphNode0.subTreeList();
      Tree[] treeArray0 = new Tree[5];
      treeArray0[0] = (Tree) treeGraphNode0;
      treeArray0[1] = (Tree) treeGraphNode0;
      treeArray0[2] = (Tree) treeGraphNode0;
      TreeFactory treeFactory0 = TreeGraphNode.factory();
      Tree tree0 = treeGraphNode0.deepCopy(treeFactory0);
      treeArray0[3] = tree0;
      CompositeTreeTransformer compositeTreeTransformer0 = new CompositeTreeTransformer();
      treeArray0[4] = (Tree) treeGraphNode0;
      tree0.setChildren(treeArray0);
      Vector<Tree> vector0 = new Vector<Tree>();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeArray0[2], vector0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      Lexicon lexicon0 = italianTreebankParserParams0.lex(options0, hashIndex0, hashIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex1, hashIndex0);
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar1, lexicon0, options0, hashIndex0, hashIndex1, hashIndex1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.scoreBinarizedTree(tree0, 1507);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // You must use a tree type that implements scoring in order call setScore()
         //
         verifyException("edu.stanford.nlp.trees.Tree", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTreeThrowsTooManyResourcesException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("398*;i@N,'n", "398*;i@N,'n");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree[] treeArray0 = new Tree[5];
      treeArray0[0] = (Tree) treeGraphNode0;
      treeArray0[1] = (Tree) treeGraphNode0;
      treeArray0[2] = (Tree) treeGraphNode0;
      TreeFactory treeFactory0 = TreeGraphNode.factory();
      Tree tree0 = treeGraphNode0.deepCopy(treeFactory0);
      treeArray0[3] = tree0;
      CompositeTreeTransformer compositeTreeTransformer0 = new CompositeTreeTransformer();
      treeArray0[4] = (Tree) treeGraphNode0;
      treeGraphNode0.setChildren(treeArray0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.scoreBinarizedTree(treeArray0[1], 100);
  }

  @Test(timeout = 4000)
  public void testGetBestParsesThrowsTooManyResourcesException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("398*;i@N,'n", "398*;i@N,'n");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree[] treeArray0 = new Tree[5];
      treeArray0[0] = (Tree) treeGraphNode0;
      treeArray0[1] = (Tree) treeGraphNode0;
      treeArray0[2] = (Tree) treeGraphNode0;
      TreeFactory treeFactory0 = TreeGraphNode.factory();
      Tree tree0 = treeGraphNode0.deepCopy(treeFactory0);
      treeArray0[3] = tree0;
      CompositeTreeTransformer compositeTreeTransformer0 = new CompositeTreeTransformer();
      Tree tree1 = compositeTreeTransformer0.transformTree(tree0);
      treeArray0[4] = tree1;
      treeGraphNode0.setChildren(treeArray0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      exhaustivePCFGParser0.scoreBinarizedTree(treeGraphNode1, 100);
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeThrowsTooManyResourcesException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("398*@,'n", "398*@,'n");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree[] treeArray0 = new Tree[5];
      treeArray0[0] = (Tree) treeGraphNode0;
      treeArray0[1] = (Tree) treeGraphNode0;
      treeArray0[2] = (Tree) treeGraphNode0;
      TreeFactory treeFactory0 = TreeGraphNode.factory();
      Tree tree0 = treeGraphNode0.deepCopy(treeFactory0);
      treeArray0[3] = tree0;
      treeArray0[4] = (Tree) treeGraphNode0;
      treeGraphNode0.setChildren(treeArray0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      exhaustivePCFGParser0.scoreBinarizedTree(treeGraphNode1, 100);
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("}", "");
      List<TaggedWord> list0 = List.of(taggedWord0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreateArrays()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      options0.doDep = false;
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.createArrays(100);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("G-5_}`-W=3-sdX&Jl");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndCreateArrays0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      options0.doDep = false;
      exhaustivePCFGParser0.lr = null;
      exhaustivePCFGParser0.createArrays(100);
      LinkedList<IndexedWord> linkedList0 = new LinkedList<IndexedWord>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsNullPointerException0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      FixedPrioritiesPriorityQueue<UnaryRule> fixedPrioritiesPriorityQueue0 = new FixedPrioritiesPriorityQueue<UnaryRule>();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      LinkedList<ParserConstraint> linkedList0 = new LinkedList<ParserConstraint>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      exhaustivePCFGParser0.constraints = (List<ParserConstraint>) linkedList0;
      options0.rerankerKBest = 70;
      ParserConstraint parserConstraint0 = new ParserConstraint(84, (-101), "");
      linkedList0.add(parserConstraint0);
      exhaustivePCFGParser0.length = 70;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.doInsideScores();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsNullPointerException1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      LinkedList<ParserConstraint> linkedList0 = new LinkedList<ParserConstraint>();
      exhaustivePCFGParser0.constraints = (List<ParserConstraint>) linkedList0;
      ParserConstraint parserConstraint0 = new ParserConstraint(100, (-79), "");
      linkedList0.add(parserConstraint0);
      exhaustivePCFGParser0.length = 100;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.doInsideScores();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOScoreAndOScoreReturningZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Edge edge0 = new Edge(false);
      hashIndex0.unmodifiableView();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      float[][][] floatArray0 = new float[9][0][2];
      float[][] floatArray1 = new float[4][5];
      float[] floatArray2 = new float[2];
      floatArray2[0] = (float) 0;
      floatArray2[1] = (float) 0;
      floatArray1[0] = floatArray2;
      float[] floatArray3 = new float[1];
      floatArray3[0] = (float) 0;
      floatArray1[1] = floatArray3;
      float[] floatArray4 = new float[3];
      floatArray4[0] = (float) 0;
      floatArray4[1] = (float) 0;
      floatArray4[2] = (float) 0;
      floatArray1[2] = floatArray4;
      float[] floatArray5 = new float[1];
      floatArray5[0] = (float) 0;
      floatArray1[3] = floatArray5;
      floatArray0[0] = floatArray1;
      float[][] floatArray6 = new float[8][6];
      floatArray6[0] = floatArray2;
      floatArray6[1] = floatArray3;
      floatArray6[2] = floatArray5;
      floatArray6[3] = floatArray2;
      floatArray6[4] = floatArray3;
      floatArray6[5] = floatArray3;
      floatArray6[6] = floatArray5;
      floatArray6[7] = floatArray2;
      floatArray0[1] = floatArray6;
      float[][] floatArray7 = new float[8][5];
      floatArray7[0] = floatArray2;
      floatArray7[1] = floatArray4;
      floatArray7[2] = floatArray5;
      floatArray7[3] = floatArray4;
      floatArray7[4] = floatArray3;
      floatArray7[5] = floatArray2;
      floatArray7[6] = floatArray5;
      float[] floatArray8 = new float[7];
      floatArray8[0] = (float) 0;
      floatArray8[1] = (float) 0;
      floatArray8[2] = (float) 0;
      floatArray8[3] = (float) 0;
      floatArray8[4] = (float) 0;
      floatArray8[5] = (float) 0;
      floatArray8[6] = (float) 0;
      floatArray7[7] = floatArray8;
      floatArray0[2] = floatArray7;
      float[][] floatArray9 = new float[2][9];
      floatArray9[0] = floatArray4;
      floatArray9[1] = floatArray8;
      floatArray0[3] = floatArray9;
      float[][] floatArray10 = new float[3][1];
      floatArray10[0] = floatArray5;
      floatArray10[1] = floatArray5;
      float[] floatArray11 = new float[2];
      floatArray11[0] = (float) 0;
      floatArray11[1] = (float) 0;
      floatArray10[2] = floatArray11;
      floatArray0[4] = floatArray10;
      float[][] floatArray12 = new float[3][7];
      floatArray12[0] = floatArray8;
      floatArray12[1] = floatArray4;
      floatArray12[2] = floatArray11;
      floatArray0[5] = floatArray12;
      float[][] floatArray13 = new float[3][7];
      floatArray13[0] = floatArray8;
      floatArray13[1] = floatArray5;
      floatArray13[2] = floatArray3;
      floatArray0[6] = floatArray13;
      float[][] floatArray14 = new float[3][0];
      floatArray14[0] = floatArray11;
      floatArray14[1] = floatArray3;
      floatArray14[2] = floatArray8;
      floatArray0[7] = floatArray14;
      float[][] floatArray15 = new float[9][5];
      floatArray15[0] = floatArray2;
      floatArray15[1] = floatArray3;
      floatArray15[2] = floatArray4;
      floatArray15[3] = floatArray11;
      floatArray15[4] = floatArray8;
      floatArray15[5] = floatArray5;
      floatArray15[6] = floatArray3;
      floatArray15[7] = floatArray11;
      floatArray15[8] = floatArray4;
      floatArray0[8] = floatArray15;
      exhaustivePCFGParser0.oScore = floatArray0;
      double double0 = exhaustivePCFGParser0.oScore(edge0);
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsNullPointerExceptionAndCreateArrays0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      boolean boolean0 = ExhaustivePCFGParser.dumpTagging;
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      hashIndex0.add("K%cX7~mzb0i");
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.createArrays(100);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.doInsideScores();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsNullPointerExceptionAndCreateArrays1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      hashIndex0.add("");
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.createArrays(100);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.doInsideScores();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetConstraintsReturningListWhereSizeIsZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      unaryGrammar0.ruleIteratorByChild(100);
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      options0.rerankerKBest = 278;
      LinkedList<ParserConstraint> linkedList0 = new LinkedList<ParserConstraint>();
      exhaustivePCFGParser0.constraints = (List<ParserConstraint>) linkedList0;
      options0.rerankerKBest = 79;
      exhaustivePCFGParser0.getConstraints();
      exhaustivePCFGParser0.doInsideScores();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateExhaustivePCFGParserThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(".S<TK");
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.memoryTreebank();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      treeGraphNode0.parent();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      coreLabel0.setValue(".S<TK");
      coreLabel0.after();
      coreLabel0.labelFactory();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreBinarizedTree(treeGraphNode1, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testInitializePossiblesThrowsTooManyResourcesException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("");
      boolean boolean0 = ExhaustivePCFGParser.dumpTagging;
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      options0.freeDependencies = false;
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.createArrays(100);
      // Undeclared exception!
      exhaustivePCFGParser0.initializePossibles();
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsTooManyResourcesException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("");
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.createArrays(100);
      // Undeclared exception!
      exhaustivePCFGParser0.initializePossibles();
  }

  @Test(timeout = 4000)
  public void testCreateArraysAndDoInsideScores()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.doInsideScores();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testOPossible()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      MockFile mockFile0 = new MockFile("btc/JNsTpk.d*(#dZ");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
      unaryGrammar0.writeData(mockPrintWriter0);
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options(negraPennTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      hashIndex0.add((String) null);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Collection<? extends String>) hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex1, hashIndex1);
      exhaustivePCFGParser1.createArrays(100);
      ExhaustivePCFGParser exhaustivePCFGParser2 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex1, hashIndex1, hashIndex1);
      exhaustivePCFGParser2.nudgeDownArraySize();
      Hook hook0 = new Hook(true);
      Hook hook1 = new Hook(hook0);
      exhaustivePCFGParser1.oPossible(hook1);
      double double0 = exhaustivePCFGParser2.getBestScore();
      assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testInitializePossibles()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.isEmpty();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      ArabicUnknownWordModelTrainer arabicUnknownWordModelTrainer0 = new ArabicUnknownWordModelTrainer();
      baseLexicon0.uwModelTrainer = (UnknownWordModelTrainer) arabicUnknownWordModelTrainer0;
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.initializePossibles();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresAndDoInsideScores()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      boolean boolean0 = ExhaustivePCFGParser.dumpTagging;
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.initializePossibles();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
      
      exhaustivePCFGParser0.doInsideScores();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeThrowsNullPointerException0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Options options1 = new Options(options0.tlpParams);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("attempt to get word when sentence and lattice are null!");
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode0.parent();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      labeledScoredTreeNode0.treeFactory();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      coreLabel0.labelFactory();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree(treeGraphNode2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeThrowsNullPointerException1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree(treeGraphNode1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreateArraysAndInitializePossibles0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ArrayList<UnaryRule> arrayList0 = new ArrayList<UnaryRule>();
      Options options0 = new Options();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, deltaIndex0, deltaIndex0, deltaIndex0);
      exhaustivePCFGParser0.createArrays(87);
      exhaustivePCFGParser0.initializePossibles();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeAndValidateBinarizedTreeThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Options options1 = new Options(options0.tlpParams);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("attempt to get word when sentence and lattice are null!");
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeFactory treeFactory0 = labeledScoredTreeNode0.treeFactory();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      LabelFactory labelFactory0 = coreLabel0.labelFactory();
      Tree tree0 = treeGraphNode2.deepCopy(treeFactory0, labelFactory0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(tree0, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsNullPointerException2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, stack0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(treeGraphNode1, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingHTKLatticeReader()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      boolean boolean0 = exhaustivePCFGParser0.parse((HTKLatticeReader) null);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testParseTakingHTKLatticeReaderAndInitializePossibles()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = (-2264);
      exhaustivePCFGParser0.initializePossibles();
      assertFalse(exhaustivePCFGParser0.hasParse());
      
      exhaustivePCFGParser0.parse((HTKLatticeReader) null);
      List<ParserConstraint> list0 = exhaustivePCFGParser0.getConstraints();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testCreateArraysAndInitializePossibles1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.initializePossibles();
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringAndOPossibleRThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      options0.newTestOptions();
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.getBestScore("H-!'Kj&v");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleR(100, 2260);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testHasParseAndScoreBinarizedTree()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
      
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory('2');
      Label label0 = wordTagFactory0.newLabel("");
      Tree tree0 = treeGraphNodeFactory0.newLeaf(label0);
      double double0 = exhaustivePCFGParser0.scoreBinarizedTree(tree0, 100);
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testHasParse0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      unaryGrammar0.purgeRules();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsNullPointerException2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      unaryGrammar0.ruleIteratorByChild(100);
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      LinkedList<ParserConstraint> linkedList0 = new LinkedList<ParserConstraint>();
      exhaustivePCFGParser0.constraints = (List<ParserConstraint>) linkedList0;
      options0.rerankerKBest = 79;
      exhaustivePCFGParser0.length = 79;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.doInsideScores();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsNullPointerExceptionAndDoInsideScores()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.doInsideScores();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKGoodParsesAndNudgeDownArraySize()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
      
      List<ScoredObject<Tree>> list0 = exhaustivePCFGParser0.getKGoodParses((-383));
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testIPossibleThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(true);
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      hook0.start = 100;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractBestParsesWithPositiveAndPositive()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("6\u0002AMWik_kx(MA<iF", "'V+ X(AoU#");
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.setConstraints((List<ParserConstraint>) null);
      List<ParserConstraint> list0 = exhaustivePCFGParser0.constraints;
      exhaustivePCFGParser0.setConstraints(list0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.extractBestParses(835, 857, 559038737);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testSetConstraintsWithEmptyList()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Stack<ParserConstraint> stack0 = new Stack<ParserConstraint>();
      exhaustivePCFGParser0.setConstraints(stack0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestParses();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testSetConstraints()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0);
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "");
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, deltaIndex0);
      exhaustivePCFGParser0.setConstraints((List<ParserConstraint>) null);
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testSetConstraintsAndGetBestScoreTakingNoArguments()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("6\u0002AMWik_kx(MA<iF", "'V+ X(Aov#");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = treeGraphNode0.treeSkeletonCopy((TreeFactory) labeledScoredTreeFactory0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      List<ParserConstraint> list0 = exhaustivePCFGParser0.constraints;
      exhaustivePCFGParser0.setConstraints((List<ParserConstraint>) null);
      double double0 = exhaustivePCFGParser0.validateBinarizedTree(tree0, 559038737);
      assertEquals(0.0, double0, 0.01);
      
      double double1 = exhaustivePCFGParser0.getBestScore();
      assertEquals(Double.NEGATIVE_INFINITY, double1, 0.01);
  }

  @Test(timeout = 4000)
  public void testGetKGoodParsesAndGetKGoodParsesThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKGoodParses(100);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.TreeAnnotator", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTree()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(false);
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Options options1 = spanishUnknownWordModelTrainer0.op;
      exhaustivePCFGParser0.getKBestParses((-1582));
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("  Word: ");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BoundaryRemover", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleLThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleL(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleL()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(false);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleL(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKSampledParses()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKSampledParses(100);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // ExhaustivePCFGParser doesn't sample.
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKSampledParsesThrowsUnsupportedOperationException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKSampledParses(100);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // ExhaustivePCFGParser doesn't sample.
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeReturningZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("-unary");
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      pennTreebankLanguagePack0.morphFeatureSpec();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon((MorphoFeatureSpecification) null, hashIndex0, hashIndex0);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Collection<? extends String>) hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex1);
      TaggedWord taggedWord0 = new TaggedWord((String) null, " { ");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = treeGraphNode0.treeSkeletonCopy((TreeFactory) labeledScoredTreeFactory0);
      double double0 = exhaustivePCFGParser0.validateBinarizedTree(tree0, 100);
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTree()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      TaggedWord taggedWord0 = new TaggedWord((String) null, (String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Options options0 = new Options(negraPennTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      double double0 = exhaustivePCFGParser0.validateBinarizedTree(treeGraphNode0, 100);
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testIPossibleThrowsNullPointerExceptionAndIPossible()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(true);
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      hook0.start = 100;
      exhaustivePCFGParser0.length = 122;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleThrowsNullPointerExceptionAndIPossibleWithHookWhereIsPreHookIsFalse()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(true);
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleThrowsNullPointerExceptionAndDoInsideScoresAndNudgeDownArraySize()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      TestOptions testOptions0 = options0.testOptions;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.nudgeDownArraySize();
      exhaustivePCFGParser0.doInsideScores();
      Hook hook0 = new Hook(true);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testHasParseAndGetBestScoreTakingNoArgumentsAndHasParse()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      Options options0 = new Options();
      TestOptions testOptions0 = options0.testOptions;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getBestScore();
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTree()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      double double0 = exhaustivePCFGParser0.scoreBinarizedTree(labeledScoredTreeNode0, 100);
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testTickAndInitializePossiblesThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.tick("Z");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.initializePossibles();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testTickAndOScoreThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      binaryGrammar0.iterator();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options(negraPennTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(false);
      Hook hook1 = new Hook(hook0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("1g|DT", "Refusal to create such large arrays.", "1g|DT");
      TaggedWord taggedWord0 = new TaggedWord(categoryWordTag0);
      Tag tag0 = new Tag(taggedWord0);
      SimpleTree simpleTree0 = new SimpleTree(tag0);
      exhaustivePCFGParser0.scoreBinarizedTree(simpleTree0, 0);
      exhaustivePCFGParser0.tick("^h\"+>");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oScore((Edge) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildOFilterThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      Options options0 = new Options();
      TestOptions testOptions0 = options0.testOptions;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.buildOFilter();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestParseThrowsNullPointerException0()  throws Throwable  {
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      Options options0 = new Options();
      Options options1 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options1, hashIndex0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.getBestParse();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options();
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      options0.wordFunction = (Function<String, String>) presetSequenceClassifier0;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(3);
      exhaustivePCFGParser0.nudgeDownArraySize();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleL(100, (-1574));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1574 out of bounds for length 3
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleLThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleL(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringReturningNegative()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      IntTaggedWord intTaggedWord0 = new IntTaggedWord("Pa_&FIu", "Pa_&FIu", hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getBestScore("Pa_&FIu");
      Options options1 = new Options();
      exhaustivePCFGParser0.doInsideScores();
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testGetKBestParses()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options();
      options0.newTestOptions();
      Hook hook0 = new Hook(true);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar1, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getBestScore();
      List<ScoredObject<Tree>> list0 = exhaustivePCFGParser0.getKBestParses((-206));
      assertNotNull(list0);
      
      double double0 = exhaustivePCFGParser0.getBestScore("\"bWGLQ06H");
      assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testGetKBestParsesWithZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(false);
      List<ScoredObject<Tree>> list0 = exhaustivePCFGParser0.getKBestParses(0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testGetKBestParsesReturningListWhereIsEmptyIsTrue()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      NegraPennTreebankParserParams negraPennTreebankParserParams1 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams1.defaultTestSentence();
      Options options0 = new Options();
      options0.newTestOptions();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.doInsideScores();
      List<ScoredObject<Tree>> list0 = exhaustivePCFGParser0.getKBestParses((-2936));
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree((Tree) null, 86);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingNoArgumentsAndParseTakingListThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      Options options0 = new Options();
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(presetSequenceClassifier0.classIndex);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, presetSequenceClassifier0.classIndex, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.nudgeDownArraySize();
      Hook hook0 = new Hook(true);
      Hook hook1 = new Hook(hook0);
      Hook hook2 = new Hook(true);
      exhaustivePCFGParser0.getBestScore();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testHasParse1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingNoArgumentsAndGetBestScoreTakingNoArguments()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      hashIndex0.add("{z9;qdEN");
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options();
      options0.newTestOptions();
      unaryGrammar0.rules();
      Hook hook0 = new Hook(true);
      Hook hook1 = new Hook(hook0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      boolean boolean0 = ExhaustivePCFGParser.dumpTagging;
      double double0 = exhaustivePCFGParser0.getBestScore();
      assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testGetKGoodParsesThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKGoodParses(100);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKBestParsesThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options();
      options0.newTestOptions();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.doInsideScores();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKBestParses(1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleWithHookWhereIsPreHookIsTrue()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(true);
      hook0.start = 559038737;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(false);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingNoArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      MockFile mockFile0 = new MockFile("btc/JNsTpk.d*(#dZ");
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(mockFile0);
      unaryGrammar0.writeData(mockPrintWriter0);
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options(negraPennTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Collection<? extends String>) hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex1, hashIndex1);
      exhaustivePCFGParser1.createArrays(100);
      ExhaustivePCFGParser exhaustivePCFGParser2 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex1, hashIndex1, hashIndex1);
      exhaustivePCFGParser2.nudgeDownArraySize();
      Hook hook0 = new Hook(true);
      Hook hook1 = new Hook(hook0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.oPossible(hook1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySizeAndCreateArrays()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options();
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      options0.wordFunction = (Function<String, String>) presetSequenceClassifier0;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(3);
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingList0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      TaggedWord taggedWord0 = new TaggedWord("Pa_&FIu", "Pa_&FIu");
      List<TaggedWord> list0 = List.of(taggedWord0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndCreateArrays1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      LinkedList<IndexedWord> linkedList0 = new LinkedList<IndexedWord>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingList1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      BasicDocument<UnaryRule> basicDocument0 = BasicDocument.init("?a", "");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.parse((List<? extends HasWord>) basicDocument0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListAndParseTakingListWithEmptyList()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      List<? extends HasWord> list0 = new LinkedList<CoreLabel>();
      Options options0 = new Options();
      options0.newTestOptions();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndHasParse()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.hasParse();
      LinkedList<IndexedWord> linkedList0 = new LinkedList<IndexedWord>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySize()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      Options options1 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.arraySize = 100;
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("-poder");
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetConstraintsAndParseTakingListThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      List<? extends HasWord> list0 = negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options();
      options0.newTestOptions();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.doInsideScores();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
      
      exhaustivePCFGParser0.getConstraints();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithEmptyList()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Vector<LabeledWord> vector0 = new Vector<LabeledWord>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestParsesThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      hashIndex0.add("T]++jr$j:*]F3");
      Index<String> index0 = null;
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestParses();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIScoreWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iScore((Edge) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIScoreAndIScoreThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options();
      options0.newTestOptions();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.doInsideScores();
      Edge edge0 = new Edge(false);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iScore(edge0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesExhaustivePCFGParser0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(true);
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Collection<? extends String>) hashIndex0);
      hashIndex1.addToIndexUnsafe("Starting outsides...");
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex1);
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testGetConstraintsAndCreateArrays()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options();
      Properties properties0 = options0.testOptions.evals;
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      options0.wordFunction = (Function<String, String>) presetSequenceClassifier0;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(3);
      List<ParserConstraint> list0 = exhaustivePCFGParser0.getConstraints();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testIPossibleRThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleR(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleRThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options();
      Properties properties0 = options0.testOptions.evals;
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      options0.wordFunction = (Function<String, String>) presetSequenceClassifier0;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(3);
      assertFalse(exhaustivePCFGParser0.hasParse());
      
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleR(3, 3);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 3 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOScoreThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Edge edge0 = new Edge(true);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oScore(edge0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOScoreAndOScoreThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      hashIndex0.add("T]++jr$j:*]F3");
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      int int0 = (-1);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      int int1 = 9;
      Hook hook0 = new Hook(true);
      Hook hook1 = new Hook(hook0);
      Edge edge0 = hook1.backEdge;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oScore((Edge) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestParseThrowsNullPointerException1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestParse();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractBestParseThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options(negraPennTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.extractBestParse(")\"wb6", (-1333), (-1333));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateExhaustivePCFGParserThrowsRuntimeException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0);
      DeltaIndex<String> deltaIndex1 = new DeltaIndex<String>(deltaIndex0, hashIndex0);
      deltaIndex0.add((String) null);
      options0.directional = false;
      Lexicon lexicon0 = chineseTreebankParserParams0.lex(options0, hashIndex0, deltaIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, deltaIndex1, deltaIndex1, deltaIndex0);
      List<Tree> list0 = new ArrayList<Tree>();
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Options options1 = spanishUnknownWordModelTrainer0.op;
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      binaryGrammar0.forEach(consumer0);
      String string0 = ",";
      Options options2 = new Options();
      ChineseLexiconAndWordSegmenter chineseLexiconAndWordSegmenter0 = null;
      try {
        chineseLexiconAndWordSegmenter0 = new ChineseLexiconAndWordSegmenter(",", options2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // java.io.FileNotFoundException
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ChineseLexiconAndWordSegmenter", e);
      }
  }

  @Test(timeout = 4000)
  public void testHasParse2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      baseLexicon0.initRulesWithWord();
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = exhaustivePCFGParser0.lr;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((Lattice) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractBestParsesWithNegativeAndZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0);
      DeltaIndex<String> deltaIndex1 = new DeltaIndex<String>(deltaIndex0, hashIndex0);
      options0.directional = false;
      Lexicon lexicon0 = chineseTreebankParserParams0.lex(options0, hashIndex0, deltaIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, deltaIndex1, deltaIndex1, deltaIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.extractBestParses((-3012), 0, 3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleR()  throws Throwable  {
      String string0 = "xMYpfwQ29+iG";
      Index<String> index0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(index0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(index0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(index0);
      DeltaIndex<String> deltaIndex1 = new DeltaIndex<String>(deltaIndex0, index0);
      options0.directional = false;
      Lexicon lexicon0 = chineseTreebankParserParams0.lex(options0, index0, deltaIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, deltaIndex0, deltaIndex0, index0);
      deltaIndex0.remove(index0);
      unaryGrammar0.rules();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleR((-1951), (-1033));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleRThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleR(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeAndParseTakingLatticeWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      ChineseLexicon chineseLexicon0 = new ChineseLexicon(options0, chineseTreebankParserParams0, hashIndex0, hashIndex0);
      Options options1 = new Options(options0.tlpParams);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options1, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options1, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((Lattice) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeAndParseTakingLatticeWithLatticeWhereGetNumEdgesIsZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options(negraPennTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoInsideScores()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.doInsideScores();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeWithLatticeWhereGetNumEdgesIsZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testInitializePossiblesThrowsNullPointerExceptionAndInitializePossibles()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.initializePossibles();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesExhaustivePCFGParser1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)75;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      BaseLexicon baseLexicon0 = new BaseLexicon((Index<String>) null, (Index<String>) null);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options();
      Properties properties0 = options0.testOptions.evals;
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, presetSequenceClassifier0.classIndex);
      exhaustivePCFGParser0.createArrays(100);
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testInitializePossiblesThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      BaseLexicon baseLexicon0 = new BaseLexicon(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.initializePossibles();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testInitializePossiblesThrowsNullPointerExceptionAndCreatesExhaustivePCFGParser()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options(negraPennTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.initializePossibles();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesWithPositive()  throws Throwable  {
      boolean boolean0 = ExhaustivePCFGParser.matches(0.34875659542892107, (-2.6976650806601064));
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesReturningFalse()  throws Throwable  {
      ExhaustivePCFGParser.matches(5005.4, 1.0E-10);
      String string0 = "";
      // Undeclared exception!
      try { 
        HashIndex.loadFromFileWithList("");
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // java.io.FileNotFoundException
         //
         verifyException("edu.stanford.nlp.util.HashIndex", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesWithNegative()  throws Throwable  {
      boolean boolean0 = ExhaustivePCFGParser.matches((-5.395239384953E-6), (-5.395239384953E-6));
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesReturningTrue()  throws Throwable  {
      ExhaustivePCFGParser.matches((-1669.2156785388), (-1669.2156785388));
      Supplier<List<String>> supplier0 = (Supplier<List<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      HashIndex<String> hashIndex0 = null;
      try {
        hashIndex0 = new HashIndex<String>(supplier0, (Supplier<Map<String, Integer>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.util.HashIndex", e);
      }
  }
}
