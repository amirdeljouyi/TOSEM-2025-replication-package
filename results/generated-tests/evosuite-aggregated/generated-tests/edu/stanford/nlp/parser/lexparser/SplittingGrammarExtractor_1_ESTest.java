/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Apr 21 18:56:45 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CategoryWordTagFactory;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.StringLabel;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.TaggedWordFactory;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordLemmaTagFactory;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.ling.WordTagFactory;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HebrewTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ItalianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.NegraPennTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.SpanishUnknownWordModelTrainer;
import edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.trees.BobChrisTreeNormalizer;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.NPTmpRetainingTreeNormalizer;
import edu.stanford.nlp.trees.PennTreeReaderFactory;
import edu.stanford.nlp.trees.PennTreebankLanguagePack;
import edu.stanford.nlp.trees.QPTreeTransformer;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeGraphNodeFactory;
import edu.stanford.nlp.trees.TreeReaderFactory;
import edu.stanford.nlp.util.Filters;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.ThreeDimensionalMap;
import edu.stanford.nlp.util.Triple;
import edu.stanford.nlp.util.TwoDimensionalMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Stack;
import java.util.Vector;
import java.util.function.Predicate;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class SplittingGrammarExtractor_1_ESTest extends SplittingGrammarExtractor_1_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testSaveTreesWithZero()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      identityHashMap0.put("WRaz~{@", doubleArray0);
      double[] doubleArray1 = new double[4];
      identityHashMap0.put("7#o<", doubleArray1);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) treeGraphNode1, list0);
      splittingGrammarExtractor0.saveTrees(treeGraphNode0, 0.0, tree0, 0.0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>(100);
      identityHashMap1.put(treeGraphNode1, doubleArray1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      List<LabeledScoredTreeNode> list1 = treeGraphNode1.getLeaves();
      treeGraphNode0.setChildren(list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[9][0];
      double[] doubleArray1 = new double[10];
      doubleArray1[0] = (-1777.9156163272348);
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = 0.0;
      doubleArray1[5] = 0.0;
      doubleArray1[6] = 0.0;
      doubleArray1[2] = (double) 100;
      doubleArray1[8] = (double) 100;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[1];
      doubleArray0[2] = doubleArray2;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = (double) 100;
      double[] doubleArray4 = new double[3];
      doubleArray4[0] = (double) 100;
      doubleArray4[1] = (double) 100;
      doubleArray4[2] = 0.0;
      doubleArray0[4] = doubleArray4;
      double[] doubleArray5 = new double[8];
      doubleArray5[0] = (-1777.9156163272348);
      doubleArray5[1] = (-1777.9156163272348);
      doubleArray5[2] = (-1777.9156163272348);
      doubleArray5[3] = (double) 100;
      doubleArray5[4] = (-1777.9156163272348);
      doubleArray5[5] = (double) 100;
      doubleArray5[6] = 0.0;
      doubleArray0[5] = doubleArray5;
      double[] doubleArray6 = new double[2];
      doubleArray6[1] = 0.0;
      doubleArray0[7] = doubleArray6;
      double[] doubleArray7 = new double[6];
      doubleArray7[0] = (-1777.9156163272348);
      doubleArray7[1] = 0.0;
      doubleArray7[2] = (-1777.9156163272348);
      doubleArray7[3] = 0.0;
      doubleArray7[5] = (-1777.9156163272348);
      doubleArray0[8] = doubleArray7;
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray1, 0, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      List<LabeledScoredTreeNode> list1 = treeGraphNode1.getLeaves();
      treeGraphNode0.setChildren(list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[9][0];
      double[] doubleArray1 = new double[9];
      doubleArray1[0] = (-1753.0775);
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = 0.0;
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      int int0 = (-3);
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray1, int0, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateBetas(options0.freeDependencies);
      boolean boolean0 = true;
      splittingGrammarExtractor0.recalculateBetas(boolean0);
      boolean boolean1 = false;
      int int1 = 1;
      IdentityHashMap<Tree, double[]> identityHashMap2 = null;
      splittingGrammarExtractor0.recountInside(treeGraphNode1, boolean1, int1, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      List<LabeledScoredTreeNode> list1 = treeGraphNode1.getLeaves();
      treeGraphNode0.setChildren(list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[][] doubleArray0 = new double[2][3];
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = (double) 100;
      doubleArray1[4] = 0.0;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[7];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = 0.0;
      doubleArray2[4] = 0.0;
      doubleArray2[5] = 0.0;
      doubleArray0[1] = doubleArray2;
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray3 = new double[0];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray3, 0, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsArrayIndexOutOfBoundsException2()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      List<LabeledScoredTreeNode> list1 = treeGraphNode1.getLeaves();
      treeGraphNode0.setChildren(list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[9][0];
      double[] doubleArray1 = new double[9];
      doubleArray1[0] = (-1753.0775);
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = 0.0;
      doubleArray1[5] = 0.0;
      doubleArray1[6] = 0.0;
      doubleArray1[7] = (double) 100;
      doubleArray1[8] = (double) 100;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = (double) 100;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = (-1753.0775);
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[1];
      doubleArray4[0] = (double) 100;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[3];
      doubleArray5[0] = (double) 100;
      doubleArray5[1] = (double) 100;
      doubleArray5[2] = 0.0;
      doubleArray0[4] = doubleArray5;
      double[] doubleArray6 = new double[8];
      doubleArray6[0] = (-1753.0775);
      doubleArray6[1] = (-1753.0775);
      doubleArray6[2] = (-1753.0775);
      doubleArray6[3] = (double) 100;
      doubleArray6[4] = (-1753.0775);
      doubleArray6[5] = (double) 100;
      doubleArray6[6] = 0.0;
      doubleArray6[7] = (-1753.0775);
      doubleArray0[5] = doubleArray6;
      double[] doubleArray7 = new double[7];
      doubleArray7[0] = (double) 100;
      doubleArray7[1] = (-1753.0775);
      doubleArray7[2] = (-1753.0775);
      doubleArray7[3] = (double) 100;
      doubleArray7[4] = 0.0;
      doubleArray7[5] = (double) 100;
      doubleArray7[6] = 0.0;
      doubleArray0[6] = doubleArray7;
      double[] doubleArray8 = new double[2];
      doubleArray8[0] = (double) 100;
      doubleArray8[1] = 0.2;
      doubleArray0[7] = doubleArray8;
      double[] doubleArray9 = new double[6];
      doubleArray9[0] = 0.2;
      doubleArray9[1] = 0.0;
      doubleArray9[2] = (-1753.0775);
      doubleArray9[3] = 0.0;
      doubleArray9[4] = 0.0;
      doubleArray9[5] = (-1753.0775);
      doubleArray0[8] = doubleArray9;
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      double[] doubleArray10 = new double[0];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray10, 0, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndRecalculateBetasAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      List<LabeledScoredTreeNode> list1 = treeGraphNode1.getLeaves();
      treeGraphNode0.setChildren(list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][] doubleArray0 = new double[9][0];
      double[] doubleArray1 = new double[4];
      doubleArray1[0] = (-1753.0775);
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = 0.0;
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      int int0 = (-3);
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray1, int0, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateBetas(options0.freeDependencies);
      boolean boolean0 = true;
      splittingGrammarExtractor0.recalculateBetas(boolean0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.useNewBetas(options0.forceCNF, twoDimensionalMap1, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeThrowsTooManyResourcesException()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<LabeledScoredTreeNode> list0 = treeGraphNode0.getLeaves();
      treeGraphNode0.setChildren(list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap.treeMap();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap1 = new HashMap<String, int[]>();
      int[] intArray0 = new int[6];
      intArray0[0] = 100;
      intArray0[1] = 100;
      intArray0[2] = 100;
      intArray0[3] = (-1443143778);
      intArray0[4] = 100;
      intArray0[5] = 100;
      hashMap1.put("7#o<", intArray0);
      // Undeclared exception!
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode0, identityHashMap0, identityHashMap2, identityHashMap0, identityHashMap1, (double[]) null, hashMap1);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<LabeledScoredTreeNode> list0 = treeGraphNode0.getLeaves();
      treeGraphNode0.setChildren(list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap.treeMap();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap1 = new HashMap<String, int[]>();
      int[] intArray0 = new int[6];
      intArray0[0] = 100;
      intArray0[2] = 100;
      hashMap1.put("7#o<", intArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.mergeTransitions(treeGraphNode0, identityHashMap0, identityHashMap2, identityHashMap0, identityHashMap2, (double[]) null, hashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      treeGraphNode0.postOrderNodeList();
      List<LabeledScoredTreeNode> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.setChildren(list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.countOriginalStates();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (-1.0);
      doubleArray0[1] = 0.0;
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode1, identityHashMap2, identityHashMap3, identityHashMap2, identityHashMap4, doubleArray0, hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndBuildMergeCorrespondence()  throws Throwable  {
      WordTag wordTag0 = new WordTag("=)F", "=)F");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.headWordNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      wordTag0.toString();
      List<LabeledScoredTreeNode> list0 = treeGraphNode0.getLeaves();
      treeGraphNode0.setChildren(list0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][] doubleArray0 = new double[2][4];
      double[] doubleArray1 = new double[3];
      doubleArray1[0] = (double) 3538;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = (double) 100;
      doubleArray0[0] = doubleArray1;
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag("Ji&sRv~_QdN_", "Ji&sRv~_QdN_");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      treeGraphNode0.setChildren(list0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments0()  throws Throwable  {
      String string0 = "=)F";
      WordTag wordTag0 = new WordTag("=)F", "=)F");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      treeGraphNode0.subTreeList();
      treeGraphNode0.headWordNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      List<LabeledScoredTreeNode> list0 = treeGraphNode0.getLeaves();
      treeGraphNode0.setChildren(list0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.outputTransitions((Tree) treeGraphNode0, 3538, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag("Ji&sRv~_QdN_", "Ji&sRv~_QdN_");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.preOrderNodeList();
      treeGraphNode1.setChildren(list0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap0, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      List<LabeledScoredTreeNode> list0 = treeGraphNode0.getLeaves();
      treeGraphNode0.setChildren(list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      int int0 = (-1120676868);
      splittingGrammarExtractor0.recountInside(treeGraphNode0, options0.useSmoothTagProjection, int0, identityHashMap1);
      String string0 = "nBx1Y'vM[XZcD";
      splittingGrammarExtractor0.getStateSplitCount(string0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag((String) null);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, linkedList0);
      Tree tree0 = treeGraphNode0.flatten();
      Tree tree1 = italianTreebankParserParams0.transformTree(tree0, tree0);
      splittingGrammarExtractor0.saveTrees(tree1, 0.0, treeGraphNode0, (-1243.34877123));
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) identityHashMap0, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsWithTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[3][0];
      twoDimensionalMap0.put(" '  ", " '  ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      MapFactory<IndexedWord, Object> mapFactory0 = MapFactory.hashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(null);
      Map<String, double[]> map1 = mapFactory0.setMap(map0);
      Map<String, double[]> map2 = mapFactory0.setMap(map1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map2, twoDimensionalMap0, threeDimensionalMap0);
      WordTag wordTag0 = WordTag.valueOf(" '  ", " '  ");
      Word word0 = new Word(wordTag0);
      LabelFactory labelFactory0 = word0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      // Undeclared exception!
      try { 
        chineseTreebankParserParams0.memoryTreebank();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.trees.international.pennchinese.CTBErrorCorrectingTreeNormalizer
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[7][6];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 30.0;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[7];
      doubleArray2[0] = Double.POSITIVE_INFINITY;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = 30.0;
      doubleArray2[3] = (double) 100;
      doubleArray2[4] = (double) 100;
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = 0.0;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[0];
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[3];
      doubleArray4[0] = 30.0;
      doubleArray4[1] = 30.0;
      doubleArray4[2] = Double.POSITIVE_INFINITY;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[0];
      doubleArray0[4] = doubleArray5;
      double[] doubleArray6 = new double[1];
      doubleArray6[0] = (double) 100;
      doubleArray0[5] = doubleArray6;
      double[] doubleArray7 = new double[0];
      doubleArray0[6] = doubleArray7;
      twoDimensionalMap0.put("E", "ner.docdate", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      WordTag.valueOf("si&sRv~_Qd%_");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[5][7];
      double[] doubleArray1 = new double[4];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = Double.POSITIVE_INFINITY;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[4];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = 0.0;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 20.0;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[2];
      doubleArray3[0] = Double.POSITIVE_INFINITY;
      doubleArray3[1] = (double) 100;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[0];
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[2];
      doubleArray5[0] = 0.0;
      doubleArray5[1] = 984.983096516;
      doubleArray0[4] = doubleArray5;
      twoDimensionalMap0.put("si&sRv~_Qd%_", "H:n3R0m+ ", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 2 out of bounds for length 2
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("Yt(BC+ !D");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      TwoDimensionalMap<String, Triple<String, String, String>, LinkedList<Object>> twoDimensionalMap1 = new TwoDimensionalMap<String, Triple<String, String, String>, LinkedList<Object>>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, true, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[6];
      identityHashMap1.put((String) null, doubleArray0);
      identityHashMap2.put(treeGraphNode1, doubleArray0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) hashMap0, identityHashMap2, identityHashMap2);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap0()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("&?2bT");
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag(wordLemmaTag0, wordLemmaTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      TwoDimensionalMap<String, Triple<String, String, String>, LinkedList<Object>> twoDimensionalMap1 = new TwoDimensionalMap<String, Triple<String, String, String>, LinkedList<Object>>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, false, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 3;
      identityHashMap3.put(treeGraphNode0, doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) hashMap0, identityHashMap3, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithEmptyMap0()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[4];
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      doubleArray0[0] = (double) 100;
      identityHashMap0.put("7#o<", doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) hashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithNegative0()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("<Su");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      List<Tree> list1 = treeGraphNode1.preOrderNodeList();
      treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(wordLemmaTag0, list1);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      TreeGraphNode treeGraphNode3 = new TreeGraphNode(treeGraphNode2, list1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode3, (-2.0), (Collection<Tree>) treeGraphNode3, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsThrowsRuntimeException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][4];
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((String) null, (List<Tree>) null);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = (-1004.70858816);
      doubleArray1[1] = 5.0;
      doubleArray1[2] = (double) 3;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = (double) 3;
      identityHashMap0.put(tree0, doubleArray1);
      splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap0, identityHashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree(tree0, true, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[5][0];
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.put("IX`9O`}^", "IX`9O`}^", doubleArray0);
      LabelFactory labelFactory0 = IndexedWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("IX`9O`}^");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap0, identityHashMap0);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.iteration = (-2342);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap1);
      assertTrue(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][4];
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((String) null, (List<Tree>) null);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = Morphology.stemStatic(";^9$q\"lGm=iE", ";^9$q\"lGm=iE");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[4][1][2];
      double[][] doubleArray1 = new double[7][3];
      double[] doubleArray2 = new double[6];
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[4];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = 0.0;
      doubleArray3[2] = 78.0;
      doubleArray3[3] = 0.0;
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[7];
      doubleArray4[0] = 5.0;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = (double) 100;
      doubleArray4[3] = 0.0;
      doubleArray4[4] = 0.0;
      doubleArray4[5] = 1.0;
      doubleArray4[6] = 0.0;
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[6];
      doubleArray5[0] = 78.0;
      doubleArray5[1] = 5.0;
      doubleArray5[2] = (-1008.5037756866);
      doubleArray5[3] = (double) 100;
      doubleArray5[4] = (-645.493833555);
      doubleArray5[5] = (double) 100;
      doubleArray1[3] = doubleArray5;
      double[] doubleArray6 = new double[2];
      doubleArray6[0] = (double) 100;
      doubleArray6[1] = 5.0;
      doubleArray1[4] = doubleArray6;
      double[] doubleArray7 = new double[2];
      doubleArray7[0] = (-1008.5037756866);
      doubleArray7[1] = 1.0;
      doubleArray1[5] = doubleArray7;
      double[] doubleArray8 = new double[2];
      doubleArray8[0] = 5.0;
      doubleArray8[1] = (-645.493833555);
      doubleArray1[6] = doubleArray8;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray9 = new double[4][0];
      doubleArray9[0] = doubleArray3;
      doubleArray9[1] = doubleArray5;
      doubleArray9[2] = doubleArray4;
      doubleArray9[3] = doubleArray5;
      doubleArray0[1] = doubleArray9;
      double[][] doubleArray10 = new double[3][4];
      doubleArray10[0] = doubleArray3;
      doubleArray10[1] = doubleArray2;
      doubleArray10[2] = doubleArray4;
      doubleArray0[2] = doubleArray10;
      double[][] doubleArray11 = new double[2][8];
      double[] doubleArray12 = new double[3];
      doubleArray12[0] = 1.0;
      doubleArray12[1] = 1.0;
      doubleArray11[0] = doubleArray12;
      doubleArray11[1] = doubleArray7;
      doubleArray0[3] = doubleArray11;
      identityHashMap1.put(treeGraphNode2, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode2, 100, identityHashMap0, identityHashMap1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = Morphology.stemStatic(";^9$q\"lGm=iE", ";^9$q\"lGm=iE");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[4][1][2];
      double[][] doubleArray1 = new double[7][3];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[4];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = 0.0;
      doubleArray3[2] = 78.0;
      doubleArray3[3] = 0.0;
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[7];
      doubleArray4[0] = 5.0;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = (double) 100;
      doubleArray4[3] = 0.0;
      doubleArray4[4] = 0.0;
      doubleArray4[5] = 1.0;
      doubleArray4[6] = 0.0;
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[6];
      doubleArray5[0] = 78.0;
      doubleArray5[1] = 5.0;
      doubleArray5[2] = (-1008.5037756866);
      doubleArray5[3] = (double) 100;
      doubleArray5[4] = (-645.493833555);
      doubleArray5[5] = (double) 100;
      doubleArray1[3] = doubleArray5;
      double[] doubleArray6 = new double[2];
      doubleArray6[0] = (double) 100;
      doubleArray6[1] = 5.0;
      doubleArray1[4] = doubleArray6;
      double[] doubleArray7 = new double[2];
      doubleArray7[0] = (-1008.5037756866);
      doubleArray7[1] = 1.0;
      doubleArray1[5] = doubleArray7;
      double[] doubleArray8 = new double[2];
      doubleArray8[0] = 5.0;
      doubleArray8[1] = (-645.493833555);
      doubleArray1[6] = doubleArray8;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray9 = new double[4][0];
      doubleArray9[0] = doubleArray3;
      doubleArray9[1] = doubleArray5;
      doubleArray9[2] = doubleArray4;
      doubleArray9[3] = doubleArray5;
      doubleArray0[1] = doubleArray9;
      double[][] doubleArray10 = new double[3][4];
      doubleArray10[0] = doubleArray3;
      doubleArray10[1] = doubleArray2;
      doubleArray10[2] = doubleArray4;
      doubleArray0[2] = doubleArray10;
      double[][] doubleArray11 = new double[2][8];
      double[] doubleArray12 = new double[3];
      doubleArray12[0] = 1.0;
      doubleArray12[1] = 1.0;
      doubleArray12[2] = 78.0;
      doubleArray11[0] = doubleArray12;
      doubleArray11[1] = doubleArray7;
      doubleArray0[3] = doubleArray11;
      identityHashMap1.put(treeGraphNode2, doubleArray0);
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode2, 100, identityHashMap0, identityHashMap1);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsTooManyResourcesException()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.setChildren(list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[1][7];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = 0.0;
      byte[] byteArray0 = new byte[3];
      byteArray0[0] = (byte) (-3);
      byteArray0[1] = (byte)79;
      byteArray0[2] = (byte)88;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      doubleArray1[1] = (double) 100;
      doubleArray0[0] = doubleArray1;
      identityHashMap0.put(treeGraphNode1, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, identityHashMap0, identityHashMap1);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = Morphology.stemStatic(";^9$q\"lGm=iE", ";^9$q\"lGm=iE");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[4][1][2];
      double[] doubleArray1 = new double[0];
      double[] doubleArray2 = new double[4];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = 0.0;
      doubleArray2[2] = 78.0;
      doubleArray2[3] = 0.0;
      double[] doubleArray3 = new double[7];
      doubleArray3[0] = 5.0;
      doubleArray3[1] = 0.0;
      doubleArray3[2] = (double) 100;
      doubleArray3[3] = 0.0;
      doubleArray3[5] = 1.0;
      doubleArray3[6] = 0.0;
      double[] doubleArray4 = new double[6];
      doubleArray4[1] = 5.0;
      doubleArray4[2] = (-1008.5037756866);
      doubleArray4[3] = (double) 100;
      doubleArray4[4] = (-645.493833555);
      doubleArray4[5] = (double) 100;
      double[] doubleArray5 = new double[2];
      doubleArray5[0] = (double) 100;
      doubleArray5[1] = 5.0;
      double[] doubleArray6 = new double[2];
      doubleArray6[0] = 5.0;
      doubleArray6[1] = (-645.493833555);
      double[][] doubleArray7 = new double[4][0];
      doubleArray7[0] = doubleArray3;
      doubleArray7[1] = doubleArray4;
      doubleArray7[2] = doubleArray3;
      doubleArray0[1] = doubleArray7;
      double[][] doubleArray8 = new double[3][4];
      doubleArray8[0] = doubleArray2;
      doubleArray8[1] = doubleArray1;
      doubleArray8[2] = doubleArray3;
      doubleArray0[2] = doubleArray8;
      double[][] doubleArray9 = new double[2][8];
      double[] doubleArray10 = new double[3];
      doubleArray10[0] = 1.0;
      doubleArray10[1] = 1.0;
      doubleArray10[2] = 78.0;
      doubleArray9[0] = doubleArray10;
      doubleArray0[3] = doubleArray9;
      identityHashMap1.put(treeGraphNode2, doubleArray0);
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode2, 100, identityHashMap0, identityHashMap1);
      assertNotSame(treeGraphNode1, treeGraphNode2);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordTag wordTag0 = WordTag.valueOf(")n?i#ezL|3AGY~q", ")n?i#ezL|3AGY~q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) identityHashMap0, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode2, doubleArray0, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      assertEquals(1, identityHashMap0.size());
      assertArrayEquals(new double[] {0.0, 0.0, 100.0, 100.0}, doubleArray0, 0.01);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithZero0()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      Label label0 = taggedWordFactory0.newLabelFromString(".$$.");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      treeGraphNode0.highestNodeWithSameHead();
      StringLabel stringLabel0 = new StringLabel();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(stringLabel0, list0);
      List<Tree> list1 = treeGraphNode0.subTreeList();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      coreLabelTokenFactory0.makeToken("^", "^", (-1), 0);
      options0.nodePrune = false;
      TreeGraphNode treeGraphNode3 = new TreeGraphNode(treeGraphNode1, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list1, (double) 0, (Collection<Tree>) treeGraphNode1, 3.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithZero1()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      Label label0 = taggedWordFactory0.newLabelFromString(".$$.");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      treeGraphNode0.highestNodeWithSameHead();
      StringLabel stringLabel0 = new StringLabel();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(stringLabel0, list0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      options0.nodePrune = false;
      TreeGraphNode treeGraphNode3 = new TreeGraphNode(treeGraphNode1, list0);
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list0, (double) 0, (Collection<Tree>) treeGraphNode1, 3.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7:o<");
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag(wordLemmaTag0, wordLemmaTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (-3213.9570531836);
      doubleArray0[3] = 0.0;
      identityHashMap0.put("7:o<", doubleArray0);
      TwoDimensionalMap<String, Triple<String, String, String>, LinkedList<Object>> twoDimensionalMap1 = new TwoDimensionalMap<String, Triple<String, String, String>, LinkedList<Object>>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, true, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      double[] doubleArray1 = new double[2];
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      identityHashMap1.put(treeGraphNode1, doubleArray1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap1()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[4];
      identityHashMap0.put("7#o<", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      identityHashMap1.put(treeGraphNode1, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][3][8];
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      threeDimensionalMap0.put("V)Mxfli", "V)Mxfli", "V)Mxfli", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      threeDimensionalMap1.thirdKeySet();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateBetas(true);
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag(".I%=HQg=4yGnu|G*!");
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.state(".I%=HQg=4yGnu|G*!", 100);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode2, doubleArray0, (-194), identityHashMap0, identityHashMap2, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag(".I%=HQg=4yGnu|G*!");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[] doubleArray0 = new double[3];
      doubleArray0[1] = 0.0;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode2, doubleArray0, 100, identityHashMap0, identityHashMap2, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      List<LabeledScoredTreeNode> list1 = treeGraphNode1.getLeaves();
      treeGraphNode0.setChildren(list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray0 = new double[0];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 0, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndBuildStateIndexAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("|PSv", 100);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.buildGrammars();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceReturningFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[4][6];
      double[] doubleArray1 = new double[2];
      doubleArray1[1] = (double) 100;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put((String) null, "^", doubleArray0);
      double[][][] doubleArray2 = new double[7][3][9];
      threeDimensionalMap0.put("p^3!P;7", "_^ck46g(&:iu:tx($[[/", "p^3!P;7", doubleArray2);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithNegative1()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("<Su");
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag(wordLemmaTag0, wordLemmaTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      List<Tree> list1 = treeGraphNode1.preOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(wordLemmaTag0, list1);
      treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode3 = new TreeGraphNode(wordLemmaTag0, list1);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      TreeGraphNode treeGraphNode4 = new TreeGraphNode(treeGraphNode3, list1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode4, (-2.0), (Collection<Tree>) treeGraphNode4, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithPositive0()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("==-,Zr");
      WordTag wordTag0 = new WordTag("==-,Zr");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      CoreLabel coreLabel0 = new CoreLabel(3);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(coreLabel0, list1);
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode2, 5.0, (Collection<Tree>) list1, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag((String) null);
      WordTag wordTag0 = new WordTag((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      List<Tree> list1 = treeGraphNode1.postOrderNodeList();
      CoreLabel coreLabel0 = new CoreLabel(3);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(coreLabel0, list1);
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode2, 5.0, (Collection<Tree>) list1, (double) 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeExceptionAndRecalculateTemporaryBetasTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag(".I%=HQg=4yGnu|G*!");
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, true, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(treeGraphNode2, false, 100, identityHashMap2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag(".I%=HQg=4yGnu|G*!");
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      treeGraphNode1.setParent(treeGraphNode0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(treeGraphNode2, identityHashMap1, identityHashMap1, identityHashMap0, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag(".I%jHQg=4ynu|G*!");
      WordTag wordTag1 = WordTag.valueOf(".I%jHQg=4ynu|G*!");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(treeGraphNode2, identityHashMap1, identityHashMap1, identityHashMap0, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag("Ji&sRv~_QdN_", "Ji&sRv~_QdN_");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.preOrderNodeList();
      treeGraphNode1.setChildren(list0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap0, identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments1()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag(".I%=HQg=4yGnu|G*!");
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode2, 19, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = Morphology.stemStatic(".I%=HQg=4yGnu|G*j!", ".I%=HQg=4yGnu|G*j!");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode2, 100, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateSplittingGrammarExtractorThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag(".I%=HQg=4yGnu|G*!");
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode2, false, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("<Su");
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag(wordLemmaTag0, wordLemmaTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      List<Tree> list1 = treeGraphNode1.preOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(wordLemmaTag0, list1);
      treeGraphNode0.highestNodeWithSameHead();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(treeGraphNode2, false, 100, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag(".I%=HQg=4yGnu|G*!");
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list1);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode0, 0.0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (-2604.6);
      doubleArray0[5] = (double) 100;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.mergeTransitions(treeGraphNode2, identityHashMap0, identityHashMap2, identityHashMap0, identityHashMap3, doubleArray0, hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerException0()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("==-,Zr", "==-,Zr");
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = new CoreLabel(3);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(coreLabel0, list1);
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>(100);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode2, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap1, (double[]) null, map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag("Ji&sRv~_QdN_", "Ji&sRv~_QdN_");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.preOrderNodeList();
      treeGraphNode1.setChildren(list0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>(100);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode1, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap2, (double[]) null, map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndUseNewBetasWithTrue()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[8][5][8];
      double[] doubleArray1 = new double[15];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.isEmpty();
      threeDimensionalMap0.put("    ", (String) null, ".$$.", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertNotSame(threeDimensionalMap0, threeDimensionalMap1);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndUseNewBetasWithFalse()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[8][5][8];
      double[][] doubleArray1 = new double[6][0];
      double[] doubleArray2 = new double[15];
      doubleArray1[1] = doubleArray2;
      doubleArray1[2] = doubleArray2;
      doubleArray1[2] = doubleArray2;
      doubleArray1[5] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.isEmpty();
      twoDimensionalMap0.put("50l", "    ", doubleArray1);
      threeDimensionalMap1.put(",MW?4", "-maSdr", "50l", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      assertNotSame(threeDimensionalMap1, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = WordTag.valueOf("BI[NARY:", "BI[NARY:");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      wordTag0.setTag("  Transitions:");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, true, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertNotSame(treeGraphNode1, treeGraphNode0);
      
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, true, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertNotSame(treeGraphNode1, treeGraphNode0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][4][8];
      double[][] doubleArray1 = new double[6][3];
      FileSystemHandling.shouldAllThrowIOExceptions();
      twoDimensionalMap0.put("    ", "cMol7", doubleArray1);
      threeDimensionalMap0.put("50l", "50l", "8op", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      double[][] doubleArray0 = new double[7][3];
      FileSystemHandling.shouldAllThrowIOExceptions();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.put(" in ", "    ", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor2.splitBetas();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray1 = new double[4][5][2];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = null;
      double[][] doubleArray2 = new double[2][8];
      double[] doubleArray3 = new double[8];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = 0.0;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = (double) 100;
      doubleArray3[4] = (double) 100;
      doubleArray3[5] = (double) 100;
      doubleArray3[6] = 1.0;
      doubleArray3[7] = (double) 100;
      doubleArray2[0] = doubleArray3;
      double[] doubleArray4 = new double[2];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 0.0;
      doubleArray2[1] = doubleArray4;
      doubleArray1[3] = doubleArray2;
      identityHashMap2.put((Tree) null, doubleArray1);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recountTree((Tree) null, true, identityHashMap3, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag0 = WordTag.valueOf(")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      treeGraphNode2.upperMostUnary(treeGraphNode1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode2, identityHashMap0, identityHashMap2, identityHashMap1, identityHashMap2, doubleArray0, hashMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>(identityHashMap0);
      splittingGrammarExtractor0.recountTree((Tree) treeGraphNode2, false, identityHashMap3, identityHashMap3, identityHashMap4, identityHashMap2);
      assertTrue(identityHashMap2.isEmpty());
      assertEquals(0, identityHashMap4.size());
      assertTrue(identityHashMap4.equals((Object)identityHashMap0));
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[6][3][8];
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      double[][] doubleArray1 = new double[2][8];
      double[] doubleArray2 = new double[2];
      doubleArray2[0] = 2026.56379;
      doubleArray2[1] = 0.0;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[6];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = 2026.56379;
      doubleArray3[2] = 2026.56379;
      doubleArray3[3] = (double) 100;
      doubleArray3[4] = 0.0;
      doubleArray3[5] = 0.0;
      doubleArray1[1] = doubleArray3;
      twoDimensionalMap0.put(" -> ", "l", doubleArray1);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetas0()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][4];
      twoDimensionalMap0.put((String) null, "a    ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap2()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[4];
      identityHashMap0.put("7#o<", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndRecalculateBetas()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("=-,Zr", (String) null);
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode3 = new TreeGraphNode(wordTag0);
      treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode4 = new TreeGraphNode(treeGraphNode2, list0);
      treeGraphNode3.highestNodeWithSameHead();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      Comparator<String> comparator0 = (Comparator<String>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      MapFactory<String, double[][]> mapFactory1 = MapFactory.weakHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, false, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap2, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      double[][][] doubleArray0 = new double[1][4][8];
      double[][] doubleArray1 = new double[5][3];
      FileSystemHandling.shouldAllThrowIOExceptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("", "", doubleArray1);
      threeDimensionalMap0.put("", "!xzx(sf", "!xzx(sf", doubleArray0);
      splittingGrammarExtractor1.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[8][5][8];
      double[][] doubleArray1 = new double[6][0];
      double[] doubleArray2 = new double[15];
      doubleArray1[1] = doubleArray2;
      doubleArray1[2] = doubleArray2;
      doubleArray1[2] = doubleArray2;
      doubleArray1[5] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      twoDimensionalMap0.put("", "", doubleArray1);
      threeDimensionalMap0.put("4W$I:S;,g!4}M", "y>g", ",MW?4", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndSplitBetas()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][3][8];
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      threeDimensionalMap0.put("V)Mxfli", "V)Mxfli", "V)Mxfli", doubleArray0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) 18;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, doubleArray1, 1305, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndUseNewBetasAndRecalculateBetasWithFalseAndUseNewBetasWithTrue()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("=-,Zr", (String) null);
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      FileSystemHandling.shouldAllThrowIOExceptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, true);
      double[][] doubleArray0 = new double[2][0];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 5.0;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[6];
      doubleArray2[0] = (double) 0;
      doubleArray2[1] = 1.0E-4;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = (double) 100;
      doubleArray2[4] = (double) 0;
      doubleArray2[5] = 1216.2572480556769;
      doubleArray0[1] = doubleArray2;
      twoDimensionalMap0.put("BINARY:", "?S81eB{#/]uFS6Y", doubleArray0);
      splittingGrammarExtractor1.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor1.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndUseNewBetasAndRecalculateBetasWithTrueAndUseNewBetasWithFalse()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("=-,Zr", (String) null);
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      treeGraphNode0.highestNodeWithSameHead();
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][3];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("", "useGenia", doubleArray0);
      splittingGrammarExtractor0.recalculateBetas(true);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean1 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][4];
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][0];
      twoDimensionalMap0.put("    ", "    ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[0][1];
      twoDimensionalMap0.put("a    ", "a    ", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecalculateTemporaryBetasTaking4ArgumentsAndTestConvergence()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][3][8];
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      threeDimensionalMap0.put("V)Mxfli", "V)Mxfli", "V)Mxfli", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      threeDimensionalMap1.thirdKeySet();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[8][5][8];
      double[] doubleArray1 = new double[15];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.isEmpty();
      threeDimensionalMap0.put("-maSdr", (String) null, ".$$.", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertNotSame(threeDimensionalMap0, threeDimensionalMap1);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithPositive1()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("=-,Zr", (String) null);
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = WordTag.valueOf("=-,Zr");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode3 = new TreeGraphNode(wordLemmaTag0, list0);
      List<Tree> list1 = treeGraphNode2.subTreeList();
      TreeGraphNode treeGraphNode4 = new TreeGraphNode(treeGraphNode1, list1);
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode4, 5.0, (Collection<Tree>) list1, (double) 3);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException0()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("=-,Zr", (String) null);
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode0.parent();
      treeGraphNode2.upperMostUnary(treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      MapFactory.linkedHashMapFactory();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) treeGraphNode2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][0];
      twoDimensionalMap0.put("    ", "    ", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetas1()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      double[][][] doubleArray0 = new double[1][3][8];
      double[][] doubleArray1 = new double[1][3];
      double[] doubleArray2 = new double[9];
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = 0.0;
      doubleArray2[4] = (double) 100;
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = 0.0;
      doubleArray2[7] = (double) 100;
      doubleArray2[8] = 0.0;
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("V)Mxfli", "V)Mxfli", "V)Mxfli", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap1.remove("^", "w`fHQto-_+S`7V>,@", "");
      threeDimensionalMap1.put((String) null, "", "V)Mxfli", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      System.setCurrentTimeMillis((-314L));
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithPositive2()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = WordTag.valueOf("si)&URru~_Qd%_", "si)&URru~_Qd%_");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1, (double) 100, (Collection<Tree>) list0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesThrowsNullPointerException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("=-,Zr", (String) null);
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode3 = treeGraphNode0.parent();
      treeGraphNode3.upperMostUnary(treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.treebankLanguagePack();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (-929.6312);
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 0;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<CoreLabel, LinkedList<Object>> mapFactory0 = MapFactory.linkedHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap3, 0);
      Map<String, double[]> map1 = mapFactory0.setMap(map0, 2);
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>(map1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode2, doubleArray0, 87, identityHashMap1, identityHashMap2, (Map<String, double[]>) hashMap1, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetas2()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][4];
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      MapFactory.hashMapFactory();
      TwoDimensionalMap.hashMap();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      CoreLabel coreLabel0 = new CoreLabel(100);
      CoreLabel coreLabel1 = new CoreLabel(coreLabel0);
      IndexedWord indexedWord0 = new IndexedWord(coreLabel1);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0, linkedList0);
      LinkedList<Triple<String, Integer, Double>> linkedList1 = new LinkedList<Triple<String, Integer, Double>>();
      indexedWord0.tag();
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("-lengthPenalty", 100, 0.0);
      linkedList1.add(triple0);
      List<Triple<String, Integer, Double>> list0 = new Stack<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(list0);
      splittingGrammarExtractor0.getStateSplitCount((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) treeGraphNode0, false, identityHashMap0, identityHashMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndState()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      TaggedWord taggedWord0 = new TaggedWord(",");
      StringLabel stringLabel0 = new StringLabel(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(treeGraphNode0, list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      stringLabel0.setValue(",");
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor2.recountWeights(simpleTree0, identityHashMap1, identityHashMap1, identityHashMap2, identityHashMap0);
      String string0 = splittingGrammarExtractor1.state(",", 1140);
      assertEquals(",^1140", string0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.remove("7P'7", "7P'7");
      threeDimensionalMap0.remove("7P'7", "7P'7", "7P'7");
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      WordTagFactory wordTagFactory0 = new WordTagFactory('8');
      wordTagFactory0.newLabelFromString("BINARY:");
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsAndRecountTreeTaking6ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("pI4+#[B;%:;Q&l#");
      StringLabel stringLabel0 = new StringLabel(taggedWord0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(stringLabel0, (-1907.822176544941));
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      stringLabel0.setValue((String) null);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(labeledScoredTreeNode0, identityHashMap2, identityHashMap2, identityHashMap0, identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) labeledScoredTreeNode0, true, identityHashMap2, identityHashMap2, identityHashMap0, identityHashMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")n[?i#ezL|3A<GY~Eq", ")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag0 = Morphology.stemStatic(")n[?i#ezL|3A<GY~Eq", ")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      treeGraphNode2.upperMostUnary(treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.size();
      double[][][] doubleArray0 = new double[8][2][2];
      double[][] doubleArray1 = new double[2][3];
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[6];
      doubleArray3[0] = (double) 0;
      doubleArray3[1] = (double) 0;
      doubleArray3[2] = (double) 0;
      doubleArray3[3] = (double) 100;
      doubleArray3[4] = (double) 0;
      doubleArray3[5] = (double) 0;
      doubleArray1[1] = doubleArray3;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray4 = new double[7][5];
      doubleArray4[0] = doubleArray3;
      doubleArray4[1] = doubleArray3;
      doubleArray4[2] = doubleArray3;
      doubleArray4[3] = doubleArray2;
      doubleArray4[4] = doubleArray3;
      doubleArray4[5] = doubleArray3;
      double[] doubleArray5 = new double[5];
      doubleArray5[0] = (-89.222480618);
      doubleArray5[1] = 0.9999000099990001;
      doubleArray5[2] = (double) 0;
      doubleArray5[3] = (double) 0;
      doubleArray5[4] = (double) 0;
      doubleArray4[6] = doubleArray5;
      doubleArray0[1] = doubleArray4;
      double[][] doubleArray6 = new double[5][1];
      doubleArray6[0] = doubleArray5;
      double[] doubleArray7 = new double[3];
      doubleArray7[0] = (double) 0;
      doubleArray7[1] = (double) 100;
      doubleArray7[2] = 0.9999000099990001;
      doubleArray6[1] = doubleArray7;
      doubleArray6[2] = doubleArray3;
      doubleArray6[3] = doubleArray2;
      doubleArray6[4] = doubleArray5;
      doubleArray0[2] = doubleArray6;
      double[][] doubleArray8 = new double[2][8];
      doubleArray8[0] = doubleArray5;
      doubleArray8[1] = doubleArray2;
      doubleArray0[3] = doubleArray8;
      double[][] doubleArray9 = new double[2][8];
      doubleArray9[0] = doubleArray2;
      doubleArray9[1] = doubleArray2;
      doubleArray0[4] = doubleArray9;
      double[][] doubleArray10 = new double[9][5];
      doubleArray10[0] = doubleArray3;
      doubleArray10[1] = doubleArray7;
      doubleArray10[2] = doubleArray3;
      doubleArray10[3] = doubleArray5;
      doubleArray10[4] = doubleArray5;
      doubleArray10[5] = doubleArray3;
      doubleArray10[6] = doubleArray7;
      doubleArray10[7] = doubleArray7;
      doubleArray10[8] = doubleArray7;
      doubleArray0[5] = doubleArray10;
      double[][] doubleArray11 = new double[1][2];
      doubleArray11[0] = doubleArray3;
      doubleArray0[6] = doubleArray11;
      double[][] doubleArray12 = new double[4][4];
      doubleArray12[0] = doubleArray2;
      doubleArray12[1] = doubleArray5;
      doubleArray12[2] = doubleArray2;
      doubleArray12[3] = doubleArray3;
      doubleArray0[7] = doubleArray12;
      threeDimensionalMap0.put(")n[?i#ezL|3A<GY~Eq", ")n[?i#ezL|3A<GY~Eq", "^H", doubleArray0);
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "F=2@gFeO]I,PY49NZZ");
      threeDimensionalMap0.getTwoDimensionalMap(")n[?i#ezL|3A<GY~Eq");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateSplittingGrammarExtractorThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      twoDimensionalMap0.put("NP=l=PRN");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("  ", "  ", "  ");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.getTwoDimensionalMap("=v");
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Options options2 = spanishUnknownWordModelTrainer0.op;
      SplittingGrammarExtractor splittingGrammarExtractor1 = null;
      try {
        splittingGrammarExtractor1 = new SplittingGrammarExtractor((Options) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsAndRecountOutsideTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("=-,Zr", (String) null);
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      CategoryWordTagFactory categoryWordTagFactory0 = new CategoryWordTagFactory();
      categoryWordTagFactory0.newLabel("y>g");
      TreeGraphNode treeGraphNode3 = new TreeGraphNode(wordTag0);
      treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode4 = new TreeGraphNode(treeGraphNode0, list0);
      TreeGraphNode treeGraphNode5 = new TreeGraphNode(treeGraphNode2, list0);
      Tree tree0 = treeGraphNode2.upperMostUnary(treeGraphNode1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      MapFactory<CoreLabel, Triple<Object, SplittingGrammarExtractor, SplittingGrammarExtractor>> mapFactory0 = MapFactory.hashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      mapFactory0.setMap(identityHashMap1);
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode2, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>(1842);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode3, tree0, identityHashMap2, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag0 = WordTag.valueOf(")n[?i#ezL|3A<GY~Eq");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      treeGraphNode1.highestNodeWithSameHead();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Options options1 = new Options(options0.tlpParams);
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) hashMap1, (Map<String, double[]>) hashMap1);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor3.recalculateMergedBetas(hashMap0);
      assertTrue(hashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecurseOutside0()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("=-,Zr", (String) null);
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      treeGraphNode1.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode0.parent();
      Tree tree0 = treeGraphNode2.upperMostUnary(treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(taggedWordFactory0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tree0, list0);
      TreeFactory treeFactory0 = labeledScoredTreeNode0.treeFactory();
      treeGraphNode0.treeSkeletonConstituentCopy(treeFactory0, (LabelFactory) taggedWordFactory0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.transformTree(labeledScoredTreeNode0, treeGraphNode1);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recurseOutside(treeGraphNode1, identityHashMap3, identityHashMap3);
      assertSame(treeGraphNode1, tree0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")n[?i#ezL|3A<GY~Eq", ")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      treeGraphNode2.upperMostUnary(treeGraphNode1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode2, 100, identityHashMap3, identityHashMap2);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor1.recountInside(treeGraphNode2, false, 65, identityHashMap4);
      assertEquals(66, int0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitionsAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")n[?i#ezL|3A<GY~Eq", ")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      treeGraphNode2.upperMostUnary(treeGraphNode1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap0, identityHashMap2);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (double) 100;
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode1, identityHashMap0, identityHashMap2, identityHashMap1, identityHashMap2, doubleArray0, hashMap0);
      assertNotSame(treeGraphNode1, treeGraphNode0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndBuildMergeCorrespondenceAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = WordTag.valueOf("mBI7NIRY:");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recountInside(treeGraphNode1, true, 100, identityHashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode1, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, (double[]) null, map0);
      assertNotSame(treeGraphNode0, treeGraphNode1);
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")n[?i#ezL|3A<GY~Eq", ")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = new WordTag(wordLemmaTag0);
      WordTag wordTag2 = WordTag.valueOf("73dcaW4!G2KFw$!w");
      Morphology.stemStatic(wordTag2);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      treeGraphNode1.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode2.upperMostUnary(treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Options options1 = new Options(options0.tlpParams);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode1, false, 100, identityHashMap2);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("g}Hme_ye. ]Bi0[Vw'D");
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag(wordLemmaTag0, wordLemmaTag0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      Label label0 = taggedWordFactory0.newLabel(".$$.");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0, list0);
      TreeGraphNode treeGraphNode3 = treeGraphNode2.highestNodeWithSameHead();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode3, true, (-52), identityHashMap0);
      assertEquals((-51), int0);
  }

  @Test(timeout = 4000)
  public void testRecountInside()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = Morphology.stemStatic("IWkA0J<7|`h", "IWkA0J<7|`h");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode1, false, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")n[?i#ezL|3A<GY~Eq", ")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      treeGraphNode2.upperMostUnary(treeGraphNode1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap0, identityHashMap2);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode2, true, 100, identityHashMap3);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testStateAndNeginfDoublesAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      MapFactory<String, double[][]> mapFactory1 = MapFactory.linkedHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("  ");
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      WordTagFactory wordTagFactory0 = new WordTagFactory('b');
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(100);
      String string0 = splittingGrammarExtractor0.state(".$$.", 198);
      assertEquals(".$$.", string0);
      
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(925);
      assertEquals(925, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testState0()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      String string0 = splittingGrammarExtractor0.state(".$$.", 100);
      assertEquals(".$$.", string0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")n[?i#ezL|3A<GY~Eq", ")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode2.upperMostUnary(treeGraphNode1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateBetas(true);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap2, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.remove("l", "l");
      threeDimensionalMap0.remove("l", "l", "e8/7vaUzsE~=");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.hashMap();
      String string0 = "c";
      twoDimensionalMap1.put("c", "(logs) -7 + -Inf = ", (double[][]) null);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetas3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.get("QsTjq)", "QsTjq)");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")n[?i#ezL|3A<GY~Eq", ")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag0 = Morphology.stemStatic(")n[?i#ezL|3A<GY~Eq", ")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode2.upperMostUnary(treeGraphNode1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.getTwoDimensionalMap(")n[?i#ezL|3A<GY~Eq");
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, (double[]) null, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap1, threeDimensionalMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(")n[?i#ezL|3A<GY~Eq", ")n[?i#ezL|3A<GY~Eq");
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      WordTag wordTag1 = Morphology.stemStatic(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag1, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode2.upperMostUnary(treeGraphNode1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      tree0.toArray();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, (double[]) null, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap1, threeDimensionalMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      TaggedWord taggedWord0 = new TaggedWord(",");
      StringLabel stringLabel0 = new StringLabel(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(treeGraphNode0, list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<CoreLabel, Triple<Object, SplittingGrammarExtractor, SplittingGrammarExtractor>> mapFactory0 = MapFactory.linkedHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      mapFactory0.setMap(hashMap0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndRecalculateMergedBetas()  throws Throwable  {
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      LabeledWord labeledWord0 = new LabeledWord("u2uS\"a");
      StringLabel stringLabel0 = new StringLabel(labeledWord0);
      CoreLabel.factory();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      labeledWord0.equals(arrayList0);
      Object object0 = new Object();
      SimpleTree simpleTree0 = new SimpleTree(labeledWord0, arrayList0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<CoreLabel, Triple<Object, SplittingGrammarExtractor, SplittingGrammarExtractor>> mapFactory0 = MapFactory.linkedHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      mapFactory0.setMap(hashMap0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.extract((Collection<Tree>) arrayList0);
      HashMap<String, int[]> hashMap1 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateMergedBetas(hashMap1);
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("7#o<", "7#o<");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.setChildren(list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(treeGraphNode1, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNull()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      HashSet<Tree> hashSet0 = new HashSet<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("&TE=g[i2", (List<Tree>) null);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor2.recountOutside(tree0, identityHashMap0, identityHashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      assertFalse(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(labeledScoredTreeNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      assertTrue(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesReturningEmptyArray()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(0);
      assertEquals(0, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerExceptionAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][] doubleArray0 = new double[6][0];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = (double) 100;
      doubleArray0[1] = doubleArray2;
      MapFactory<Object, Object> mapFactory0 = MapFactory.hashMapFactory();
      MapFactory<String, CoreLabel> mapFactory1 = MapFactory.identityHashMapFactory();
      Map<String, double[]> map0 = mapFactory1.setMap(null);
      mapFactory0.setMap(map0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      WordTag wordTag0 = new WordTag(",", "Serializing classifier to ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.outputBetas();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountOutside((Tree) treeGraphNode0, (Tree) treeGraphNode0, (Tree) treeGraphNode1, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndBuildGrammarsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("qnuM[Tn7_$");
      StringLabel stringLabel0 = new StringLabel(labeledWord0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      WordTag wordTag0 = new WordTag("LEXICON");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.preOrderNodeList();
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      Label label0 = taggedWordFactory0.newLabel(",Mf.5K");
      SimpleTree simpleTree0 = new SimpleTree(label0, list0);
      TwoDimensionalMap.treeMap();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode1, identityHashMap0, identityHashMap0);
      HashSet<Tree> hashSet0 = new HashSet<Tree>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.hashMapFactory();
      mapFactory0.setMap(identityHashMap0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      WordTag wordTag0 = new WordTag("LEXICON", "LEXICON");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode2.preOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.outputBetas();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode2, (Tree) simpleTree0, (Tree) treeGraphNode2, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Integer integer0 = new Integer((-388));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>(".I%jHQg=4ynu|G*!", integer0, (Double) 0.0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.buildMergeCorrespondence(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("qnuM[Tn7_$");
      StringLabel stringLabel0 = new StringLabel("qnuM[Tn7_$", 100, 100);
      LabelFactory labelFactory0 = CoreLabel.factory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) labeledWord0, (List<Tree>) arrayList0);
      arrayList0.add(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>(0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap1, identityHashMap2);
      splittingGrammarExtractor0.state("Mc13", 100);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap3, identityHashMap2);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      boolean boolean0 = true;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) null, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = null;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) null, (Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideWithTreeWhereScoreIsNegative()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      String[] stringArray0 = new String[7];
      stringArray0[0] = "4Ga!/);-";
      stringArray0[1] = "F(,bFspOE#g";
      stringArray0[2] = "Ba;XI5>eey[#";
      stringArray0[3] = "v~iu5kN=1;";
      options1.dcTags = false;
      stringArray0[4] = ")n[?i#ezL|3A<GY~Eq";
      stringArray0[5] = "-------------------";
      stringArray0[6] = " | ";
      options1.setOptionsOrWarn(stringArray0);
      TaggedWord taggedWord0 = new TaggedWord("pI4+#[B;%:;Q&l#");
      StringLabel stringLabel0 = new StringLabel(taggedWord0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(stringLabel0, (-1907.822176544941));
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (-1907.822176544941);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(labeledScoredTreeNode0, identityHashMap2, identityHashMap3);
      assertNotSame(identityHashMap3, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndRecurseOutside()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("==-,Zr");
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = new CoreLabel(3);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(coreLabel0, list1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>(0);
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(treeGraphNode2, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabelFactory labelFactory0 = CoreLabel.factory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>(0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      System.setCurrentTimeMillis(0);
      splittingGrammarExtractor0.extract((Collection<Tree>) arrayList0, (double) 0, (Collection<Tree>) arrayList0, (double) 0);
      assertEquals(0, arrayList0.size());
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndExtractTakingCollectionThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.hashMapFactory();
      mapFactory0.setMap(identityHashMap0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      WordTag wordTag0 = new WordTag("LEXICON");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(wordTag0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      MapFactory<CoreLabel, Triple<Object, SplittingGrammarExtractor, SplittingGrammarExtractor>> mapFactory1 = MapFactory.linkedHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      mapFactory1.setMap(identityHashMap0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments2()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.hashMapFactory();
      mapFactory0.setMap(identityHashMap0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      WordTag wordTag0 = new WordTag("LEXICON");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode2.preOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      coreLabelTokenFactory0.makeToken();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode1);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      treeGraphNodeFactory0.newLeaf((Label) treeGraphNode2);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.outputTransitions((Tree) simpleTree0, 100, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndOutputTransitionsTaking4ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = Morphology.stemStatic(";^9$q\"lGm=iE", ";^9$q\"lGm=iE");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, identityHashMap0, identityHashMap1);
      assertNotSame(treeGraphNode0, treeGraphNode1);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRescaleTemporaryBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][] doubleArray0 = new double[6][0];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      doubleArray0[1] = doubleArray1;
      double[] doubleArray2 = new double[9];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray2[4] = 0.0;
      doubleArray2[8] = 0.0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap1.remove("&T?Oy_k~@-m=", "&T?Oy_k~@-m=", "i");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.hashMap();
      twoDimensionalMap1.put("w<hy;ckq", "--== ", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap1);
      WordTagFactory wordTagFactory0 = new WordTagFactory('8');
      threeDimensionalMap0.getTwoDimensionalMap("(logs) -7 + -Inf = ");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap3 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap3);
      assertTrue(twoDimensionalMap0.equals((Object)twoDimensionalMap2));
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("pI4+#[B;%:;Q&l#");
      StringLabel stringLabel0 = new StringLabel(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode1.preOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(taggedWord0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory.linkedHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.state("Post-split betas", 100);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Double double0 = new Double(0.0);
      Double double1 = new Double(100);
      Triple.makeTriple("pI4+#[B;%:;Q&l#", 100, double1);
      Integer integer0 = new Integer((-2023));
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("Post-split betas^100", integer0, double1);
      linkedList0.add(triple0);
      treeGraphNode1.yield(linkedList0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsWithNull()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      TaggedWordFactory taggedWordFactory1 = new TaggedWordFactory('X');
      WordTagFactory wordTagFactory0 = new WordTagFactory('n');
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      Label label0 = wordTagFactory0.newLabelFromString("XoaD8vW(j");
      Tree tree0 = treeGraphNodeFactory0.newLeaf(label0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.state("Post-split betas", 100);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Double double0 = new Double(0.0);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("Post-split betas^100", 100, double0);
      linkedList0.add(triple0);
      List<Triple<String, Integer, Double>> list0 = tree0.yield(linkedList0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap2, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(list0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // class edu.stanford.nlp.ling.CoreLabel cannot be cast to class edu.stanford.nlp.util.Triple (edu.stanford.nlp.ling.CoreLabel and edu.stanford.nlp.util.Triple are in unnamed module of loader org.evosuite.instrumentation.InstrumentingClassLoader @37968eca)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("4CD_X>!+", 100, 0.0);
      linkedList0.add(triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("qnuM[Tn7_$");
      StringLabel stringLabel0 = new StringLabel(labeledWord0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      WordTag wordTag0 = new WordTag("LEXICON");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.preOrderNodeList();
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      Label label0 = taggedWordFactory0.newLabel(",Mf.5K");
      SimpleTree simpleTree0 = new SimpleTree(label0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode2, doubleArray0, 63107296, identityHashMap0, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
      MapFactory<CoreLabel, Triple<Object, SplittingGrammarExtractor, SplittingGrammarExtractor>> mapFactory0 = MapFactory.linkedHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      mapFactory0.setMap(hashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      stack0.add((Triple<String, Integer, Double>) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNegative()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("pI4+#[B;%:;Q&l#");
      StringLabel stringLabel0 = new StringLabel(taggedWord0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(stringLabel0, (-1907.822176544941));
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.saveTrees(labeledScoredTreeNode0, 979.6555, labeledScoredTreeNode0, (-7.0));
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      PriorityQueue<Tree> priorityQueue0 = new PriorityQueue<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) priorityQueue0, (double) 100, (Collection<Tree>) priorityQueue0, (-1.0));
      assertEquals(0, priorityQueue0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      LabeledWord labeledWord0 = new LabeledWord("qnuM[Tn7_$");
      StringLabel stringLabel0 = new StringLabel(labeledWord0);
      LabelFactory labelFactory0 = CoreLabel.factory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) labeledWord0, (List<Tree>) arrayList0);
      arrayList0.add(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.saveTrees(tree0, (-3434.3734422), tree0, 1515.3449642485436);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(false);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndRecalculateBetasWithFalse()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.hashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      WordTag wordTag0 = new WordTag("LEXICON");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode2.preOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      coreLabelTokenFactory0.makeToken();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode1);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor2.recalculateBetas(false);
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) identityHashMap1, map0, identityHashMap3, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithEmptyMap1()  throws Throwable  {
      WordTag wordTag0 = new WordTag("w=)F", "w=)F");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetas4()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[8][8][8];
      double[][] doubleArray1 = new double[20][0];
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("Or#4jTC", "Or#4jTC", "Or#4jTC", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecountOutsideTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      hebrewTreebankParserParams0.setOutputEncoding("sz-o\"XQob");
      pennTreebankLanguagePack0.isPunctuationTag("sz-o\"XQob");
      pennTreebankLanguagePack0.isEvalBIgnoredPunctuationTag(")yr/}yz_~GIhmZ");
      Options options2 = new Options(hebrewTreebankParserParams0);
      options0.newTrainOptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(coreLabel0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateBetas(true);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap0, identityHashMap2, identityHashMap2);
      splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, identityHashMap2, identityHashMap2);
      assertFalse(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.hashMapFactory();
      mapFactory0.setMap(identityHashMap0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      WordTag wordTag0 = new WordTag("k0Gd");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode2.preOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.outputBetas();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      splittingGrammarExtractor0.getStateSplitCount("}y|%d[");
      Map<String, int[]> map1 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      assertTrue(map1.equals((Object)map0));
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringWithNonEmptyString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount("-;GU,,3}kY4U?lGq5y");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testRecurseOutside1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode((Label) null);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3Arguments()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      hebrewTreebankParserParams0.setOutputEncoding("sz-o\"XQob");
      pennTreebankLanguagePack0.isPunctuationTag("sz-o\"XQob");
      pennTreebankLanguagePack0.isEvalBIgnoredPunctuationTag("sz-o\"XQob");
      Options options0 = new Options(hebrewTreebankParserParams0);
      options0.newTrainOptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(coreLabel0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      MapFactory<String, String> mapFactory0 = MapFactory.weakHashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) identityHashMap0, map0, identityHashMap1, identityHashMap1);
      splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, identityHashMap1, identityHashMap1);
      assertFalse(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testStateThrowsNullPointerException()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      hebrewTreebankParserParams0.setOutputEncoding("sz-o\"XQob");
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      LabelFactory labelFactory0 = CategoryWordTag.factory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('v');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("sz-o\"XQob");
      Tree tree0 = treeGraphNodeFactory0.newTreeNode(label0, (List<Tree>) arrayList0);
      Object object0 = new Object();
      Predicate.isEqual("IE9]1zW");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0, arrayList0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      ArrayList<Predicate<Tree>> arrayList1 = new ArrayList<Predicate<Tree>>();
      Filters.DisjFilter<Tree> filters_DisjFilter0 = new Filters.DisjFilter<Tree>(arrayList1);
      treeGraphNode1.spliceOut((Predicate<Tree>) filters_DisjFilter0, (TreeFactory) treeGraphNodeFactory0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.saveTrees(treeGraphNode1, 1366.426485043, (Collection<Tree>) null, (-411.356113687));
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>(100);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.outputTransitions((Tree) treeGraphNode1, (-531), identityHashMap3, identityHashMap2);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.state((String) null, (-531));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException1()  throws Throwable  {
      Options options0 = new Options();
      CoreLabel.factory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      MapFactory.linkedHashMapFactory();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException4()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.hashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      WordTag wordTag0 = new WordTag("f=^)kl8@8(");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode2.preOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 1401;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 1401, identityHashMap1, identityHashMap2, map0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][4][8];
      threeDimensionalMap0.put("Env", "Env", "Env", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testUseNewBetas5()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[6][8][8];
      threeDimensionalMap0.put("Or#4:TYj/C", "Or#4:TYj/C", "Or#4:TYj/C", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeWithNull()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTree()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) simpleTree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasThrowsArrayIndexOutOfBoundsExceptionAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[8][5][8];
      double[][] doubleArray1 = new double[6][0];
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = (double) 100;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = (double) 100;
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[9];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = 0.0;
      doubleArray4[3] = (double) 100;
      doubleArray4[4] = 0.0;
      doubleArray4[5] = 0.0;
      doubleArray4[6] = (double) 100;
      doubleArray4[7] = 0.0;
      doubleArray4[8] = 0.0;
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[3];
      doubleArray5[0] = 0.0;
      doubleArray5[1] = (-1273.42552);
      doubleArray5[2] = (double) 100;
      doubleArray1[3] = doubleArray5;
      double[] doubleArray6 = new double[9];
      doubleArray6[0] = 0.0;
      doubleArray6[1] = 0.0;
      doubleArray6[2] = (double) 100;
      doubleArray6[3] = (double) 100;
      doubleArray6[4] = (double) 100;
      doubleArray6[5] = 0.0;
      doubleArray6[6] = 0.0;
      doubleArray6[7] = (-1273.42552);
      doubleArray6[8] = 0.0;
      doubleArray1[4] = doubleArray6;
      double[] doubleArray7 = new double[5];
      doubleArray7[0] = 0.0;
      doubleArray7[1] = (-1273.42552);
      doubleArray7[2] = (-1273.42552);
      doubleArray7[3] = (-1273.42552);
      doubleArray7[4] = (-1273.42552);
      doubleArray1[5] = doubleArray7;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray8 = new double[6][4];
      doubleArray8[0] = doubleArray4;
      doubleArray8[1] = doubleArray6;
      doubleArray8[2] = doubleArray5;
      doubleArray8[3] = doubleArray3;
      doubleArray8[4] = doubleArray4;
      doubleArray8[5] = doubleArray2;
      doubleArray0[1] = doubleArray8;
      double[][] doubleArray9 = new double[9][3];
      doubleArray9[0] = doubleArray6;
      doubleArray9[1] = doubleArray2;
      doubleArray9[2] = doubleArray4;
      doubleArray9[3] = doubleArray4;
      doubleArray9[4] = doubleArray2;
      doubleArray9[5] = doubleArray4;
      doubleArray9[6] = doubleArray3;
      doubleArray9[7] = doubleArray3;
      doubleArray9[8] = doubleArray5;
      doubleArray0[2] = doubleArray9;
      double[][] doubleArray10 = new double[8][0];
      doubleArray10[0] = doubleArray7;
      doubleArray10[1] = doubleArray5;
      doubleArray10[2] = doubleArray5;
      doubleArray10[3] = doubleArray3;
      doubleArray10[4] = doubleArray7;
      doubleArray10[5] = doubleArray7;
      double[] doubleArray11 = new double[9];
      doubleArray11[0] = 0.0;
      doubleArray11[1] = 0.0;
      doubleArray11[2] = (-1273.42552);
      doubleArray11[3] = 0.0;
      doubleArray11[4] = 0.0;
      doubleArray11[5] = (double) 100;
      doubleArray11[6] = 0.0;
      doubleArray11[7] = 0.0;
      doubleArray11[8] = 0.0;
      doubleArray10[6] = doubleArray11;
      doubleArray10[7] = doubleArray6;
      doubleArray0[3] = doubleArray10;
      double[][] doubleArray12 = new double[6][9];
      doubleArray12[0] = doubleArray5;
      doubleArray12[1] = doubleArray3;
      doubleArray12[2] = doubleArray4;
      doubleArray12[3] = doubleArray3;
      double[] doubleArray13 = new double[4];
      doubleArray13[0] = (double) 100;
      doubleArray13[1] = (-1273.42552);
      doubleArray13[2] = (double) 100;
      doubleArray13[3] = (double) 100;
      doubleArray12[4] = doubleArray13;
      doubleArray12[5] = doubleArray5;
      doubleArray0[4] = doubleArray12;
      double[][] doubleArray14 = new double[2][9];
      doubleArray14[0] = doubleArray6;
      double[] doubleArray15 = new double[8];
      doubleArray15[0] = 0.0;
      doubleArray15[1] = (double) 100;
      doubleArray15[2] = 0.0;
      doubleArray15[3] = (-1273.42552);
      doubleArray15[4] = (double) 100;
      doubleArray15[5] = 0.0;
      doubleArray15[6] = (double) 100;
      doubleArray15[7] = 0.0;
      doubleArray14[1] = doubleArray15;
      doubleArray0[5] = doubleArray14;
      double[][] doubleArray16 = new double[7][0];
      doubleArray16[0] = doubleArray7;
      doubleArray16[1] = doubleArray11;
      doubleArray16[2] = doubleArray5;
      doubleArray16[3] = doubleArray5;
      doubleArray16[4] = doubleArray11;
      doubleArray16[5] = doubleArray5;
      doubleArray16[6] = doubleArray15;
      doubleArray0[6] = doubleArray16;
      double[][] doubleArray17 = new double[2][5];
      doubleArray17[0] = doubleArray5;
      doubleArray17[1] = doubleArray5;
      doubleArray0[7] = doubleArray17;
      threeDimensionalMap0.put("=#,]:tdOg1KN&)|qo)r", ",", "Serializing classifier to ", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 2 out of bounds for length 2
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[8][5][8];
      double[][] doubleArray1 = new double[6][0];
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = (double) 100;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = (double) 100;
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[9];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = 0.0;
      doubleArray4[3] = (double) 100;
      doubleArray4[4] = 0.0;
      doubleArray4[5] = 0.0;
      doubleArray4[8] = 0.0;
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[3];
      doubleArray5[0] = 0.0;
      doubleArray5[1] = 0.0;
      doubleArray5[2] = (double) 100;
      doubleArray1[3] = doubleArray5;
      double[] doubleArray6 = new double[9];
      doubleArray6[0] = 0.0;
      doubleArray6[1] = 0.0;
      doubleArray6[2] = (double) 100;
      doubleArray6[3] = (double) 100;
      doubleArray6[4] = (double) 100;
      doubleArray6[5] = 0.0;
      doubleArray4[5] = 0.0;
      doubleArray6[7] = (double) 100;
      doubleArray6[8] = 0.0;
      doubleArray1[4] = doubleArray6;
      double[] doubleArray7 = new double[5];
      doubleArray7[0] = 0.0;
      doubleArray7[1] = 0.0;
      doubleArray7[3] = 0.0;
      doubleArray7[4] = (double) 100;
      doubleArray1[5] = doubleArray7;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray8 = new double[6][4];
      doubleArray8[0] = doubleArray4;
      doubleArray8[1] = doubleArray6;
      doubleArray8[2] = doubleArray5;
      doubleArray8[3] = doubleArray3;
      doubleArray8[4] = doubleArray4;
      doubleArray8[5] = doubleArray2;
      doubleArray0[1] = doubleArray8;
      double[][] doubleArray9 = new double[9][3];
      doubleArray9[0] = doubleArray6;
      doubleArray9[1] = doubleArray2;
      doubleArray9[2] = doubleArray4;
      doubleArray9[3] = doubleArray4;
      doubleArray9[4] = doubleArray2;
      doubleArray9[5] = doubleArray4;
      doubleArray9[6] = doubleArray3;
      doubleArray9[7] = doubleArray3;
      doubleArray0[2] = doubleArray9;
      double[][] doubleArray10 = new double[8][0];
      doubleArray10[0] = doubleArray7;
      doubleArray10[1] = doubleArray5;
      doubleArray10[2] = doubleArray5;
      doubleArray10[3] = doubleArray3;
      doubleArray10[4] = doubleArray7;
      doubleArray10[5] = doubleArray7;
      double[] doubleArray11 = new double[9];
      doubleArray11[0] = 0.0;
      doubleArray11[1] = 0.0;
      doubleArray11[2] = 0.0;
      doubleArray11[3] = 0.0;
      doubleArray11[4] = 0.0;
      doubleArray11[5] = (double) 100;
      doubleArray11[6] = 0.0;
      doubleArray11[7] = 0.0;
      doubleArray11[8] = 0.0;
      doubleArray10[6] = doubleArray11;
      doubleArray10[7] = doubleArray6;
      doubleArray0[3] = doubleArray10;
      double[][] doubleArray12 = new double[6][9];
      doubleArray12[1] = doubleArray3;
      doubleArray12[2] = doubleArray4;
      doubleArray12[3] = doubleArray3;
      double[] doubleArray13 = new double[4];
      doubleArray13[0] = (double) 100;
      doubleArray13[1] = 100.0;
      doubleArray13[2] = (double) 100;
      doubleArray13[3] = (double) 100;
      doubleArray12[4] = doubleArray13;
      doubleArray12[5] = doubleArray5;
      doubleArray0[4] = doubleArray12;
      double[][] doubleArray14 = new double[2][9];
      doubleArray14[0] = doubleArray6;
      double[] doubleArray15 = new double[8];
      doubleArray15[0] = 0.0;
      doubleArray15[1] = (double) 100;
      doubleArray15[2] = 0.0;
      doubleArray15[3] = (double) 100;
      doubleArray15[4] = (double) 100;
      doubleArray15[5] = 0.0;
      doubleArray15[6] = (double) 100;
      doubleArray15[7] = 0.0;
      doubleArray14[1] = doubleArray15;
      doubleArray0[5] = doubleArray14;
      double[][] doubleArray16 = new double[7][0];
      doubleArray16[0] = doubleArray7;
      doubleArray16[1] = doubleArray11;
      doubleArray16[2] = doubleArray5;
      doubleArray16[3] = doubleArray5;
      doubleArray16[4] = doubleArray11;
      doubleArray16[5] = doubleArray5;
      doubleArray16[6] = doubleArray15;
      doubleArray0[6] = doubleArray16;
      double[][] doubleArray17 = new double[2][5];
      doubleArray17[0] = doubleArray5;
      doubleArray0[7] = doubleArray17;
      threeDimensionalMap0.put("=#,]:tdOg1KN&)|qo)r", ",", "Serializing classifier to ", doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetas6()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[8][8][8];
      threeDimensionalMap0.put("Or#4jTC", "Or#4jTC", "Or#4jTC", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.get("5fdME=5/y5", "5fdME=5/y5", "5fdME=5/y5");
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningNegative()  throws Throwable  {
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IndexedWord indexedWord0 = new IndexedWord("}2Qtm=~KRKY$*", (-331), (-331));
      MapFactory<Triple<CoreLabel, Object, Object>, Object> mapFactory0 = MapFactory.weakHashMapFactory();
      mapFactory0.setMap(null, 100);
      Map<String, int[]> map0 = mapFactory0.setMap(null, 100);
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      splittingGrammarExtractor0.neginfDoubles(846);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap.hashMap();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0, arrayList0);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 1056;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (double) (-331);
      doubleArray0[4] = (double) 1056;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) (-331);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = TwoDimensionalMap.hashMap();
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, (-3692), (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap2, threeDimensionalMap0);
      assertEquals((-3692), int0);
      
      double[] doubleArray1 = splittingGrammarExtractor1.neginfDoubles(846);
      assertEquals(846, doubleArray1.length);
  }

  @Test(timeout = 4000)
  public void testCountOriginalStates()  throws Throwable  {
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      LabeledWord labeledWord0 = new LabeledWord("qnuM[Tn7_$");
      StringLabel stringLabel0 = new StringLabel(labeledWord0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(stringLabel0, 723.317969);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 723.317969;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 723.317969;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) 100;
      doubleArray0[7] = 723.317969;
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, hashMap0);
      assertTrue(identityHashMap0.isEmpty());
      
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testSaveTrees()  throws Throwable  {
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      LabeledWord labeledWord0 = new LabeledWord("qnuM[Tn7_$");
      StringLabel stringLabel0 = new StringLabel(labeledWord0);
      LabelFactory labelFactory0 = CoreLabel.factory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) labeledWord0, (List<Tree>) arrayList0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options0 = new Options(negraPennTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.saveTrees(tree0, 100, tree0, 0.0);
      assertEquals(Double.NaN, tree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashIndex<Tree> hashIndex0 = new HashIndex<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) hashIndex0, 0.0, (Collection<Tree>) hashIndex0, 0.0);
      assertEquals(0, hashIndex0.size());
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexAndBuildStateIndex()  throws Throwable  {
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Options options0 = new Options(negraPennTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) null, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
  }

  @Test(timeout = 4000)
  public void testBuildStateIndex()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][2];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put(".$$.", ".$$.", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndOutputBetas()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.hashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      mapFactory0.setMap(identityHashMap2);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      WordTag wordTag0 = new WordTag("l[kF6R_V8wP_V,:");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode2.preOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(wordTag0, list0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("pI4G+#[B;h:;Q&f#", "pI4G+#[B;h:;Q&f#", "pI4G+#[B;h:;Q&f#");
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(categoryWordTag0, 100);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      double[] doubleArray0 = new double[15];
      splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, hashMap0);
      assertEquals(0, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException5()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("learned", (String) null);
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.headWordNode();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.treebankLanguagePack();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 5.0;
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      identityHashMap2.putIfAbsent("learned", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode2, doubleArray0, 0, identityHashMap0, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap.hashMap();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.hashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      mapFactory0.setMap(identityHashMap2);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      WordTag wordTag0 = new WordTag("l[kF6R_V8wP_V,:");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode2.preOrderNodeList();
      SimpleTree simpleTree0 = new SimpleTree(wordTag0, list0);
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = 5.0;
      doubleArray0[1] = 5.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = (double) 0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 1401, identityHashMap0, identityHashMap1, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithZero2()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag("si&URru~_Qd%_");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1, 0.0, (Collection<Tree>) list0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndGetStateSplitCountTakingString()  throws Throwable  {
      String string0 = "w=)F";
      WordTag wordTag0 = new WordTag("w=)F", "w=)F");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      wordTag0.setTag("<Su");
      treeGraphNode0.subTreeList();
      treeGraphNode0.headWordNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      List<LabeledScoredTreeNode> list0 = treeGraphNode0.getLeaves();
      treeGraphNode0.setChildren(list0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = false;
      splittingGrammarExtractor1.recountInside(treeGraphNode0, boolean0, options0.rerankerKBest, identityHashMap2);
      splittingGrammarExtractor1.getStateSplitCount(string0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsWithEmptyMapAndEmptyMap()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(null);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap1, threeDimensionalMap0);
      IndexedWord indexedWord0 = new IndexedWord("}2Qtm=~KRKY$*", 0, 0);
      LabelFactory labelFactory0 = indexedWord0.labelFactory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) indexedWord0, (List<Tree>) arrayList0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap1, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      options0.dcTags = false;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDEBUG()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Options options1 = spanishUnknownWordModelTrainer0.op;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNullAndNull()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(null);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap1, threeDimensionalMap0);
      IndexedWord indexedWord0 = new IndexedWord("}2Qtm=~KRKY$*", 0, 0);
      LabelFactory labelFactory0 = indexedWord0.labelFactory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) indexedWord0, (List<Tree>) arrayList0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) null, (Map<String, double[]>) null, identityHashMap0, identityHashMap1);
      assertTrue(identityHashMap1.isEmpty());
      
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap1, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsClassCastException()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      TaggedWordFactory taggedWordFactory1 = new TaggedWordFactory('X');
      WordTagFactory wordTagFactory0 = new WordTagFactory('n');
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      Label label0 = wordTagFactory0.newLabelFromString("XoaD8vW(j");
      Tree tree0 = treeGraphNodeFactory0.newLeaf(label0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.state("Post-split betas", 100);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      List<Triple<String, Integer, Double>> list0 = tree0.yield(linkedList0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(list0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // class edu.stanford.nlp.ling.CoreLabel cannot be cast to class edu.stanford.nlp.util.Triple (edu.stanford.nlp.ling.CoreLabel and edu.stanford.nlp.util.Triple are in unnamed module of loader org.evosuite.instrumentation.InstrumentingClassLoader @37968eca)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException6()  throws Throwable  {
      WordTag wordTag0 = new WordTag("w=)F", "w=)F");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[0];
      List<LabeledScoredTreeNode> list1 = treeGraphNode0.getLeaves();
      treeGraphNode0.setChildren(list1);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 3538, identityHashMap1, identityHashMap2, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningPositive()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("\u00BB", "\u00BB");
      WordTag wordTag0 = new WordTag(wordLemmaTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.headWordNode();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      englishTreebankParserParams0.treebankLanguagePack();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode2, doubleArray0, 882, identityHashMap4, identityHashMap2, (Map<String, double[]>) identityHashMap3, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceWithEmptyList()  throws Throwable  {
      Options options0 = new Options();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(100);
      assertEquals(100, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      double[] doubleArray0 = new double[1];
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, doubleArray0, 79, (IdentityHashMap<Tree, double[][]>) null, (IdentityHashMap<Tree, double[][][]>) null, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(79, int0);
      
      TwoDimensionalMap.hashMap();
      String string0 = splittingGrammarExtractor0.state("N", 79);
      assertEquals("N^79", string0);
  }

  @Test(timeout = 4000)
  public void testStateAndMergeStates()  throws Throwable  {
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Options options0 = new Options(negraPennTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      String string0 = splittingGrammarExtractor0.state("l[kF6R_V8wP_V,:", 100);
      assertEquals("l[kF6R_V8wP_V,:^100", string0);
  }

  @Test(timeout = 4000)
  public void testState1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = splittingGrammarExtractor0.state("lang", 100);
      assertEquals("lang^100", string0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      int int0 = 0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = null;
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      options0.distance = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      MapFactory<CoreLabel, Triple<Object, SplittingGrammarExtractor, SplittingGrammarExtractor>> mapFactory0 = MapFactory.linkedHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, map0, (Map<String, double[]>) hashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer((-1902), true, 1852, true);
      PennTreeReaderFactory pennTreeReaderFactory0 = new PennTreeReaderFactory(nPTmpRetainingTreeNormalizer0);
      Tree.valueOf("_m", (TreeReaderFactory) pennTreeReaderFactory0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[7][2];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[6];
      doubleArray2[0] = (double) (-1902);
      doubleArray2[1] = 0.0;
      doubleArray2[2] = (double) (-1902);
      doubleArray2[3] = (double) (-1902);
      doubleArray2[4] = 0.0;
      doubleArray2[5] = (double) 1852;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[5];
      doubleArray3[0] = (double) 1852;
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = 8.0;
      doubleArray3[3] = (double) 100;
      doubleArray3[4] = 5968.0;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[7];
      doubleArray4[0] = 5968.0;
      doubleArray4[1] = (double) 100;
      doubleArray4[2] = 0.0;
      doubleArray4[3] = (double) (-1902);
      doubleArray4[4] = 5968.0;
      doubleArray4[5] = (double) (-1902);
      doubleArray4[6] = (double) 100;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[7];
      doubleArray5[0] = 0.0;
      doubleArray5[1] = 5968.0;
      doubleArray5[2] = (double) 100;
      doubleArray5[3] = 8.0;
      doubleArray5[4] = 0.0;
      doubleArray5[5] = 0.0;
      doubleArray5[6] = (double) 100;
      doubleArray0[4] = doubleArray5;
      double[] doubleArray6 = new double[8];
      doubleArray6[0] = 8.0;
      doubleArray6[1] = 5968.0;
      doubleArray6[2] = 0.0;
      doubleArray6[3] = 0.5;
      doubleArray6[4] = (double) (-1902);
      doubleArray6[5] = (double) 1852;
      doubleArray6[6] = 3511.10556;
      doubleArray6[7] = 0.0;
      doubleArray0[5] = doubleArray6;
      double[] doubleArray7 = new double[9];
      doubleArray7[0] = (-66.56133701884511);
      doubleArray7[1] = (double) (-1902);
      doubleArray7[2] = 5968.0;
      doubleArray7[3] = (double) 100;
      doubleArray7[4] = (double) 1852;
      doubleArray7[5] = 0.0;
      doubleArray7[6] = (-1700.468292271057);
      doubleArray7[7] = (double) 1852;
      doubleArray7[8] = 0.5;
      doubleArray0[6] = doubleArray7;
      identityHashMap0.put((Tree) null, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) null, true, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithNegative2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0, (-1249.4717), (Collection<Tree>) labeledScoredTreeNode0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasAndRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      Tree tree0 = null;
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      hashMap1.put("know", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][] doubleArray1 = new double[8][5];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = null;
      doubleArray1[2] = null;
      double[] doubleArray2 = new double[5];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) (-3349);
      doubleArray2[2] = (double) (-3349);
      doubleArray2[3] = (double) 100;
      doubleArray2[4] = (double) 100;
      doubleArray1[3] = doubleArray2;
      double[] doubleArray3 = new double[5];
      doubleArray3[0] = 0.0;
      doubleArray3[1] = 0.0;
      doubleArray3[2] = (double) 100;
      doubleArray3[3] = (double) (-3349);
      doubleArray3[4] = (double) (-3349);
      doubleArray1[4] = doubleArray3;
      doubleArray1[5] = null;
      doubleArray1[6] = null;
      doubleArray1[7] = null;
      identityHashMap0.replace((Tree) null, doubleArray1, doubleArray1);
      threeDimensionalMap0.isEmpty();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) null, doubleArray0, (-3349), identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap1, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndUseNewBetasWithTrue()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.valueIterator();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get(":i-Z|Im0kc}QW`\"h", ":i-Z|Im0kc}QW`\"h", "l[kF6R_V8wP_V,:");
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testTestConvergence()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][3][8];
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      threeDimensionalMap0.put("V)Mxfli", "V)Mxfli", "V)Mxfli", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      threeDimensionalMap1.thirdKeySet();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDEBUGThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.treeMapFactory();
      String[] stringArray0 = new String[1];
      stringArray0[0] = "";
      mapFactory0.newSet();
      options0.setOptionsOrWarn(stringArray0, 1762, 1762);
      MapFactory<String, double[][]> mapFactory1 = MapFactory.identityHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][4][8];
      double[][] doubleArray1 = new double[6][3];
      FileSystemHandling.shouldAllThrowIOExceptions();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.put("    ", "cMol7", doubleArray1);
      threeDimensionalMap1.put("50l", "=<'f$#R,oV", "8op", doubleArray0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndBuildStateIndexAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][3][8];
      threeDimensionalMap0.put("l", "V)Mxfli", "Or#4jTC", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.state("Or#4jTC", 100);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      Options options1 = new Options();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesAndOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[10][3];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.put("Incrementing trees read: ", "50l", doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
      
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.getStateSplitCount("Incrementing trees read: ");
      boolean boolean1 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean1);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecalculateBetasWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      chineseTreebankParserParams0.markCC = true;
      Options options0 = new Options(chineseTreebankParserParams0);
      options0.forceCNF = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.treeMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.values();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      QPTreeTransformer qPTreeTransformer0 = null;
      try {
        qPTreeTransformer0 = new QPTreeTransformer();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }
}
