/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Apr 21 18:17:16 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.NERClassifierCombiner;
import edu.stanford.nlp.international.arabic.ArabicMorphoFeatureSpecification;
import edu.stanford.nlp.international.french.FrenchMorphoFeatureSpecification;
import edu.stanford.nlp.ling.BasicDocument;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Document;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.StringLabelFactory;
import edu.stanford.nlp.ling.Tag;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.parser.common.ParserConstraint;
import edu.stanford.nlp.parser.lexparser.BaseLexicon;
import edu.stanford.nlp.parser.lexparser.BinaryGrammar;
import edu.stanford.nlp.parser.lexparser.ChineseCharacterBasedLexicon;
import edu.stanford.nlp.parser.lexparser.ChineseLexicon;
import edu.stanford.nlp.parser.lexparser.ChineseLexiconAndWordSegmenter;
import edu.stanford.nlp.parser.lexparser.ChineseMarkovWordSegmenter;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Edge;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser;
import edu.stanford.nlp.parser.lexparser.FactoredLexicon;
import edu.stanford.nlp.parser.lexparser.HTKLatticeReader;
import edu.stanford.nlp.parser.lexparser.HebrewTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Hook;
import edu.stanford.nlp.parser.lexparser.HungarianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Lattice;
import edu.stanford.nlp.parser.lexparser.LatticeEdge;
import edu.stanford.nlp.parser.lexparser.Lexicon;
import edu.stanford.nlp.parser.lexparser.NegraPennTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.SpanishUnknownWordModelTrainer;
import edu.stanford.nlp.parser.lexparser.UnaryGrammar;
import edu.stanford.nlp.parser.lexparser.UnaryRule;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.process.WordTokenFactory;
import edu.stanford.nlp.sequences.SeqClassifierFlags;
import edu.stanford.nlp.sequences.TrueCasingForNISTDocumentReaderAndWriter;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeGraphNodeFactory;
import edu.stanford.nlp.util.DeltaIndex;
import edu.stanford.nlp.util.Filters;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.ScoredObject;
import java.io.IOException;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.Vector;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.Supplier;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.EvoSuiteURL;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.testdata.NetworkHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class ExhaustivePCFGParser_3_ESTest extends ExhaustivePCFGParser_3_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testInitializePossiblesThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      ArabicMorphoFeatureSpecification arabicMorphoFeatureSpecification0 = new ArabicMorphoFeatureSpecification();
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(options0, arabicMorphoFeatureSpecification0, hashIndex0, hashIndex1);
      factoredLexicon0.initRulesWithWord();
      ExhaustivePCFGParser.matches(100, 100);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex1, hashIndex1, hashIndex0);
      Tag tag0 = new Tag("RBE");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      hashIndex0.add("RBE");
      ArrayList<LabeledWord> arrayList0 = treeGraphNode0.yieldHasWord();
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex1, hashIndex0);
      exhaustivePCFGParser0.tick("2V*Y");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 2 outside the bounds [0,2)
         //
         verifyException("edu.stanford.nlp.util.HashIndex", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      HashIndex<String> hashIndex1 = new HashIndex<String>((Collection<? extends String>) hashIndex0);
      hashIndex0.add((String) null);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("ExhaustivePCFGParser doesn't sample.");
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options();
      ArabicMorphoFeatureSpecification arabicMorphoFeatureSpecification0 = new ArabicMorphoFeatureSpecification();
      HashIndex<String> hashIndex2 = new HashIndex<String>();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(options0, arabicMorphoFeatureSpecification0, hashIndex2, hashIndex1);
      factoredLexicon0.initRulesWithWord();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex2);
      boolean boolean0 = ExhaustivePCFGParser.spillGuts;
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex2, hashIndex2, hashIndex1);
      unaryGrammar0.purgeRules();
      Tag tag0 = new Tag("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      treeGraphNode0.getLeaves();
      ArrayList<LabeledWord> arrayList0 = treeGraphNode0.yieldHasWord();
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex1, hashIndex0, hashIndex1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      HashIndex<String> hashIndex1 = new HashIndex<String>((Collection<? extends String>) hashIndex0);
      hashIndex0.add((String) null);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("ExhaustivePCFGParser doesn't sample.");
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      ArabicMorphoFeatureSpecification arabicMorphoFeatureSpecification0 = new ArabicMorphoFeatureSpecification();
      HashIndex<String> hashIndex2 = new HashIndex<String>();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(options0, arabicMorphoFeatureSpecification0, hashIndex2, hashIndex1);
      factoredLexicon0.initRulesWithWord();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex2);
      boolean boolean0 = ExhaustivePCFGParser.spillGuts;
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex2, hashIndex2, hashIndex1);
      Tag tag0 = new Tag("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      ArrayList<LabeledWord> arrayList0 = treeGraphNode1.yieldHasWord();
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex1, hashIndex0, hashIndex1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      HashIndex<String> hashIndex1 = new HashIndex<String>((Collection<? extends String>) hashIndex0);
      hashIndex0.add((String) null);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options();
      ArabicMorphoFeatureSpecification arabicMorphoFeatureSpecification0 = new ArabicMorphoFeatureSpecification();
      HashIndex<String> hashIndex2 = new HashIndex<String>();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(options0, arabicMorphoFeatureSpecification0, hashIndex2, hashIndex1);
      factoredLexicon0.initRulesWithWord();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex2);
      boolean boolean0 = ExhaustivePCFGParser.spillGuts;
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex2, hashIndex2, hashIndex1);
      unaryGrammar0.purgeRules();
      Tag tag0 = new Tag("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      treeGraphNode0.getLeaves();
      ArrayList<LabeledWord> arrayList0 = treeGraphNode0.yieldHasWord();
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex1, hashIndex0, hashIndex1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsArrayIndexOutOfBoundsException2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      HashIndex<String> hashIndex1 = new HashIndex<String>((Collection<? extends String>) hashIndex0);
      hashIndex0.add((String) null);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("ExhaustivePCFGParser doesn't sample.");
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      ArabicMorphoFeatureSpecification arabicMorphoFeatureSpecification0 = new ArabicMorphoFeatureSpecification();
      HashIndex<String> hashIndex2 = new HashIndex<String>();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(options0, arabicMorphoFeatureSpecification0, hashIndex2, hashIndex1);
      factoredLexicon0.initRulesWithWord();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex2);
      boolean boolean0 = ExhaustivePCFGParser.spillGuts;
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex2, hashIndex2, hashIndex1);
      Tag tag0 = new Tag("-BE");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      ArrayList<LabeledWord> arrayList0 = treeGraphNode1.yieldHasWord();
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex1, hashIndex0, hashIndex1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsArrayIndexOutOfBoundsException3()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      HashIndex<String> hashIndex1 = new HashIndex<String>(set0);
      hashIndex0.add("\"CDC@UnHA`uD");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("m=&R6w]07jp1pMBo");
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      ArabicMorphoFeatureSpecification arabicMorphoFeatureSpecification0 = new ArabicMorphoFeatureSpecification();
      HashIndex<String> hashIndex2 = new HashIndex<String>();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(options0, arabicMorphoFeatureSpecification0, hashIndex2, hashIndex1);
      factoredLexicon0.initRulesWithWord();
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex2);
      boolean boolean0 = ExhaustivePCFGParser.dumpTagging;
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex2);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex1, hashIndex0, hashIndex2);
      Tag tag0 = new Tag(") danK>1C1");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.yieldHasWord();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 7 outside the bounds [0,2)
         //
         verifyException("edu.stanford.nlp.util.HashIndex", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      ArabicMorphoFeatureSpecification arabicMorphoFeatureSpecification0 = new ArabicMorphoFeatureSpecification();
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(options0, arabicMorphoFeatureSpecification0, hashIndex0, hashIndex1);
      factoredLexicon0.initRulesWithWord();
      ExhaustivePCFGParser.matches(100, 100);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex1, hashIndex1, hashIndex0);
      Tag tag0 = new Tag("RBE");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      ArrayList<LabeledWord> arrayList0 = treeGraphNode0.yieldHasWord();
      exhaustivePCFGParser0.tick("RBE");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsArrayIndexOutOfBoundsException4()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      HashIndex<String> hashIndex1 = new HashIndex<String>((Collection<? extends String>) hashIndex0);
      hashIndex1.add("}QX+r]u`8y@");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser1 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser1.apply("m=&R6w]07jp1pMBo");
      baseLexicon0.initRulesWithWord();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex1);
      boolean boolean0 = ExhaustivePCFGParser.dumpTagging;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex1, hashIndex0, hashIndex1);
      Tag tag0 = new Tag("PCFG parsing ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      ArrayList<LabeledWord> arrayList0 = treeGraphNode1.yieldHasWord();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsArrayIndexOutOfBoundsException5()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      ChineseLexicon chineseLexicon0 = new ChineseLexicon(options0, chineseTreebankParserParams0, hashIndex0, hashIndex0);
      chineseLexicon0.initRulesWithWord();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex1);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex1, hashIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, chineseLexicon0, options0, hashIndex0, hashIndex0, hashIndex1);
      ArrayList<CategoryWordTag> arrayList0 = treeGraphNode0.yieldHasWord();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsArrayIndexOutOfBoundsException6()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      ChineseLexicon chineseLexicon0 = new ChineseLexicon(options0, chineseTreebankParserParams0, hashIndex0, hashIndex1);
      chineseLexicon0.initRulesWithWord();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex1);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex1);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(deltaIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar1, unaryGrammar0, chineseLexicon0, options0, hashIndex0, hashIndex1, hashIndex1);
      ArrayList<CategoryWordTag> arrayList0 = treeGraphNode0.yieldHasWord();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsArrayIndexOutOfBoundsException7()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options();
      ArabicMorphoFeatureSpecification arabicMorphoFeatureSpecification0 = new ArabicMorphoFeatureSpecification();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(options0, arabicMorphoFeatureSpecification0, hashIndex0, hashIndex0);
      factoredLexicon0.initRulesWithWord();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Tag tag0 = new Tag("-BE");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      ArrayList<LabeledWord> arrayList0 = treeGraphNode0.yieldHasWord();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 3
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      String string0 = "n>Hi ]_l";
      hashIndex0.add("n>Hi ]_l");
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("PCFG parsing ");
      baseLexicon0.initRulesWithWord();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      hashIndex0.add("PCFG parsing ");
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("^!uG50!l%D\")R");
      baseLexicon0.initRulesWithWord();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser((BinaryGrammar) null, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleRThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      hashIndex1.add("~%%E-&pe");
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex1);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ChineseLexicon chineseLexicon0 = new ChineseLexicon(options0, chineseTreebankParserParams0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, chineseLexicon0, options0, hashIndex1, hashIndex0, hashIndex1);
      binaryGrammar0.splitRules();
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.doInsideScores();
      exhaustivePCFGParser0.iPossibleR(0, 100);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleR(60, 60);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 60 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsArrayIndexOutOfBoundsException8()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      HashIndex<String> hashIndex1 = new HashIndex<String>((Collection<? extends String>) hashIndex0);
      hashIndex0.add((String) null);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("ExhaustivePCFGParser doesn't sample.");
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      ArabicMorphoFeatureSpecification arabicMorphoFeatureSpecification0 = new ArabicMorphoFeatureSpecification();
      HashIndex<String> hashIndex2 = new HashIndex<String>();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(options0, arabicMorphoFeatureSpecification0, hashIndex2, hashIndex1);
      factoredLexicon0.initRulesWithWord();
      boolean boolean0 = ExhaustivePCFGParser.dumpTagging;
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser((BinaryGrammar) null, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex2, hashIndex2);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySizeAndCreateArraysAndDoInsideScores0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      assertFalse(exhaustivePCFGParser0.hasParse());
      
      binaryGrammar0.splitRules();
      exhaustivePCFGParser0.createArrays(100);
      boolean[] booleanArray0 = new boolean[4];
      booleanArray0[2] = true;
      boolean[] booleanArray1 = new boolean[1];
      booleanArray1[0] = true;
      unaryGrammar0.makeCRArrays();
      options0.forceCNF = false;
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.doInsideScores();
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsNullPointerExceptionAndCreateArrays0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      binaryGrammar0.splitRules();
      exhaustivePCFGParser0.createArrays(100);
      boolean[][] booleanArray0 = new boolean[7][4];
      boolean[] booleanArray1 = new boolean[4];
      booleanArray1[0] = true;
      booleanArray1[1] = false;
      booleanArray1[2] = true;
      booleanArray1[3] = true;
      booleanArray0[0] = booleanArray1;
      boolean[] booleanArray2 = new boolean[6];
      booleanArray2[0] = true;
      booleanArray2[1] = false;
      booleanArray2[2] = false;
      booleanArray2[3] = true;
      booleanArray2[4] = true;
      booleanArray2[5] = true;
      booleanArray0[1] = booleanArray2;
      boolean[] booleanArray3 = new boolean[1];
      booleanArray3[0] = true;
      booleanArray0[2] = booleanArray3;
      boolean[] booleanArray4 = new boolean[1];
      booleanArray4[0] = true;
      booleanArray0[3] = booleanArray4;
      boolean[] booleanArray5 = new boolean[1];
      booleanArray5[0] = false;
      booleanArray0[4] = booleanArray5;
      boolean[] booleanArray6 = new boolean[1];
      booleanArray6[0] = true;
      booleanArray0[5] = booleanArray6;
      boolean[] booleanArray7 = new boolean[3];
      booleanArray7[0] = true;
      booleanArray7[1] = true;
      booleanArray7[2] = false;
      booleanArray0[6] = booleanArray7;
      exhaustivePCFGParser0.oPossibleByL = booleanArray0;
      exhaustivePCFGParser0.length = 100;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.doInsideScores();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySizeAndCreateArraysAndDoInsideScores1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      binaryGrammar0.splitRules();
      exhaustivePCFGParser0.createArrays(100);
      boolean[] booleanArray0 = new boolean[4];
      booleanArray0[2] = true;
      unaryGrammar0.makeCRArrays();
      options0.forceCNF = false;
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.doInsideScores();
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsNullPointerExceptionAndGetBestScoreTakingString()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.getBestScore("m@83C35bbU|P");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.doInsideScores();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsNullPointerExceptionAndCreateArrays1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.length = 100;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.doInsideScores();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testBuildOFilterThrowsNullPointerExceptionAndGetBestScoreTakingString()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("bde");
      hashIndex0.add("");
      hashIndex0.add("Oj$D`4W7xMG0[D<G");
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      float[][][] floatArray0 = new float[16][4][8];
      float[][] floatArray1 = new float[1][2];
      floatArray0[0] = floatArray1;
      exhaustivePCFGParser0.iScore = floatArray0;
      exhaustivePCFGParser0.getBestScore("Oj$D`4W7xMG0[D<G");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.buildOFilter();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIScoreAndOPossibleRThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("Oj$D`4W7xMG0[D<G");
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      float[][][] floatArray0 = new float[5][1][8];
      float[] floatArray1 = new float[10];
      floatArray1[0] = (float) 100;
      floatArray1[6] = (float) 100;
      floatArray1[2] = (float) 100;
      floatArray1[3] = (float) 100;
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      float[] floatArray2 = new float[36];
      floatArray1[8] = (float) 100;
      floatArray2[2] = (float) 100;
      floatArray2[3] = (float) 100;
      floatArray2[19] = 100.0F;
      float[][] floatArray3 = new float[4][2];
      floatArray3[2] = floatArray3[3];
      floatArray0[0] = floatArray3;
      exhaustivePCFGParser0.iScore = floatArray0;
      exhaustivePCFGParser0.getBestScore("Oj$D`4W7xMG0[D<G");
      exhaustivePCFGParser0.hasParse();
      Edge edge0 = new Edge(false);
      exhaustivePCFGParser0.iScore(edge0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleR(75, 559038737);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testHasParseThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Lattice lattice0 = new Lattice();
      lattice0.addBoundary();
      LatticeEdge latticeEdge0 = new LatticeEdge("ad+[$PUSM;HFw'bp", 0.0, 100, 100);
      lattice0.addEdge(latticeEdge0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      BasicDocument<UnaryRule> basicDocument0 = BasicDocument.init("ad+[$PUSM;HFw'bp", true);
      BasicDocument<UnaryRule> basicDocument1 = new BasicDocument<UnaryRule>((Document<UnaryRule, Word, Word>) basicDocument0);
      Document<UnaryRule, Word, ParserConstraint> document0 = basicDocument1.blankDocument();
      exhaustivePCFGParser0.constraints = (List<ParserConstraint>) document0;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Lattice lattice0 = new Lattice();
      lattice0.addBoundary();
      LatticeEdge latticeEdge0 = new LatticeEdge("ad+[$PUSM;HFw'bp", 0.0, 100, 100);
      lattice0.addEdge(latticeEdge0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      BasicDocument<UnaryRule> basicDocument0 = new BasicDocument<UnaryRule>();
      Document<UnaryRule, Word, ParserConstraint> document0 = basicDocument0.blankDocument();
      exhaustivePCFGParser0.constraints = (List<ParserConstraint>) document0;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTreeReturningNegative()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
      
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("pc", "pc", "pc");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      List<Tree> list1 = treeGraphNode0.getLeaves(list0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list1);
      CoreLabel coreLabel0 = new CoreLabel(100);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      unaryGrammar0.forEach(consumer0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) coreLabel0, list1);
      exhaustivePCFGParser0.scoreBinarizedTree(tree0, 100);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(tree0, (-2219));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetBestParsesThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.arraySize = 3061;
      exhaustivePCFGParser0.myMaxLength = 100;
      exhaustivePCFGParser0.nudgeDownArraySize();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestParses();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsUnsupportedOperationException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      options0.doDep = false;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.length = 100;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKSampledParses(100);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // ExhaustivePCFGParser doesn't sample.
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeWithNegative()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("pc", "pc", "pc");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      List<Tree> list1 = treeGraphNode0.getLeaves(list0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(categoryWordTag0, list1);
      CoreLabel coreLabel0 = treeGraphNode1.label();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) coreLabel0, list1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(tree0, (-2219));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsNullPointerException0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      treeGraphNode0.getLeaves(list0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(treeGraphNode1, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsTooManyResourcesException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      treeGraphNode0.setChildren(list0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Lexicon lexicon0 = englishTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, lexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      exhaustivePCFGParser0.validateBinarizedTree(treeGraphNode0, 100);
  }

  @Test(timeout = 4000)
  public void testBuildOFilterThrowsNullPointerExceptionAndDoInsideScores()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      assertFalse(exhaustivePCFGParser0.hasParse());
      
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.doInsideScores();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.buildOFilter();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoInsideScoresThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.doInsideScores();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringReturningZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("Oj$D`4W7xMG0[D<G");
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(13);
      float[][][] floatArray0 = new float[7][1][8];
      float[][] floatArray1 = new float[9][5];
      float[] floatArray2 = new float[9];
      floatArray2[0] = (float) 13;
      floatArray2[1] = (float) 100;
      floatArray2[2] = (float) 13;
      floatArray2[3] = (float) 13;
      floatArray2[4] = (float) 13;
      floatArray2[5] = (float) 100;
      floatArray2[6] = (float) 13;
      floatArray2[7] = (float) 100;
      floatArray2[8] = (float) 100;
      floatArray1[0] = floatArray2;
      float[] floatArray3 = new float[7];
      floatArray3[0] = (float) 13;
      floatArray3[1] = (float) 100;
      floatArray3[2] = (float) 13;
      floatArray3[3] = (float) 100;
      floatArray3[4] = (float) 100;
      floatArray3[5] = (float) 13;
      floatArray1[1] = floatArray3;
      float[] floatArray4 = new float[9];
      floatArray4[0] = (float) 13;
      floatArray4[1] = 0.0F;
      floatArray4[2] = (float) 13;
      floatArray4[3] = (float) 13;
      floatArray4[4] = (float) 13;
      floatArray4[5] = (float) 100;
      floatArray4[6] = (float) 13;
      floatArray4[7] = (float) 100;
      floatArray4[8] = (float) 100;
      floatArray1[2] = floatArray4;
      float[] floatArray5 = new float[2];
      floatArray5[0] = (float) 13;
      floatArray1[3] = floatArray5;
      float[] floatArray6 = new float[1];
      floatArray6[0] = 0.0F;
      floatArray1[4] = floatArray6;
      float[] floatArray7 = new float[5];
      floatArray7[0] = (float) 100;
      floatArray7[1] = (float) 100;
      floatArray7[2] = (float) 100;
      floatArray7[3] = (float) 13;
      floatArray7[4] = 0.0F;
      floatArray1[5] = floatArray7;
      float[] floatArray8 = new float[0];
      floatArray1[6] = floatArray8;
      float[] floatArray9 = new float[0];
      floatArray1[7] = floatArray9;
      float[] floatArray10 = new float[5];
      floatArray10[0] = 0.0F;
      floatArray10[1] = (float) 100;
      floatArray10[2] = (float) 13;
      floatArray10[3] = (float) 100;
      floatArray10[4] = 0.0F;
      floatArray1[8] = floatArray10;
      float[][] floatArray11 = new float[4][2];
      floatArray11[0] = floatArray9;
      floatArray11[1] = floatArray6;
      floatArray11[2] = floatArray2;
      floatArray11[3] = floatArray5;
      floatArray0[1] = floatArray11;
      float[][] floatArray12 = new float[1][7];
      floatArray12[0] = floatArray3;
      floatArray0[2] = floatArray12;
      float[][] floatArray13 = new float[0][3];
      floatArray0[3] = floatArray13;
      float[][] floatArray14 = new float[9][8];
      floatArray14[0] = floatArray6;
      floatArray14[1] = floatArray4;
      floatArray14[2] = floatArray9;
      floatArray14[3] = floatArray3;
      floatArray14[4] = floatArray3;
      floatArray14[5] = floatArray9;
      floatArray14[6] = floatArray4;
      floatArray14[8] = floatArray3;
      floatArray0[4] = floatArray14;
      float[][] floatArray15 = new float[6][4];
      floatArray15[0] = floatArray3;
      floatArray15[1] = floatArray4;
      floatArray15[2] = floatArray7;
      float[] floatArray16 = new float[8];
      floatArray16[0] = 0.0F;
      floatArray16[1] = (float) 13;
      floatArray16[2] = 0.0F;
      floatArray16[3] = 0.0F;
      floatArray16[4] = (float) 100;
      floatArray16[5] = (float) 100;
      floatArray16[6] = (float) 13;
      floatArray16[7] = 0.0F;
      floatArray15[3] = floatArray16;
      floatArray15[4] = floatArray10;
      floatArray15[5] = floatArray9;
      floatArray0[5] = floatArray15;
      float[][] floatArray17 = new float[3][6];
      floatArray17[0] = floatArray6;
      floatArray17[1] = floatArray6;
      floatArray17[2] = floatArray6;
      floatArray0[6] = floatArray17;
      exhaustivePCFGParser0.iScore = floatArray0;
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      double double0 = exhaustivePCFGParser0.getBestScore("Oj$D`4W7xMG0[D<G");
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringReturningPositive()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("Oj$D`4W7xMG0[D<G");
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(13);
      float[][][] floatArray0 = new float[7][1][8];
      float[][] floatArray1 = new float[9][5];
      float[] floatArray2 = new float[9];
      floatArray2[0] = (float) 13;
      floatArray2[1] = (float) 100;
      floatArray2[2] = (float) 13;
      floatArray2[3] = (float) 13;
      floatArray2[4] = (float) 13;
      floatArray2[5] = (float) 100;
      floatArray2[6] = (float) 13;
      floatArray2[7] = (float) 100;
      floatArray2[8] = (float) 100;
      floatArray1[0] = floatArray2;
      float[] floatArray3 = new float[7];
      floatArray3[0] = (float) 13;
      floatArray3[1] = (float) 100;
      floatArray3[2] = (float) 13;
      floatArray3[3] = (float) 100;
      floatArray3[4] = (float) 100;
      floatArray3[5] = (float) 13;
      floatArray3[6] = (float) 13;
      floatArray1[1] = floatArray3;
      float[] floatArray4 = new float[9];
      floatArray4[0] = (float) 13;
      floatArray4[1] = 0.0F;
      floatArray4[2] = (float) 13;
      floatArray4[3] = (float) 13;
      floatArray4[4] = (float) 13;
      floatArray4[5] = (float) 100;
      floatArray4[6] = (float) 13;
      floatArray4[7] = (float) 100;
      floatArray4[8] = (float) 100;
      floatArray1[2] = floatArray4;
      float[] floatArray5 = new float[2];
      floatArray5[0] = (float) 13;
      floatArray5[1] = (float) 13;
      floatArray1[3] = floatArray5;
      float[] floatArray6 = new float[1];
      floatArray6[0] = 0.0F;
      floatArray1[4] = floatArray6;
      float[] floatArray7 = new float[5];
      floatArray7[0] = (float) 100;
      floatArray7[1] = (float) 100;
      floatArray7[2] = (float) 100;
      floatArray7[3] = (float) 13;
      floatArray7[4] = 0.0F;
      floatArray1[5] = floatArray7;
      float[] floatArray8 = new float[0];
      floatArray1[6] = floatArray8;
      float[] floatArray9 = new float[0];
      floatArray1[7] = floatArray9;
      float[] floatArray10 = new float[5];
      floatArray10[0] = 0.0F;
      floatArray10[1] = (float) 100;
      floatArray10[2] = (float) 13;
      floatArray10[3] = (float) 100;
      floatArray10[4] = 0.0F;
      floatArray1[8] = floatArray10;
      floatArray0[0] = floatArray1;
      float[][] floatArray11 = new float[4][2];
      floatArray11[0] = floatArray9;
      floatArray11[1] = floatArray6;
      floatArray11[2] = floatArray2;
      floatArray11[3] = floatArray5;
      floatArray0[1] = floatArray11;
      float[][] floatArray12 = new float[1][7];
      floatArray12[0] = floatArray3;
      floatArray0[2] = floatArray12;
      float[][] floatArray13 = new float[0][3];
      floatArray0[3] = floatArray13;
      float[][] floatArray14 = new float[9][8];
      floatArray14[0] = floatArray6;
      floatArray14[1] = floatArray4;
      floatArray14[2] = floatArray9;
      floatArray14[3] = floatArray3;
      floatArray14[4] = floatArray3;
      floatArray14[5] = floatArray9;
      floatArray14[6] = floatArray4;
      floatArray14[7] = floatArray10;
      floatArray14[8] = floatArray3;
      floatArray0[4] = floatArray14;
      float[][] floatArray15 = new float[6][4];
      floatArray15[0] = floatArray3;
      floatArray15[1] = floatArray4;
      floatArray15[2] = floatArray7;
      float[] floatArray16 = new float[8];
      floatArray16[0] = 0.0F;
      floatArray16[1] = (float) 13;
      floatArray16[2] = 0.0F;
      floatArray16[3] = 0.0F;
      floatArray16[4] = (float) 100;
      floatArray16[5] = (float) 100;
      floatArray16[6] = (float) 13;
      floatArray16[7] = 0.0F;
      floatArray15[3] = floatArray16;
      floatArray15[4] = floatArray10;
      floatArray15[5] = floatArray9;
      floatArray0[5] = floatArray15;
      float[][] floatArray17 = new float[3][6];
      floatArray17[0] = floatArray6;
      floatArray17[1] = floatArray6;
      floatArray17[2] = floatArray6;
      floatArray0[6] = floatArray17;
      exhaustivePCFGParser0.iScore = floatArray0;
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      double double0 = exhaustivePCFGParser0.getBestScore("Oj$D`4W7xMG0[D<G");
      assertEquals(13.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringAndGetBestScoreTakingStringWithNonEmptyString()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("Oj$D`4W7xMG0[D<G");
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      float[][][] floatArray0 = new float[5][1][8];
      exhaustivePCFGParser0.iScore = floatArray0;
      double double0 = exhaustivePCFGParser0.getBestScore("Oj$D`4W7xMG0[D<G");
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testOPossibleReturningFalse()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      options0.distance = true;
      Hook hook0 = new Hook(true);
      exhaustivePCFGParser0.oPossible(hook0);
      exhaustivePCFGParser0.length = 100;
      // Undeclared exception!
      exhaustivePCFGParser0.initializePossibles();
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringThrowsNullPointerExceptionAndGetBestScoreTakingString()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestScore((String) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestScore((String) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOScoreAndOScoreReturningPositive()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Word word0 = new Word("-_88o}:`KMerUf-s0yj");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Edge edge0 = new Edge(true);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Lexicon lexicon0 = spanishUnknownWordModelTrainer0.lex;
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex1, hashIndex1);
      float[][][] floatArray0 = new float[8][5][6];
      float[][] floatArray1 = new float[6][1];
      float[] floatArray2 = new float[4];
      floatArray2[0] = (float) 100;
      floatArray2[1] = (float) 0;
      floatArray2[2] = (float) 0;
      floatArray2[3] = (float) 100;
      floatArray1[0] = floatArray2;
      float[] floatArray3 = new float[0];
      floatArray1[1] = floatArray3;
      float[] floatArray4 = new float[5];
      floatArray4[0] = (float) 0;
      floatArray4[1] = (float) 0;
      floatArray4[2] = (float) 0;
      floatArray4[3] = (float) 0;
      floatArray4[4] = (float) 0;
      floatArray1[2] = floatArray4;
      float[] floatArray5 = new float[5];
      floatArray5[0] = (float) 0;
      floatArray5[1] = (float) 0;
      floatArray5[2] = (float) 100;
      floatArray5[3] = (float) 0;
      floatArray5[4] = (float) 0;
      floatArray1[3] = floatArray5;
      float[] floatArray6 = new float[4];
      floatArray6[0] = (float) 0;
      floatArray6[1] = (float) 100;
      floatArray6[2] = (float) 0;
      floatArray6[3] = 0.0F;
      floatArray1[4] = floatArray6;
      float[] floatArray7 = new float[2];
      floatArray7[0] = (float) 0;
      floatArray7[1] = 0.0F;
      floatArray1[5] = floatArray7;
      floatArray0[0] = floatArray1;
      float[][] floatArray8 = new float[8][8];
      floatArray8[0] = floatArray2;
      floatArray8[1] = floatArray4;
      floatArray8[2] = floatArray3;
      floatArray8[3] = floatArray4;
      floatArray8[4] = floatArray5;
      floatArray8[5] = floatArray4;
      float[] floatArray9 = new float[5];
      floatArray9[0] = (float) 0;
      floatArray9[1] = (float) 0;
      floatArray9[2] = (float) 0;
      floatArray9[3] = 0.0F;
      floatArray9[4] = (float) 0;
      floatArray8[6] = floatArray9;
      floatArray8[7] = floatArray7;
      floatArray0[1] = floatArray8;
      float[][] floatArray10 = new float[5][1];
      floatArray10[0] = floatArray5;
      floatArray10[1] = floatArray4;
      floatArray10[2] = floatArray2;
      floatArray10[3] = floatArray3;
      floatArray10[4] = floatArray2;
      floatArray0[2] = floatArray10;
      float[][] floatArray11 = new float[3][3];
      floatArray11[0] = floatArray5;
      floatArray11[1] = floatArray9;
      floatArray11[2] = floatArray3;
      floatArray0[3] = floatArray11;
      float[][] floatArray12 = new float[0][7];
      floatArray0[4] = floatArray12;
      float[][] floatArray13 = new float[8][3];
      floatArray13[0] = floatArray5;
      floatArray13[1] = floatArray6;
      floatArray13[2] = floatArray9;
      floatArray13[3] = floatArray9;
      floatArray13[4] = floatArray6;
      floatArray13[5] = floatArray6;
      floatArray13[6] = floatArray9;
      floatArray13[7] = floatArray4;
      floatArray0[5] = floatArray13;
      float[][] floatArray14 = new float[4][9];
      floatArray14[0] = floatArray3;
      floatArray14[1] = floatArray6;
      floatArray14[2] = floatArray6;
      float[] floatArray15 = new float[1];
      floatArray15[0] = (float) 0;
      floatArray14[3] = floatArray15;
      floatArray0[6] = floatArray14;
      float[][] floatArray16 = new float[9][7];
      floatArray16[0] = floatArray6;
      floatArray16[1] = floatArray6;
      floatArray16[2] = floatArray7;
      floatArray16[3] = floatArray7;
      floatArray16[4] = floatArray6;
      floatArray16[5] = floatArray6;
      floatArray16[6] = floatArray9;
      floatArray16[7] = floatArray6;
      floatArray16[8] = floatArray3;
      floatArray0[7] = floatArray16;
      exhaustivePCFGParser0.oScore = floatArray0;
      double double0 = exhaustivePCFGParser0.oScore(edge0);
      assertEquals(100.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeWithLatticeWhereGetNumEdgesIsPositive0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add("DIAGONAL");
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Lattice lattice0 = new Lattice();
      LatticeEdge latticeEdge0 = new LatticeEdge("DIAGONAL", 100, 100, 269);
      lattice0.addEdge(latticeEdge0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.length = 100;
      binaryGrammar0.splitRules();
      exhaustivePCFGParser0.getBestScore((String) null);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.TreeAnnotator", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      hashIndex1.add("i");
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex1, hashIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Lattice lattice0 = new Lattice();
      LatticeEdge latticeEdge0 = new LatticeEdge("i", 812, 100, 812);
      lattice0.addEdge(latticeEdge0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex1, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 100 out of bounds for length 2
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsException2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      HashIndex<String> hashIndex1 = new HashIndex<String>(98);
      hashIndex1.add("DIAGONAL");
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex1, hashIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Lattice lattice0 = new Lattice();
      LatticeEdge latticeEdge0 = new LatticeEdge("DIAGONAL", 0.0, 98, 796);
      lattice0.addEdge(latticeEdge0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex1);
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar1, baseLexicon0, options0, hashIndex1, hashIndex1, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 98 out of bounds for length 2
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeWithLatticeWhereGetNumEdgesIsPositive1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Lattice lattice0 = new Lattice();
      LatticeEdge latticeEdge0 = new LatticeEdge((String) null, 2081.484, 100, (-362));
      lattice0.addEdge(latticeEdge0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.IntTaggedWord", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeWithLatticeWhereGetNumEdgesIsPositive2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      LatticeEdge latticeEdge0 = new LatticeEdge("|>+5hT@JGRTIvrN$y", 100, 939, 100);
      Lattice lattice0 = new Lattice();
      lattice0.addEdge(latticeEdge0);
      hashIndex0.add((String) null);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.IntTaggedWord", e);
      }
  }

  @Test(timeout = 4000)
  public void testInitializePossiblesThrowsTooManyResourcesException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.length = 100;
      // Undeclared exception!
      exhaustivePCFGParser0.initializePossibles();
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingList0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Word word0 = new Word("-_88o}:`KMerUf-s0yj");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      WordTag wordTag0 = new WordTag("%", "bde");
      ArrayList<WordTag> arrayList0 = new ArrayList<WordTag>();
      arrayList0.add(wordTag0);
      unaryGrammar0.toString();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingNoArguments()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.initializePossibles();
      assertFalse(exhaustivePCFGParser0.hasParse());
      
      double double0 = exhaustivePCFGParser0.getBestScore();
      assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testHasParse0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeAndScoreNonBinarizedTreeReturningTreeWhereScoreIsPositive()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      Word word0 = new Word("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) word0, list0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      FrenchMorphoFeatureSpecification frenchMorphoFeatureSpecification0 = new FrenchMorphoFeatureSpecification();
      FactoredLexicon factoredLexicon0 = new FactoredLexicon(frenchMorphoFeatureSpecification0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, factoredLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Tree tree1 = exhaustivePCFGParser0.scoreNonBinarizedTree(tree0);
      assertNotSame(tree1, tree0);
  }

  @Test(timeout = 4000)
  public void testInitializePossiblesThrowsNullPointerException0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.length = 100;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.initializePossibles();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsNullPointerExceptionAndValidateBinarizedTree()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTokenFactory wordTokenFactory0 = new WordTokenFactory();
      Word word0 = new Word("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      treeGraphNode0.getLeaves();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Options options0 = new Options(hungarianTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser((BinaryGrammar) null, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(tree0, 86);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsNullPointerException1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree(tree0, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTreeThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTokenFactory wordTokenFactory0 = new WordTokenFactory();
      Word word0 = new Word("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      treeGraphNode0.getLeaves();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreBinarizedTree(tree0, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeThrowsNullPointerException0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(false);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTokenFactory wordTokenFactory0 = new WordTokenFactory();
      Word word0 = wordTokenFactory0.makeToken("", 0, 0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      treeGraphNode0.getLeaves();
      List<Tree> list0 = treeGraphNode0.getLeaves();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) word0, list0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeThrowsNullPointerException1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsException3()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Lattice lattice0 = new Lattice();
      lattice0.addBoundary();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTreeReturningZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Options options1 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options1, hashIndex0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options1, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser1.doInsideScores();
      double double0 = exhaustivePCFGParser0.scoreBinarizedTree(simpleTree0, 100);
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testExtractBestParseThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ChineseCharacterBasedLexicon chineseCharacterBasedLexicon0 = new ChineseCharacterBasedLexicon(chineseTreebankParserParams0, hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, chineseCharacterBasedLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      chineseTreebankParserParams0.setGenerateOriginalDependencies(true);
      exhaustivePCFGParser0.getBestScore();
      int int0 = 2;
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, (String) null);
      exhaustivePCFGParser0.createArrays(2);
      int int1 = 973;
      exhaustivePCFGParser0.initializePossibles();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.extractBestParse((String) null, 973, 100);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 973 out of bounds for length 2
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreateArraysAndInitializePossibles()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.initializePossibles();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testOPossibleThrowsNullPointerExceptionAndOPossibleWithHookWhereIsPreHookIsTrue()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(false);
      hook0.start = 100;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndValidateBinarizedTree()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      treeGraphNode0.headWordNode();
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar1, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.validateBinarizedTree(simpleTree0, 100);
      List<Tree> list0 = new Stack<Tree>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser((BinaryGrammar) null, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingList1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      String[] stringArray0 = new String[9];
      String string0 = "5&u{K<a$N";
      HashIndex<String> hashIndex1 = new HashIndex<String>((Collection<? extends String>) hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex1, hashIndex1, hashIndex1);
      Annotation annotation0 = new Annotation("");
      Annotation annotation1 = new Annotation(annotation0);
      CoreLabel coreLabel0 = new CoreLabel(annotation1);
      LabeledWord labeledWord0 = new LabeledWord("5&u{K<a$N", coreLabel0);
      Word word0 = new Word();
      List<Word> list0 = List.of(labeledWord0, word0, labeledWord0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractBestParsesThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(false);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      float[][][] floatArray0 = new float[8][5][8];
      float[][] floatArray1 = new float[5][7];
      float[] floatArray2 = new float[4];
      floatArray2[0] = (float) 100;
      floatArray2[1] = (float) 0;
      floatArray2[2] = (float) 0;
      floatArray2[3] = (float) 0;
      floatArray1[0] = floatArray2;
      float[] floatArray3 = new float[9];
      floatArray3[0] = 1.0E-4F;
      floatArray3[1] = (float) 0;
      floatArray3[2] = (float) 0;
      floatArray3[3] = (float) 0;
      floatArray3[4] = (float) 0;
      floatArray3[5] = (float) 0;
      floatArray3[6] = (float) 0;
      floatArray3[7] = (float) 0;
      floatArray3[8] = 1.0E-4F;
      floatArray1[1] = floatArray3;
      float[] floatArray4 = new float[0];
      floatArray1[2] = floatArray4;
      float[] floatArray5 = new float[8];
      floatArray5[0] = (float) 100;
      floatArray5[1] = 1.0E-4F;
      floatArray5[2] = (float) 0;
      floatArray5[3] = (float) 0;
      floatArray5[4] = (float) 100;
      floatArray5[5] = (float) 0;
      floatArray5[6] = (float) 0;
      floatArray5[7] = 1.0E-4F;
      floatArray1[3] = floatArray5;
      float[] floatArray6 = new float[8];
      floatArray6[0] = (float) 0;
      floatArray6[1] = 1.0E-4F;
      floatArray6[2] = (float) 0;
      floatArray6[3] = (float) 0;
      floatArray6[4] = (float) 0;
      floatArray6[5] = (float) 0;
      floatArray6[6] = (float) 0;
      floatArray6[7] = (float) 0;
      floatArray1[4] = floatArray6;
      floatArray0[0] = floatArray1;
      float[][] floatArray7 = new float[9][1];
      floatArray7[0] = floatArray4;
      floatArray7[1] = floatArray2;
      floatArray7[2] = floatArray4;
      floatArray7[3] = floatArray2;
      floatArray7[4] = floatArray4;
      floatArray7[5] = floatArray5;
      floatArray7[6] = floatArray5;
      floatArray7[7] = floatArray2;
      floatArray7[8] = floatArray4;
      floatArray0[1] = floatArray7;
      float[][] floatArray8 = new float[1][6];
      floatArray8[0] = floatArray6;
      floatArray0[2] = floatArray8;
      float[][] floatArray9 = new float[8][0];
      floatArray9[0] = floatArray4;
      floatArray9[1] = floatArray4;
      floatArray9[2] = floatArray3;
      floatArray9[3] = floatArray4;
      floatArray9[4] = floatArray4;
      floatArray9[5] = floatArray6;
      floatArray9[6] = floatArray6;
      floatArray9[7] = floatArray3;
      floatArray0[3] = floatArray9;
      float[][] floatArray10 = new float[9][6];
      floatArray10[0] = floatArray5;
      floatArray10[1] = floatArray2;
      floatArray10[2] = floatArray4;
      floatArray10[3] = floatArray2;
      floatArray10[4] = floatArray4;
      floatArray10[5] = floatArray6;
      float[] floatArray11 = new float[5];
      floatArray11[0] = (float) 0;
      floatArray11[1] = (float) 0;
      floatArray11[2] = (float) 0;
      floatArray11[3] = (float) 100;
      floatArray11[4] = (float) 0;
      floatArray10[6] = floatArray11;
      floatArray10[7] = floatArray5;
      floatArray10[8] = floatArray2;
      floatArray0[4] = floatArray10;
      float[][] floatArray12 = new float[1][6];
      floatArray12[0] = floatArray4;
      floatArray0[5] = floatArray12;
      float[][] floatArray13 = new float[3][1];
      floatArray13[0] = floatArray5;
      floatArray13[1] = floatArray6;
      floatArray13[2] = floatArray5;
      floatArray0[6] = floatArray13;
      float[][] floatArray14 = new float[9][4];
      floatArray14[0] = floatArray4;
      floatArray14[1] = floatArray5;
      floatArray14[2] = floatArray2;
      floatArray14[3] = floatArray11;
      floatArray14[4] = floatArray3;
      floatArray14[5] = floatArray11;
      floatArray14[6] = floatArray4;
      floatArray14[7] = floatArray5;
      floatArray14[8] = floatArray6;
      floatArray0[7] = floatArray14;
      exhaustivePCFGParser0.iScore = floatArray0;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.extractBestParses(0, 0, 0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 outside the bounds [0,0)
         //
         verifyException("edu.stanford.nlp.util.HashIndex", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleAndDoInsideScores()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      boolean[][] booleanArray0 = new boolean[5][3];
      boolean[] booleanArray1 = new boolean[4];
      booleanArray1[0] = false;
      booleanArray1[1] = false;
      booleanArray1[2] = false;
      booleanArray1[3] = true;
      booleanArray0[0] = booleanArray1;
      boolean[] booleanArray2 = new boolean[4];
      booleanArray2[0] = true;
      booleanArray2[1] = false;
      booleanArray2[2] = false;
      booleanArray2[3] = false;
      booleanArray0[1] = booleanArray2;
      boolean[] booleanArray3 = new boolean[0];
      booleanArray0[2] = booleanArray3;
      boolean[] booleanArray4 = new boolean[3];
      booleanArray4[0] = false;
      booleanArray4[1] = false;
      booleanArray4[2] = false;
      booleanArray0[3] = booleanArray4;
      boolean[] booleanArray5 = new boolean[2];
      booleanArray5[0] = false;
      booleanArray5[1] = true;
      booleanArray0[4] = booleanArray5;
      exhaustivePCFGParser0.iPossibleByL = booleanArray0;
      Hook hook0 = new Hook(false);
      exhaustivePCFGParser0.iPossible(hook0);
      exhaustivePCFGParser0.doInsideScores();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testOPossibleReturningTrue()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(false);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, deltaIndex0, deltaIndex0, deltaIndex0);
      boolean[][] booleanArray0 = new boolean[7][7];
      boolean[] booleanArray1 = new boolean[3];
      booleanArray1[0] = true;
      booleanArray1[1] = false;
      booleanArray1[2] = false;
      booleanArray0[0] = booleanArray1;
      boolean[] booleanArray2 = new boolean[6];
      booleanArray2[0] = false;
      booleanArray2[1] = true;
      booleanArray2[2] = true;
      booleanArray2[3] = true;
      booleanArray2[4] = false;
      booleanArray2[5] = false;
      booleanArray0[1] = booleanArray2;
      boolean[] booleanArray3 = new boolean[0];
      booleanArray0[2] = booleanArray3;
      boolean[] booleanArray4 = new boolean[4];
      booleanArray4[0] = true;
      booleanArray4[1] = false;
      booleanArray4[2] = true;
      booleanArray4[3] = true;
      booleanArray0[3] = booleanArray4;
      boolean[] booleanArray5 = new boolean[8];
      booleanArray5[0] = true;
      booleanArray5[1] = false;
      booleanArray5[2] = false;
      booleanArray5[3] = false;
      booleanArray5[4] = true;
      booleanArray5[5] = false;
      booleanArray5[6] = false;
      booleanArray5[7] = true;
      booleanArray0[4] = booleanArray5;
      boolean[] booleanArray6 = new boolean[3];
      booleanArray6[0] = true;
      booleanArray6[1] = false;
      booleanArray6[2] = false;
      booleanArray0[5] = booleanArray6;
      boolean[] booleanArray7 = new boolean[3];
      booleanArray7[0] = false;
      booleanArray7[1] = true;
      booleanArray7[2] = false;
      booleanArray0[6] = booleanArray7;
      exhaustivePCFGParser0.oPossibleByL = booleanArray0;
      boolean boolean0 = exhaustivePCFGParser0.oPossible(hook0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTreeAndScoreBinarizedTreeThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      Options options0 = new Options();
      DeltaIndex<String> deltaIndex1 = new DeltaIndex<String>(hashIndex0);
      Hook hook0 = new Hook(true);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(deltaIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ChineseMarkovWordSegmenter chineseMarkovWordSegmenter0 = new ChineseMarkovWordSegmenter(chineseTreebankParserParams0, deltaIndex1, deltaIndex0);
      ChineseLexiconAndWordSegmenter chineseLexiconAndWordSegmenter0 = new ChineseLexiconAndWordSegmenter((ChineseLexicon) null, chineseMarkovWordSegmenter0);
      Options options1 = new Options(chineseTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar1, unaryGrammar0, chineseLexiconAndWordSegmenter0, options1, hashIndex0, deltaIndex1, deltaIndex1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreBinarizedTree((Tree) null, 2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIScoreThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser((BinaryGrammar) null, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Edge edge0 = new Edge(true);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iScore(edge0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIScoreAndIScoreThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, deltaIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, deltaIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iScore((Edge) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList3()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(deltaIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(deltaIndex0, deltaIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag((String) null, "\"CDC@UnHA`uD", "");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar1, unaryGrammar1, baseLexicon0, options0, deltaIndex0, hashIndex0, deltaIndex0);
      ArrayList<CoreLabel> arrayList0 = treeGraphNode0.yieldHasWord();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList4()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(deltaIndex0, deltaIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag((String) null, "\"CDC@UnHA`uD", "");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar1, unaryGrammar0, baseLexicon0, options0, deltaIndex0, hashIndex0, deltaIndex0);
      ArrayList<CoreLabel> arrayList0 = treeGraphNode0.yieldHasWord();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeThrowsTooManyResourcesExceptionAndValidateBinarizedTree()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      treeGraphNode0.setChildren(list0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      exhaustivePCFGParser0.validateBinarizedTree(tree0, 100);
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTree()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      double double0 = exhaustivePCFGParser0.validateBinarizedTree(simpleTree0, 100);
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testValidateBinarizedTreeWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(deltaIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, deltaIndex0);
      Options options0 = new Options();
      binaryGrammar1.spliterator();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar1, unaryGrammar0, baseLexicon0, options0, deltaIndex0, deltaIndex0, deltaIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.validateBinarizedTree((Tree) null, 2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testBuildOFilterThrowsNullPointerExceptionAndSetConstraints()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser((BinaryGrammar) null, (UnaryGrammar) null, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.setConstraints((List<ParserConstraint>) null);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.buildOFilter();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingHTKLatticeReaderThrowsIOException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(deltaIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, deltaIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      exhaustivePCFGParser0.doInsideScores();
      HTKLatticeReader hTKLatticeReader0 = null;
      try {
        hTKLatticeReader0 = new HTKLatticeReader("Lh$3tmS", false);
        fail("Expecting exception: IOException");
      
      } catch(Throwable e) {
         //
         // Unable to open \"Lh$3tmS\" as class path, filename or URL
         //
         verifyException("edu.stanford.nlp.io.IOUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleAndIPossibleThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(deltaIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      UnaryGrammar unaryGrammar2 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar2, baseLexicon0, options0, hashIndex0, deltaIndex0, hashIndex0);
      Hook hook0 = new Hook(false);
      Hook hook1 = new Hook(hook0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossible(hook1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleWithHookWhereIsPostHookIsFalseAndHookWhereIsPreHookIsTrue()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(false);
      hook0.head = (-779);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(false);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleR()  throws Throwable  {
      Properties properties0 = new Properties();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags(properties0);
      List<String> list0 = seqClassifierFlags0.gazettes;
      seqClassifierFlags0.pctSegmenterLenAdjust = false;
      HashIndex<String> hashIndex0 = new HashIndex<String>(list0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleR(559038737, 2985);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleRThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleR(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListAndCreateArrays()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.initializePossibles();
      IndexedWord indexedWord0 = IndexedWord.NO_WORD;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      ArrayList<WordTag> arrayList0 = treeGraphNode0.yieldHasWord();
      WordTag wordTag0 = new WordTag("gb5", "gb5");
      arrayList0.add(wordTag0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList5()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("");
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag("", "");
      List<WordLemmaTag> list0 = List.of(wordLemmaTag0, wordLemmaTag1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKBestParsesReturningListWhereIsEmptyIsTrue()  throws Throwable  {
      Properties properties0 = new Properties();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags(properties0);
      HashIndex<String> hashIndex0 = new HashIndex<String>(seqClassifierFlags0.comboProps);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getKBestParses((-2535));
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(hashIndex0);
      // Undeclared exception!
      try { 
        HashIndex.loadFromFilename((String) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Attempt to open file with null name
         //
         verifyException("edu.stanford.nlp.io.IOUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList6()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("5&u{K<a$N");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySize0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.arraySize = 100;
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndCreateArrays()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      ArrayList<WordTag> arrayList0 = new ArrayList<WordTag>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithNonEmptyList7()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser((BinaryGrammar) null, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ArrayList<Word> arrayList0 = chineseTreebankParserParams0.defaultTestSentence();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BaseLexicon", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingHTKLatticeReader()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      boolean boolean0 = exhaustivePCFGParser0.parse((HTKLatticeReader) null);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySizeThrowsTooManyResourcesException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, (Index<String>) null);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, (UnaryGrammar) null, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.arraySize = 3049;
      // Undeclared exception!
      exhaustivePCFGParser0.nudgeDownArraySize();
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySize1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.nudgeDownArraySize();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testNudgeDownArraySizeAndScoreNonBinarizedTreeThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(deltaIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, deltaIndex0);
      Options options1 = new Options();
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Lexicon lexicon0 = negraPennTreebankParserParams0.lex(options1, deltaIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar1, lexicon0, options1, deltaIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getConstraints();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      Filters.RandomFilter<Tree> filters_RandomFilter0 = new Filters.RandomFilter<Tree>();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(stringLabelFactory0);
      exhaustivePCFGParser0.nudgeDownArraySize();
      Tree tree0 = treeGraphNode0.spliceOut((Predicate<Tree>) filters_RandomFilter0, (TreeFactory) treeGraphNodeFactory0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BoundaryRemover", e);
      }
  }

  @Test(timeout = 4000)
  public void testOScoreWithNull()  throws Throwable  {
      Properties properties0 = new Properties();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags(properties0);
      HashIndex<String> hashIndex0 = new HashIndex<String>(1);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(false);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Index<? extends String>) hashIndex0);
      hashIndex1.addToIndex("Invalid binary:");
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex1);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, deltaIndex0, hashIndex1);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, deltaIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser1.getConstraints();
      exhaustivePCFGParser0.createArrays(131);
      System.setCurrentTimeMillis(0L);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oScore((Edge) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreBinarizedTreeAndScoreBinarizedTreeWithTreeWhereScoreIsPositive()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      SimpleTree simpleTree0 = new SimpleTree();
      double double0 = exhaustivePCFGParser0.scoreBinarizedTree(simpleTree0, 100);
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeThrowsNullPointerException2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      SimpleTree simpleTree0 = new SimpleTree();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree(simpleTree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.trees.Tree", e);
      }
  }

  @Test(timeout = 4000)
  public void testScoreNonBinarizedTreeAndScoreNonBinarizedTreeThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(deltaIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, deltaIndex0);
      Options options1 = new Options();
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Lexicon lexicon0 = negraPennTreebankParserParams0.lex(options1, deltaIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar1, lexicon0, options1, deltaIndex0, hashIndex0, hashIndex0);
      List<ParserConstraint> list0 = exhaustivePCFGParser0.getConstraints();
      assertNull(list0);
      
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      Filters.RandomFilter<Tree> filters_RandomFilter0 = new Filters.RandomFilter<Tree>();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(stringLabelFactory0);
      Tree tree0 = treeGraphNode0.spliceOut((Predicate<Tree>) filters_RandomFilter0, (TreeFactory) treeGraphNodeFactory0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.scoreNonBinarizedTree(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BoundaryRemover", e);
      }
  }

  @Test(timeout = 4000)
  public void testSetConstraintsAndSetConstraintsWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      BinaryGrammar binaryGrammar1 = new BinaryGrammar(deltaIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, deltaIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar1, unaryGrammar0, baseLexicon0, options0, deltaIndex0, deltaIndex0, deltaIndex0);
      exhaustivePCFGParser0.setConstraints((List<ParserConstraint>) null);
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testSetConstraints()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, deltaIndex0, hashIndex0, hashIndex0);
      Stack<ParserConstraint> stack0 = new Stack<ParserConstraint>();
      exhaustivePCFGParser0.setConstraints(stack0);
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testSetConstraintsAndSetConstraints()  throws Throwable  {
      Properties properties0 = new Properties();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags(properties0);
      HashIndex<String> hashIndex0 = new HashIndex<String>(seqClassifierFlags0.gazettes);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      options0.genStop = false;
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Stack<ParserConstraint> stack0 = new Stack<ParserConstraint>();
      exhaustivePCFGParser1.setConstraints(stack0);
      assertEquals(10, stack0.capacity());
  }

  @Test(timeout = 4000)
  public void testTickAndCreateArraysThrowsTooManyResourcesException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(false);
      unaryGrammar0.rulesByParent(0);
      hashIndex0.addToIndex("0<8tj`7");
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getConstraints();
      exhaustivePCFGParser0.tick("0<8tj`7");
      // Undeclared exception!
      exhaustivePCFGParser0.createArrays(919);
  }

  @Test(timeout = 4000)
  public void testTickAndBuildOFilterThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.tick(" words (incl. stop) iScore ");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.buildOFilter();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListAndParseTakingListWithEmptyList()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.initializePossibles();
      IndexedWord indexedWord0 = IndexedWord.NO_WORD;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      ArrayList<WordTag> arrayList0 = new ArrayList<WordTag>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingListThrowsNullPointerExceptionAndParseTakingListWithEmptyList()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Vector<CoreLabel> vector0 = new Vector<CoreLabel>();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((List<? extends HasWord>) vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreateArraysThrowsTooManyResourcesException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(false);
      hashIndex0.addToIndex("0<8tj`7");
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      HashIndex<String> hashIndex1 = new HashIndex<String>();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex1, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getConstraints();
      // Undeclared exception!
      exhaustivePCFGParser0.createArrays(919);
  }

  @Test(timeout = 4000)
  public void testHasParse1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      HashIndex<String> hashIndex1 = new HashIndex<String>((Index<? extends String>) hashIndex0);
      hashIndex1.add("9g<YA$yh,t;N.");
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex1);
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testOPossibleLWithPositiveAndPositive()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleL(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleL()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Options options0 = new Options();
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      StringWriter stringWriter0 = new StringWriter(100);
      StringWriter stringWriter1 = stringWriter0.append('7');
      binaryGrammar0.writeData(stringWriter1);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Index<? extends String>) hashIndex0);
      ChineseLexicon chineseLexicon0 = new ChineseLexicon(options0, chineseTreebankParserParams0, hashIndex1, hashIndex1);
      Options options1 = new Options(chineseTreebankParserParams0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, chineseLexicon0, options1, hashIndex1, hashIndex0, hashIndex1);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossibleL(0, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleWithNull()  throws Throwable  {
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Properties properties0 = new Properties();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags(properties0);
      ArrayList<String> arrayList0 = new ArrayList<String>(1);
      HashIndex<String> hashIndex0 = new HashIndex<String>(arrayList0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      hashIndex0.add((String) null);
      seqClassifierFlags0.usePhraseWordSpecialTags = true;
      BaseLexicon baseLexicon1 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar1, baseLexicon1, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      Lattice lattice1 = new Lattice();
      exhaustivePCFGParser0.getBestScore();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossible((Hook) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreateArrays()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(false);
      hashIndex0.addToIndex("0<8tj`7");
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getConstraints();
      // Undeclared exception!
      exhaustivePCFGParser0.createArrays(919);
  }

  @Test(timeout = 4000)
  public void testIPossibleL()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getBestScore();
      exhaustivePCFGParser0.getBestScore("RNIJ!1y!(,''6:daNF");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleL(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleLThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleL(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingNoArgumentsThrowsUnsupportedOperationException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getBestScore();
      exhaustivePCFGParser0.getBestScore("attemt to get word wen setence and lattice are null!");
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKSampledParses(116);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // ExhaustivePCFGParser doesn't sample.
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKSampledParsesThrowsUnsupportedOperationException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKSampledParses(100);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // ExhaustivePCFGParser doesn't sample.
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeWithNull()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = exhaustivePCFGParser0.lr;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse((Lattice) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleRThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleR(100, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testIPossibleR()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ArrayList<String> arrayList0 = new ArrayList<String>();
      Supplier<List<String>> supplier0 = (Supplier<List<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      MapFactory<Object, CoreLabel> mapFactory0 = MapFactory.linkedHashMapFactory();
      MapFactory<Object, UnaryRule> mapFactory1 = MapFactory.arrayMapFactory();
      Map<String, Integer> map0 = mapFactory1.setMap(null, 100);
      mapFactory0.setMap(map0);
      hashIndex0.add((String) null);
      binaryGrammar0.spliterator();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options1 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options1, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.iPossibleR(930, (-1478));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractBestParsesThrowsNullPointerException()  throws Throwable  {
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Properties properties0 = new Properties();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags(properties0);
      ArrayList<String> arrayList0 = new ArrayList<String>(1);
      HashIndex<String> hashIndex0 = new HashIndex<String>(arrayList0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.extractBestParses((-1042), 0, 1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsExceptionAndParseTakingLattice()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      LatticeEdge latticeEdge0 = new LatticeEdge("|>+5hT@JGRTIvrN$y", (-1090.0), 1004, 103);
      Lattice lattice0 = new Lattice();
      lattice0.addEdge(latticeEdge0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsArrayIndexOutOfBoundsException4()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      LatticeEdge latticeEdge0 = new LatticeEdge("g>+5hT@JGRTIvrN$y", 100, 939, 100);
      Lattice lattice0 = new Lattice();
      lattice0.addBoundary();
      lattice0.addEdge(latticeEdge0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringWithEmptyString()  throws Throwable  {
      int int0 = 666;
      HashIndex<String> hashIndex0 = new HashIndex<String>(666);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      hashIndex0.clear();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Lexicon lexicon0 = spanishUnknownWordModelTrainer0.lex;
      Options options0 = new Options();
      spanishUnknownWordModelTrainer0.op = options0;
      Options options1 = new Options();
      int[] intArray0 = new int[9];
      intArray0[0] = 666;
      intArray0[1] = 100;
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0);
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(deltaIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar1, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getBestScore("");
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options1, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = exhaustivePCFGParser1.lr;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser1.parse((Lattice) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeAndParseTakingLatticeWithLatticeWhereGetNumEdgesIsPositive()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      options0.doDep = false;
      LatticeEdge latticeEdge0 = new LatticeEdge("ordm", 100, 939, 100);
      Lattice lattice0 = new Lattice();
      lattice0.addEdge(latticeEdge0);
      hashIndex0.add((String) null);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.IntTaggedWord", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeAndParseTakingLatticeWithLatticeWhereGetNumEdgesIsZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ArrayList<String> arrayList0 = new ArrayList<String>();
      Supplier<List<String>> supplier0 = (Supplier<List<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      MapFactory<Object, CoreLabel> mapFactory0 = MapFactory.linkedHashMapFactory();
      MapFactory<Object, UnaryRule> mapFactory1 = MapFactory.arrayMapFactory();
      Map<String, Integer> map0 = mapFactory1.setMap(null, 100);
      mapFactory0.setMap(map0);
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options1 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options1, hashIndex0, hashIndex0, hashIndex0);
      Lattice lattice0 = new Lattice();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoInsideScores()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.doInsideScores();
      assertEquals(Double.NEGATIVE_INFINITY, exhaustivePCFGParser0.getBestScore(), 0.01);
  }

  @Test(timeout = 4000)
  public void testParseTakingLatticeThrowsNullPointerExceptionAndParseTakingLatticeWithLatticeWhereGetNumEdgesIsZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Lattice lattice0 = new Lattice();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.parse(lattice0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testHasParseAndGetBestParsesThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getBestScore();
      exhaustivePCFGParser0.getBestScore("attemt to get word wen setence and lattice are null!");
      ExhaustivePCFGParser exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.hasParse();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestParses();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildOFilterThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>(666);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      hashIndex0.clear();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Lexicon lexicon0 = spanishUnknownWordModelTrainer0.lex;
      Options options0 = new Options();
      spanishUnknownWordModelTrainer0.op = options0;
      Options options1 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, spanishUnknownWordModelTrainer0.op, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKBestParses(17);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetBestScoreTakingStringAndGetBestScoreTakingString()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      hashIndex0.add((String) null);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      double double0 = exhaustivePCFGParser0.getBestScore((String) null);
      assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateExhaustivePCFGParserThrowsNullPointerException()  throws Throwable  {
      Properties properties0 = new Properties();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags(properties0);
      List<String> list0 = seqClassifierFlags0.gazettes;
      HashIndex<String> hashIndex0 = new HashIndex<String>(list0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getBestScore((String) null);
      ExhaustivePCFGParser exhaustivePCFGParser1 = null;
      try {
        exhaustivePCFGParser1 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, (Index<String>) null, (Index<String>) null, (Index<String>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKBestParses()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      List<ScoredObject<Tree>> list0 = exhaustivePCFGParser0.getKBestParses((-1884));
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetKGoodParsesThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getKGoodParses(100);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -1 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetKGoodParses()  throws Throwable  {
      Properties properties0 = new Properties();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags(properties0);
      List<String> list0 = seqClassifierFlags0.gazettes;
      HashIndex<String> hashIndex0 = new HashIndex<String>(list0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      double double0 = exhaustivePCFGParser0.getBestScore();
      assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
      
      List<ScoredObject<Tree>> list1 = exhaustivePCFGParser0.getKGoodParses(0);
      assertNotNull(list1);
      assertFalse(exhaustivePCFGParser0.hasParse());
  }

  @Test(timeout = 4000)
  public void testOScoreWithEdgeWhereScoreIsNegative()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Edge edge0 = new Edge(false);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oScore(edge0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOScoreAndOScoreThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, deltaIndex0);
      Hook hook0 = new Hook(false);
      boolean[][] booleanArray0 = new boolean[7][7];
      boolean[] booleanArray1 = new boolean[5];
      booleanArray1[0] = false;
      booleanArray1[1] = false;
      booleanArray1[2] = true;
      booleanArray1[3] = false;
      booleanArray1[4] = true;
      booleanArray0[0] = booleanArray1;
      boolean[] booleanArray2 = new boolean[3];
      booleanArray2[0] = false;
      booleanArray2[1] = false;
      booleanArray2[2] = false;
      booleanArray0[1] = booleanArray2;
      boolean[] booleanArray3 = new boolean[3];
      booleanArray3[0] = true;
      booleanArray3[1] = false;
      booleanArray3[2] = false;
      booleanArray0[2] = booleanArray3;
      boolean[] booleanArray4 = new boolean[7];
      booleanArray4[0] = false;
      booleanArray4[1] = false;
      booleanArray4[2] = true;
      booleanArray4[3] = true;
      booleanArray4[4] = false;
      booleanArray4[5] = true;
      booleanArray4[6] = false;
      booleanArray0[3] = booleanArray4;
      boolean[] booleanArray5 = new boolean[7];
      booleanArray5[0] = false;
      booleanArray5[1] = false;
      booleanArray5[2] = false;
      booleanArray5[3] = true;
      booleanArray5[4] = true;
      booleanArray5[5] = true;
      booleanArray5[6] = false;
      booleanArray0[4] = booleanArray5;
      boolean[] booleanArray6 = new boolean[2];
      booleanArray6[0] = false;
      booleanArray6[1] = true;
      booleanArray0[5] = booleanArray6;
      boolean[] booleanArray7 = new boolean[1];
      booleanArray7[0] = true;
      booleanArray0[6] = booleanArray7;
      exhaustivePCFGParser0.oFilteredStart = booleanArray0;
      Hook hook1 = new Hook(hook0);
      Edge edge0 = hook1.backEdge;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oScore((Edge) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildOFilterThrowsNullPointerExceptionAndInitializePossibles()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.createArrays(100);
      exhaustivePCFGParser0.length = 100;
      exhaustivePCFGParser0.initializePossibles();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.buildOFilter();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testInitializePossiblesThrowsNullPointerException1()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.initializePossibles();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testInitializePossiblesThrowsNullPointerExceptionAndInitializePossibles()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      Options options0 = new Options();
      UnaryGrammar unaryGrammar1 = new UnaryGrammar(deltaIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, deltaIndex0);
      Options options1 = new Options();
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar1, baseLexicon0, options1, deltaIndex0, hashIndex0, hashIndex0);
      exhaustivePCFGParser0.getBestScore();
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.initializePossibles();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetConstraints()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(false);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      List<ParserConstraint> list0 = exhaustivePCFGParser0.getConstraints();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testOPossibleThrowsNullPointerExceptionAndOPossibleAndOPossibleWithHookWhereIsPreHookIsTrue()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      Hook hook0 = new Hook(false);
      hook0.start = 1393;
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleThrowsNullPointerExceptionAndOPossibleWithHookWhereIsPreHookIsFalse()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(false);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testOPossibleThrowsNullPointerExceptionAndOPossibleAndOPossibleWithHookWhereIsPreHookIsFalse()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Lexicon lexicon0 = null;
      Options options0 = new Options();
      ArrayList<String> arrayList0 = new ArrayList<String>();
      Supplier<List<String>> supplier0 = (Supplier<List<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      MapFactory<Object, CoreLabel> mapFactory0 = MapFactory.linkedHashMapFactory();
      MapFactory<Object, UnaryRule> mapFactory1 = MapFactory.arrayMapFactory();
      Map<String, Integer> map0 = mapFactory1.setMap(null, 100);
      mapFactory0.setMap(map0);
      Supplier<Map<String, Integer>> supplier1 = (Supplier<Map<String, Integer>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      Hook hook0 = new Hook(true);
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      spanishUnknownWordModelTrainer0.initializeTraining(options0, (Lexicon) null, hashIndex0, hashIndex0, 1803.7479753073774);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.oPossible(hook0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesWithZero()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      Hook hook0 = new Hook(false);
      boolean boolean0 = ExhaustivePCFGParser.matches(0.0, 0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetConstraintsThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, deltaIndex0, deltaIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestParse();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testHasParse2()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      boolean boolean0 = exhaustivePCFGParser0.hasParse();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetBestParseThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      BaseLexicon baseLexicon0 = new BaseLexicon(hashIndex0, hashIndex0);
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, baseLexicon0, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.getBestParse();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractBestParseThrowsNullPointerException()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      Options options0 = new Options();
      Supplier<List<String>> supplier0 = (Supplier<List<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      Supplier<Map<String, Integer>> supplier1 = (Supplier<Map<String, Integer>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier1).get();
      HashIndex<String> hashIndex1 = new HashIndex<String>(supplier0, supplier1);
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex1, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.extractBestParse("A#`pKge1G", 100, 709);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesReturningTrue()  throws Throwable  {
      ExhaustivePCFGParser.matches(0.0, 0.0);
      HashIndex<String> hashIndex0 = new HashIndex<String>(0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      ChineseLexiconAndWordSegmenter chineseLexiconAndWordSegmenter0 = null;
      try {
        chineseLexiconAndWordSegmenter0 = new ChineseLexiconAndWordSegmenter("niskUMCc<1lea]S", options0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // java.io.FileNotFoundException
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ChineseLexiconAndWordSegmenter", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesWithPositive()  throws Throwable  {
      Options options0 = new Options();
      boolean boolean0 = ExhaustivePCFGParser.matches(0.0, 100);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesReturningFalse()  throws Throwable  {
      ExhaustivePCFGParser.matches(0.0, (-5135.334));
      Index<String> index0 = null;
      BinaryGrammar binaryGrammar0 = null;
      try {
        binaryGrammar0 = new BinaryGrammar((Index<String>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testBuildOFilterThrowsNullPointerException0()  throws Throwable  {
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex0, hashIndex0);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(deltaIndex0);
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(deltaIndex0);
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      deltaIndex0.add("zh<-Wo3");
      Lexicon lexicon0 = spanishUnknownWordModelTrainer0.lex;
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.buildOFilter();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildOFilterThrowsNullPointerException1()  throws Throwable  {
      int int0 = 665;
      HashIndex<String> hashIndex0 = new HashIndex<String>(665);
      BinaryGrammar binaryGrammar0 = new BinaryGrammar(hashIndex0);
      hashIndex0.clear();
      UnaryGrammar unaryGrammar0 = new UnaryGrammar(hashIndex0);
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Lexicon lexicon0 = spanishUnknownWordModelTrainer0.lex;
      Options options0 = new Options();
      ExhaustivePCFGParser exhaustivePCFGParser0 = new ExhaustivePCFGParser(binaryGrammar0, unaryGrammar0, (Lexicon) null, options0, hashIndex0, hashIndex0, hashIndex0);
      // Undeclared exception!
      try { 
        exhaustivePCFGParser0.buildOFilter();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ExhaustivePCFGParser", e);
      }
  }
}
