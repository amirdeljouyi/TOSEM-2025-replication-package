/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Apr 21 18:36:02 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.StringLabel;
import edu.stanford.nlp.ling.StringLabelFactory;
import edu.stanford.nlp.ling.Tag;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.TaggedWordFactory;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordFactory;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordLemmaTagFactory;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.ling.WordTagFactory;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HebrewTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HungarianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ItalianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.NegraPennTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.SpanishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor;
import edu.stanford.nlp.parser.lexparser.TestOptions;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.trees.BobChrisTreeNormalizer;
import edu.stanford.nlp.trees.CompositeTreeTransformer;
import edu.stanford.nlp.trees.HeadFinder;
import edu.stanford.nlp.trees.LabeledScoredConstituentFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.LabeledScoredTreeReaderFactory;
import edu.stanford.nlp.trees.MemoryTreebank;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.SimpleTreeFactory;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeGraphNodeFactory;
import edu.stanford.nlp.trees.TreeLeafLabelTransformer;
import edu.stanford.nlp.trees.TreeReaderFactory;
import edu.stanford.nlp.trees.TreeTransformer;
import edu.stanford.nlp.trees.TreebankLanguagePack;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.ThreeDimensionalMap;
import edu.stanford.nlp.util.Triple;
import edu.stanford.nlp.util.TwoDimensionalMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.Vector;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.EvoSuiteURL;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.testdata.NetworkHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class SplittingGrammarExtractor_3_ESTest extends SplittingGrammarExtractor_3_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][1][1];
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray0);
      IdentityHashMap<String, double[][][]> identityHashMap0 = new IdentityHashMap<String, double[][][]>();
      Stack<String> stack0 = new Stack<String>();
      stack0.add((String) null);
      splittingGrammarExtractor0.startSymbols = (List<String>) stack0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsTooManyResourcesException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[19][0];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 200000;
      identityHashMap2.putIfAbsent(treeGraphNode1, doubleArray0);
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 1, identityHashMap2, identityHashMap1);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      MapFactory.hashMapFactory();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      MapFactory<Object, CoreLabel> mapFactory0 = MapFactory.identityHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      HashIndex<Object> hashIndex0 = new HashIndex<Object>(1369);
      mapFactory0.newSet((Collection<Object>) hashIndex0);
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map0, twoDimensionalMap1, threeDimensionalMap0);
      Annotation annotation0 = new Annotation((String) null);
      CoreLabel coreLabel0 = new CoreLabel(annotation0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Tree tree0 = treeGraphNode0.deepCopy();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      splittingGrammarExtractor0.saveTrees(tree0, 0.45, tree0, (-50.0));
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap1, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("`__D5OEU@c&:{K*B", "`__D5OEU@c&:{K*B", "`__D5OEU@c&:{K*B");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options0);
      String string0 = "ywnV309";
      BiFunction<Object, Object, int[]> biFunction0 = (BiFunction<Object, Object, int[]>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.outputTransitions((Tree) treeGraphNode0, 3, identityHashMap1, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndSplitBetasAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString("itV=#kx\u00078pV@Q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[][] doubleArray0 = new double[4][4];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[3];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = 332.8425132;
      doubleArray2[2] = 0.0;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[3];
      doubleArray3[0] = (double) 961;
      doubleArray3[1] = (double) 961;
      doubleArray3[2] = 332.8425132;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[2];
      doubleArray4[0] = (double) 961;
      doubleArray4[1] = 0.0;
      doubleArray0[3] = doubleArray4;
      twoDimensionalMap0.put("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsNullPointerExceptionAndRescaleTemporaryBetasWithNull0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[21][4];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("Converged for cycle ", "X^7..{A1HGI|uN6", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "r]4h:G*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor1.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>(0);
      double[][] doubleArray1 = new double[5][1];
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      double[] doubleArray2 = new double[8];
      doubleArray1[3] = doubleArray2;
      doubleArray1[4] = doubleArray0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(treeGraphNode1, identityHashMap0, identityHashMap0, identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap3);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap0, identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor1.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>(0);
      double[][] doubleArray1 = new double[5][1];
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      double[] doubleArray2 = new double[8];
      doubleArray2[0] = (double) 1;
      double[][][] doubleArray3 = new double[3][9][5];
      doubleArray3[0] = doubleArray1;
      doubleArray3[1] = doubleArray1;
      doubleArray3[2] = doubleArray1;
      threeDimensionalMap0.put((String) null, "V=", "20nvR_umP", doubleArray3);
      splittingGrammarExtractor2.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recurseOutside(treeGraphNode1, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[10];
      identityHashMap0.put("itV=#kx\u00078pV@Q", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      identityHashMap1.entrySet();
      identityHashMap1.put(treeGraphNode1, doubleArray0);
      MapFactory.weakHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) hashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      identityHashMap0.put("itV=#kx\u00078pV@Q", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      identityHashMap1.entrySet();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      identityHashMap1.put(treeGraphNode1, doubleArray0);
      MapFactory<Object, Triple<Object, Object, Object>> mapFactory0 = MapFactory.weakHashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap0, 100);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap0, map0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('c');
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      identityHashMap0.put("itV=#kx\u00078pV@Q", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      MapFactory.weakHashMapFactory();
      splittingGrammarExtractor1.recountInside(treeGraphNode1, true, (-1), identityHashMap1);
      TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.splitBetas();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsTooManyResourcesExceptionAndOutputTransitionsTaking3ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor1.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[5][1];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      double[] doubleArray2 = new double[8];
      doubleArray2[0] = (double) 1;
      doubleArray1[3] = doubleArray2;
      doubleArray1[4] = doubleArray0;
      identityHashMap2.putIfAbsent(treeGraphNode0, doubleArray1);
      double[][][] doubleArray3 = new double[0][6][6];
      BiFunction<Object, Object, double[][][]> biFunction0 = (BiFunction<Object, Object, double[][][]>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      identityHashMap1.merge(treeGraphNode1, doubleArray3, biFunction0);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      splittingGrammarExtractor1.outputTransitions((Tree) treeGraphNode1, identityHashMap2, identityHashMap1);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsTooManyResourcesExceptionAndOutputTransitionsTaking3ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldAllThrowIOExceptions();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("`__D53OEU@c&:{K*B", "`__D53OEU@c&:{K*B", "`__D53OEU@c&:{K*B");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[5][1];
      doubleArray1[4] = doubleArray0;
      identityHashMap1.putIfAbsent(treeGraphNode0, doubleArray1);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, identityHashMap1, identityHashMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('c');
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      double[] doubleArray1 = identityHashMap0.put("itV=#kx\u00078pV@Q", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray2 = new double[6][6];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      doubleArray2[2] = doubleArray0;
      identityHashMap0.put(" in ", doubleArray0);
      doubleArray2[3] = null;
      doubleArray2[4] = null;
      doubleArray2[5] = null;
      identityHashMap2.putIfAbsent(treeGraphNode0, doubleArray2);
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray1, 100, identityHashMap2, identityHashMap3, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      TestOptions testOptions0 = options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(100);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[1][0];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 200000;
      doubleArray0[0] = doubleArray1;
      identityHashMap2.putIfAbsent(treeGraphNode1, doubleArray0);
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0[0], testOptions0.printFactoredKGood, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor1.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = 3416.242974697;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 3416.242974697;
      doubleArray0[3] = (double) 19;
      doubleArray0[4] = (-1.0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[5][1];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = (double) 1;
      doubleArray1[3] = doubleArray2;
      doubleArray1[4] = doubleArray0;
      identityHashMap2.putIfAbsent(treeGraphNode0, doubleArray1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 358, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeThrowsTooManyResourcesException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[19][0];
      identityHashMap2.putIfAbsent(treeGraphNode1, doubleArray0);
      // Undeclared exception!
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0[0], 0, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerExceptionAndMergeStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('\'');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("chat");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(1);
      double[] doubleArray0 = new double[4];
      doubleArray0[1] = (double) 0;
      doubleArray0[2] = 3416.242974697;
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      identityHashMap2.put("-nH", doubleArray0);
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray1 = new double[6][8][8];
      double[][] doubleArray2 = new double[7][7];
      doubleArray2[0] = null;
      doubleArray2[1] = null;
      double[] doubleArray3 = new double[5];
      doubleArray3[0] = 3416.242974697;
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = (double) 1;
      doubleArray3[3] = (double) 0;
      doubleArray3[4] = (double) 0;
      doubleArray2[2] = doubleArray3;
      doubleArray2[3] = null;
      doubleArray2[4] = null;
      doubleArray2[5] = doubleArray0;
      doubleArray2[6] = doubleArray0;
      doubleArray1[0] = doubleArray2;
      double[][] doubleArray4 = new double[9][3];
      doubleArray4[0] = null;
      doubleArray4[1] = doubleArray0;
      doubleArray4[2] = doubleArray3;
      doubleArray4[3] = null;
      doubleArray4[4] = null;
      doubleArray4[5] = doubleArray3;
      doubleArray4[6] = null;
      doubleArray4[7] = doubleArray3;
      doubleArray4[8] = null;
      doubleArray1[1] = doubleArray4;
      double[][] doubleArray5 = new double[6][5];
      doubleArray5[0] = doubleArray0;
      doubleArray5[1] = doubleArray0;
      doubleArray5[2] = doubleArray3;
      doubleArray5[3] = null;
      doubleArray5[4] = doubleArray3;
      doubleArray5[5] = doubleArray3;
      doubleArray1[2] = doubleArray5;
      double[][] doubleArray6 = new double[0][7];
      doubleArray1[3] = doubleArray6;
      double[][] doubleArray7 = new double[2][3];
      doubleArray7[0] = doubleArray3;
      doubleArray7[1] = null;
      doubleArray1[4] = doubleArray7;
      double[][] doubleArray8 = new double[5][2];
      doubleArray8[0] = null;
      doubleArray8[1] = doubleArray3;
      double[] doubleArray9 = new double[7];
      doubleArray9[0] = (-635.5642519946);
      doubleArray9[1] = (double) 100;
      doubleArray9[2] = (double) 1;
      doubleArray9[3] = (double) 0;
      doubleArray9[4] = (double) 100;
      doubleArray9[5] = (double) 200000;
      doubleArray9[6] = (double) 50;
      doubleArray8[2] = doubleArray9;
      doubleArray8[3] = doubleArray3;
      doubleArray8[4] = doubleArray0;
      doubleArray1[5] = doubleArray8;
      BiFunction<Object, Object, double[][][]> biFunction0 = (BiFunction<Object, Object, double[][][]>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      identityHashMap3.merge(treeGraphNode0, doubleArray1, biFunction0);
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, identityHashMap4, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking3ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('c');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("->");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      splittingGrammarExtractor0.recalculateBetas(false);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.splitBetas();
      MapFactory.hashMapFactory();
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = (double) 'c';
      doubleArray0[1] = (double) 'c';
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = (-1824.5472054417667);
      doubleArray0[6] = 0.0;
      doubleArray0[7] = (double) 100;
      int int0 = 1016;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 1016, identityHashMap1, identityHashMap2, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('\'');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      WordTag.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordLemmaTagFactory0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("", ",1KKV4lP)WOh", ",1KKV4lP)WOh");
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      MapFactory<String, CoreLabel> mapFactory0 = MapFactory.arrayMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(null);
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 5.0;
      doubleArray0[1] = (double) 0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = (double) 0;
      doubleArray0[6] = 5.0;
      doubleArray0[7] = 5.0;
      doubleArray0[8] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 3, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, map0, twoDimensionalMap1, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      options0.newTrainOptions();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(100);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[1];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, (-1), identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap1, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      TwoDimensionalMap<Object, String, CoreLabel> twoDimensionalMap1 = new TwoDimensionalMap<Object, String, CoreLabel>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory((LabelFactory) null);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      double[][] doubleArray0 = new double[3][5];
      double[] doubleArray1 = new double[4];
      doubleArray1[0] = (double) 0;
      doubleArray1[1] = (double) 0;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 5.0;
      double[] doubleArray2 = new double[2];
      doubleArray2[0] = (double) 3;
      doubleArray2[1] = 0.0;
      doubleArray0[2] = doubleArray2;
      twoDimensionalMap0.put((String) null, "JfnrDVWKqxOfe9%*", doubleArray0);
      MapFactory.linkedHashMapFactory();
      MapFactory.treeMapFactory();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 2 out of bounds for length 2
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNullAndMergeTransitionsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(true);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor3.mergeTransitions(treeGraphNode1, identityHashMap1, identityHashMap0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("complement", "complement", "complement");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode0.highestNodeWithSameHead();
      splittingGrammarExtractor0.mergeStates();
      options0.newTestOptions();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      LabelFactory labelFactory0 = CategoryWordTag.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      List<Tree> list1 = treeGraphNode2.dominationPath(treeGraphNode1);
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      WordTag.factory();
      Tree tree0 = treeGraphNode0.treeSkeletonConstituentCopy((TreeFactory) labeledScoredTreeFactory0, labelFactory0);
      TreeGraphNode treeGraphNode3 = new TreeGraphNode(tree0, list1);
      treeGraphNode3.localTree();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(treeGraphNode3, false, (-974), identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      Stack<String> stack0 = new Stack<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) stack0;
      stack0.add("Oj3?zZ6~7=Z9)3>cu");
      String string0 = splittingGrammarExtractor0.state("Oj3?zZ6~7=Z9)3>cu", 100);
      assertEquals("Oj3?zZ6~7=Z9)3>cu", string0);
      
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('c');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("itV=#kx\u00078pV@Q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      treeGraphNode1.localTree();
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      identityHashMap0.put("itV=#kx\u00078pV@Q", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      MapFactory<Object, Triple<Object, Object, Object>> mapFactory0 = MapFactory.weakHashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap0, 100);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap0, map0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("complement", "complement", "complement");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      treeGraphNode0.highestNodeWithSameHead();
      splittingGrammarExtractor0.mergeStates();
      options0.newTestOptions();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      LabelFactory labelFactory0 = CategoryWordTag.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      double[][] doubleArray0 = new double[1][4];
      double[] doubleArray1 = new double[7];
      doubleArray1[0] = (double) 200000;
      doubleArray1[1] = (double) 1;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = (double) 1;
      doubleArray1[5] = 462.877391;
      doubleArray1[6] = (double) 100;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put((String) null, "|!+6+U?K/[", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
      
      String string0 = splittingGrammarExtractor0.state("complement", (-1));
      assertEquals("complement^-1", string0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      double[][] doubleArray0 = new double[1][6];
      double[] doubleArray1 = new double[20];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (-3485.673384864274);
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = (double) 100;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put((String) null, "->", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      MapFactory.linkedHashMapFactory();
      MapFactory.treeMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      twoDimensionalMap0.secondKeySet();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap1, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndTestConvergence0()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      options0.useSmoothTagProjection = false;
      TwoDimensionalMap<Object, String, CoreLabel> twoDimensionalMap1 = new TwoDimensionalMap<Object, String, CoreLabel>();
      double[][] doubleArray0 = new double[1][8];
      twoDimensionalMap0.put("-------------------", ",1KKV4lP)WOh", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      MapFactory.linkedHashMapFactory();
      MapFactory.treeMapFactory();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      options0.doPCFG = false;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testTestConvergenceThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      TwoDimensionalMap<Object, String, CoreLabel> twoDimensionalMap1 = new TwoDimensionalMap<Object, String, CoreLabel>();
      double[][] doubleArray0 = new double[3][4];
      double[] doubleArray1 = new double[4];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = (-3485.673384864274);
      doubleArray1[3] = 0.0;
      doubleArray0[0] = doubleArray1;
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory((LabelFactory) null);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      twoDimensionalMap0.put((String) null, "->", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.linkedHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.treeMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.testConvergence(twoDimensionalMap2, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory('?');
      Label label0 = taggedWordFactory0.newLabel("<anW.\"<!BJtU", (int) '?');
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[7];
      doubleArray0[1] = (double) '?';
      double[][] doubleArray1 = new double[1][1];
      splittingGrammarExtractor0.outputBetas();
      doubleArray1[0] = doubleArray0;
      twoDimensionalMap0.put("<anW.\"<!BJtU", "<anW.\"<!BJtU", doubleArray1);
      UnaryOperator<double[][]> unaryOperator0 = UnaryOperator.identity();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(unaryOperator0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      twoDimensionalMap1.get("<anW.\"<!BJtU", "ECP^lcN");
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      identityHashMap2.put(treeGraphNode0, doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, (Tree) treeGraphNode0, identityHashMap4, identityHashMap2);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      identityHashMap0.put("itV=#kx\u00078pV@Q", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      identityHashMap1.entrySet();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      MapFactory.weakHashMapFactory();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('c');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("itV=#kx\u00078pV@Q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      Tree tree0 = treeGraphNode1.localTree();
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 'c';
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) 'c';
      identityHashMap0.put("itV=#kx\u00078pV@Q", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      identityHashMap0.put("itV=#kx\u00078pV@Q", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      identityHashMap1.entrySet();
      identityHashMap1.put(treeGraphNode1, doubleArray0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) hashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory('?');
      Label label0 = taggedWordFactory0.newLabel("<anW.\"<!BJtU", 7);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[7];
      doubleArray0[1] = (double) 7;
      double[][] doubleArray1 = new double[1][1];
      doubleArray1[0] = doubleArray0;
      twoDimensionalMap0.put("<anW.\"<!BJtU", "<anW.\"<!BJtU", doubleArray1);
      UnaryOperator<double[][]> unaryOperator0 = UnaryOperator.identity();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(unaryOperator0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      twoDimensionalMap1.get("<anW.\"<!BJtU", "ECP^lcN");
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap2);
      int int0 = splittingGrammarExtractor1.getStateSplitCount("2xq9!yt[b9&|.a0");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndSplitBetasAndTestConvergence0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      TwoDimensionalMap<Object, String, CoreLabel> twoDimensionalMap1 = new TwoDimensionalMap<Object, String, CoreLabel>();
      double[][] doubleArray0 = new double[3][4];
      double[] doubleArray1 = new double[4];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = (-3485.673384864274);
      doubleArray1[3] = 0.0;
      doubleArray0[0] = doubleArray1;
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory((LabelFactory) null);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      twoDimensionalMap0.put((String) null, "->", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      MapFactory.linkedHashMapFactory();
      MapFactory.treeMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap2, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndTestConvergence1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      TwoDimensionalMap<Object, String, CoreLabel> twoDimensionalMap1 = new TwoDimensionalMap<Object, String, CoreLabel>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory((LabelFactory) null);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      double[][] doubleArray0 = new double[3][5];
      double[] doubleArray1 = new double[4];
      doubleArray1[0] = (double) 0;
      doubleArray1[1] = (double) 0;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 5.0;
      double[] doubleArray2 = new double[2];
      doubleArray2[0] = (double) 3;
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      MapFactory.linkedHashMapFactory();
      MapFactory.treeMapFactory();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.splitBetas();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerExceptionAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      double[][] doubleArray0 = new double[19][8];
      twoDimensionalMap0.put((String) null, "F&c{", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString(")s*>");
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0, (List<Tree>) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledScoredTreeNode0, list0);
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      System.setCurrentTimeMillis(559038737);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) hashMap0, (Map<String, double[]>) identityHashMap1);
      assertEquals(Double.NaN, treeGraphNode1.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsNullPointerExceptionAndRescaleTemporaryBetasWithNull1()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      twoDimensionalMap0.put("X^7..{A1HGI|uN6", "X^7..{A1HGI|uN6", (double[][]) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndSplitBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[15][6];
      twoDimensionalMap0.put("chat", "chat", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesReturningEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      twoDimensionalMap0.size();
      double[][][] doubleArray0 = new double[18][7][0];
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      double[] doubleArray1 = splittingGrammarExtractor0.neginfDoubles(0);
      assertEquals(0, doubleArray1.length);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndTestConvergence2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory('?');
      Label label0 = taggedWordFactory0.newLabel((String) null, 7);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      double[][] doubleArray0 = new double[1][8];
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) '?';
      doubleArray1[2] = 0.0;
      doubleArray1[3] = 0.9999000099990001;
      doubleArray1[1] = (double) 7;
      doubleArray1[5] = 0.0;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("@ADVP|QP|ADJP < ((DT|RB=node1 < /^(?i)all$/) $+ (CC|RB|IN=node2 < /^(?i)but$/))", "@ADVP|QP|ADJP < ((DT|RB=node1 < /^(?i)all$/) $+ (CC|RB|IN=node2 < /^(?i)but$/))", doubleArray0);
      twoDimensionalMap0.get("<anW.\"<!BJtU", "~}e7L[");
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndRecalculateBetasAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('c');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("->");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      splittingGrammarExtractor0.recalculateBetas(false);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(treeGraphNode1, true, 559038737, identityHashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list0, 5.5, (Collection<Tree>) treeGraphNode1, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory('?');
      Label label0 = taggedWordFactory0.newLabel((String) null, 7);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[1][8];
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) '?';
      doubleArray1[2] = 0.0;
      doubleArray1[3] = 0.9999000099990001;
      doubleArray1[4] = (double) 7;
      doubleArray1[5] = 0.0;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("@ADVP|QP|ADJP < ((DT|RB=node1 < /^(?i)all$/) $+ (CC|RB|IN=node2 < /^(?i)but$/))", "@ADVP|QP|ADJP < ((DT|RB=node1 < /^(?i)all$/) $+ (CC|RB|IN=node2 < /^(?i)but$/))", doubleArray0);
      twoDimensionalMap0.get("<anW.\"<!BJtU", "~}e7L[");
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0, (-801.1), (Collection<Tree>) treeGraphNode0, (double) 7);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      String string0 = ")$";
      twoDimensionalMap0.get(")$", ")$");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      twoDimensionalMap0.put(".$$.", ".$$.", (double[][]) null);
      twoDimensionalMap0.get("exp", "F)x5)a[tu:Vgbt");
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory('?');
      Label label0 = taggedWordFactory0.newLabel((String) null, 38);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[1][8];
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) '?';
      doubleArray1[2] = 0.0;
      doubleArray1[3] = 0.9999000099990001;
      doubleArray1[4] = (double) 38;
      doubleArray1[5] = 0.0;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("@ADVP|QP|ADJP < ((DT|RB=node1 < /^(?i)all$/) $+ (CC|RB|IN=node2 < /^(?i)but$/))", "@ADVP|QP|ADJP < ((DT|RB=node1 < /^(?i)all$/) $+ (CC|RB|IN=node2 < /^(?i)but$/))", doubleArray0);
      twoDimensionalMap0.get("<anW.\"<!BJtU", "~}e7L[");
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      System.setCurrentTimeMillis(38);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideWithNonEmptyMapAndNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('c');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("complement");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      treeGraphNode0.getLeaves();
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      Tree tree0 = treeGraphNode1.localTree();
      splittingGrammarExtractor0.mergeStates();
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(tree0, true, 2, identityHashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      System.setCurrentTimeMillis(2);
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>(50);
      splittingGrammarExtractor0.outputTransitions(tree0, 481, identityHashMap1, identityHashMap3);
      splittingGrammarExtractor0.recurseOutside(treeGraphNode1, identityHashMap0, identityHashMap0);
      assertNotSame(treeGraphNode0, treeGraphNode1);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsAndMergeStatesAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('[');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("complement");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      treeGraphNode0.getLeaves();
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      Tree tree0 = treeGraphNode1.localTree();
      splittingGrammarExtractor0.mergeStates();
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(tree0, true, 2, identityHashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, identityHashMap1, identityHashMap3);
      assertNotSame(treeGraphNode1, tree0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndRecalculateBetasAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString("xB->");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      splittingGrammarExtractor0.recalculateBetas(false);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(treeGraphNode1, true, 559038737, identityHashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, identityHashMap1, identityHashMap2);
      assertNotSame(treeGraphNode1, treeGraphNode0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('[');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("complement");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      wordLemmaTagFactory0.newLabelFromString("complement");
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      treeGraphNode0.getLeaves();
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      Tree tree0 = treeGraphNode1.localTree();
      splittingGrammarExtractor0.mergeStates();
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(tree0, false, Integer.MAX_VALUE, identityHashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode1, list0);
      labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode1, (List<Tree>) null);
      splittingGrammarExtractor0.recountTree(tree1, true, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      assertTrue(identityHashMap1.isEmpty());
      assertTrue(identityHashMap2.isEmpty());
      assertEquals(0, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments4()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('[');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("complement");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      treeGraphNode0.getLeaves();
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      Tree tree0 = treeGraphNode1.localTree();
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      MapFactory<CoreLabel.GenericAnnotation<CoreLabel>, Object> mapFactory0 = MapFactory.weakHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      HeadFinder headFinder0 = hungarianTreebankParserParams0.typedDependencyHeadFinder();
      tree0.headPreTerminal(headFinder0);
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects(tree0, map0, map0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      String string0 = ";UrF";
      Label label0 = wordLemmaTagFactory0.newLabelFromString(";UrF");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap2, (Map<String, double[]>) identityHashMap2, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNullAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][1][1];
      threeDimensionalMap0.put((String) null, "", "", doubleArray0);
      threeDimensionalMap0.get((String) null, (String) null);
      Vector<String> vector0 = new Vector<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) vector0;
      splittingGrammarExtractor0.recalculateBetas(true);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString("Oj3?zZ6~7=Z9)3>cu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      treeGraphNode0.getLeaves();
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      Tree tree0 = treeGraphNode1.localTree();
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "");
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null, identityHashMap2, (IdentityHashMap<Tree, double[][][]>) null, (double[]) null, identityHashMap3);
      assertEquals(0, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("complement", "complement", "complement");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(2295);
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 2295;
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode1, identityHashMap0, identityHashMap2, identityHashMap4, identityHashMap2, doubleArray0, identityHashMap3);
      assertTrue(identityHashMap3.isEmpty());
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndTestConvergence3()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][8][8];
      threeDimensionalMap0.put("t@j.i1]]", "t@j.i1]]", "    ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][1][1];
      threeDimensionalMap0.put((String) null, "", "", doubleArray0);
      threeDimensionalMap0.get((String) null, (String) null);
      Vector<String> vector0 = new Vector<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) vector0;
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
      
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString("Oj3?zZ6~7=Z9)3>cu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      treeGraphNode0.getLeaves();
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      Tree tree0 = treeGraphNode1.localTree();
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(tree0, false, 100, identityHashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountTree(tree0, true, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      assertTrue(identityHashMap2.isEmpty());
      assertEquals(0, identityHashMap2.size());
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndBuildStateIndexAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      double[][][] doubleArray0 = new double[1][8][8];
      TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.buildGrammars();
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][1][1];
      threeDimensionalMap0.put((String) null, "", "", doubleArray0);
      threeDimensionalMap0.get((String) null, (String) null);
      Vector<String> vector0 = new Vector<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) vector0;
      splittingGrammarExtractor0.recalculateBetas(true);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString("Oj3?zZ6~7=Z9)3>cu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      treeGraphNode0.getLeaves();
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      Tree tree0 = treeGraphNode1.localTree();
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, true, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeExceptionAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      String string0 = "";
      double[][][] doubleArray0 = new double[1][1][1];
      threeDimensionalMap0.put((String) null, "", "", doubleArray0);
      threeDimensionalMap0.get((String) null, (String) null);
      Vector<String> vector0 = new Vector<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) vector0;
      splittingGrammarExtractor0.recalculateBetas(true);
      splittingGrammarExtractor0.splitBetas();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString("Oj3?zZ6~7=Z9)3>cu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      List<Tree> list1 = treeGraphNode1.preOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(label0, list1);
      Tree tree0 = treeGraphNode2.localTree();
      boolean boolean0 = true;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree0, true, 100, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeExceptionAndRecalculateBetasWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('c');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("->");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      splittingGrammarExtractor0.recalculateBetas(false);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(treeGraphNode1, true, 559038737, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString("->");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      splittingGrammarExtractor0.recalculateBetas(false);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode1, true, 559038737, identityHashMap0);
      assertEquals(559038738, int0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsStackOverflowError()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString("itV=#kx\u00078pV@Q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(treeGraphNode0, options0.testOptions.quietEvaluation, options0.testOptions.printPCFGkBest, identityHashMap0);
      TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Tag tag0 = new Tag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0, (List<Tree>) null);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.pathNodeToNode(treeGraphNode0, treeGraphNode0);
      Tree tree0 = simpleTreeFactory0.newTreeNode(")\"kGrI_Wqvj<", list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, identityHashMap0, identityHashMap0);
      MapFactory.hashMapFactory();
      MapFactory.arrayMapFactory();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[1][1][9];
      double[][] doubleArray1 = new double[0][6];
      doubleArray0[0] = doubleArray1;
      identityHashMap1.put(treeGraphNode1, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap2);
      splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap0, identityHashMap0);
      assertEquals(Double.NaN, tree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndSplitBetas1()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[2][6][4];
      double[][] doubleArray1 = new double[1][7];
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray3 = new double[4][6];
      double[] doubleArray4 = new double[7];
      doubleArray4[0] = (-3065.12);
      doubleArray4[1] = (double) 100;
      doubleArray4[2] = 0.0;
      doubleArray4[3] = (double) 100;
      doubleArray4[4] = 0.0;
      doubleArray4[5] = 0.0;
      doubleArray4[6] = 4366.8187635;
      doubleArray3[0] = doubleArray4;
      doubleArray3[1] = doubleArray2;
      doubleArray3[2] = doubleArray2;
      doubleArray3[3] = doubleArray2;
      doubleArray0[1] = doubleArray3;
      threeDimensionalMap0.put(" trees with total weight ", "kYGc,\"tW++%='KaTe", "kYGc,\"tW++%='KaTe", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerExceptionAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[18][6][0];
      threeDimensionalMap0.put("C'iS1X[U*k&.*P", "C'iS1X[U*k&.*P", (String) null, doubleArray0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.values();
      double[][][] doubleArray0 = new double[0][2][5];
      threeDimensionalMap0.put("Qoz7A#3", "Qoz7A#3", "Qoz7A#3", doubleArray0);
      threeDimensionalMap0.get((String) null, "Qoz7A#3");
      Vector<String> vector0 = new Vector<String>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateBetas(true);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndBuildMergeCorrespondenceAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.get("", "");
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.outputBetas();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testOutputBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.get(")$", ")$");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][1][1];
      double[][] doubleArray1 = new double[3][6];
      double[] doubleArray2 = new double[1];
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[8];
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[2];
      doubleArray4[0] = (double) 100;
      doubleArray4[1] = (double) 100;
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("LEXICON", "", "", doubleArray0);
      threeDimensionalMap0.get((String) null, (String) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Vector<String> vector0 = new Vector<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) vector0;
      splittingGrammarExtractor0.recalculateBetas(true);
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabel("GdZ", 4554);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(treeGraphNode1, identityHashMap0, identityHashMap0);
      assertSame(treeGraphNode0, treeGraphNode1);
  }

  @Test(timeout = 4000)
  public void testSplitBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[18][7][0];
      threeDimensionalMap0.put("-markMasdarVP", "-markMasdarVP", "Bo3H;R?$", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor1.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[3][4][7];
      double[][] doubleArray1 = new double[1][8];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray3 = new double[3][3];
      doubleArray3[0] = doubleArray2;
      doubleArray3[1] = doubleArray2;
      doubleArray3[2] = doubleArray2;
      doubleArray0[1] = doubleArray3;
      double[][] doubleArray4 = new double[2][9];
      doubleArray4[0] = doubleArray2;
      doubleArray4[1] = doubleArray2;
      doubleArray0[2] = doubleArray4;
      threeDimensionalMap0.put("", "", "x_", doubleArray0);
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(twoDimensionalMap0.equals((Object)twoDimensionalMap1));
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Integer integer0 = new Integer((-1144));
      Double double0 = new Double(889.2238910818744);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("Found ", integer0, double0);
      arrayList0.add(triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Word word0 = Word.EMPTY;
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      MemoryTreebank memoryTreebank0 = hebrewTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0, memoryTreebank0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.pathNodeToNode(treeGraphNode0, treeGraphNode0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("(;tX-%Ob2", list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode1, identityHashMap0, identityHashMap0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      MapFactory.hashMapFactory();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap.identityHashMap();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      Morphology morphology0 = new Morphology();
      Word word1 = morphology0.stem(word0);
      SimpleTree simpleTree0 = new SimpleTree(word1, list0);
      double[][][] doubleArray0 = new double[7][0][3];
      double[][] doubleArray1 = new double[3][5];
      double[] doubleArray2 = new double[9];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = 0.0;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      doubleArray2[4] = 0.0;
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = (double) 100;
      doubleArray2[7] = 0.0;
      doubleArray2[8] = 0.0;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = 0.0;
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[5];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = (double) 100;
      doubleArray4[3] = (-17.5699182605952);
      doubleArray4[4] = 0.0;
      doubleArray1[2] = doubleArray4;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray5 = new double[9][6];
      doubleArray5[0] = doubleArray4;
      doubleArray5[1] = doubleArray2;
      doubleArray5[2] = doubleArray2;
      doubleArray5[3] = doubleArray3;
      doubleArray5[4] = doubleArray3;
      doubleArray5[5] = doubleArray3;
      doubleArray5[6] = doubleArray4;
      doubleArray5[7] = doubleArray2;
      doubleArray5[8] = doubleArray4;
      doubleArray0[1] = doubleArray5;
      double[][] doubleArray6 = new double[4][7];
      doubleArray6[0] = doubleArray2;
      doubleArray6[1] = doubleArray3;
      double[] doubleArray7 = new double[6];
      doubleArray7[0] = (-17.5699182605952);
      doubleArray7[1] = (-17.5699182605952);
      doubleArray7[2] = (-2054.126899308);
      doubleArray7[3] = (-17.5699182605952);
      doubleArray7[4] = (-17.5699182605952);
      doubleArray7[5] = (double) 100;
      doubleArray6[2] = doubleArray7;
      doubleArray6[3] = doubleArray3;
      doubleArray0[2] = doubleArray6;
      double[][] doubleArray8 = new double[2][2];
      doubleArray8[0] = doubleArray2;
      doubleArray8[1] = doubleArray7;
      doubleArray0[3] = doubleArray8;
      double[][] doubleArray9 = new double[9][9];
      doubleArray9[0] = doubleArray7;
      doubleArray9[1] = doubleArray2;
      doubleArray9[2] = doubleArray7;
      doubleArray9[3] = doubleArray2;
      doubleArray9[4] = doubleArray2;
      doubleArray9[5] = doubleArray3;
      doubleArray9[6] = doubleArray7;
      doubleArray9[7] = doubleArray3;
      doubleArray9[8] = doubleArray4;
      doubleArray0[4] = doubleArray9;
      double[][] doubleArray10 = new double[5][3];
      doubleArray10[0] = doubleArray4;
      double[] doubleArray11 = new double[8];
      doubleArray11[0] = 0.0;
      doubleArray11[1] = (-17.5699182605952);
      doubleArray11[2] = (-2054.126899308);
      doubleArray11[3] = (-17.5699182605952);
      doubleArray11[4] = (double) 100;
      doubleArray11[5] = 1234.22366;
      doubleArray11[6] = 0.0;
      doubleArray11[7] = 0.0;
      doubleArray10[1] = doubleArray11;
      doubleArray10[2] = doubleArray2;
      doubleArray10[3] = doubleArray3;
      doubleArray10[4] = doubleArray7;
      doubleArray0[5] = doubleArray10;
      double[][] doubleArray12 = new double[8][3];
      doubleArray12[0] = doubleArray11;
      doubleArray12[1] = doubleArray7;
      doubleArray12[2] = doubleArray4;
      doubleArray12[3] = doubleArray4;
      doubleArray12[4] = doubleArray2;
      double[] doubleArray13 = new double[7];
      doubleArray13[0] = (double) 100;
      doubleArray13[1] = 0.0;
      doubleArray13[2] = (-17.5699182605952);
      doubleArray13[3] = 0.0;
      doubleArray13[4] = 1234.22366;
      doubleArray13[5] = 0.0;
      doubleArray13[6] = (double) 100;
      doubleArray12[5] = doubleArray13;
      doubleArray12[6] = doubleArray11;
      doubleArray12[7] = doubleArray3;
      doubleArray0[6] = doubleArray12;
      identityHashMap3.put(simpleTree0, doubleArray0);
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap2, identityHashMap3);
      assertEquals(1, identityHashMap3.size());
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndSplitBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[9][8][9];
      threeDimensionalMap0.put("C'iS1X[U*k&.*P", "C'iS1X[U*k&.*P", " in ", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][1][1];
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray0);
      threeDimensionalMap0.get((String) null, (String) null);
      Vector<String> vector0 = new Vector<String>();
      vector0.add((String) null);
      splittingGrammarExtractor0.startSymbols = (List<String>) vector0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(true);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[18][7][0];
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      double[][][] doubleArray0 = new double[3][6][4];
      double[] doubleArray1 = new double[0];
      double[][] doubleArray2 = new double[8][4];
      doubleArray2[0] = doubleArray1;
      doubleArray2[1] = doubleArray1;
      doubleArray2[2] = doubleArray1;
      threeDimensionalMap1.put((String) null, (String) null, (String) null, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap2.get("1\\/2", "*");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap3 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateBetas(true);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceThrowsArrayIndexOutOfBoundsExceptionAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      double[][][] doubleArray0 = new double[3][6][4];
      double[] doubleArray1 = new double[0];
      double[][] doubleArray2 = new double[8][4];
      doubleArray2[0] = doubleArray1;
      doubleArray2[1] = doubleArray1;
      doubleArray2[2] = doubleArray1;
      doubleArray2[3] = doubleArray1;
      doubleArray2[4] = doubleArray1;
      doubleArray2[5] = doubleArray1;
      doubleArray2[6] = doubleArray1;
      doubleArray2[7] = doubleArray1;
      doubleArray0[1] = doubleArray2;
      double[][] doubleArray3 = new double[1][3];
      doubleArray3[0] = doubleArray1;
      doubleArray0[2] = doubleArray2;
      threeDimensionalMap1.put((String) null, (String) null, (String) null, doubleArray0);
      threeDimensionalMap1.get("useNegaKDict3", "`UIN8X`^");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = splittingGrammarExtractor1.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, threeDimensionalMap2);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndOutputBetasAndTestConvergence0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      double[][][] doubleArray0 = new double[3][6][4];
      double[] doubleArray1 = new double[0];
      double[][] doubleArray2 = new double[8][4];
      doubleArray2[0] = doubleArray1;
      doubleArray2[1] = doubleArray1;
      doubleArray2[2] = doubleArray1;
      threeDimensionalMap1.put((String) null, (String) null, (String) null, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap2.get("1\\/2", "*");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap3 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor1.outputBetas();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndTestConvergence0()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[3][6][4];
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsWithTreeWhereScoreIsPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Tag tag0 = new Tag();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0, (List<Tree>) null);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.pathNodeToNode(treeGraphNode0, treeGraphNode0);
      Tree tree0 = simpleTreeFactory0.newTreeNode(")\"kGrI_Wqvj<", list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, identityHashMap0, identityHashMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.countOriginalStates();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      LabeledScoredTreeReaderFactory labeledScoredTreeReaderFactory0 = new LabeledScoredTreeReaderFactory(stringLabelFactory0);
      Tree.valueOf("V<4H|d", (TreeReaderFactory) labeledScoredTreeReaderFactory0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode1, (Tree) treeGraphNode1, (Tree) labeledScoredTreeNode0, identityHashMap2, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Integer integer0 = new Integer((-808));
      Integer integer1 = new Integer((-1480));
      Double double0 = new Double((-808));
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("-np1", integer1, double0);
      vector0.add(triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.buildMergeCorrespondence(vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceReturningMapWhereIsEmptyIsTrueAndMapWhereSizeIsZero()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldAllThrowIOExceptions();
      byte[] byteArray0 = new byte[3];
      byteArray0[0] = (byte)105;
      byteArray0[1] = (byte)1;
      byteArray0[2] = (byte) (-77);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Integer integer0 = new Integer((byte)1);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("-np1", integer0, null);
      vector0.add(triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceWithNonEmptyList()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("", 100, 0.0);
      arrayList0.add(triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndRecurseOutsideWithTreeWhereScoreIsPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      treeGraphNode0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
      
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountTree((Tree) treeGraphNode1, false, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      assertEquals(0, identityHashMap1.size());
      assertEquals(0, identityHashMap2.size());
      assertTrue(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndTestConvergence1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      twoDimensionalMap0.get("Iteration ", "Iteration ");
      threeDimensionalMap0.get("AMX&9Broa4_F?(", "AMX&9Broa4_F?(");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.outputBetas();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode((Label) null);
      // Undeclared exception!
      try { 
        bobChrisTreeNormalizer0.transformTree(labeledScoredTreeNode0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      FileSystemHandling.shouldAllThrowIOExceptions();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      MapFactory.weakHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      LabeledScoredTreeReaderFactory labeledScoredTreeReaderFactory0 = new LabeledScoredTreeReaderFactory(stringLabelFactory0);
      Tree.valueOf("", (TreeReaderFactory) labeledScoredTreeReaderFactory0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) treeGraphNode0, (Tree) treeGraphNode0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.countOriginalStates();
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Tree tree0 = simpleTreeFactory0.newLeaf("+FE&+z>");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      identityHashMap0.put(tree0, (double[][]) null);
      WordTagFactory wordTagFactory0 = new WordTagFactory(' ');
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordTagFactory0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0, arrayList0);
      Tree tree1 = treeGraphNode0.skipRoot();
      chineseTreebankParserParams0.transformTree(tree0, tree1);
      treeGraphNode0.dominationPath(tree0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken((String) null, "=7b]ufFT", 710, 3);
      labeledScoredTreeFactory0.newTreeNode((Label) coreLabel0, (List<Tree>) arrayList0);
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 5.0;
      doubleArray0[1] = (double) 710;
      doubleArray0[2] = (-1413.864);
      doubleArray0[3] = (-1410.37858950469);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      hashMap0.put("=7b]ufFT", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 0, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[3][3];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[5];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = 200.0;
      doubleArray3[2] = 0.0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray4 = new double[2][6][1];
      doubleArray4[0] = doubleArray0;
      doubleArray4[1] = doubleArray0;
      threeDimensionalMap0.put(".$$.", "-PCNCHUNK", ".$$.", doubleArray4);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('c');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("->");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      splittingGrammarExtractor0.recalculateBetas(false);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      splittingGrammarExtractor0.mergeStates();
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      System.setCurrentTimeMillis(200000);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) treeGraphNode1, Double.NEGATIVE_INFINITY, (Collection<Tree>) null, (-1156.33090197));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNonEmptyMapAndRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory('?');
      Label label0 = taggedWordFactory0.newLabel("<anW.\"<!BJtU", 7);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<SplittingGrammarExtractor, SplittingGrammarExtractor> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      MapFactory.weakHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      Comparator<Object> comparator1 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<Object, Object> mapFactory1 = MapFactory.treeMapFactory(comparator1);
      Map<String, double[]> map0 = mapFactory1.setMap(identityHashMap0);
      mapFactory1.setMap(map0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      mapFactory0.setMap(hashMap0, 1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[9][0];
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = (double) '?';
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = (double) 1;
      doubleArray1[3] = (double) 100;
      doubleArray1[4] = (-2704.58);
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[8];
      doubleArray2[0] = (-2704.58);
      doubleArray2[1] = (double) '?';
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = (double) 1;
      doubleArray2[4] = (double) '?';
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = 0.0;
      doubleArray2[7] = (double) 100;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[2];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = (double) 1;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[6];
      doubleArray4[0] = (double) 7;
      doubleArray4[1] = 12.0;
      doubleArray4[2] = 0.0;
      doubleArray4[3] = (double) 1;
      doubleArray4[4] = 322.2252070672023;
      doubleArray4[5] = (double) 1;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[5];
      doubleArray5[0] = (double) 7;
      doubleArray5[1] = (double) 100;
      doubleArray5[2] = 322.2252070672023;
      doubleArray5[3] = (double) 100;
      doubleArray5[4] = (double) 7;
      doubleArray0[4] = doubleArray5;
      double[] doubleArray6 = new double[1];
      doubleArray6[0] = (-2704.58);
      doubleArray0[5] = doubleArray6;
      double[] doubleArray7 = new double[6];
      doubleArray7[0] = 322.2252070672023;
      doubleArray7[1] = 0.0;
      doubleArray7[2] = 322.2252070672023;
      doubleArray7[3] = (double) 100;
      doubleArray7[4] = (double) 100;
      doubleArray7[5] = (double) 7;
      doubleArray0[6] = doubleArray7;
      double[] doubleArray8 = new double[5];
      doubleArray8[0] = 0.0;
      doubleArray8[1] = (double) 100;
      doubleArray8[2] = (double) 100;
      doubleArray8[3] = (double) '?';
      doubleArray8[4] = 12.0;
      doubleArray0[7] = doubleArray8;
      double[] doubleArray9 = new double[6];
      doubleArray9[0] = (double) 7;
      doubleArray9[1] = (-2704.58);
      doubleArray9[2] = 322.2252070672023;
      doubleArray9[3] = (-1410.37858950469);
      doubleArray9[4] = 322.2252070672023;
      doubleArray9[5] = (double) 100;
      doubleArray0[8] = doubleArray9;
      identityHashMap2.put(treeGraphNode0, doubleArray0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(taggedWordFactory0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Tree tree0 = chineseTreebankParserParams0.transformTree(treeGraphNode0, treeGraphNode0);
      List<Tree> list0 = treeGraphNode0.dominationPath(tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      double[] doubleArray10 = new double[1];
      doubleArray10[0] = (double) '?';
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray10, 3, identityHashMap2, (IdentityHashMap<Tree, double[][][]>) null, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString("itV=#kx\u00078pV@Q");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      splittingGrammarExtractor0.mergeStates();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1, (double) 100, (Collection<Tree>) treeGraphNode0, (-1517.88850016));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('c');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("->");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      splittingGrammarExtractor0.recalculateBetas(false);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap1);
      Tree tree0 = treeGraphNode1.deepCopy();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, false, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap1);
      assertSame(threeDimensionalMap1, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldAllThrowIOExceptions();
      byte[] byteArray0 = new byte[3];
      byteArray0[0] = (byte)105;
      byteArray0[1] = (byte)105;
      byteArray0[2] = (byte) (-74);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[4][8][4];
      threeDimensionalMap0.put((String) null, "Iteration ", "Iteration ", doubleArray0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = 0.001;
      doubleArray1[2] = (double) (byte)105;
      doubleArray1[3] = (double) (byte)105;
      doubleArray1[4] = (-165.13);
      doubleArray1[5] = 0.0;
      identityHashMap0.put((String) null, doubleArray1);
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) null, (Tree) null, (IdentityHashMap<Tree, double[]>) null, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndBuildMergeCorrespondenceAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      twoDimensionalMap0.get("Iteration ", "Iteration ");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      splittingGrammarExtractor0.splitBetas();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.get("", "");
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNullAndZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>(100);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      BobChrisTreeNormalizer.EmptyFilter bobChrisTreeNormalizer_EmptyFilter0 = new BobChrisTreeNormalizer.EmptyFilter();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap1);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(taggedWord0);
      treeGraphNode0.headWordNode();
      splittingGrammarExtractor0.saveTrees(treeGraphNode1, 100, (Collection<Tree>) null, 0.0);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.recurseOutside(treeGraphNode0, identityHashMap4, identityHashMap4);
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningNegative()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      hebrewTreebankParserParams0.headFinder();
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      Label label0 = taggedWordFactory0.newLabel("", (-1717986916));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(treeGraphNode0, (double[][][]) null);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<SplittingGrammarExtractor, SplittingGrammarExtractor> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      MapFactory<Object, Object> mapFactory1 = MapFactory.weakHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      Comparator<Object> comparator1 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<Object, Object> mapFactory2 = MapFactory.treeMapFactory(comparator1);
      Map<String, double[]> map0 = mapFactory1.setMap(identityHashMap1);
      mapFactory2.setMap(identityHashMap1);
      mapFactory0.setMap(identityHashMap1, (-1717986916));
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = (-1410.37858950469);
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (-12.116476694);
      doubleArray0[3] = (-988.308048387);
      doubleArray0[4] = (double) 100;
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, (-1008), identityHashMap2, identityHashMap0, map0, twoDimensionalMap0, threeDimensionalMap1);
      assertEquals((-1008), int0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldAllThrowIOExceptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>(100);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      BobChrisTreeNormalizer.EmptyFilter bobChrisTreeNormalizer_EmptyFilter0 = new BobChrisTreeNormalizer.EmptyFilter();
      BobChrisTreeNormalizer.EmptyFilter bobChrisTreeNormalizer_EmptyFilter1 = new BobChrisTreeNormalizer.EmptyFilter();
      bobChrisTreeNormalizer_EmptyFilter1.negate();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.saveTrees(treeGraphNode0, 0.0, labeledScoredTreeNode0, 100);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, identityHashMap3, identityHashMap3);
      assertFalse(identityHashMap3.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldAllThrowIOExceptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.arrayMapFactory();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      MapFactory.hashMapFactory();
      mapFactory0.setMap(identityHashMap2);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.state("abstr", 100);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel((String) null);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      MemoryTreebank memoryTreebank0 = negraPennTreebankParserParams0.memoryTreebank();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(label0, (List<Tree>) memoryTreebank0);
      splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap0, identityHashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountOutside(tree0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsAndRecountOutsideTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(taggedWord0);
      treeGraphNode0.deepCopy();
      splittingGrammarExtractor1.saveTrees(labeledScoredTreeNode0, 0.9999000099990001, labeledScoredTreeNode0, (-863.99161203476));
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode1, (IdentityHashMap<Tree, double[]>) null, (IdentityHashMap<Tree, double[]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsWithNullAndEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      splittingGrammarExtractor0.op = options0;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) null, 100, identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>(100);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      IdentityHashMap<SimpleTree, double[][]> identityHashMap2 = new IdentityHashMap<SimpleTree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>(identityHashMap0);
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[3][5][0];
      double[][] doubleArray1 = new double[0][1];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[8];
      doubleArray2[0] = 1704.1467;
      doubleArray2[1] = (-86.50532032941678);
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      LabeledScoredTreeNode labeledScoredTreeNode1 = new LabeledScoredTreeNode(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      LabelFactory labelFactory0 = CategoryWordTag.factory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      treeGraphNodeFactory0.newTreeNode((String) null, (List<Tree>) linkedList0);
      Vector<TreeTransformer> vector0 = new Vector<TreeTransformer>();
      CompositeTreeTransformer compositeTreeTransformer0 = new CompositeTreeTransformer(vector0);
      compositeTreeTransformer0.transformTree(labeledScoredTreeNode1);
      IdentityHashMap<Tree, double[][]> identityHashMap5 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap6 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap7 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap8 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode0, identityHashMap8, identityHashMap7, identityHashMap3, identityHashMap1, doubleArray2, hashMap0);
      splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, 100, identityHashMap5, identityHashMap4);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideAndRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldAllThrowIOExceptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.arrayMapFactory();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      MapFactory.hashMapFactory();
      mapFactory0.setMap(identityHashMap2);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.state("abstr", 100);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory('n');
      Label label0 = wordTagFactory0.newLabel((String) null);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      MemoryTreebank memoryTreebank0 = negraPennTreebankParserParams0.memoryTreebank();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(label0, (List<Tree>) memoryTreebank0);
      splittingGrammarExtractor1.recurseOutside(tree0, identityHashMap0, identityHashMap0);
      assertEquals(Double.NaN, tree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recurseOutside(simpleTree0, identityHashMap0, identityHashMap0);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('\'');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      splittingGrammarExtractor0.recalculateBetas(false);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      treeGraphNode0.addChild((Tree) treeGraphNode1);
      options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(1);
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 1;
      doubleArray0[1] = (double) 0;
      doubleArray0[2] = 3416.242974697;
      doubleArray0[3] = (double) 3;
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode0, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, doubleArray0, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor0.getStateSplitCount("LEXICON");
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.mergeStates();
      CompositeTreeTransformer compositeTreeTransformer0 = new CompositeTreeTransformer();
      LabelFactory labelFactory0 = CategoryWordTag.factory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("LEXICON", (List<Tree>) linkedList0);
      Tree tree1 = compositeTreeTransformer0.transformTree(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (-467.6865);
      doubleArray0[2] = (double) 0;
      doubleArray0[3] = 654.1;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = (double) 100;
      doubleArray0[6] = 0.0;
      doubleArray0[7] = (double) 100;
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.mergeTransitions(tree1, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, hashMap0);
      assertEquals(0, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNullAndEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeTransitions(simpleTree0, identityHashMap2, identityHashMap0, identityHashMap2, identityHashMap0, (double[]) null, identityHashMap1);
      assertTrue(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndTestConvergence2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      FileSystemHandling.shouldAllThrowIOExceptions();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap1.get("", "AMX&9Broa4_F?(");
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap3 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap3);
      splittingGrammarExtractor0.outputBetas();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsNullPointerException()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      hebrewTreebankParserParams0.headFinder();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      twoDimensionalMap0.get(";~<5", "Converged for cycle ");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[4][6][3];
      doubleArray0[0] = null;
      doubleArray0[1] = null;
      doubleArray0[2] = null;
      doubleArray0[3] = null;
      threeDimensionalMap0.put(":)#F2&V/z)sZR'", "[\u5E74\u6708\u65E5\u53F7]", "Trees should have been binarized, expected 1 or 2 children", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStateAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      MapFactory<Object, Object> mapFactory0 = MapFactory.arrayMapFactory();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      MapFactory.hashMapFactory();
      mapFactory0.setMap(identityHashMap2);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.state(".$$.", (-197));
      splittingGrammarExtractor2.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertNotSame(splittingGrammarExtractor2, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndState()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      HashSet<Tree> hashSet0 = new HashSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) hashSet0);
      String string0 = splittingGrammarExtractor0.state(".$$.", (-1));
      assertEquals(".$$.", string0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithZeroAndExtractTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.countOriginalStates();
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Tree tree0 = simpleTreeFactory0.newLeaf("@Tae6%T,6c$|#");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (double) 100, (Collection<Tree>) tree0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>(100);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      MapFactory<Object, CoreLabel> mapFactory0 = MapFactory.identityHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      mapFactory0.setMap(hashMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor1.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      Annotation annotation0 = new Annotation((String) null);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken((String) null, "**/zXH:'>W3QZQ/;a8", 100, 100);
      CoreLabel coreLabel1 = new CoreLabel((CoreMap) coreLabel0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(labeledScoredTreeNode0);
      treeGraphNode0.deepCopy();
      splittingGrammarExtractor1.saveTrees(treeGraphNode1, 0.0, treeGraphNode0, 2832.28);
      assertEquals(Double.NaN, treeGraphNode0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q", "itV=#kx\u00078pV@Q");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.addChild((Tree) treeGraphNode0);
      TestOptions testOptions0 = options0.newTestOptions();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(100);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[1][0];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 200000;
      doubleArray0[0] = doubleArray1;
      identityHashMap2.putIfAbsent(treeGraphNode1, doubleArray0);
      splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0[0], testOptions0.printFactoredKGood, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNonEmptyMapAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>(100);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      IdentityHashMap<SimpleTree, double[][]> identityHashMap2 = new IdentityHashMap<SimpleTree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>(identityHashMap0);
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[3][5][0];
      double[][] doubleArray1 = new double[0][1];
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray2 = new double[7][2];
      double[] doubleArray3 = new double[8];
      doubleArray3[0] = 1704.1467;
      doubleArray3[1] = (-86.50532032941678);
      doubleArray3[2] = (double) 100;
      doubleArray3[3] = 0.0;
      doubleArray3[4] = 0.0;
      doubleArray3[5] = 0.0;
      doubleArray3[6] = 0.0;
      doubleArray3[7] = 0.0;
      doubleArray2[0] = doubleArray3;
      double[] doubleArray4 = new double[5];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 1704.1467;
      doubleArray4[2] = 0.0;
      doubleArray4[3] = 252.3052187;
      doubleArray4[4] = (double) 100;
      doubleArray2[1] = doubleArray4;
      double[] doubleArray5 = new double[7];
      doubleArray5[0] = (-86.50532032941678);
      doubleArray5[1] = 1704.1467;
      doubleArray5[2] = 1704.1467;
      doubleArray5[3] = 1.0;
      doubleArray5[4] = 252.3052187;
      doubleArray5[5] = 1704.1467;
      doubleArray5[6] = (double) 100;
      doubleArray2[2] = doubleArray5;
      double[] doubleArray6 = new double[1];
      doubleArray6[0] = 0.0;
      doubleArray2[3] = doubleArray6;
      double[] doubleArray7 = new double[4];
      doubleArray7[0] = 1.0;
      doubleArray7[1] = (-86.50532032941678);
      doubleArray7[2] = 252.3052187;
      doubleArray7[3] = 0.0;
      doubleArray2[4] = doubleArray7;
      double[] doubleArray8 = new double[8];
      doubleArray8[0] = 252.3052187;
      doubleArray8[1] = (-243.4);
      doubleArray8[2] = (-86.50532032941678);
      doubleArray8[3] = 0.0;
      doubleArray8[4] = (-1090.3803086362);
      doubleArray8[5] = 252.3052187;
      doubleArray8[6] = (-86.50532032941678);
      doubleArray8[7] = 1.0;
      doubleArray2[5] = doubleArray8;
      double[] doubleArray9 = new double[5];
      doubleArray9[0] = (-86.50532032941678);
      doubleArray9[1] = 1.0E-4;
      doubleArray9[2] = 0.0;
      doubleArray9[3] = (-86.50532032941678);
      doubleArray9[4] = (-243.4);
      doubleArray2[6] = doubleArray9;
      doubleArray0[1] = doubleArray2;
      double[][] doubleArray10 = new double[0][7];
      doubleArray0[2] = doubleArray10;
      identityHashMap1.put(labeledScoredTreeNode0, doubleArray0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<SplittingGrammarExtractor, SplittingGrammarExtractor> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      MapFactory<Object, Object> mapFactory1 = MapFactory.weakHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap5 = new IdentityHashMap<String, double[]>();
      Comparator<Object> comparator1 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<Object, Object> mapFactory2 = MapFactory.treeMapFactory(comparator1);
      Map<String, double[]> map0 = mapFactory2.setMap(identityHashMap5);
      Map<String, double[]> map1 = mapFactory1.setMap(map0);
      mapFactory0.setMap(map1, (-1008));
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap6 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray11 = new double[2];
      doubleArray11[0] = (double) 463;
      doubleArray11[1] = (double) 100;
      int int0 = splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, doubleArray11, 100, identityHashMap0, identityHashMap1, map0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("complement", "complement", "complement");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      TreeGraphNode treeGraphNode3 = treeGraphNode0.highestNodeWithSameHead();
      splittingGrammarExtractor0.mergeStates();
      options0.newTestOptions();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      LabelFactory labelFactory0 = CategoryWordTag.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      treeGraphNode3.dominationPath(treeGraphNode1);
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabelFromString(",1KKV4lP)WOh");
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(label0, list0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (-2890.37393798);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 559038737, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap1);
      assertFalse(identityHashMap1.isEmpty());
      assertEquals(1, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      int int0 = splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, (double[]) null, 100, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsNullPointerExceptionAndSplitBetas()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      hebrewTreebankParserParams0.headFinder();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      twoDimensionalMap0.get(";~<5", "Converged for cycle ");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      splittingGrammarExtractor0.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.remove("V", "V");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testSplitBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[25][6];
      twoDimensionalMap0.put("chat", "chat", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeThrowsNullPointerException()  throws Throwable  {
      LinkedHashSet<Tree> linkedHashSet0 = new LinkedHashSet<Tree>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTree()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = splittingGrammarExtractor1.binaryBetas;
      threeDimensionalMap2.size();
      threeDimensionalMap2.get("WTY!g/UZ?9", "xLZ']");
      FileSystemHandling.shouldAllThrowIOExceptions();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newLeaf("2k,[Ed9K#");
      Tree tree1 = englishTreebankParserParams0.transformTree(tree0, (Tree) null);
      splittingGrammarExtractor1.getStateSplitCount(tree1);
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)2;
      byteArray0[1] = (byte) (-123);
      byteArray0[2] = (byte)2;
      byteArray0[3] = (byte)2;
      byteArray0[4] = (byte)37;
      byteArray0[5] = (byte) (-123);
      Word word0 = Word.EMPTY;
      SimpleTree simpleTree0 = new SimpleTree(word0);
      simpleTree0.treeFactory();
      splittingGrammarExtractor1.state("WTY!g/UZ?9", 387);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap1.get("", "WTY!g/UZ?9");
      byte[] byteArray0 = new byte[8];
      byteArray0[0] = (byte)4;
      byteArray0[1] = (byte)2;
      byteArray0[2] = (byte)2;
      byteArray0[3] = (byte) (-123);
      LinkedHashSet<Tree> linkedHashSet0 = new LinkedHashSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) linkedHashSet0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside((Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.put((String) null, (String) null, (String) null, (double[][][]) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsAndSplitBetas()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      threeDimensionalMap0.get((String) null, (String) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSaveTrees()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      MapFactory.hashMapFactory();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      MapFactory<Object, CoreLabel> mapFactory0 = MapFactory.identityHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map0, twoDimensionalMap1, threeDimensionalMap0);
      Annotation annotation0 = new Annotation((String) null);
      CoreLabel coreLabel0 = new CoreLabel(annotation0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Tree tree0 = treeGraphNode0.deepCopy();
      splittingGrammarExtractor0.saveTrees(tree0, 0.45, tree0, (-50.0));
      assertNotSame(tree0, treeGraphNode0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndOutputBetasAndTestConvergence1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      FileSystemHandling.shouldAllThrowIOExceptions();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap1.get("", "WTY!g/UZ?9");
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap3 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, threeDimensionalMap3);
      splittingGrammarExtractor0.outputBetas();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testOutputBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      threeDimensionalMap0.get("+ID", "A-+?!%dF");
      splittingGrammarExtractor0.outputBetas();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      MapFactory<String, CoreLabel> mapFactory0 = MapFactory.arrayMapFactory();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      hashMap0.put("-transformMatrixType", (int[]) null);
      Map<String, int[]> map0 = mapFactory0.setMap(hashMap0);
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4ArgumentsWithPositiveAndExtractTaking4ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldAllThrowIOExceptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 685.82675055638;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      options0.newTestOptions();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) arrayList0, 379.6835568708, (Collection<Tree>) arrayList0, (double) 100);
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode((Label) null, arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsAndStateWithPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString(".$$.");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      treeGraphNode1.skipRoot();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap2, (Map<String, double[]>) identityHashMap2, identityHashMap1, identityHashMap1);
      String string0 = splittingGrammarExtractor0.state(".$$.", 100);
      assertEquals(".$$.", string0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsAndStateWithNegative()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldAllThrowIOExceptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "Aa:k=$k>;");
      BobChrisTreeNormalizer.EmptyFilter bobChrisTreeNormalizer_EmptyFilter0 = new BobChrisTreeNormalizer.EmptyFilter();
      Predicate<Tree> predicate0 = bobChrisTreeNormalizer_EmptyFilter0.negate();
      treeGraphNode0.spliceOut(predicate0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.identityHashMapFactory();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      mapFactory0.setMap(hashMap0);
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      MapFactory<Object, Object> mapFactory1 = MapFactory.hashMapFactory();
      mapFactory1.setMap(identityHashMap3);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("<anW.\"<!BJtU", (-1160));
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      Options options2 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options2);
      splittingGrammarExtractor2.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap4, identityHashMap4);
      assertEquals(0, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap0, identityHashMap0);
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      MapFactory.arrayMapFactory();
      byte[] byteArray0 = new byte[0];
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      splittingGrammarExtractor0.recalculateBetas(false);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      LinkedHashSet<Tree> linkedHashSet0 = new LinkedHashSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) linkedHashSet0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recurseOutside((Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringAndGetStateSplitCountTakingStringAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = 469;
      splittingGrammarExtractor0.state("", 469);
      String[] stringArray0 = new String[7];
      stringArray0[0] = "^469";
      stringArray0[1] = "";
      stringArray0[2] = "";
      stringArray0[3] = "";
      stringArray0[4] = "^469";
      stringArray0[5] = "^469";
      stringArray0[6] = "";
      options0.setOptions(stringArray0, 469, 469);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.getStateSplitCount("");
      SpanishTreebankParserParams spanishTreebankParserParams0 = null;
      try {
        spanishTreebankParserParams0 = new SpanishTreebankParserParams();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.trees.tregex.TregexParser
         //
         verifyException("edu.stanford.nlp.trees.tregex.TregexPatternCompiler", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      int int0 = splittingGrammarExtractor0.getStateSplitCount("%:is{X_QCc}");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNull()  throws Throwable  {
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>(60);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "z");
      BobChrisTreeNormalizer.EmptyFilter bobChrisTreeNormalizer_EmptyFilter0 = new BobChrisTreeNormalizer.EmptyFilter();
      Predicate<Tree> predicate0 = bobChrisTreeNormalizer_EmptyFilter0.negate();
      treeGraphNode0.spliceOut(predicate0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.identityHashMapFactory();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap4 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap4);
      IdentityHashMap<String, double[]> identityHashMap5 = new IdentityHashMap<String, double[]>();
      MapFactory.hashMapFactory();
      mapFactory0.setMap(map0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("z", 603);
      IdentityHashMap<Tree, double[]> identityHashMap6 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) null, map0, (Map<String, double[]>) identityHashMap5, identityHashMap6, identityHashMap6);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsWithTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('c');
      Label label0 = wordLemmaTagFactory0.newLabelFromString("complement");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "complement");
      treeGraphNode0.getLeaves();
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      Tree tree0 = treeGraphNode1.localTree();
      splittingGrammarExtractor0.mergeStates();
      options0.newTestOptions();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap2);
      System.setCurrentTimeMillis((-67L));
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, true, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      System.setCurrentTimeMillis(5173L);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>(60);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "z");
      BobChrisTreeNormalizer.EmptyFilter bobChrisTreeNormalizer_EmptyFilter0 = new BobChrisTreeNormalizer.EmptyFilter();
      Object object0 = new Object();
      Predicate.isEqual(object0);
      Predicate<Tree> predicate0 = bobChrisTreeNormalizer_EmptyFilter0.negate();
      treeGraphNode0.spliceOut(predicate0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.arrayMapFactory();
      IdentityHashMap<String, double[]> identityHashMap5 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap5);
      mapFactory0.setMap(identityHashMap5);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("z", 60);
      splittingGrammarExtractor0.recountWeights(labeledScoredTreeNode0, identityHashMap4, identityHashMap4, identityHashMap0, identityHashMap1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) null, false, map0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      hebrewTreebankParserParams0.headFinder();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>(60);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "z");
      BobChrisTreeNormalizer.EmptyFilter bobChrisTreeNormalizer_EmptyFilter0 = new BobChrisTreeNormalizer.EmptyFilter();
      Predicate<Tree> predicate0 = bobChrisTreeNormalizer_EmptyFilter0.negate();
      treeGraphNode0.spliceOut(predicate0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, identityHashMap2, identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) treeGraphNode0, true, identityHashMap2, identityHashMap3);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, identityHashMap1, identityHashMap0);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsAndExtractTakingCollectionThrowsRuntimeException()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      hebrewTreebankParserParams0.headFinder();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>(60);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.arrayMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap3);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("!ieVOgcUj1H&", "'>+?9 C#.k(UVx,8?:");
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor1.recalculateTemporaryBetas(true, map0, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor1.recalculateBetas(true);
      Options options2 = new Options(options1.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options2);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.extract((Collection<Tree>) labeledScoredTreeNode0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndRecountWeightsAndState()  throws Throwable  {
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>(60);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "z");
      BobChrisTreeNormalizer.EmptyFilter bobChrisTreeNormalizer_EmptyFilter0 = new BobChrisTreeNormalizer.EmptyFilter();
      Predicate<Tree> predicate0 = bobChrisTreeNormalizer_EmptyFilter0.negate();
      treeGraphNode0.spliceOut(predicate0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      MapFactory<Object, Object> mapFactory0 = MapFactory.arrayMapFactory();
      IdentityHashMap<String, double[]> identityHashMap5 = new IdentityHashMap<String, double[]>();
      mapFactory0.setMap(identityHashMap5);
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap5);
      mapFactory0.setMap(map0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = splittingGrammarExtractor0.state("z", 60);
      assertEquals("z^60", string0);
      
      splittingGrammarExtractor0.recountWeights(labeledScoredTreeNode0, identityHashMap4, identityHashMap4, identityHashMap0, identityHashMap1);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Tree tree0 = simpleTreeFactory0.newLeaf("(;tX-%Ob2");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testTestConvergenceReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      double[][][] doubleArray0 = new double[3][6][4];
      double[][] doubleArray1 = new double[1][6];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray3 = new double[8][4];
      doubleArray3[0] = doubleArray2;
      doubleArray3[1] = doubleArray2;
      doubleArray3[2] = doubleArray2;
      doubleArray3[3] = doubleArray2;
      doubleArray3[4] = doubleArray2;
      doubleArray3[5] = doubleArray2;
      doubleArray3[6] = doubleArray2;
      doubleArray3[7] = doubleArray2;
      doubleArray0[1] = doubleArray3;
      double[][] doubleArray4 = new double[1][3];
      doubleArray4[0] = doubleArray2;
      doubleArray0[2] = doubleArray4;
      threeDimensionalMap1.put((String) null, (String) null, (String) null, doubleArray0);
      threeDimensionalMap1.get("useNegHKDict3", "`UIN8X`^");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, threeDimensionalMap2);
      splittingGrammarExtractor1.outputBetas();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndSplitBetasAndTestConvergence1()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][8][8];
      threeDimensionalMap0.put("C'iS1X[U*k&.*P", "C'iS1X[U*k&.*P", "    ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[18][7][0];
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndBuildGrammarsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      TestOptions testOptions0 = new TestOptions();
      options0.testOptions = testOptions0;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithZeroAndExtractTaking4ArgumentsAndRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      HashIndex<Tree> hashIndex0 = new HashIndex<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) hashIndex0, 0.0, (Collection<Tree>) hashIndex0, (-896.786));
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(0, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndExtractTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashSet<Tree> hashSet0 = new HashSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) hashSet0);
      splittingGrammarExtractor0.extract((Collection<Tree>) hashSet0, (-387.3), (Collection<Tree>) hashSet0, (double) 100);
      assertTrue(hashSet0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndBuildStateIndex()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.buildGrammars();
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TreeLeafLabelTransformer treeLeafLabelTransformer0 = new TreeLeafLabelTransformer((Function<String, String>) null);
      String[] stringArray0 = new String[0];
      options0.setOptionsOrWarn(stringArray0, 877, (-490));
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      options0.newTestOptions();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) arrayList0, (-1803.0174397), (Collection<Tree>) arrayList0, (-1201.92225007297));
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode((Label) null, arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasAndRecalculateMergedBetas()  throws Throwable  {
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "WCQ;[M^n");
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "WCQ;[M^n");
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer(treebankLanguagePack0);
      WordFactory wordFactory0 = new WordFactory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(wordFactory0);
      String[] stringArray0 = new String[9];
      stringArray0[2] = "";
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      MapFactory<String, CoreLabel> mapFactory0 = MapFactory.hashMapFactory();
      Map<String, int[]> map1 = mapFactory0.setMap(map0);
      splittingGrammarExtractor0.recalculateMergedBetas(map1);
      assertNotSame(map1, map0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<SimpleTree, double[][]> identityHashMap0 = new IdentityHashMap<SimpleTree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      MemoryTreebank memoryTreebank0 = negraPennTreebankParserParams0.memoryTreebank();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode(".$$.", (List<Tree>) memoryTreebank0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountInside(tree0, true, 525, identityHashMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      String string0 = splittingGrammarExtractor0.state("I:$D2~3P", 100);
      assertEquals("I:$D2~3P^100", string0);
  }

  @Test(timeout = 4000)
  public void testStateAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      Stack<String> stack0 = new Stack<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) stack0;
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabelFromString("Oj3?zZ6~7=Z9)3>cu");
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "Oj3?zZ6~7=Z9)3>cu");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0, (List<Tree>) null);
      stack0.add("Oj3?zZ6~7=Z9)3>cu");
      treeGraphNode0.getLeaves();
      String string0 = splittingGrammarExtractor0.state("Oj3?zZ6~7=Z9)3>cu", 100);
      assertEquals("Oj3?zZ6~7=Z9)3>cu", string0);
      
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testStateThrowsNullPointerException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.state((String) null, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldAllThrowIOExceptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[3][7];
      double[] doubleArray1 = new double[4];
      doubleArray1[0] = 685.82675055638;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 0.0;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[5];
      doubleArray2[0] = 685.82675055638;
      doubleArray2[1] = 685.82675055638;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = 685.82675055638;
      doubleArray2[4] = 0.0;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[9];
      doubleArray3[0] = 685.82675055638;
      doubleArray3[1] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "M\"J{\"JTrQAl>-W1l");
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("");
      labeledScoredTreeFactory0.newTreeNode((Label) tree0, (List<Tree>) null);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree(tree0, true, identityHashMap2, identityHashMap2, identityHashMap0, identityHashMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas1()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldAllThrowIOExceptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[4][8][4];
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[18][6][0];
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String[] stringArray0 = new String[4];
      stringArray0[0] = "@sn <, (/^(sn|grup.nom)/ $+ (@conj < /^(cc|grup.cc)/ $+ /^(sn|grup.nom)/=last))<` =last";
      stringArray0[3] = "qxV?P";
      options0.setOptionsOrWarn(stringArray0, 83, (-1050));
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor2.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedHashSet<Tree> linkedHashSet0 = new LinkedHashSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) linkedHashSet0);
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      options0.doPCFG = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<Object, Object> mapFactory0 = MapFactory.hashMapFactory();
      MapFactory<SplittingGrammarExtractor, SplittingGrammarExtractor> mapFactory1 = MapFactory.arrayMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory1.setMap(hashMap0, 100);
      Map<String, double[]> map1 = mapFactory1.setMap(map0, 954);
      Map<String, double[]> map2 = mapFactory0.setMap(map1);
      Map<String, double[]> map3 = mapFactory0.setMap(map2);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map3, twoDimensionalMap0, threeDimensionalMap0);
      assertNotSame(map2, map3);
      
      splittingGrammarExtractor0.recalculateBetas(true);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndOutputBetasAndTestConvergence2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
      
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testOutputBetas3()  throws Throwable  {
      Options options0 = new Options();
      options0.newTrainOptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      hebrewTreebankParserParams0.headFinder();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>(60);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TaggedWord taggedWord0 = new TaggedWord();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "z");
      BobChrisTreeNormalizer.EmptyFilter bobChrisTreeNormalizer_EmptyFilter0 = new BobChrisTreeNormalizer.EmptyFilter();
      Predicate<Tree> predicate0 = bobChrisTreeNormalizer_EmptyFilter0.negate();
      treeGraphNode0.spliceOut(predicate0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) null, true, identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      StringLabel stringLabel0 = new StringLabel();
      SimpleTree simpleTree0 = new SimpleTree(stringLabel0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(100);
      assertEquals(100, doubleArray0.length);
      
      TreeLeafLabelTransformer treeLeafLabelTransformer0 = new TreeLeafLabelTransformer((Function<String, String>) null);
      threeDimensionalMap0.thirdKeySet();
      String[] stringArray0 = new String[0];
      splittingGrammarExtractor0.countOriginalStates();
      options0.setOptionsOrWarn(stringArray0, 877, (-490));
      LabeledScoredConstituentFactory labeledScoredConstituentFactory0 = new LabeledScoredConstituentFactory();
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndCountOriginalStates()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 0;
      doubleArray0[3] = 5.0;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = (double) 3;
      doubleArray0[6] = 1041.6310514;
      IdentityHashMap<SimpleTree, double[][]> identityHashMap0 = new IdentityHashMap<SimpleTree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>(identityHashMap0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      Comparator<SplittingGrammarExtractor> comparator0 = (Comparator<SplittingGrammarExtractor>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<SplittingGrammarExtractor, SplittingGrammarExtractor> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      MapFactory<Object, Object> mapFactory1 = MapFactory.weakHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory1.setMap(identityHashMap3);
      Map<String, double[]> map1 = mapFactory1.setMap(map0);
      Map<String, double[]> map2 = mapFactory0.setMap(map1, 308);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) null, doubleArray0, 308, identityHashMap1, identityHashMap2, map2, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      TestOptions testOptions0 = options0.testOptions;
      options0.testOptions = testOptions0;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStatesAndBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer(treebankLanguagePack0);
      WordFactory wordFactory0 = new WordFactory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(wordFactory0);
      String[] stringArray0 = new String[9];
      stringArray0[0] = "";
      stringArray0[1] = "";
      stringArray0[2] = "";
      stringArray0[3] = "nCR&VCGK3ZX0`K}.%";
      stringArray0[4] = "!:,$_";
      stringArray0[5] = "kkSU*]FGEEU+T!";
      stringArray0[6] = "5hYY<.T=3 =Nj";
      stringArray0[7] = "gAWYu#k(9V%Z(g";
      stringArray0[8] = "Unclosed paren in encoded map: ";
      CoreLabel coreLabel0 = null;
      try {
        coreLabel0 = new CoreLabel(stringArray0, stringArray0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Unknown key 
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStates()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testRecountInsideWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside((Tree) null, true, 4220, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testBuildStateIndex()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      boolean boolean0 = false;
      options0.forceCNF = false;
      MapFactory.identityHashMapFactory();
      options0.rerankerKBest = 61;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence((List<Triple<String, Integer, Double>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRescaleTemporaryBetas1()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[3][3];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (-751.48815004569);
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[5];
      doubleArray3[0] = (-751.48815004569);
      doubleArray3[1] = 200.0;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = 0.0;
      doubleArray3[4] = 0.0;
      doubleArray0[2] = doubleArray3;
      twoDimensionalMap0.put("-PCNCHUNK", "-PCNCHUNK", doubleArray0);
      twoDimensionalMap0.get("~}e7L[", "~}e7L[");
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRescaleTemporaryBetas2()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldAllThrowIOExceptions();
      byte[] byteArray0 = new byte[3];
      byteArray0[0] = (byte)105;
      byteArray0[1] = (byte)1;
      byteArray0[2] = (byte) (-74);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[4][8][4];
      threeDimensionalMap0.put((String) null, "Iteration ", "Iteration ", doubleArray0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      assertEquals(0, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testNeginfDoubles()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(100);
      assertEquals(100, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesAndNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.neginfDoubles(100);
      TreeLeafLabelTransformer treeLeafLabelTransformer0 = new TreeLeafLabelTransformer((Function<String, String>) null);
      threeDimensionalMap0.thirdKeySet();
      Label label0 = null;
      String[] stringArray0 = new String[0];
      splittingGrammarExtractor0.countOriginalStates();
      int int0 = (-490);
      options0.setOptionsOrWarn(stringArray0, 877, (-490));
      // Undeclared exception!
      try { 
        options0.setOptions(stringArray0, (-490), 877);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -490 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.Options", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceWithEmptyList()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testSplitBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      hebrewTreebankParserParams0.headFinder();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      splittingGrammarExtractor0.splitBetas();
  }
}
