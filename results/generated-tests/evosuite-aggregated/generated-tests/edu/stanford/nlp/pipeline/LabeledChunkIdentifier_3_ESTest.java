/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Apr 21 16:30:18 GMT 2025
 */

package edu.stanford.nlp.pipeline;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.AbstractSequenceClassifier;
import edu.stanford.nlp.ie.NERClassifierCombiner;
import edu.stanford.nlp.ie.PresetSequenceClassifier;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.pipeline.LabeledChunkIdentifier;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.sequences.TrueCasingForNISTDocumentReaderAndWriter;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.util.ArrayCoreMap;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.Filters;
import edu.stanford.nlp.util.Pair;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.Stack;
import java.util.Vector;
import java.util.function.Function;
import java.util.function.Predicate;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.mock.java.util.MockRandom;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.EvoSuiteURL;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.testdata.NetworkHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class LabeledChunkIdentifier_3_ESTest extends LabeledChunkIdentifier_3_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testGetDefaultPosTagReturningEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultPosTag("");
      labeledChunkIdentifier0.getDefaultPosTag();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsAndGetAnnotatedChunksTaking5Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag(".");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("z");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(".");
      Predicate<Pair<CoreLabel, CoreLabel>> predicate1 = predicate0.negate();
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1591), class0, class0, predicate0);
      Class<Object> class1 = Object.class;
      Class<CoreLabel> class2 = CoreLabel.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1591), class1, class2);
      Class<CoreLabel> class3 = CoreLabel.class;
      Class<Object> class4 = Object.class;
      Class<CoreLabel> class5 = CoreLabel.class;
      List<CoreMap> list2 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1073741822), class3, class2, class4, class5, predicate1);
      assertTrue(list2.equals((Object)list1));
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5Arguments0()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag(".");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply(" dominatesI=");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 3127554, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals(0, list1.size());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "B");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("B", "O", "B");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetDefaultPosTagReturningNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      labeledChunkIdentifier0.setDefaultPosTag((String) null);
      labeledChunkIdentifier0.getDefaultPosTag();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5Arguments1()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("S");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("S");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<Object> class0 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 590, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5Arguments2()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("[");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("New chunkRstarted, prev chunk not ended yet!");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 1018, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals(7, list1.size());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6ArgumentsReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("TSo");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("New chunk started, prev chunk not ended yet!");
      Class<Object> class0 = Object.class;
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(class0);
      Class<Object> class1 = Object.class;
      Class<CoreLabel> class2 = CoreLabel.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-607), class1, class2, class2, class0, predicate0);
      labeledChunkIdentifier0.getTagType("O");
      Class<Object> class3 = Object.class;
      List<CoreMap> list2 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1845), class0, class3, class1, class0);
      assertFalse(list2.equals((Object)list1));
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("TSo");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("TSo");
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("6\"?E8gxK");
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0);
      labeledChunkIdentifier0.getDefaultPosTag();
      Class<Object> class0 = Object.class;
      Class<CoreLabel> class1 = CoreLabel.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-28578680), class0, class1, predicate0);
      assertEquals(1, list1.size());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("R", "R", "R");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("S", "S", "R");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("R", "R", "R");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("S", "S", "R");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("TSo");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("New chunk started, prev chunk not ended yet!");
      Class<Object> class0 = Object.class;
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(class0);
      Class<Object> class1 = Object.class;
      Class<CoreLabel> class2 = CoreLabel.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-607), class1, class2, class2, class0, predicate0);
      assertFalse(list1.isEmpty());
      
      labeledChunkIdentifier0.getTagType("%? =wKeW\"$S");
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      Class<Object> class3 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-607), class3, class1);
      AbstractSequenceClassifier<CoreLabel>[] abstractSequenceClassifierArray0 = (AbstractSequenceClassifier<CoreLabel>[]) Array.newInstance(AbstractSequenceClassifier.class, 0);
      NERClassifierCombiner nERClassifierCombiner0 = null;
      try {
        nERClassifierCombiner0 = new NERClassifierCombiner(false, false, abstractSequenceClassifierArray0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
      }
  }

  @Test(timeout = 4000)
  public void testGetTagTypeThrowsIllegalStateExceptionAndGetAnnotatedChunksTaking7Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("TSo");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("+d");
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<Object> class1 = Object.class;
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(class0);
      labeledChunkIdentifier0.setNegLabel("+d");
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 44, class0, class0, class1, class0, predicate0);
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("-OifnM1)6hU0#pL`~");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetNegLabelReturningEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("");
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      labeledChunkIdentifier0.setNegLabel("");
      labeledChunkIdentifier0.setDefaultNegTag("=iIV;h2WD? csy");
      labeledChunkIdentifier0.getNegLabel();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsAndGetAnnotatedChunksTaking5ArgumentsWithNegative()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("New chunk started, prev chunk not ended yet!");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("New chunk started, prev chunk not ended yet!");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1841455493), (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals(7, list1.size());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5Arguments3()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("B");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("B");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 531, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals(1, list1.size());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagReturningNull()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, (String) null);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultPosTag((String) null);
      labeledChunkIdentifier0.setDefaultNegTag((String) null);
      labeledChunkIdentifier0.setNegLabel((String) null);
      labeledChunkIdentifier0.getNegLabel();
      int int0 = (-86747544);
      labeledChunkIdentifier0.setDefaultPosTag((String) null);
      Random.setNextRandom((-86747544));
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier0.getNegLabel();
      labeledChunkIdentifier0.getTagType((String) null);
      List<CoreLabel> list0 = null;
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<Object> class1 = Object.class;
      Class<Object> class2 = Object.class;
      // Undeclared exception!
      try { 
        Predicate.not(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Objects", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "U", "U");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments2()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "U", "U");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunk()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("]", "]", "]");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments3()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType(".", ".", ".");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments4()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("]", "]", "]");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments2()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType(".", ".", ".");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5Arguments4()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("I");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("I");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 619, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals(1, list1.size());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6ArgumentsAndGetDefaultPosTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      Function.identity();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("K QyB");
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1), class0, class0, class0, class0);
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Class<Object> class2 = Object.class;
      Vector<Predicate<Pair<CoreLabel, CoreLabel>>> vector0 = new Vector<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(vector0);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1), (Class) class1, (Class) class2, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      Random.setNextRandom((-1));
      Vector<Predicate<Object>> vector1 = new Vector<Predicate<Object>>();
      Filters.ConjFilter<Object> filters_ConjFilter0 = new Filters.ConjFilter<Object>(vector1);
      Predicate.not(filters_ConjFilter0);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1), class1, class1);
      Class<Object> class3 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1), (Class) class1, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      Class<Object> class4 = Object.class;
      Class<Object> class5 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1), class4, class5);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1), (Class) class3, (Class) class3, (Class) class0, (Class) class2, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      labeledChunkIdentifier0.getTagType("K QyB");
      labeledChunkIdentifier0.getDefaultPosTag();
      Random.setNextRandom((-1));
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments5()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("__ < (@CC $.. @CC)", "E", "__ < (@CC $.. @CC)");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments6()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("L", "L", "L");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments3()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("L", "L", "L");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkThrowsNullPointerExceptionAndGetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getDefaultNegTag();
      assertEquals("O", string0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      labeledChunkIdentifier0.getNegLabel();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = null;
      // Undeclared exception!
      try { 
        LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, (LabeledChunkIdentifier.LabelTagType) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsWithNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      ArrayList<CoreLabel> arrayList0 = new ArrayList<CoreLabel>();
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<Object> class1 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList0, (-1373), (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      CoreLabel coreLabel0 = new CoreLabel();
      CoreLabel coreLabel1 = new CoreLabel(coreLabel0);
      arrayList0.add(coreLabel1);
      FileSystemHandling.shouldAllThrowIOExceptions();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("Q?TK A9S31X]*:>w");
      String string0 = labeledChunkIdentifier_LabelTagType0.toString();
      assertEquals("(Q?TK A9S31X]*:>w,I,Q?TK A9S31X]*:>w)", string0);
      
      labeledChunkIdentifier0.getTagType("rQS*(q/L&~sgV`C");
      Class<CoreLabel> class2 = CoreLabel.class;
      Class<Object> class3 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList0, 3070, (Class) class2, (Class) class3);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      labeledChunkIdentifier0.getTagType("I");
      Class<Object> class4 = Object.class;
      Class<Object> class5 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList0, 3070, (Class) class3, (Class) class1, (Class) class4, (Class) class5, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      assertTrue(arrayList0.contains(coreLabel0));
      
      labeledChunkIdentifier0.getDefaultPosTag();
      Class<CoreLabel> class6 = CoreLabel.class;
      Class<Object> class7 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList0, (-1329), (Class) class6, (Class) class7, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      labeledChunkIdentifier0.getTagType("2J");
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("TSo");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("New chunk started, prev chunk not ended yet!");
      Class<Object> class0 = Object.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<CoreLabel> class1 = CoreLabel.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-607), (Class) class0, (Class) class0, (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals(7, list1.size());
      
      Class<Object> class2 = Object.class;
      Class<CoreLabel> class3 = CoreLabel.class;
      Class<Object> class4 = Object.class;
      Class<ArrayCoreMap> class5 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1423), (Class) class2, (Class) class3, (Class) class4, (Class) class5, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunk0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "B");
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("B");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments7()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("R", "[", "R");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments4()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("[", "[", "[");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetAnnotatedChunksTaking5Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("New chunkRstarted, prev chunk not ended yet!");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 990, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals(0, list1.size());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndGetAnnotatedChunksTaking5Arguments()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType(";I^i$1}\r58CH", "B", "4_[>@&zj");
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setNegLabel("cpq,Y%C.");
      WordTag wordTag0 = new WordTag("4_[>@&zj");
      Vector<Tree> vector0 = new Vector<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0, vector0);
      List<CoreLabel> list0 = treeGraphNode0.taggedLabeledYield();
      Predicate<Pair<CoreLabel, CoreLabel>>[] predicateArray0 = (Predicate<Pair<CoreLabel, CoreLabel>>[]) Array.newInstance(Predicate.class, 4);
      LinkedList<Predicate<Pair<CoreLabel, CoreLabel>>> linkedList0 = new LinkedList<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(linkedList0);
      predicateArray0[0] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>((-2421.12011879));
      predicateArray0[1] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0;
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
      
      labeledChunkIdentifier0.setNegLabel("-TTTS-CS");
      List<CoreLabel> list1 = treeGraphNode0.yield(list0);
      Class<Object> class0 = Object.class;
      List<CoreMap> list2 = labeledChunkIdentifier0.getAnnotatedChunks(list1, 0, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      assertTrue(list2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkThrowsNullPointerException()  throws Throwable  {
      // Undeclared exception!
      try { 
        LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, (LabeledChunkIdentifier.LabelTagType) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsWithPositive()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel coreLabel0 = new CoreLabel(245);
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 245, class0, class0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments5()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("O", "O", "O");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetTagTypeThrowsIllegalStateExceptionAndGetTagType()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier0.getNegLabel();
      labeledChunkIdentifier0.setDefaultPosTag("O");
      labeledChunkIdentifier0.setDefaultPosTag("oSqvO0;");
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      labeledChunkIdentifier0.getTagType("B");
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("[12][0-9]{3}[-/](?:0?[1-9]|1[0-2])[-/][0-3][0-9]");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetTagTypeThrowsIllegalStateExceptionAndSetIgnoreProvidedTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      assertTrue(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("^([^-]*)-(.*)$");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetNegLabelReturningNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      labeledChunkIdentifier0.setNegLabel((String) null);
      labeledChunkIdentifier0.getNegLabel();
      String string0 = labeledChunkIdentifier0.getDefaultPosTag();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", string0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments8()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "B");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndToString()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "B");
      String string0 = labeledChunkIdentifier_LabelTagType0.toString();
      assertEquals("(B,B,B)", string0);
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("B", "(B,B,B)", "B");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndIsEndOfChunk()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getNegLabel();
      assertEquals("O", string0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("O");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType(";I^i$1}\r58CH");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
      
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier1.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments6()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "B");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments7()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("E", "E", "E");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagReturningEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("");
      labeledChunkIdentifier0.getDefaultNegTag();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType((String) null);
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunk1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("L", "L", "L");
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getTagType("E");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("ygE@1^)y${'4WqaE");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType2 = labeledChunkIdentifier0.getTagType("I");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType2, labeledChunkIdentifier_LabelTagType1);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertTrue(boolean0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType3 = new LabeledChunkIdentifier.LabelTagType("E", "E", "E");
      boolean boolean1 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType3, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkReturningTrue()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier0.getNegLabel();
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier1.getDefaultPosTag());
      
      labeledChunkIdentifier1.setDefaultPosTag("");
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("O");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier1.getTagType("");
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      LabeledChunkIdentifier.isEndOfChunk((LabeledChunkIdentifier.LabelTagType) null, labeledChunkIdentifier_LabelTagType0);
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier1.setNegLabel(".4X:-on]Y|x-:");
      assertEquals("O", labeledChunkIdentifier1.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments9()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("-DISTSIM_TTS1", "-DISTSIM_TTS1", "^aQG7");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("-DISTSIM_TTS1", "^aQG7", "-DISTSIM_TTS1");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkWithNull()  throws Throwable  {
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk((LabeledChunkIdentifier.LabelTagType) null, (LabeledChunkIdentifier.LabelTagType) null);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkReturningFalse()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getDefaultPosTag();
      assertEquals("I", string0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("I");
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier0.setNegLabel("^ewk5YvTt/");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("I");
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, (String) null);
      labeledChunkIdentifier_LabelTagType1.tag = "";
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier_LabelTagType0.toString();
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      Class<Object> class2 = Object.class;
      labeledChunkIdentifier_LabelTagType1.type = "h17BW:z";
      labeledChunkIdentifier0.getDefaultPosTag();
      labeledChunkIdentifier_LabelTagType0.type = "^ewk5YvTt/";
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier_LabelTagType1.tag = "^ewk5YvTt/";
      labeledChunkIdentifier_LabelTagType1.label = null;
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) null, (-1872), (Class) class0, (Class) class1, (Class) class2, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsReturningListWhereIsEmptyIsTrue()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>();
      Class<Object> class0 = Object.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      Class<Object> class2 = Object.class;
      Class<CoreLabel> class3 = CoreLabel.class;
      LinkedList<Predicate<Pair<CoreLabel, CoreLabel>>> linkedList1 = new LinkedList<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(linkedList1);
      Annotation annotation0 = new Annotation("[");
      ArrayCoreMap arrayCoreMap0 = new ArrayCoreMap((ArrayCoreMap) annotation0);
      ArrayCoreMap arrayCoreMap1 = new ArrayCoreMap((CoreMap) arrayCoreMap0);
      CoreLabel coreLabel0 = new CoreLabel(arrayCoreMap1);
      Pair<CoreLabel, CoreLabel> pair0 = Pair.makePair(coreLabel0, coreLabel0);
      Pair.internedStringPair("[", "multiThreadPerceptron");
      filters_DisjFilter0.test(pair0);
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 0, (Class) class0, (Class) class1, (Class) class2, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      assertTrue(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsAndGetAnnotatedChunksTaking7ArgumentsWithPositive()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("TSo");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("+Jd");
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<Object> class1 = Object.class;
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(class0);
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 44, class0, class0, class1, class0, predicate0);
      assertEquals(1, list1.size());
      
      Class<CoreLabel> class2 = CoreLabel.class;
      List<CoreMap> list2 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-40366234), class0, class2);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertTrue(list2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetDefaultPosTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getNegLabel();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("jawdrop");
      labeledChunkIdentifier_LabelTagType0.tag = "O";
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier0.getTagType("YV$i>fnvz4O}:<");
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier0.setDefaultPosTag("I");
      Vector<CoreLabel> vector0 = new Vector<CoreLabel>();
      Class<Object> class0 = Object.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>((-3309.665969));
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) vector0, 887, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      labeledChunkIdentifier0.setDefaultNegTag("");
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      labeledChunkIdentifier0.getDefaultPosTag();
      labeledChunkIdentifier0.getTagType("");
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Class<Object> class2 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) vector0, 887, (Class) class1, (Class) class2, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      Class<ArrayCoreMap> class3 = ArrayCoreMap.class;
      Class<ArrayCoreMap> class4 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) vector0, 887, (Class) class3, (Class) class0, (Class) class4, (Class) class4);
      labeledChunkIdentifier0.getTagType("");
      Class<ArrayCoreMap> class5 = ArrayCoreMap.class;
      Predicate<Pair<CoreLabel, CoreLabel>>[] predicateArray0 = (Predicate<Pair<CoreLabel, CoreLabel>>[]) Array.newInstance(Predicate.class, 6);
      predicateArray0[0] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0;
      predicateArray0[1] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0;
      predicateArray0[2] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0;
      predicateArray0[3] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0;
      predicateArray0[4] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0;
      predicateArray0[5] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0;
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(predicateArray0);
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) vector0, 887, (Class) class5, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      assertTrue(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetTagTypeWithNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType((String) null);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType(",@,SSwL><-5RafN4a", ",@,SSwL><-5RafN4a", "O");
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      labeledChunkIdentifier0.setNegLabel("QvK&^L-;DF&");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType2 = labeledChunkIdentifier0.getTagType("wyKZ9xq?\u00079O'0=|");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType2);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndGetTagType()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("L", "L", "L");
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("L");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNull()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("R", "R", "R");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsIgnoreProvidedTagReturningTrue()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "oSqvO0;", "&<hq oL?^Q)0qy-|");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("B", "", "outside of a track");
      labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType1);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier_LabelTagType0.toString();
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType2 = labeledChunkIdentifier0.getTagType("J=Zvz&cNtV02{A,Y(");
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      labeledChunkIdentifier0.setNegLabel("outside of a track");
      labeledChunkIdentifier0.setDefaultNegTag("Y/hm@|B[&]vq ");
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType3 = new LabeledChunkIdentifier.LabelTagType("/,j/_Ly>[", "{<w?G", "");
      boolean boolean0 = labeledChunkIdentifier_LabelTagType2.typeMatches(labeledChunkIdentifier_LabelTagType3);
      assertTrue(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testTypeMatches()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("L", "L", "L");
      boolean boolean0 = labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments8()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("fNlX.Ty7rp-'_(9wP", "fNlX.Ty7rp-'_(9wP", "fNlX.Ty7rp-'_(9wP");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsIgnoreProvidedTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      boolean boolean0 = labeledChunkIdentifier0.isIgnoreProvidedTag();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(boolean0);
      
      labeledChunkIdentifier0.setDefaultPosTag("cod");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("cod");
      labeledChunkIdentifier_LabelTagType0.toString();
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = new CoreLabel();
      CoreLabel coreLabel1 = coreLabelTokenFactory0.makeToken(coreLabel0);
      coreLabel1.setIsNewline(false);
      LinkedList<CoreMap> linkedList0 = new LinkedList<CoreMap>();
      Annotation annotation0 = new Annotation(linkedList0);
      presetSequenceClassifier0.classifyWithGlobalInformation(stack0, coreLabel1, annotation0);
      int int0 = 0;
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      annotation0.copy();
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Object object0 = new Object();
      Object object1 = new Object();
      Class<Object>[] classArray0 = (Class<Object>[]) Array.newInstance(Class.class, 0);
      CoreLabel coreLabel2 = null;
      try {
        coreLabel2 = new CoreLabel(classArray0, (String[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments10()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("O", "O", "O");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier0.getNegLabel();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      labeledChunkIdentifier0.setDefaultPosTag("O");
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("O");
      labeledChunkIdentifier_LabelTagType0.tag = "O";
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier0.setNegLabel("?d<xSw[");
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetTagType()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getTagType("O");
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndSetDefaultPosTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      labeledChunkIdentifier0.setDefaultPosTag("r:78so>\"_C");
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testCreatesLabelTagTypeTaking3ArgumentsAndToString()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("R", "R", "R");
      String string0 = labeledChunkIdentifier_LabelTagType0.toString();
      assertEquals("(R,R,R)", string0);
  }

  @Test(timeout = 4000)
  public void testGetTagTypeThrowsIllegalStateException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("^([^-]*)-(.*)$");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsAndSetDefaultPosTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      int int0 = 0;
      labeledChunkIdentifier0.setDefaultPosTag("SYqfznYgizAhW*g*F-");
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      stack0.removeAllElements();
      Class<Object> class1 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, 0, (Class) class0, (Class) class1);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("}9_(-:TDhXrwz", "New chunk started, prev chunk not ended yet!", "New chunk started, prev chunk not ended yet!");
      labeledChunkIdentifier_LabelTagType0.toString();
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("}9_(-:TDhXrwz");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndSetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      labeledChunkIdentifier0.setNegLabel("Y");
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsWithEmptyList()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      Vector<CoreLabel> vector0 = new Vector<CoreLabel>();
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) vector0, (-2098678281), (Class) class0, (Class) class0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6ArgumentsAndSetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      labeledChunkIdentifier0.setNegLabel("8 oAZ");
      ArrayList<CoreLabel> arrayList0 = new ArrayList<CoreLabel>();
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<Object> class1 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList0, 0, (Class) class0, (Class) class0, (Class) class1, (Class) class0);
      labeledChunkIdentifier0.getTagType("");
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments11()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("I", "I", "I");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagAndSetDefaultNegTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("Fu,5sX");
      labeledChunkIdentifier0.getDefaultNegTag();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("New chunk started, prev chunk not ended yet!");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndSetDefaultNegTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("YG1+`>30mC;");
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments12()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("", "", "");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsWithEmptyList()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>();
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>((-1685003551));
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, (-1685003551), (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      boolean boolean0 = false;
      labeledChunkIdentifier0.setIgnoreProvidedTag(false);
      List<CoreLabel> list0 = null;
      int int0 = 0;
      Class<Object> class0 = Object.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      ArrayList<Predicate<Pair<CoreLabel, CoreLabel>>> arrayList0 = new ArrayList<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(arrayList0);
      MockRandom mockRandom0 = new MockRandom(0L);
      Filters.RandomFilter<Object> filters_RandomFilter0 = new Filters.RandomFilter<Object>(0.0, mockRandom0);
      filters_DisjFilter0.or(filters_RandomFilter0);
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) null, 0, (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesLabelTagTypeTaking3Arguments()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("WlSZ", "WlSZ", "WlSZ");
  }

  @Test(timeout = 4000)
  public void testGetTagType()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getTagType("{3x)`0+");
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetAnnotatedChunksTaking7ArgumentsThrowsNullPointerException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      Class<Object> class0 = Object.class;
      Class<CoreLabel> class1 = CoreLabel.class;
      Predicate<Pair<CoreLabel, CoreLabel>>[] predicateArray0 = (Predicate<Pair<CoreLabel, CoreLabel>>[]) Array.newInstance(Predicate.class, 0);
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(predicateArray0);
      CoreLabel coreLabel0 = new CoreLabel(1580);
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(coreLabel0);
      filters_DisjFilter0.addFilter(predicate0);
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) null, 0, (Class) class0, (Class) class0, (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }
}
