/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 19:39:11 GMT 2025
 */

package opennlp.tools.chunker;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.function.BiFunction;
import opennlp.tools.chunker.ChunkSample;
import opennlp.tools.chunker.ChunkerFactory;
import opennlp.tools.chunker.ChunkerME;
import opennlp.tools.chunker.ChunkerModel;
import opennlp.tools.dictionary.Dictionary;
import opennlp.tools.ml.maxent.GISModel;
import opennlp.tools.ml.model.Context;
import opennlp.tools.ml.model.UniformPrior;
import opennlp.tools.ml.naivebayes.NaiveBayesModel;
import opennlp.tools.ml.perceptron.PerceptronModel;
import opennlp.tools.sentdetect.SentenceDetectorFactory;
import opennlp.tools.util.CollectionObjectStream;
import opennlp.tools.util.ObjectStream;
import opennlp.tools.util.Sequence;
import opennlp.tools.util.Span;
import opennlp.tools.util.TrainingParameters;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class ChunkerME_4_ESTest extends ChunkerME_4_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testTopKSequencesTaking2ArgumentsReturningEmptyArray()  throws Throwable  {
      Context[] contextArray0 = new Context[9];
      int[] intArray0 = new int[0];
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 3026.4541360538;
      doubleArray0[1] = (-1744.3);
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 460.41179931971;
      Context context0 = new Context(intArray0, doubleArray0);
      contextArray0[0] = context0;
      Context context1 = new Context(intArray0, doubleArray0);
      contextArray0[1] = context1;
      Context context2 = new Context(intArray0, doubleArray0);
      contextArray0[2] = context2;
      Context context3 = new Context(intArray0, doubleArray0);
      contextArray0[3] = context3;
      Context context4 = new Context(intArray0, doubleArray0);
      contextArray0[4] = context4;
      Context context5 = new Context(intArray0, doubleArray0);
      contextArray0[5] = context5;
      Context context6 = new Context(intArray0, doubleArray0);
      contextArray0[6] = context6;
      Context context7 = new Context(intArray0, doubleArray0);
      contextArray0[7] = context7;
      Context context8 = new Context(intArray0, doubleArray0);
      contextArray0[8] = context8;
      String[] stringArray0 = new String[7];
      stringArray0[0] = "yH:U";
      stringArray0[1] = "</W";
      stringArray0[2] = "yH:U";
      stringArray0[3] = "yH:U";
      stringArray0[4] = "yH:U";
      stringArray0[5] = "yH:U";
      stringArray0[6] = "yH:U";
      NaiveBayesModel naiveBayesModel0 = new NaiveBayesModel(contextArray0, stringArray0, stringArray0);
      Dictionary dictionary0 = new Dictionary(false);
      char[] charArray0 = new char[6];
      charArray0[0] = 'l';
      charArray0[1] = '|';
      charArray0[2] = 'r';
      charArray0[3] = 'q';
      charArray0[4] = 'n';
      charArray0[5] = 'w';
      SentenceDetectorFactory sentenceDetectorFactory0 = new SentenceDetectorFactory("0.0000", false, dictionary0, charArray0);
      Map<String, String> map0 = sentenceDetectorFactory0.createManifestEntries();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("yH:U", naiveBayesModel0, map0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      Sequence[] sequenceArray0 = chunkerME0.topKSequences(stringArray0, stringArray0);
      assertEquals(0, sequenceArray0.length);
  }

  @Test(timeout = 4000)
  public void testTopKSequencesTaking3ArgumentsReturningEmptyArray()  throws Throwable  {
      int[] intArray0 = new int[2];
      intArray0[0] = 1242;
      intArray0[1] = 1;
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 1;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 0;
      doubleArray0[3] = (double) 1242;
      doubleArray0[4] = (double) 1;
      doubleArray0[5] = (double) 1;
      Context context0 = new Context(intArray0, doubleArray0);
      Context[] contextArray0 = new Context[5];
      contextArray0[0] = context0;
      contextArray0[1] = context0;
      contextArray0[2] = context0;
      contextArray0[3] = context0;
      contextArray0[4] = context0;
      String[] stringArray0 = new String[2];
      stringArray0[0] = "XMIq6sG/";
      stringArray0[1] = "XMIq6sG/";
      PerceptronModel perceptronModel0 = new PerceptronModel(contextArray0, stringArray0, stringArray0);
      perceptronModel0.getAllOutcomes(doubleArray0);
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("XMIq6sG/", perceptronModel0, hashMap0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      Span[] spanArray0 = chunkerME0.chunkAsSpans(stringArray0, stringArray0);
      assertEquals(2, spanArray0.length);
      
      chunkerME0.topKSequences(stringArray0, stringArray0, (double) 1);
      Sequence[] sequenceArray0 = chunkerME0.topKSequences(stringArray0, stringArray0);
      assertEquals(4, sequenceArray0.length);
  }

  @Test(timeout = 4000)
  public void testChunkReturningNonEmptyArray()  throws Throwable  {
      TrainingParameters.defaultParams();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      Context[] contextArray0 = new Context[2];
      int[] intArray0 = new int[0];
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (-4478.7731);
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (-1.0);
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = 1803.646937895558;
      doubleArray0[6] = 100.0;
      Context context0 = new Context(intArray0, doubleArray0);
      contextArray0[0] = context0;
      Context context1 = new Context(intArray0, doubleArray0);
      contextArray0[1] = context1;
      String[] stringArray0 = new String[2];
      stringArray0[0] = "t1=eos";
      stringArray0[1] = "t1=eos";
      UniformPrior uniformPrior0 = new UniformPrior();
      GISModel gISModel0 = new GISModel(contextArray0, stringArray0, stringArray0, uniformPrior0);
      ChunkerModel chunkerModel0 = new ChunkerModel("t1=eos", gISModel0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      String[] stringArray1 = chunkerME0.chunk(stringArray0, stringArray0);
      Sequence[] sequenceArray0 = chunkerME0.topKSequences(stringArray1, stringArray1);
      assertEquals(4, sequenceArray0.length);
  }

  @Test(timeout = 4000)
  public void testChunkAsSpansThrowsIllegalArgumentException()  throws Throwable  {
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 4094.61438749764;
      doubleArray0[1] = (-1.0);
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (-679.6062911742);
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (-1.0);
      perceptronModel0.getAllOutcomes(doubleArray1);
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("rW", perceptronModel0, hashMap0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      chunkerME0.chunkAsSpans(stringArray0, stringArray0);
      Stack<ChunkSample> stack0 = new Stack<ChunkSample>();
      List.of(chunkerModel0, chunkerModel0, chunkerModel0, chunkerModel0);
      hashMap0.clear();
      System.setCurrentTimeMillis(0L);
      chunkerME0.probs();
      String[] stringArray1 = new String[3];
      stringArray1[0] = "4sS*:#Hb";
      stringArray1[1] = "4sS*:#Hb";
      stringArray1[2] = "{_#A,K'*jig]d']d[Z";
      // Undeclared exception!
      try { 
        chunkerME0.chunkAsSpans(stringArray0, stringArray1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // All arrays must have the same length: sentenceSize: 0, tagsSize: 3, predsSize: 0!
         //
         verifyException("opennlp.tools.chunker.ChunkSample", e);
      }
  }

  @Test(timeout = 4000)
  public void testTopKSequencesTaking2ArgumentsAndChunkAndProbsTakingDoubleArray()  throws Throwable  {
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 4094.61438749764;
      doubleArray0[1] = (-1.0);
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (-679.6062911742);
      doubleArray0[4] = 0.0;
      doubleArray0[5] = 4094.61438749764;
      doubleArray0[6] = 0.0;
      perceptronModel0.getAllOutcomes(doubleArray0);
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("{_#A,K'*jig]d']d[Z", perceptronModel0, hashMap0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      chunkerME0.chunkAsSpans(stringArray0, stringArray0);
      Stack<ChunkSample> stack0 = new Stack<ChunkSample>();
      List.of(chunkerModel0, chunkerModel0, chunkerModel0, chunkerModel0);
      CollectionObjectStream<ChunkSample> collectionObjectStream0 = new CollectionObjectStream<ChunkSample>(stack0);
      ChunkerME chunkerME1 = new ChunkerME(chunkerModel0);
      chunkerME1.chunk(stringArray0, stringArray0);
      double[] doubleArray1 = new double[8];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (-1.0);
      doubleArray1[2] = (-679.6062911742);
      doubleArray1[3] = 0.0;
      doubleArray1[4] = 0.0;
      doubleArray1[5] = (-632.5);
      doubleArray1[6] = (-679.6062911742);
      doubleArray1[7] = (-1.0);
      chunkerME0.probs(doubleArray1);
      Sequence[] sequenceArray0 = chunkerME0.topKSequences(stringArray0, stringArray0);
      assertEquals(1, sequenceArray0.length);
  }

  @Test(timeout = 4000)
  public void testProbsTakingNoArgumentsThrowsNullPointerException()  throws Throwable  {
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("", perceptronModel0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      // Undeclared exception!
      try { 
        chunkerME0.probs();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.chunker.ChunkerME", e);
      }
  }

  @Test(timeout = 4000)
  public void testProbsTakingNoArguments()  throws Throwable  {
      Context[] contextArray0 = new Context[5];
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 2514.1;
      doubleArray0[1] = 342.85055;
      doubleArray0[2] = (-3760.06323742033);
      doubleArray0[3] = 0.0;
      Context context0 = new Context((int[]) null, doubleArray0);
      contextArray0[0] = context0;
      Context context1 = new Context((int[]) null, doubleArray0);
      contextArray0[1] = context1;
      Context context2 = new Context((int[]) null, doubleArray0);
      contextArray0[2] = context2;
      Context context3 = new Context((int[]) null, doubleArray0);
      contextArray0[3] = context3;
      Context context4 = new Context((int[]) null, doubleArray0);
      contextArray0[4] = context4;
      String[] stringArray0 = new String[4];
      stringArray0[0] = "XMIq6sG/";
      stringArray0[1] = "XMIq6sG/";
      stringArray0[2] = "XMIq6sG/";
      stringArray0[3] = "XMIq6sG/";
      PerceptronModel perceptronModel0 = new PerceptronModel(contextArray0, stringArray0, stringArray0);
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      HashMap<String, String> hashMap1 = new HashMap<String, String>(hashMap0);
      BiFunction<Object, String, String> biFunction0 = (BiFunction<Object, String, String>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      hashMap1.merge("Missing the parser type property!", "My$", biFunction0);
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("XMIq6sG/", perceptronModel0, hashMap0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      chunkerME0.chunkAsSpans(stringArray0, stringArray0);
      double[] doubleArray1 = chunkerME0.probs();
      assertEquals(4, doubleArray1.length);
  }

  @Test(timeout = 4000)
  public void testChunkAsSpansAndProbsTakingDoubleArray()  throws Throwable  {
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      double[] doubleArray0 = new double[7];
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("{_#A,K'*jig]d']d[Z", perceptronModel0, hashMap0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      chunkerME0.chunkAsSpans(stringArray0, stringArray0);
      chunkerME0.probs(doubleArray0);
      assertArrayEquals(new double[] {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, doubleArray0, 0.01);
  }

  @Test(timeout = 4000)
  public void testProbsTakingDoubleArrayThrowsNullPointerException()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 4094.61438749764;
      doubleArray0[1] = (-1.0);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      perceptronModel0.getAllOutcomes(doubleArray0);
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("{_#A,K'*jig]d']d[Z", perceptronModel0, hashMap0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      ChunkerME chunkerME1 = new ChunkerME(chunkerModel0);
      chunkerME1.chunkAsSpans(stringArray0, stringArray0);
      String[] stringArray1 = new String[0];
      chunkerME1.topKSequences(stringArray1, stringArray1, 4094.61438749764);
      // Undeclared exception!
      try { 
        chunkerME0.probs(doubleArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs(double[])\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.chunker.ChunkerME", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateChunkerMETakingStringThrowsIOException()  throws Throwable  {
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 4094.61438749764;
      doubleArray0[1] = (-1.0);
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (-679.6062911742);
      doubleArray0[4] = 0.0;
      doubleArray0[5] = (-2790.8);
      doubleArray0[6] = 0.0;
      perceptronModel0.getAllOutcomes(doubleArray0);
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("{_#A,K'*jig]d']d[Z", perceptronModel0, hashMap0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      Span[] spanArray0 = chunkerME0.chunkAsSpans(stringArray0, stringArray0);
      assertEquals(0, spanArray0.length);
      
      Stack<ChunkSample> stack0 = new Stack<ChunkSample>();
      List.of(chunkerModel0, chunkerModel0, chunkerModel0, chunkerModel0);
      CollectionObjectStream<ChunkSample> collectionObjectStream0 = new CollectionObjectStream<ChunkSample>(stack0);
      ChunkerME chunkerME1 = new ChunkerME(chunkerModel0);
      ChunkerME chunkerME2 = null;
      try {
        chunkerME2 = new ChunkerME("The double array sent as a parameter to AbstractModel.getAllOutcomes() must not have been produced by this model.");
        fail("Expecting exception: IOException");
      
      } catch(Throwable e) {
         //
         // Invalid model.
         //
         verifyException("opennlp.tools.util.DownloadUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void testTopKSequencesTaking3ArgumentsReturningNonEmptyArray()  throws Throwable  {
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 4094.61438749764;
      doubleArray0[1] = (-1.0);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      perceptronModel0.getAllOutcomes(doubleArray0);
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("{_#A,K'*jig]d']d[Z", perceptronModel0, hashMap0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      ChunkerME chunkerME1 = new ChunkerME(chunkerModel0);
      chunkerME1.chunkAsSpans(stringArray0, stringArray0);
      String[] stringArray1 = new String[0];
      Sequence[] sequenceArray0 = chunkerME1.topKSequences(stringArray1, stringArray1, 4094.61438749764);
      assertEquals(1, sequenceArray0.length);
  }

  @Test(timeout = 4000)
  public void testChunkAndChunkAndChunkAsSpans()  throws Throwable  {
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 4094.61438749764;
      doubleArray0[1] = (-1.0);
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (-679.6062911742);
      doubleArray0[4] = 0.0;
      doubleArray0[5] = (-2790.8);
      doubleArray0[6] = 0.0;
      perceptronModel0.getAllOutcomes(doubleArray0);
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("{_#A,K'*jig]d']d[Z", perceptronModel0, hashMap0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      chunkerME0.chunkAsSpans(stringArray0, stringArray0);
      String[] stringArray1 = chunkerME0.chunk(stringArray0, stringArray0);
      assertEquals(0, stringArray1.length);
  }

  @Test(timeout = 4000)
  public void testTopKSequencesTaking3ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 4094.61438749764;
      doubleArray0[1] = (-1.0);
      doubleArray0[3] = 0.0;
      doubleArray0[3] = (-679.6062911742);
      doubleArray0[4] = 0.0;
      doubleArray0[5] = (-2790.8);
      doubleArray0[6] = 0.0;
      perceptronModel0.getAllOutcomes(doubleArray0);
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("{_#A,K'*jig]d']d[Z", perceptronModel0, hashMap0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      chunkerME0.chunkAsSpans(stringArray0, stringArray0);
      String[] stringArray1 = new String[5];
      stringArray1[0] = "The double array sent as a parameter to AbstractModel.getAllOutcomes() must not have been produced by this model.";
      stringArray1[1] = "The double array sent as a parameter to AbstractModel.getAllOutcomes() must not have been produced by this model.";
      stringArray1[2] = "{_#A,K'*jig]d']d[Z";
      stringArray1[3] = "The double array sent as a parameter to AbstractModel.getAllOutcomes() must not have been produced by this model.";
      stringArray1[4] = "The double array sent as a parameter to AbstractModel.getAllOutcomes() must not have been produced by this model.";
      String[] stringArray2 = new String[8];
      stringArray2[0] = "{_#A,K'*jig]d']d[Z";
      stringArray2[1] = "{_#A,K'*jig]d']d[Z";
      stringArray2[2] = "E?}z3iD1";
      stringArray2[3] = "The double array sent as a parameter to AbstractModel.getAllOutcomes() must not have been produced by this model.";
      stringArray2[4] = "The double array sent as a parameter to AbstractModel.getAllOutcomes() must not have been produced by this model.";
      stringArray2[5] = "{_#A,K'*jig]d']d[Z";
      stringArray2[6] = "{_#A,K'*jig]d']d[Z";
      stringArray2[7] = "{_#A,K'*jig]d']d[Z";
      // Undeclared exception!
      try { 
        chunkerME0.topKSequences(stringArray1, stringArray2, 3127.93041396);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("opennlp.tools.ml.BeamSearch", e);
      }
  }

  @Test(timeout = 4000)
  public void testTopKSequencesTaking3Arguments()  throws Throwable  {
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("", perceptronModel0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      Sequence[] sequenceArray0 = chunkerME0.topKSequences(stringArray0, stringArray0, 1.0E-4);
      assertEquals(1, sequenceArray0.length);
  }

  @Test(timeout = 4000)
  public void testTopKSequencesTaking2Arguments()  throws Throwable  {
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("", perceptronModel0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      Sequence[] sequenceArray0 = chunkerME0.topKSequences(stringArray0, stringArray0);
      assertEquals(1, sequenceArray0.length);
  }

  @Test(timeout = 4000)
  public void testTopKSequencesTaking2ArgumentsAndTopKSequencesTaking2Arguments()  throws Throwable  {
      Stack<ChunkSample> stack0 = new Stack<ChunkSample>();
      CollectionObjectStream<ChunkSample> collectionObjectStream0 = new CollectionObjectStream<ChunkSample>(stack0);
      Context[] contextArray0 = new Context[1];
      int[] intArray0 = new int[0];
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 81.66;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = (-2790.8);
      doubleArray0[6] = (-2790.8);
      doubleArray0[7] = (-2790.8);
      doubleArray0[8] = (-2790.8);
      Context context0 = new Context(intArray0, doubleArray0);
      contextArray0[0] = context0;
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel(contextArray0, stringArray0, stringArray0);
      perceptronModel0.getAllOutcomes(doubleArray0);
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("lX45k@HaW?R?#/@", perceptronModel0, hashMap0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      chunkerME0.chunkAsSpans(stringArray0, stringArray0);
      Sequence[] sequenceArray0 = chunkerME0.topKSequences(stringArray0, stringArray0);
      assertEquals(1, sequenceArray0.length);
  }

  @Test(timeout = 4000)
  public void testTrainThrowsIOException()  throws Throwable  {
      Stack<ChunkSample> stack0 = new Stack<ChunkSample>();
      CollectionObjectStream<ChunkSample> collectionObjectStream0 = new CollectionObjectStream<ChunkSample>(stack0);
      TrainingParameters trainingParameters0 = new TrainingParameters();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      try { 
        ChunkerME.train("XMIq6sG/", collectionObjectStream0, trainingParameters0, chunkerFactory0);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Insufficient training data to create model.
         //
         verifyException("opennlp.tools.ml.model.AbstractDataIndexer", e);
      }
  }

  @Test(timeout = 4000)
  public void testTrainThrowsNullPointerException()  throws Throwable  {
      TrainingParameters trainingParameters0 = TrainingParameters.defaultParams();
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      // Undeclared exception!
      try { 
        ChunkerME.train("BeamSize", (ObjectStream<ChunkSample>) null, trainingParameters0, chunkerFactory0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.ObjectStream.read()\" because \"this.samples\" is null
         //
         verifyException("opennlp.tools.util.AbstractEventStream", e);
      }
  }

  @Test(timeout = 4000)
  public void testChunkAsSpans()  throws Throwable  {
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("f", perceptronModel0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      Span[] spanArray0 = chunkerME0.chunkAsSpans(stringArray0, stringArray0);
      assertEquals(0, spanArray0.length);
  }

  @Test(timeout = 4000)
  public void testChunk()  throws Throwable  {
      String[] stringArray0 = new String[0];
      PerceptronModel perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
      ChunkerFactory chunkerFactory0 = new ChunkerFactory();
      ChunkerModel chunkerModel0 = new ChunkerModel("", perceptronModel0, chunkerFactory0);
      ChunkerME chunkerME0 = new ChunkerME(chunkerModel0);
      String[] stringArray1 = chunkerME0.chunk(stringArray0, stringArray0);
      assertFalse(stringArray1.equals((Object)stringArray0));
  }
}
