/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 20:40:37 GMT 2025
 */

package opennlp.tools.namefind;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.IOException;
import java.io.StringWriter;
import java.net.URI;
import java.nio.file.FileSystemNotFoundException;
import java.nio.file.Path;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Stack;
import java.util.regex.Pattern;
import opennlp.tools.dictionary.Dictionary;
import opennlp.tools.ml.maxent.GISModel;
import opennlp.tools.ml.model.Context;
import opennlp.tools.ml.model.UniformPrior;
import opennlp.tools.namefind.BioCodec;
import opennlp.tools.namefind.NameFinderME;
import opennlp.tools.namefind.NameSample;
import opennlp.tools.namefind.TokenNameFinderFactory;
import opennlp.tools.namefind.TokenNameFinderModel;
import opennlp.tools.postag.POSSample;
import opennlp.tools.postag.POSTaggerFactory;
import opennlp.tools.postag.POSTaggerME;
import opennlp.tools.tokenize.TokenizerFactory;
import opennlp.tools.util.CollectionObjectStream;
import opennlp.tools.util.ObjectStream;
import opennlp.tools.util.SequenceCodec;
import opennlp.tools.util.Span;
import opennlp.tools.util.TrainingParameters;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.net.MockURI;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class NameFinderME_2_ESTest extends NameFinderME_2_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testTrainWithNull()  throws Throwable  {
      TrainingParameters trainingParameters0 = new TrainingParameters();
      trainingParameters0.putIfAbsent("Algorithm", "Algorithm");
      // Undeclared exception!
      try { 
        NameFinderME.train("Algorithm", "Algorithm", (ObjectStream<NameSample>) null, trainingParameters0, (TokenNameFinderFactory) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Unexpected trainer type!
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractNameTypeThrowsIllegalStateExceptionAndExtractNameType()  throws Throwable  {
      NameFinderME.extractNameType("'gKU");
      // Undeclared exception!
      try { 
        NameFinderME.extractNameType("\u0000-0");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractNameTypeThrowsIllegalStateException()  throws Throwable  {
      // Undeclared exception!
      try { 
        NameFinderME.extractNameType("\u0000-0");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpans0()  throws Throwable  {
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(1544, 1544, 0.0);
      Span span1 = new Span(span0, 0.0);
      Span span2 = new Span(span1, 1544);
      spanArray0[0] = span2;
      Span span3 = new Span(span1, 0.0);
      spanArray0[1] = span3;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(2, spanArray1.length);
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpansReturningEmptyArray()  throws Throwable  {
      Span[] spanArray0 = new Span[0];
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(0, spanArray1.length);
      
      String string0 = "";
      Context[] contextArray0 = new Context[5];
      int[] intArray0 = new int[3];
      intArray0[0] = 1478;
      intArray0[1] = 6669;
      intArray0[2] = 0;
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 1478;
      doubleArray0[1] = (double) 0;
      doubleArray0[2] = (double) 1478;
      doubleArray0[3] = 0.1;
      Context context0 = new Context(intArray0, doubleArray0);
      contextArray0[0] = context0;
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = (-81.3);
      doubleArray1[1] = 1742.915779320374;
      doubleArray1[2] = (double) 6669;
      doubleArray1[3] = (double) 6669;
      doubleArray1[4] = (double) 1478;
      doubleArray1[5] = (double) 1478;
      Context context1 = new Context(intArray0, doubleArray1);
      contextArray0[1] = context1;
      Context context2 = new Context((int[]) null, doubleArray0);
      contextArray0[2] = context2;
      int[] intArray1 = new int[9];
      intArray1[0] = 1478;
      intArray1[1] = 0;
      intArray1[2] = 0;
      intArray1[3] = 6669;
      intArray1[4] = 0;
      intArray1[5] = 6669;
      intArray1[6] = 1478;
      intArray1[7] = 300;
      intArray1[8] = 0;
      Context context3 = new Context(intArray1, doubleArray0);
      contextArray0[3] = context3;
      Context context4 = new Context(intArray0, doubleArray1);
      contextArray0[4] = context4;
      String[] stringArray0 = new String[6];
      stringArray0[0] = "";
      stringArray0[1] = "";
      stringArray0[2] = "";
      stringArray0[3] = "Cutoff";
      stringArray0[4] = "";
      stringArray0[5] = "";
      UniformPrior uniformPrior0 = new UniformPrior();
      GISModel gISModel0 = null;
      try {
        gISModel0 = new GISModel(contextArray0, stringArray0, stringArray0, uniformPrior0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 5 out of bounds for length 5
         //
         verifyException("opennlp.tools.ml.model.AbstractModel", e);
      }
  }

  @Test(timeout = 4000)
  public void testTrainThrowsIOException()  throws Throwable  {
      LinkedHashSet<NameSample> linkedHashSet0 = new LinkedHashSet<NameSample>(639);
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedHashSet0);
      TrainingParameters trainingParameters0 = TrainingParameters.defaultParams();
      TrainingParameters trainingParameters1 = new TrainingParameters(trainingParameters0);
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      try { 
        NameFinderME.train("", "", collectionObjectStream0, trainingParameters1, tokenNameFinderFactory0);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Insufficient training data to create model.
         //
         verifyException("opennlp.tools.ml.model.AbstractDataIndexer", e);
      }
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpans1()  throws Throwable  {
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(537, 537, 537);
      spanArray0[0] = span0;
      spanArray0[1] = span0;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(1, spanArray1.length);
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpansAndDropOverlappingSpans0()  throws Throwable  {
      Span[] spanArray0 = new Span[4];
      Span span0 = new Span(2004, 2004, "Rjo", 0.0);
      spanArray0[0] = span0;
      Span span1 = new Span(span0, (double) 2004);
      spanArray0[1] = span1;
      Span span2 = new Span(2004, 2004, (-8.976636531812));
      spanArray0[2] = span2;
      Span span3 = new Span(span2, 387);
      spanArray0[3] = span3;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(2, spanArray1.length);
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpans2()  throws Throwable  {
      Span[] spanArray0 = new Span[1];
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(1, spanArray1.length);
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpansAndDropOverlappingSpans1()  throws Throwable  {
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(300, 300, 1163.9297745320382);
      StringWriter stringWriter0 = new StringWriter(300);
      StringWriter stringWriter1 = stringWriter0.append('d');
      stringWriter1.write("0(VcpY!ru#W=K,~MIm");
      StringBuffer stringBuffer0 = stringWriter1.getBuffer();
      span0.trim(stringBuffer0);
      spanArray0[0] = span0;
      Span span1 = new Span(300, 300, "");
      spanArray0[1] = span1;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(1, spanArray1.length);
  }

  @Test(timeout = 4000)
  public void testTrainThrowsIllegalStateException()  throws Throwable  {
      TrainingParameters.defaultParams();
      POSTaggerFactory pOSTaggerFactory0 = new POSTaggerFactory();
      Map<String, Object> map0 = pOSTaggerFactory0.createArtifactMap();
      TrainingParameters trainingParameters0 = new TrainingParameters(map0);
      byte[] byteArray0 = new byte[4];
      trainingParameters0.putIfAbsent("Algorithm", "FxD/H8o*fY;RdO:V-V~");
      trainingParameters0.putIfAbsent("E", "\u0000-0", 606);
      byteArray0[0] = (byte)67;
      byteArray0[1] = (byte)45;
      byteArray0[2] = (byte)1;
      byteArray0[3] = (byte)8;
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory(byteArray0, map0, (SequenceCodec<String>) null);
      // Undeclared exception!
      try { 
        NameFinderME.train("SN", "E", (ObjectStream<NameSample>) null, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Unexpected trainer type!
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testTrainThrowsRuntimeException()  throws Throwable  {
      Stack<NameSample> stack0 = new Stack<NameSample>();
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(stack0);
      ObjectStream<POSSample> objectStream0 = (ObjectStream<POSSample>) mock(ObjectStream.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(objectStream0).read();
      Dictionary dictionary0 = POSTaggerME.buildNGramDictionary(objectStream0, 0);
      Pattern pattern0 = Pattern.compile("start", 0);
      TokenizerFactory tokenizerFactory0 = new TokenizerFactory("", dictionary0, false, pattern0);
      Map<String, Object> map0 = tokenizerFactory0.createArtifactMap();
      TrainingParameters trainingParameters0 = new TrainingParameters(map0);
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte)48;
      byteArray0[1] = (byte) (-62);
      byteArray0[2] = (byte)0;
      byteArray0[3] = (byte)0;
      byteArray0[4] = (byte) (-1);
      byteArray0[5] = (byte)0;
      byteArray0[6] = (byte)0;
      byteArray0[7] = (byte)0;
      byteArray0[8] = (byte)94;
      BioCodec bioCodec0 = new BioCodec();
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory(byteArray0, map0, bioCodec0);
      // Undeclared exception!
      try { 
        NameFinderME.train("start", "start", collectionObjectStream0, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // org.evosuite.runtime.mock.java.lang.MockThrowable: Descriptor is not valid XML!
         //
         verifyException("opennlp.tools.namefind.TokenNameFinderFactory", e);
      }
  }

  @Test(timeout = 4000)
  public void testTrainThrowsNullPointerException()  throws Throwable  {
      TrainingParameters trainingParameters0 = TrainingParameters.defaultParams();
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      // Undeclared exception!
      try { 
        NameFinderME.train("(.+)-w+", "(.+)-w+", (ObjectStream<NameSample>) null, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.ObjectStream.read()\" because \"this.samples\" is null
         //
         verifyException("opennlp.tools.util.AbstractEventStream", e);
      }
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpansThrowsNullPointerException()  throws Throwable  {
      // Undeclared exception!
      try { 
        NameFinderME.dropOverlappingSpans((Span[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot read the array length because \"spans\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException()  throws Throwable  {
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME((TokenNameFinderModel) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderModel.getFactory()\" because \"model\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesNameFinderME()  throws Throwable  {
      String string0 = "K}ZtP";
      NameFinderME.extractNameType("K}ZtP");
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME((TokenNameFinderModel) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderModel.getFactory()\" because \"model\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractNameTypeAndExtractNameType()  throws Throwable  {
      NameFinderME.extractNameType("<END>");
      URI uRI0 = MockURI.aHttpURI;
      // Undeclared exception!
      try { 
        Path.of(uRI0);
        fail("Expecting exception: FileSystemNotFoundException");
      
      } catch(FileSystemNotFoundException e) {
         //
         // Provider \"http\" not installed
         //
         verifyException("java.nio.file.Path", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractNameType()  throws Throwable  {
      String string0 = NameFinderME.extractNameType("other");
      assertNull(string0);
  }
}
