/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jun 29 15:11:05 GMT 2025
 */

package opennlp.tools.parser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collection;
import java.util.EmptyStackException;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Stack;
import opennlp.tools.parser.Constituent;
import opennlp.tools.parser.GapLabeler;
import opennlp.tools.parser.HeadRules;
import opennlp.tools.parser.Parse;
import opennlp.tools.parser.lang.es.AncoraSpanishHeadRules;
import opennlp.tools.util.Span;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class Parse_4_ESTest extends Parse_4_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testCloneTakingParseWithParseWhereCompleteIsTrueAndParseWhereGetChildCountIsPositive()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("x[I5svI1S\"z,X&lK", span0, "x[I5svI1S\"z,X&lK", 0.0, 1);
      parse0.toStringPennTreebank();
      Parse parse1 = Parse.parseParse("(x[I5svI1S\"z,X&lK -LSB-)");
      parse0.getLabel();
      // Undeclared exception!
      try { 
        parse0.clone(parse1);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: -1, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTaking2Arguments0()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("x[I5svI1S\"z,X&lK", span0, "x[I5svI1S\"z,X&lK", 2, 1);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(x[I5svI1S\"z,X&lK -LSB-)", string0);
      
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("(x[I5svI1S\"z,X&lK -LSB-)", (GapLabeler) headRules0);
      assertEquals(1, parse1.getChildCount());
  }

  @Test(timeout = 4000)
  public void testParseParseTaking2Arguments1()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("W)D!~#=E$S3a_|1Fz", span0, "x[I5svI1S\"z,X&lK", 0.0, 1);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(x[I5svI1S\"z,X&lK -RRB-)", string0);
      
      Reader reader0 = Reader.nullReader();
      assertNotNull(reader0);
      
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Reader reader1 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules1 = new opennlp.tools.parser.lang.en.HeadRules(reader1);
      Parse parse1 = Parse.parseParse("(x[I5svI1S\"z,X&lK -RRB-)", (GapLabeler) headRules1);
      assertEquals(") ", parse1.getText());
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndCreatesParseTaking5ArgumentsAndToStringPennTreebank0()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("W)D!~#=E$S3a_|1Fz", span0, "x[I5svI1S\"z,X&lK", 0.0, 1);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(x[I5svI1S\"z,X&lK -RRB-)", string0);
      
      Parse parse1 = Parse.parseParse("(x[I5svI1S\"z,X&lK -RRB-)");
      assertEquals(") ", parse1.toString());
      assertEquals(1, parse1.getChildCount());
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndCreatesParseTaking5ArgumentsAndToStringPennTreebank1()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("}{<4", span0, "L'MRN-", 2, 2);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(L'MRN- -LCB-)", string0);
      
      Parse parse1 = Parse.parseParse("(L'MRN- -LCB-)");
      assertEquals(1.0, parse1.getProb(), 0.01);
      assertEquals(1, parse1.getChildCount());
      assertEquals("{ ", parse1.getCoveredText());
  }

  @Test(timeout = 4000)
  public void testIsChunkTakingNoArgumentsReturningTrue()  throws Throwable  {
      Parse parse0 = Parse.parseParse("@^h=-]:-([HH |n@=I)");
      Span span0 = new Span(2, 2);
      Parse parse1 = new Parse("@^h=-]:-([HH |n@=I)", span0, "@^h=-]:-([HH |n@=I)", 2, 2);
      parse0.insert(parse1);
      parse1.isChunk(true);
      Span[] spanArray0 = new Span[2];
      spanArray0[0] = span0;
      parse1.getTagSequenceProb();
      boolean boolean0 = parse1.isChunk();
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetCommonParentReturningParseWhereGetHeadIndexIsNegative()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("Y*(>(eXanwc;nT~", span0, "Y*(>(eXanwc;nT~", 1, 2);
      parse0.toStringPennTreebank();
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(Y*(>(eXanwc;nT~ *)", string0);
      
      Parse parse1 = new Parse("Y*(>(eXanwc;nT~", span0, "(Y*(>(eXanwc;nT~ *)", 0.0, (-1106683006));
      Parse parse2 = parse0.getCommonParent(parse1);
      assertEquals((-1106683006), parse2.getHeadIndex());
      assertNotNull(parse2);
      assertEquals(0.0, parse2.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringThrowsEmptyStackExceptionAndCreatesParseTaking5Arguments0()  throws Throwable  {
      Span span0 = new Span(1, 1, "\"nSBK[:+p([H #,FN=.)");
      Parse parse0 = new Parse("\"nSBK[:+p([H #,FN=.)", span0, "\"nSBK[:+p([H #,FN=.)", 1, 1);
      Parse parse1 = new Parse("-LSB-", span0, "-LRB-eXanwc;n.TDB *)", 1.0, parse0);
      parse1.toStringPennTreebank();
      // Undeclared exception!
      try { 
        Parse.parseParse("(-LRB-eXanwc;n.TDB *) )");
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesParseTaking5ArgumentsAndToStringPennTreebank0()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("^[^ ()]+ ([^ ()]+)s*)", span0, "^[^ ()]+ ([^ ()]+)s*)", 0.0, 1);
      String string0 = parse0.toStringPennTreebank();
      assertEquals(1, parse0.getHeadIndex());
      assertEquals(0.0, parse0.getProb(), 0.01);
      assertEquals("(^[^ ()]+ ([^ ()]+)s*) -LSB-)", string0);
  }

  @Test(timeout = 4000)
  public void testParseParseTaking2ArgumentsWithNull()  throws Throwable  {
      Span span0 = new Span(33, 33);
      Parse parse0 = new Parse("pP*31<", span0, "-NONE-[HH @-=)", 33, 33);
      parse0.toStringPennTreebank();
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      // Undeclared exception!
      try { 
        Parse.parseParse("(-NONE-[HH @-=) )", (GapLabeler) null);
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringThrowsEmptyStackExceptionAndCreatesParseTaking5Arguments1()  throws Throwable  {
      Span span0 = new Span(4, 4, "y9Q}'13t2", 4);
      Span span1 = new Span(span0, (double) 4);
      Parse parse0 = new Parse("-LSB-", span0, "-LSB-", (-1281.84113104), 4);
      Parse parse1 = new Parse("z4^t+", span1, "-RCB-[HH @=I)", 0.0, parse0);
      parse1.toStringPennTreebank();
      // Undeclared exception!
      try { 
        Parse.parseParse("(-RCB-[HH @=I) )");
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTaking2ArgumentsThrowsEmptyStackException0()  throws Throwable  {
      Span span0 = new Span(3208, 3208);
      Parse parse0 = new Parse("-RCB--HH @-=)", span0, "-RCB--HH @-=)", 3208, 1820);
      parse0.toStringPennTreebank();
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      // Undeclared exception!
      try { 
        Parse.parseParse("(-RCB--HH @-=) )", (GapLabeler) ancoraSpanishHeadRules0);
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndCreatesParseTaking5ArgumentsAndToStringPennTreebank2()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("T]", span0, "T]", 2, 2);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(T] -RSB-)", string0);
      
      Parse parse1 = Parse.parseParse("LG'M,N-");
      assertEquals(0, parse1.getHeadIndex());
      assertEquals(1.0, parse1.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testGetCoveredText()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("^(c#e! `!07;}r&Q", span0, "T,$K", 574.296576278, 2);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(T,$K -LRB-)", string0);
      assertEquals(574.296576278, parse0.getProb(), 0.01);
      assertEquals(2, parse0.getHeadIndex());
      
      parse0.getCoveredText();
      assertEquals(574.296576278, parse0.getProb(), 0.01);
      assertEquals(2, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndCreatesParseTaking5ArgumentsAndToStringPennTreebank3()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("zhed%@l2P!7<ipf", span0, "-RRB-3PBE-l", 2, 1);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(-RRB-3PBE-l h)", string0);
      
      Parse parse1 = Parse.parseParse("(-RRB-3PBE-l h)");
      assertTrue(parse1.complete());
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndCreatesParseTaking5ArgumentsAndToStringPennTreebank4()  throws Throwable  {
      Span span0 = new Span(2, 2);
      Parse parse0 = new Parse("zhed%@l2P!7<ipf", span0, "-RRB-3PBE-l", 2, 2);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(-RRB-3PBE-l )", string0);
      
      Parse parse1 = Parse.parseParse("(-RRB-3PBE-l )");
      assertEquals(0, parse1.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testIsPosTagReturningTrue()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      Parse parse0 = Parse.parseParse("^%[^ =-(7]+-([^ =-+)");
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      double double0 = parse0.getTagSequenceProb();
      assertEquals(0.0, double0, 0.01);
      
      parse0.updateHeads(headRules0);
      Parse parse1 = parse0.getHead();
      assertTrue(parse1.isPosTag());
      assertEquals("[^", parse1.getType());
      
      Parse.fixPossesives(parse0);
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("=-+ ", parse0.getCoveredText());
      assertFalse(parse0.isPosTag());
      
      boolean boolean0 = parse1.isPosTag();
      assertEquals("[^", parse1.getType());
      assertTrue(boolean0);
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("=-+ ", parse1.getText());
  }

  @Test(timeout = 4000)
  public void testCloneTakingParseReturningParseWhereGetHeadIndexIsNegative()  throws Throwable  {
      Span span0 = new Span(1, 1);
      Span[] spanArray0 = new Span[2];
      spanArray0[0] = span0;
      spanArray0[1] = span0;
      Parse[] parseArray0 = new Parse[2];
      Parse parse0 = new Parse("-RCB-", span0, "-RCB-", 1, (-1346));
      parseArray0[0] = parse0;
      Parse parse1 = new Parse("-RCB-", span0, "POS", (-1346), 4);
      parseArray0[1] = parse1;
      Parse.addNames("-RSB-y{;f'qcAD7S.", spanArray0, parseArray0);
      Parse.addNames("", spanArray0, parseArray0);
      parse0.clone(parse0);
      assertEquals(1, parse0.getChildCount());
  }

  @Test(timeout = 4000)
  public void testCreatesParseTaking5ArgumentsAndToStringPennTreebank1()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("v{?r)", span0, "LG'M,N-", 100, 1);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(LG'M,N- -LCB-)", string0);
      assertEquals(1, parse0.getHeadIndex());
      assertEquals(100.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testParseParseTaking2ArgumentsThrowsEmptyStackException1()  throws Throwable  {
      Span span0 = new Span(1, 1);
      Parse parse0 = new Parse(")", span0, "-NONE-[HH @-=I)", 1, 1);
      parse0.toStringPennTreebank();
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      // Undeclared exception!
      try { 
        Parse.parseParse("(-NONE-[HH @-=I) )", (GapLabeler) headRules0);
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testCloneTakingParseReturningParseWhereGetProbIsZero()  throws Throwable  {
      Span span0 = new Span(1, 3, "null type for: {}", 224.0);
      Parse parse0 = new Parse("K8wA", span0, "K8wA", 0.0, 5);
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[8];
      parseArray0[0] = parse0;
      parseArray0[1] = parse0;
      parseArray0[2] = parse0;
      parseArray0[3] = parse0;
      parseArray0[4] = parse0;
      parseArray0[5] = parse0;
      parseArray0[6] = parse0;
      parseArray0[7] = parse0;
      Parse parse1 = ancoraSpanishHeadRules0.getHead(parseArray0, "-NONE-");
      Parse parse2 = parse0.clone(parse1);
      assertEquals("K8wA", parse2.getType());
      assertEquals(0.0, parse2.getProb(), 0.01);
      assertEquals(5, parse2.getHeadIndex());
      assertNotSame(parse2, parse1);
      assertTrue(parse2.equals((Object)parse0));
      assertEquals(0.0, parse1.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringThrowsEmptyStackException0()  throws Throwable  {
      Span span0 = new Span(1, 1);
      Parse parse0 = new Parse(")", span0, "-NONE-[HH @-=I)", 1, 1);
      parse0.toStringPennTreebank();
      // Undeclared exception!
      try { 
        Parse.parseParse("(-NONE-[HH @-=I) )");
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndGetDerivation()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("t}f4", span0, "LB~M,N-", 2, 2);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(LB~M,N- -RCB-)", string0);
      
      parse0.getDerivation();
      assertEquals(2, parse0.getHeadIndex());
      
      Parse parse1 = Parse.parseParse("(LB~M,N- -RCB-)");
      assertEquals("} ", parse1.getText());
      assertEquals(1.0, parse1.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndCreatesParseTaking5ArgumentsAndToStringPennTreebank5()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("t}f4", span0, "LB~M,N-", 2, 2);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(LB~M,N- -RCB-)", string0);
      
      Parse parse1 = Parse.parseParse("(LB~M,N- -RCB-)");
      assertEquals("} ", parse1.getCoveredText());
      assertEquals(0, parse1.getHeadIndex());
      assertEquals(1, parse1.getChildCount());
  }

  @Test(timeout = 4000)
  public void testGetCommonParentReturningParseWhereGetProbIsZero()  throws Throwable  {
      Span span0 = new Span(0, 1);
      Parse parse0 = new Parse("-RSB-[:+-([H #NF=.)", span0, "-RSB-[:+-([H #NF=.)", 1, 1);
      Parse parse1 = new Parse("-RSB-[:+-([H #NF=.)", span0, "-RSB-[:+-([H #NF=.)", 0.0, 0);
      Parse parse2 = parse0.getCommonParent(parse1);
      assertNotNull(parse2);
      
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(-RSB-[:+-([H #NF=.) -)", string0);
      assertEquals(1, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetParentReturningParseWhereGetProbIsNegative()  throws Throwable  {
      Span span0 = new Span(10, 10);
      Parse parse0 = new Parse("-RSB-[:+-([H #NF=.)", span0, "-RSB-[:+-([H #NF=.)", (-953.17), 10);
      Parse parse1 = new Parse("YVr*7:\"pv", span0, "-RSB-[:+-([H #NF=.)", 0.0, parse0);
      parse0.insert(parse1);
      Span[] spanArray0 = new Span[0];
      Parse[] parseArray0 = new Parse[3];
      parseArray0[0] = parse0;
      parseArray0[1] = parse1;
      parseArray0[2] = parse1;
      Parse.addNames("-RSB-[:+-([H #NF=.)", spanArray0, parseArray0);
      Parse parse2 = parse1.getParent();
      assertEquals((-953.17), parse2.getProb(), 0.01);
      assertEquals("-RSB-[:+-([H #NF=.)", parse2.getType());
      assertEquals(10, parse1.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetCommonParentReturningParseWhereGetProbIsNegative()  throws Throwable  {
      Span span0 = new Span(1, 1);
      Parse parse0 = new Parse("-RSB-[:+-([H #NF=.)", span0, "-RSB-[:+-([H #NF=.)", 1, 1);
      Parse parse1 = new Parse("-RSB-[:+-([H #NF=.)", span0, "-RSB-[:+-([H #NF=.)", (-2545.2211177784525), parse0);
      Parse parse2 = parse0.getCommonParent(parse1);
      assertNotNull(parse2);
      
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(-RSB-[:+-([H #NF=.) )", string0);
      
      Parse parse3 = Parse.parseParse("(-RSB-[:+-([H #NF=.) )");
      assertFalse(parse3.isPosTag());
  }

  @Test(timeout = 4000)
  public void testCreatesParseTaking5ArgumentsAndToStringPennTreebank2()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("t}f4", span0, "LB~D,N-", 2, 1);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(LB~D,N- -RCB-)", string0);
      assertEquals(2.0, parse0.getProb(), 0.01);
      assertEquals(1, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testCreatesParseTaking5ArgumentsAndToStringPennTreebank3()  throws Throwable  {
      Span span0 = new Span(1, 2);
      Parse parse0 = new Parse("{} ", span0, "{} ", 1, 2);
      String string0 = parse0.toStringPennTreebank();
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("({}  -RCB-)", string0);
      assertEquals(2, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringThrowsEmptyStackExceptionAndCreatesParseTaking5Arguments2()  throws Throwable  {
      Span span0 = new Span(1, 1);
      Parse parse0 = new Parse("-RSB-[:+-([H #NF=.)", span0, "-RSB-[:+-([H #NF=.)", 1, 1);
      Parse parse1 = new Parse("^l1S>E;=%_8K", span0, "-LSB-[H #NIF=.)", 1, parse0);
      parse1.toStringPennTreebank();
      // Undeclared exception!
      try { 
        Parse.parseParse("(-LSB-[H #NIF=.) )");
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringThrowsEmptyStackExceptionAndCreatesParseTaking5Arguments3()  throws Throwable  {
      Span span0 = new Span(1, 1);
      Parse parse0 = new Parse("-RSB-[:+-([H #NF=.)", span0, "-RSB-[:+-([H #NF=.)", 1, 1);
      Parse parse1 = new Parse("-RSB-[:+-([H #NF=.)", span0, "-LSB-[H #NIF=.)", 1, parse0);
      parse1.toStringPennTreebank();
      // Undeclared exception!
      try { 
        Parse.parseParse("(-LSB-[H #NIF=.) )");
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testExpandTopNodeWithParseWhereGetHeadIndexIsPositive()  throws Throwable  {
      Span span0 = new Span(15, 15);
      Parse parse0 = new Parse("-RSB-[:+-([H #NF=.)", span0, "-RSB-[:+-([H #NF=.)", 15, 15);
      Parse parse1 = new Parse("Hv:C~aNMC5r", span0, "-LCB-3PRE/", 15, parse0);
      parse1.toStringPennTreebank();
      Parse.parseParse("(-LCB-3PRE/ )");
      // Undeclared exception!
      try { 
        parse1.expandTopNode(parse0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringThrowsEmptyStackExceptionAndCreatesParseTaking5Arguments4()  throws Throwable  {
      Span span0 = new Span(1, 1);
      Parse parse0 = new Parse("-LCB-[H #OF=.)", span0, "-LCB-[H #OF=.)", 1, 1);
      Parse parse1 = new Parse("-LCB-[H #OF=.)", span0, "-LCB-[H #OF=.)", 1, parse0);
      parse1.toStringPennTreebank();
      // Undeclared exception!
      try { 
        Parse.parseParse("(-LCB-[H #OF=.) )");
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndShowCodeTree0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("(-RSB-Xanwc;n.TDB");
      parse0.showCodeTree();
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testUpdateSpan()  throws Throwable  {
      Span span0 = new Span(1, 1);
      Parse parse0 = Parse.parseParse("-RSB-[+-([H #NF=.)");
      assertTrue(parse0.complete());
      
      Parse parse1 = new Parse("-RSB-[+-([H #NF=.)", span0, "5~a;<Uj?.Wz?n-x&k", 1, 1);
      Parse parse2 = Parse.parseParse("-RSB-[+-([H #NF=.)");
      parse2.insert(parse0);
      parse2.toStringPennTreebank();
      Parse parse3 = Parse.parseParse("(TOP (TOP ([H #NF=.)([H #NF=.) ))");
      StringBuffer stringBuffer0 = new StringBuffer(1);
      parse2.updateSpan();
      parse3.show(stringBuffer0);
      parse3.clone();
      assertFalse(parse3.complete());
  }

  @Test(timeout = 4000)
  public void testGetParentReturningParseWhereGetHeadIndexIsNegative()  throws Throwable  {
      Span span0 = new Span(40, 100);
      Parse parse0 = new Parse("Xqa{lWAs(3_PB-w", span0, "Xqa{lWAs(3_PB-w", (-1.0), (-3604));
      Parse parse1 = new Parse("-> IOP {}", span0, "Xqa{lWAs(3_PB-w", 3437.165573073, 51);
      parse1.insert(parse0);
      Parse parse2 = Parse.parseParse("Xqa{lWAs(3_PB-w");
      Parse parse3 = new Parse("5~a;<Uj?.Wz?n-x&k", span0, "Xqa{lWAs(3_PB-w", 0.0, parse0);
      parse3.insert(parse0);
      String string0 = parse2.toStringPennTreebank();
      assertEquals("(TOP )", string0);
      
      Parse parse4 = parse0.getParent();
      assertEquals((-3604), parse4.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetParentReturningParseWhereGetHeadIndexIsPositive()  throws Throwable  {
      Span span0 = new Span(1, 1);
      Parse parse0 = new Parse("-RSB-[+-([H #NF=.)", span0, "-RSB-[+-([H #NF=.)", 0.0, 1);
      Parse parse1 = new Parse("-RSB-[+-([H #NF=.)", span0, "5~a;<Uj?.Wz?n-x&k", 0.0, 1);
      parse0.insert(parse1);
      Parse parse2 = Parse.parseParse("-RSB-[+-([H #NF=.)");
      parse2.insert(parse0);
      String string0 = parse2.toStringPennTreebank();
      assertEquals("(TOP ([H #(-RSB-[+-([H #NF=.) (5~a;<Uj?.Wz?n-x&k ))NF=.) )", string0);
      
      Parse.fixPossesives(parse1);
      Parse parse3 = parse1.getParent();
      assertEquals(1, parse3.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetCommonParentReturningParseWhereGetHeadIndexIsPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Rn9@2bBuBC(vQc0F");
      Span span0 = new Span(2, 2, "Rn9@2bBuBC(vQc0F");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Rn9@2bBuBC(vQc0F", (GapLabeler) headRules0);
      Span[] spanArray0 = new Span[3];
      spanArray0[0] = span0;
      Parse parse2 = new Parse("Rn9@2bBuBC(vQc0F", span0, "O", 0.0, 1185);
      Parse parse3 = Parse.parseParse("O", (GapLabeler) headRules0);
      parse3.insert(parse1);
      parse1.isChunk();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse4 = parse3.adjoin(parse2, ancoraSpanishHeadRules0);
      assertEquals(1185, parse3.getHeadIndex());
      
      parse1.getCommonParent(parse3);
      // Undeclared exception!
      try { 
        parse4.clone(parse0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: -1, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testAdjoinReturningParseWhereGetHeadIndexIsNegative()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^A^h=-]:-([HH @-=I)");
      Span span0 = new Span(12, 12, (String) null);
      Parse parse1 = new Parse((String) null, span0, (String) null, 12, (-1207));
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse0.adjoin(parse1, headRules0);
      parse0.getTagNodes();
      // Undeclared exception!
      try { 
        parse0.showCodeTree();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.parser.Parse.hashCode()\" because the return value of \"opennlp.tools.parser.Parse.getParent()\" is null
         //
         verifyException("opennlp.tools.parser.Parse", e);
      }
  }

  @Test(timeout = 4000)
  public void testCloneTakingParseReturningParseWhereGetProbIsNegative()  throws Throwable  {
      Parse parse0 = new Parse("POS", (Span) null, "POS", (-427.2220860262), 124);
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[9];
      parseArray0[0] = parse0;
      parseArray0[1] = parse0;
      Parse parse1 = Parse.parseParse("x>g ");
      parseArray0[2] = parse1;
      parseArray0[3] = parse0;
      parseArray0[4] = parse0;
      parseArray0[5] = parse0;
      parseArray0[6] = parse0;
      Parse parse2 = new Parse("POS", (Span) null, "x>g ", 370.90188416029, 124);
      parseArray0[7] = parse2;
      parseArray0[8] = parse0;
      Parse parse3 = ancoraSpanishHeadRules0.getHead(parseArray0, "POS");
      Parse parse4 = parse0.clone(parse3);
      assertEquals("POS", parse4.getText());
      assertEquals("POS", parse4.getType());
      assertEquals(124, parse4.getHeadIndex());
      assertEquals((-427.2220860262), parse4.getProb(), 0.01);
      assertNotSame(parse3, parse4);
      
      parse2.getDerivation();
      assertEquals(370.90188416029, parse2.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testParseParseTaking2ArgumentsAndToStringPennTreebank()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse0 = Parse.parseParse("^A^C =-]-([HH =-=I)", (GapLabeler) headRules0);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(TOP ([HH =-=I) )", string0);
      
      Parse parse1 = Parse.parseParse("(TOP ([HH =-=I) )", (GapLabeler) headRules0);
      assertFalse(parse1.isPosTag());
  }

  @Test(timeout = 4000)
  public void testAdjoinRootAndSetChildThrowsIndexOutOfBoundsException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^^C=-]+([[ =_=IQ)");
      Reader reader0 = Reader.nullReader();
      LinkedList<Parse> linkedList0 = new LinkedList<Parse>();
      parse0.setPrevPunctuation(linkedList0);
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse1 = parse0.adjoinRoot(parse0, ancoraSpanishHeadRules0, 0);
      // Undeclared exception!
      try { 
        parse1.setChild(68, "{");
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 68, Size: 2
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetHeadIndexReturningNegative()  throws Throwable  {
      Parse parse0 = new Parse("-NONE-[G[ =_=IQ)", (Span) null, "-RRB-[GH =-=I;)", (-1.0), (-133));
      parse0.getSpan();
      int int0 = parse0.getHeadIndex();
      assertEquals((-1.0), parse0.getProb(), 0.01);
      assertEquals((-133), int0);
      assertEquals("-RRB-[GH =-=I;)", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testInsert0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([GH =-=I;)");
      assertEquals("=-=I; ", parse0.toString());
      
      Span span0 = new Span(3, 3);
      Parse parse1 = new Parse("^[^C=-]+-([GH =-=I;)", span0, "^[^C=-]+-([GH =-=I;)", 3, 3);
      parse0.insert(parse1);
      assertTrue(parse0.complete());
  }

  @Test(timeout = 4000)
  public void testAdjoinRootWithNegative()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([GH =-=I;)");
      Span span0 = new Span(6, 6, "^[^C=-]+-([GH =-=I;)", 6);
      Parse parse1 = new Parse("^[^C=-]+-([GH =-=I;)", span0, "^[^C=-]+-([GH =-=I;)", 6, 6);
      parse0.insert(parse1);
      parse1.isChunk();
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[7];
      Parse.fixPossesives(parse0);
      parseArray0[0] = parse1;
      parseArray0[1] = parse0;
      parseArray0[2] = parse0;
      parseArray0[3] = parse1;
      parseArray0[4] = parse0;
      Parse parse2 = Parse.parseParse("vYUAC9D");
      parseArray0[5] = parse2;
      parseArray0[6] = parse1;
      Parse parse3 = ancoraSpanishHeadRules0.getHead(parseArray0, "=_=IQ");
      // Undeclared exception!
      try { 
        parse0.adjoinRoot(parse3, ancoraSpanishHeadRules0, (-842));
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: -842, Size: 2
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testInsert1()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^hU-]n2:(ta |@=IA)");
      Span span0 = new Span(6, 6, "^hU-]n2:(ta |@=IA)");
      Parse parse1 = new Parse("^hU-]n2:(ta |@=IA)", span0, "^hU-]n2:(ta |@=IA)", 6, 6);
      parse0.insert(parse1);
      String string0 = Parse.BRACKET_LCB;
      assertEquals("{", string0);
  }

  @Test(timeout = 4000)
  public void testIndexOfReturningPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^^C=-]+([G[ =_=IQ)");
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse[] parseArray0 = new Parse[1];
      parseArray0[0] = parse0;
      Parse parse1 = headRules0.getHead(parseArray0, "Inserting constituent not contained in the sentence!");
      Parse parse2 = parse0.adjoinRoot(parse1, headRules0, 0);
      parse2.indexOf(parse0);
      // Undeclared exception!
      try { 
        parse2.adjoinRoot(parse1, ancoraSpanishHeadRules0, 24);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 24, Size: 2
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testCloneTakingParseReturningParseWhereGetHeadIndexIsPositive()  throws Throwable  {
      Span span0 = new Span(2, 2, "^[^C=-]+-([GH =-=I;)", 2);
      Parse parse0 = new Parse("^[^C=-]+-([GH =-=I;)", span0, "^[^C=-]+-([GH =-=I;)", 2, 2);
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse[] parseArray0 = new Parse[4];
      parseArray0[0] = parse0;
      parseArray0[1] = parse0;
      parseArray0[2] = parse0;
      parseArray0[3] = parse0;
      Parse parse1 = headRules0.getHead(parseArray0, "^[^C=-]+-([GH =-=I;)");
      Parse parse2 = parse0.clone(parse1);
      assertEquals(2, parse2.getHeadIndex());
      assertEquals(2.0, parse2.getProb(), 0.01);
      assertEquals("^[^C=-]+-([GH =-=I;)", parse2.getType());
      
      boolean boolean0 = parse0.isPosTag();
      assertFalse(boolean0);
      assertNotSame(parse0, parse2);
      assertTrue(parse0.equals((Object)parse2));
      assertEquals(2.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testToStringPennTreebankReturningEmptyString()  throws Throwable  {
      Parse.parseParse("TK");
      Span span0 = new Span(3, 3);
      Parse parse0 = new Parse("TK", span0, "TK", 1.0, 1935);
      String string0 = parse0.toStringPennTreebank();
      assertEquals(1935, parse0.getHeadIndex());
      assertEquals("", string0);
      assertEquals(1.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndToStringPennTreebank0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("-RSB-[:+-([H #NF=.)");
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(TOP ([H #NF=.) )", string0);
      
      Parse parse1 = Parse.parseParse("(TOP ([H #NF=.) )");
      assertEquals(1.0, parse1.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testAddNames0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([GH =-=I;)");
      Span span0 = new Span(2, 2, "^[^C=-]+-([GH =-=I;)", 2);
      Parse parse1 = new Parse("^[^C=-]+-([GH =-=I;)", span0, "^[^C=-]+-([GH =-=I;)", 2, 2);
      parse0.insert(parse1);
      Span[] spanArray0 = new Span[3];
      spanArray0[0] = span0;
      spanArray0[1] = span0;
      spanArray0[2] = span0;
      Parse[] parseArray0 = new Parse[3];
      parseArray0[0] = parse1;
      parseArray0[1] = parse1;
      parseArray0[2] = parse1;
      Parse.addNames("^[^C=-]+-([GH =-=I;)", spanArray0, parseArray0);
      assertEquals(3, spanArray0.length);
  }

  @Test(timeout = 4000)
  public void testAddNamesThrowsNullPointerExceptionAndInsert0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^@^h=-]:-([HH @-=I)");
      Span span0 = new Span(2, 2);
      Parse parse1 = new Parse("^@^h=-]:-([HH @-=I)", span0, "^@^h=-]:-([HH @-=I)", 2, 2);
      parse0.insert(parse1);
      Span[] spanArray0 = new Span[40];
      spanArray0[0] = span0;
      Parse[] parseArray0 = new Parse[3];
      parseArray0[2] = parse1;
      parseArray0[1] = parse1;
      // Undeclared exception!
      try { 
        Parse.addNames("^@^h=-]:-([HH @-=I)", spanArray0, parseArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Span.getStart()\" because \"nameTokenSpan\" is null
         //
         verifyException("opennlp.tools.parser.Parse", e);
      }
  }

  @Test(timeout = 4000)
  public void testSetParentWithParseWhereCompleteIsTrueAndParseWhereGetChildCountIsPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([H =-=I)");
      Span span0 = new Span(2, 2, "^[^C=-]+-([GH =-=I;)");
      parse0.setParent(parse0);
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse1 = parse0.adjoinRoot(parse0, ancoraSpanishHeadRules0, 0);
      assertEquals("[H", parse1.getType());
      assertTrue(parse0.complete());
      assertEquals("=-=I ", parse1.getText());
      assertEquals(2, parse1.getChildCount());
      assertEquals(1.0, parse1.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testAdjoinRoot()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^^C=-]+([G[ =_=IQ)");
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse1 = parse0.adjoinRoot(parse0, ancoraSpanishHeadRules0, 0);
      assertEquals("=_=IQ ", parse1.getText());
      assertEquals("[G[", parse1.getType());
  }

  @Test(timeout = 4000)
  public void testAdjoinRootReturningParseWhereGetHeadIndexIsPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([H =-=I)");
      Span span0 = new Span(2, 2, "^[^C=-]+-([GH =-=I;)");
      Parse parse1 = new Parse("^[^C=-]+-([GH =-=I;)", span0, "^[^C=-]+-([GH =-=I;)", 2, 2);
      parse1.setParent(parse0);
      parse0.insert(parse1);
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse2 = parse0.adjoinRoot(parse1, ancoraSpanishHeadRules0, 0);
      assertEquals(2, parse2.getHeadIndex());
      assertTrue(parse0.complete());
      assertEquals(1.0, parse2.getProb(), 0.01);
      assertEquals(2, parse2.getChildCount());
      assertEquals("[H", parse2.getType());
  }

  @Test(timeout = 4000)
  public void testGetTypeReturningNull()  throws Throwable  {
      Parse parse0 = new Parse("/=<t8'e-+H!", (Span) null, (String) null, (-1359.001163389697), 20);
      String string0 = parse0.getType();
      assertNull(string0);
      assertEquals((-1359.001163389697), parse0.getProb(), 0.01);
      assertEquals(20, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndInsert()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([GH =-=I;)");
      Span span0 = new Span(2, 2, "^[^C=-]+-([GH =-=I;)");
      Parse parse1 = new Parse("^[^C=-]+-([GH =-=I;)", span0, "^[^C=-]+-([GH =-=I;)", 2, 2);
      parse0.insert(parse1);
      assertEquals(2, parse1.getHeadIndex());
      
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(TOP ([GH =-(^[^C=-]+-([GH =-=I;) )=I;) )", string0);
      assertEquals("=-=I; ", parse0.getText());
      assertEquals("=-=I; ", parse0.toString());
      
      Parse parse2 = Parse.parseParse("(TOP ([GH =-(^[^C=-]+-([GH =-=I;) )=I;) )");
      assertFalse(parse2.isPosTag());
  }

  @Test(timeout = 4000)
  public void testAddNamesThrowsNullPointerExceptionAndInsert1()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^@^h=-]:-([HH @-=I)");
      Span span0 = new Span(2, 2);
      Parse parse1 = new Parse("^@^h=-]:-([HH @-=I)", span0, "^@^h=-]:-([HH @-=I)", 2, 2);
      parse0.insert(parse1);
      Span[] spanArray0 = new Span[21];
      spanArray0[0] = span0;
      Parse[] parseArray0 = new Parse[4];
      parseArray0[2] = parse1;
      parseArray0[1] = parse0;
      // Undeclared exception!
      try { 
        Parse.addNames("^@^h=-]:-([HH @-=I)", spanArray0, parseArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Span.getStart()\" because \"nameTokenSpan\" is null
         //
         verifyException("opennlp.tools.parser.Parse", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetLabelReturningNonEmptyString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("expandTopNode: parts={}");
      parse0.setLabel("NP.*");
      String string0 = parse0.getLabel();
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("NP.*", string0);
      assertEquals(1.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testGetNextPunctuationSetReturningNonNull()  throws Throwable  {
      Parse parse0 = Parse.parseParse("4[/qtWAH(3BE--~");
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(TOP )", string0);
      
      LinkedList<Parse> linkedList0 = new LinkedList<Parse>();
      parse0.setNextPunctuation(linkedList0);
      boolean boolean0 = parse0.isPosTag();
      assertFalse(boolean0);
      
      parse0.getNextPunctuationSet();
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testSetParentAndPruneParseThrowsNullPointerException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("VP+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse[] parseArray0 = new Parse[9];
      parseArray0[0] = parse0;
      parseArray0[1] = parse0;
      parseArray0[2] = parse0;
      parseArray0[3] = parse0;
      parseArray0[4] = parse0;
      parseArray0[5] = parse0;
      parseArray0[6] = parse0;
      parseArray0[7] = parse0;
      parseArray0[8] = parse0;
      Parse parse1 = headRules0.getHead(parseArray0, "^[^ =-]+-([^ =-]+)");
      parse0.setParent(parse1);
      parse0.add(parse0, headRules0);
      // Undeclared exception!
      try { 
        Parse.pruneParse(parse0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetSpanReturningSpanWhereGetProbIsPositive()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse0 = Parse.parseParse("^[^ =-]+-([^ =-]+Q)", (GapLabeler) headRules0);
      Span span0 = new Span(3, 3, "-NONE-vQc0F", 3);
      Parse parse1 = new Parse("A%17PJ", span0, "A%17PJ", 17.134684104477024, 3);
      parse0.insert(parse1);
      assertEquals(1, parse0.getChildCount());
      assertFalse(parse0.isPosTag());
      
      parse1.getSpan();
      assertEquals(17.134684104477024, parse1.getProb(), 0.01);
      assertFalse(parse1.complete());
  }

  @Test(timeout = 4000)
  public void testGetParentReturningParseWhereCompleteIsTrue()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse0 = Parse.parseParse("^[^ =-]+-([^ =-]+Q)", (GapLabeler) headRules0);
      assertEquals("=-]+Q ", parse0.toString());
      
      Span span0 = new Span(3, 3, "-NONE-vQc0F", 3);
      Parse parse1 = new Parse("A%17PJ", span0, "A%17PJ", 0.0, 3);
      parse0.insert(parse1);
      assertFalse(parse0.isPosTag());
      assertEquals(0.0, parse1.getProb(), 0.01);
      assertEquals(3, parse1.getHeadIndex());
      assertEquals(1, parse0.getChildCount());
      assertEquals("=-]+Q ", parse0.getText());
      assertEquals("A%17PJ", parse1.getType());
      
      Parse parse2 = parse1.getParent();
      assertEquals(0, parse2.getHeadIndex());
      assertEquals("TK", parse2.getType());
  }

  @Test(timeout = 4000)
  public void testAdjoinRootThrowsNullPointerException()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =-=+Q)");
      parse0.isPosTag();
      Parse[] parseArray0 = parse0.getTokenNodes();
      parse0.getHeadIndex();
      ancoraSpanishHeadRules0.getHead(parseArray0, "''");
      // Undeclared exception!
      try { 
        parse0.adjoinRoot((Parse) null, (HeadRules) null, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.parser.Parse.getSpan()\"
         //
         verifyException("opennlp.tools.parser.Parse", e);
      }
  }

  @Test(timeout = 4000)
  public void testSetPrevPunctuation()  throws Throwable  {
      Parse parse0 = Parse.parseParse("VP+EBpfSF\"]");
      LinkedList<Parse> linkedList0 = new LinkedList<Parse>();
      parse0.setPrevPunctuation(linkedList0);
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse0.add(parse0, headRules0);
      // Undeclared exception!
      try { 
        Parse.pruneParse(parse0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetHeadReturningParseWhereIsChunkIsTrue()  throws Throwable  {
      Parse parse0 = Parse.parseParse("se8m");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse0.isChunk(true);
      Parse parse1 = Parse.parseParse("~+z#", (GapLabeler) headRules0);
      Parse parse2 = Parse.parseParse("0");
      parse2.add(parse0, headRules0);
      assertTrue(parse0.isChunk());
      
      Reader.nullReader();
      Parse.pruneParse(parse1);
      Parse parse3 = parse2.getHead();
      int int0 = parse3.getHeadIndex();
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testSetChild()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =-=+Q)");
      parse0.isPosTag();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Stack<Constituent> stack0 = new Stack<Constituent>();
      parse0.setChild(0, "^[^C=-]+-([G =-=+Q)");
      assertEquals("=-=+Q ", parse0.toString());
      assertEquals(1, parse0.getChildCount());
      assertEquals("TOP", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testPruneParseThrowsIndexOutOfBoundsException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Span span0 = new Span(48, 48, "Vo+EBpfSF\"]", 48);
      Span span1 = new Span(span0, (-1.0));
      Parse parse1 = new Parse("Vo+EBpfSF\"]", span1, "stack.size={}", (-1733.1), (-1));
      parse0.setParent(parse1);
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse2, headRules0);
      Reader.nullReader();
      // Undeclared exception!
      try { 
        Parse.pruneParse(parse0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: -1, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testAddNamesThrowsNullPointerExceptionAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Rn9@2bBuBC(vQc0F");
      Span span0 = new Span(2, 2, "Rn9@2bBuBC(vQc0F");
      Parse parse1 = Parse.parseParse("Rn9@2bBuBC(vQc0F");
      Span[] spanArray0 = new Span[3];
      spanArray0[0] = span0;
      Parse[] parseArray0 = new Parse[24];
      parseArray0[1] = parse0;
      parseArray0[2] = parse1;
      // Undeclared exception!
      try { 
        Parse.addNames("Rn9@2bBuBC(vQc0F", spanArray0, parseArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Span.getStart()\" because \"nameTokenSpan\" is null
         //
         verifyException("opennlp.tools.parser.Parse", e);
      }
  }

  @Test(timeout = 4000)
  public void testInsert2()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([GH =-=IQ)");
      Span span0 = new Span(2, 2, "^[^C=-]+-([GH =-=IQ)", 2);
      Parse parse1 = new Parse("^[^C=-]+-([GH =-=IQ)", span0, "^[^C=-]+-([GH =-=IQ)", 2, 2);
      parse0.insert(parse1);
      assertEquals(2, parse1.getHeadIndex());
      assertFalse(parse1.complete());
      assertEquals("=-=IQ ", parse0.toString());
      assertEquals(1, parse0.getChildCount());
  }

  @Test(timeout = 4000)
  public void testGetCoveredTextThrowsStringIndexOutOfBoundsException()  throws Throwable  {
      Reader.nullReader();
      Span span0 = new Span(2780, 2780, (-1.0));
      Parse parse0 = Parse.parseParse("^[^ =-]+-([^ =-]+)");
      Parse parse1 = new Parse("^[^ =-]+-([^ =-]+)", span0, "%", 1676.97170610134, parse0);
      Object object0 = new Object();
      Object object1 = parse1.clone();
      Parse parse2 = new Parse("@02", span0, "^[^ =-]+-([^ =-]+)", (-1.0), parse1);
      Object object2 = parse2.clone();
      parse1.equals(object2);
      parse1.equals(object1);
      parse1.getSpan();
      // Undeclared exception!
      try { 
        parse2.getCoveredText();
        fail("Expecting exception: StringIndexOutOfBoundsException");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }

  @Test(timeout = 4000)
  public void testInsertThrowsTooManyResourcesException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%VXEi-R)mIfr\"^nMte");
      parse0.showCodeTree();
      parse0.getChildCount();
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[2];
      parseArray0[0] = parse0;
      parseArray0[1] = parse0;
      Parse parse1 = ancoraSpanishHeadRules0.getHead(parseArray0, "b(%VXEi-R)mIfr\"^nMte");
      parse0.insert(parse1);
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse2 = headRules0.getHead(parseArray0, "b(%VXEi-R)mIfr\"^nMte");
      parse0.insert(parse2);
      parse0.insert(parse0);
      parse1.remove(1);
      // Undeclared exception!
      Parse.fixPossesives(parse0);
  }

  @Test(timeout = 4000)
  public void testGetSpanReturningSpanWhereLengthIsPositive()  throws Throwable  {
      Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      Parse parse0 = Parse.parseParse("^%[^ =-]+-([^ =-]+)");
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(TOP ([^ =-]+) )", string0);
      
      double double0 = parse0.getTagSequenceProb();
      assertEquals(0.0, double0, 0.01);
      
      parse0.getSpan();
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testToStringReturningNonEmptyString()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      Parse parse0 = Parse.parseParse("^%[^ =-(7]+-([^ =-+)");
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      String string0 = parse0.toString();
      assertFalse(parse0.isPosTag());
      assertEquals("=-+ ", string0);
      assertEquals("TOP", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testFixPossesivesThrowsTooManyResourcesExceptionAndRemove()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%VXEi-R)mIfr\"^nMte");
      parse0.showCodeTree();
      parse0.getChildCount();
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[2];
      parseArray0[0] = parse0;
      parseArray0[1] = parse0;
      Parse parse1 = ancoraSpanishHeadRules0.getHead(parseArray0, "[");
      parse0.insert(parse1);
      parse0.insert(parse0);
      parse1.remove(1);
      // Undeclared exception!
      Parse.fixPossesives(parse0);
  }

  @Test(timeout = 4000)
  public void testFixPossesivesThrowsTooManyResourcesException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%VXEi-R)mIfr\"^nMte");
      parse0.showCodeTree();
      parse0.getChildCount();
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[2];
      parseArray0[0] = parse0;
      parseArray0[1] = parse0;
      Parse parse1 = ancoraSpanishHeadRules0.getHead(parseArray0, "b(%VXEi-R)mIfr\"^nMte");
      parse0.insert(parse1);
      parse0.insert(parse0);
      parse1.remove(1);
      // Undeclared exception!
      Parse.fixPossesives(parse0);
  }

  @Test(timeout = 4000)
  public void testEqualsReturningFalse()  throws Throwable  {
      Parse parse0 = Parse.parseParse("GVo+EBpvSF\"]");
      Parse parse1 = Parse.parseParse("GVo+EBpvSF\"]");
      Parse.pruneParse(parse1);
      assertTrue(parse1.equals((Object)parse0));
      
      parse0.setLabel("GVo+EBpvSF\"]");
      parse0.getTagNodes();
      boolean boolean0 = parse0.equals(parse1);
      assertFalse(boolean0);
      
      parse0.isFlat();
      Parse.fixPossesives(parse1);
      assertFalse(parse1.equals((Object)parse0));
  }

  @Test(timeout = 4000)
  public void testGetSpanReturningSpanWhereGetEndIsPositive()  throws Throwable  {
      String string0 = ",";
      Span span0 = new Span(68, 68, (String) null);
      Parse parse0 = new Parse(",", span0, ",", (-1.0), 7);
      parse0.showCodeTree();
      parse0.getSpan();
      StringReader stringReader0 = new StringReader("%F+i-R");
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = null;
      try {
        ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(stringReader0);
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.StringTokenizer", e);
      }
  }

  @Test(timeout = 4000)
  public void testUpdateHeadsAndGetTagNodesAndGetTagSequenceProb()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      Parse parse0 = Parse.parseParse("^[^ =-]+-([^ =-]+)");
      Parse[] parseArray0 = parse0.getTagNodes();
      assertEquals(1, parseArray0.length);
      
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse1 = ancoraSpanishHeadRules0.getHead(parseArray0, "^[^ =-]+-([^ =-]+)");
      parse1.getTagSequenceProb();
      parse1.updateHeads(headRules0);
      assertFalse(parse0.isPosTag());
      assertEquals("[^", parse1.getType());
      assertEquals("=-]+", parse1.toString());
  }

  @Test(timeout = 4000)
  public void testRemoveWithNegative()  throws Throwable  {
      Reader.nullReader();
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      StringWriter stringWriter0 = new StringWriter();
      headRules0.serialize(stringWriter0);
      headRules0.serialize(stringWriter0);
      Parse parse0 = Parse.parseParse("^[^ =-]+-([^ =-]+)");
      parse0.showCodeTree();
      parse0.getChildCount();
      Parse parse1 = Parse.parseParse("^[^ =-]+-([^ =-]+)", (GapLabeler) headRules0);
      parse0.insert(parse1);
      parse0.insert(parse1);
      // Undeclared exception!
      try { 
        parse1.remove((-1615967744));
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: -1615967744, Size: 3
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsPosTagAndShowTakingStringBuffer()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      Parse parse0 = Parse.parseParse("^[^ =-]+-([^ =-]+)");
      parse0.getTagNodes();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Reader.nullReader();
      StringBuffer stringBuffer0 = new StringBuffer(1058);
      parse0.show(stringBuffer0);
      assertEquals(16, stringBuffer0.length());
      
      Parse.pruneParse(parse0);
      boolean boolean0 = parse0.isPosTag();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsPosTag()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      Parse parse0 = Parse.parseParse("^[^ =-]+-([^ =-]+)");
      Parse[] parseArray0 = parse0.getTagNodes();
      assertEquals(1, parseArray0.length);
      
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Reader.nullReader();
      Parse.pruneParse(parse0);
      boolean boolean0 = parse0.isPosTag();
      assertEquals("=-]+ ", parse0.toString());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetTagSequenceProbAndGetNextPunctuationSet()  throws Throwable  {
      Parse parse0 = Parse.parseParse("TK");
      parse0.setType("TK");
      StringBuffer stringBuffer0 = new StringBuffer((CharSequence) "TK");
      parse0.show(stringBuffer0);
      Reader.nullReader();
      parse0.getNextPunctuationSet();
      double double0 = parse0.getTagSequenceProb();
      assertEquals("TK", parse0.getType());
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testAddNamesAndFixPossesives()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Rn9@2bBuBC(vQc0F");
      Span span0 = new Span(2, 2, "dkV>NZ?;}");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("dkV>NZ?;}", (GapLabeler) headRules0);
      parse0.addPreviousPunctuation(parse1);
      assertTrue(parse1.equals((Object)parse0));
      
      parse0.show();
      Span[] spanArray0 = new Span[3];
      spanArray0[0] = span0;
      spanArray0[1] = span0;
      spanArray0[2] = span0;
      Parse[] parseArray0 = new Parse[25];
      parseArray0[0] = parse1;
      parseArray0[1] = parse0;
      parseArray0[2] = parse1;
      parseArray0[3] = parse1;
      parseArray0[4] = parse1;
      parseArray0[5] = parse1;
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse2 = Parse.parseParse("yz5=ABqD>kRAn=\"h`F_", (GapLabeler) ancoraSpanishHeadRules0);
      parseArray0[6] = parse2;
      parseArray0[7] = parse0;
      parseArray0[8] = parse1;
      Parse.addNames("dkV>NZ?;}", spanArray0, parseArray0);
      Parse.fixPossesives(parse1);
      assertFalse(parse1.equals((Object)parse0));
      assertTrue(parse1.equals((Object)parse2));
  }

  @Test(timeout = 4000)
  public void testAddNamesThrowsNullPointerExceptionAndCreatesParseTaking5Arguments()  throws Throwable  {
      Span span0 = new Span(2, 2);
      Parse parse0 = new Parse("^@^h=-]:-([HH @-=I)", span0, "^@^h=-]:-([HH @-=I)", 2, 2);
      Span[] spanArray0 = new Span[21];
      spanArray0[0] = span0;
      Parse[] parseArray0 = new Parse[4];
      parseArray0[2] = parse0;
      // Undeclared exception!
      try { 
        Parse.addNames("^@^h=-]:-([HH @-=I)", spanArray0, parseArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Span.getStart()\" because \"nameTokenSpan\" is null
         //
         verifyException("opennlp.tools.parser.Parse", e);
      }
  }

  @Test(timeout = 4000)
  public void testAdjoinAndAdjoinAndGetCoveredText()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      StringBuffer stringBuffer0 = new StringBuffer("");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("", (GapLabeler) headRules0);
      Reader reader1 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules1 = new opennlp.tools.parser.lang.en.HeadRules(reader1);
      parse1.add(parse0, headRules1);
      Parse.fixPossesives(parse1);
      parse1.isChunk();
      parse1.addPreviousPunctuation(parse0);
      parse1.show();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      headRules0.labelGaps(stack0);
      parse1.adjoin(parse0, headRules1);
      assertTrue(parse1.complete());
      
      parse0.getCoveredText();
      Parse parse2 = Parse.parseParse("GmE;\"CldF{fv#XL", (GapLabeler) headRules0);
      assertEquals(0, parse2.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testAdjoinWithParseWhereCompleteIsTrue()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =-=+Q)");
      Parse parse1 = parse0.adjoin(parse0, ancoraSpanishHeadRules0);
      assertEquals(1.0, parse1.getProb(), 0.01);
      assertEquals("=-=+Q ", parse1.getCoveredText());
      assertEquals("[G", parse1.getType());
      assertEquals(1, parse0.getChildCount());
      assertEquals("=-=+Q ", parse1.getText());
  }

  @Test(timeout = 4000)
  public void testAdjoinAndExpandTopNode()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse.fixPossesives(parse0);
      parse0.isChunk();
      parse1.addPreviousPunctuation(parse0);
      parse0.show();
      Parse parse2 = parse0.adjoin(parse1, headRules0);
      assertTrue(parse0.complete());
      
      parse2.expandTopNode(parse0);
      parse1.indexOf(parse2);
      assertEquals(3, parse0.getChildCount());
      assertEquals("", parse2.getText());
  }

  @Test(timeout = 4000)
  public void testExpandTopNodeThrowsTooManyResourcesException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^^C=-]+([G[ =_=IQ)");
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[1];
      parseArray0[0] = parse0;
      Parse parse1 = ancoraSpanishHeadRules0.getHead(parseArray0, "^^C=-]+([G[ =_=IQ)");
      parse0.add(parse1, ancoraSpanishHeadRules0);
      // Undeclared exception!
      parse0.expandTopNode(parse0);
  }

  @Test(timeout = 4000)
  public void testExpandTopNodeThrowsIndexOutOfBoundsExceptionAndInsert()  throws Throwable  {
      Parse parse0 = Parse.parseParse("/=<t8-+H!");
      Parse parse1 = Parse.parseParse("/=<t8-+H!");
      parse1.insert(parse0);
      // Undeclared exception!
      try { 
        parse1.expandTopNode(parse0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetSpanReturningNull()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse0 = Parse.parseParse("d*In'{zT9j", (GapLabeler) headRules0);
      Parse parse1 = new Parse("d*In'{zT9j", (Span) null, "d*In'{zT9j", 3559.6, parse0);
      Parse.pruneParse(parse1);
      parse1.getSpan();
      assertEquals(3559.6, parse1.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse1.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetChildCountReturningPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse.fixPossesives(parse0);
      parse0.isChunk();
      parse1.addPreviousPunctuation(parse0);
      parse0.show();
      parse0.adjoin(parse1, headRules0);
      parse0.getDerivation();
      int int0 = parse0.getChildCount();
      assertEquals(1, int0);
  }

  @Test(timeout = 4000)
  public void testAddPreviousPunctuationWithParseWhereGetHeadIndexIsPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("|$P");
      parse0.getPreviousPunctuationSet();
      parse0.setNextPunctuation((Collection<Parse>) null);
      parse0.compareTo(parse0);
      parse0.setType("5_");
      parse0.isFlat();
      Parse.pruneParse(parse0);
      parse0.isChunk();
      Span span0 = new Span(0, 4, "a");
      Parse parse1 = new Parse("Parse.insert:adding con={} to {}", span0, "|$P", 4, 1);
      parse0.addPreviousPunctuation(parse1);
      parse1.show();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = null;
      try {
        headRules0 = new opennlp.tools.parser.lang.en.HeadRules((Reader) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.io.Reader", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetProbReturningNegative()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Stack<Constituent> stack0 = new Stack<Constituent>();
      headRules0.labelGaps(stack0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      Span span0 = new Span(0, 0);
      Parse parse3 = new Parse("Parse.insert:subPart contains con", span0, "Parse.insert:subPart contains con", (-4651.235), parse2);
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[1];
      parseArray0[0] = parse1;
      Parse parse4 = ancoraSpanishHeadRules0.getHead(parseArray0, "[j5]id}3,ZB[4;");
      double double0 = parse0.getTagSequenceProb();
      assertEquals(0.0, double0, 0.01);
      assertEquals(0, parse0.getHeadIndex());
      
      parse4.isChunk();
      parse2.getChildCount();
      double double1 = parse3.getProb();
      assertEquals((-4651.235), double1, 0.01);
      
      Parse.fixPossesives(parse1);
      assertEquals("TOP", parse1.getType());
  }

  @Test(timeout = 4000)
  public void testParseParseTaking2ArgumentsReturningParseWhereCompleteIsTrue()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse.parseParse("]wADk^zETs");
      Parse parse1 = Parse.parseParse("^[^ =-]+-([^ =-]+)", (GapLabeler) headRules0);
      assertEquals("=-]+ ", parse1.getText());
      assertEquals(1, parse1.getChildCount());
      assertFalse(parse1.isPosTag());
      
      StringReader stringReader0 = new StringReader("^[^ =-]+-([^ =-]+)");
      parse0.getTagNodes();
      assertFalse(parse0.equals((Object)parse1));
  }

  @Test(timeout = 4000)
  public void testGetTagNodesThrowsTooManyResourcesException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      StringWriter stringWriter0 = new StringWriter(0);
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      headRules0.serialize(stringWriter0);
      headRules0.serialize(stringWriter0);
      headRules0.serialize(stringWriter0);
      parse0.showCodeTree();
      parse0.getChildCount();
      parse0.insert(parse0);
      parse0.insert(parse0);
      parse0.remove(0);
      parse0.getLabel();
      // Undeclared exception!
      parse0.getTagNodes();
  }

  @Test(timeout = 4000)
  public void testGetCommonParentWithParseWhereGetHeadIndexIsPositive()  throws Throwable  {
      Span span0 = new Span(1, 3, "^A^h=-]:-([HH @-=I)");
      Parse parse0 = new Parse("^A^h=-]:-([HH @-=I)", span0, "-LSB-", 3, 1);
      Parse parse1 = new Parse("-LSB-", span0, "^A^h=-]:-([HH @-=I)", 3, parse0);
      Parse parse2 = parse0.getCommonParent(parse1);
      assertNull(parse2);
      assertEquals(1, parse1.getHeadIndex());
      assertEquals("^A^h=-]:-([HH @-=I)", parse1.getType());
      assertEquals(3.0, parse1.getProb(), 0.01);
      assertEquals(3.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testShowCodeTreeThrowsNullPointerException()  throws Throwable  {
      String string0 = "Vo+EBpfSF\"]";
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse0.add(parse0, headRules0);
      Parse.parseParse("Vo+EBpfSF\"]");
      // Undeclared exception!
      try { 
        parse0.showCodeTree();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.parser.Parse.hashCode()\" because the return value of \"opennlp.tools.parser.Parse.getParent()\" is null
         //
         verifyException("opennlp.tools.parser.Parse", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetDerivationReturningStringBufferWhereLengthIsZero()  throws Throwable  {
      Parse parse0 = Parse.parseParse("9XlK:w<rOS(w;X:8Q");
      Parse parse1 = Parse.parseParse("9XlK:w<rOS(w;X:8Q");
      StringBuffer stringBuffer0 = new StringBuffer();
      parse1.setDerivation(stringBuffer0);
      parse1.addNextPunctuation(parse0);
      StringBuffer stringBuffer1 = parse1.getDerivation();
      parse0.show(stringBuffer1);
      assertEquals(6, stringBuffer1.length());
      assertEquals("(TOP )", stringBuffer1.toString());
  }

  @Test(timeout = 4000)
  public void testExpandTopNodeWithParseWhereCompleteIsTrueAndParseWhereGetChildCountIsPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =-=+Q)");
      // Undeclared exception!
      try { 
        parse0.expandTopNode(parse0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 2, Size: 1
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testIndexOfReturningZero()  throws Throwable  {
      Parse parse0 = Parse.parseParse("V$+EBpfc'\"]");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("V$+EBpfc'\"]", (GapLabeler) headRules0);
      assertTrue(parse1.equals((Object)parse0));
      
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("V$+EBpfc'\"]");
      parse2.getChildren();
      opennlp.tools.parser.lang.en.HeadRules headRules1 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse0.getTagSequenceProb();
      parse2.getCoveredText();
      int int0 = parse0.indexOf(parse2);
      assertFalse(parse2.equals((Object)parse0));
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testShowTakingStringBufferThrowsStringIndexOutOfBoundsException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("|$P");
      Span span0 = new Span(1, 75);
      parse0.getPreviousPunctuationSet();
      parse0.setNextPunctuation((Collection<Parse>) null);
      parse0.compareTo(parse0);
      Parse parse1 = new Parse("i1eR04l", span0, "RG", (-1168.284713588), 1);
      StringBuffer stringBuffer0 = new StringBuffer(1);
      // Undeclared exception!
      try { 
        parse1.show(stringBuffer0);
        fail("Expecting exception: StringIndexOutOfBoundsException");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingString0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("(");
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testGetTokenNodesReturningNonEmptyArray()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      int int0 = 0;
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Span span0 = new Span(0, 0);
      Parse.parseParse("Parse.insert:subPart contains con");
      Parse parse0 = new Parse("K!5=:8(F~+5", span0, (String) null, 0, 0);
      Parse parse1 = Parse.parseParse("^[^ =-]+-([^ =-]+)");
      Parse parse2 = Parse.parseParse("NI(]do?OZ?1.w3Mu");
      parse2.showCodeTree();
      parse1.getTokenNodes();
      Parse parse3 = new Parse((String) null, span0, "Parse.insert:subPart contains con", 0, parse1);
      // Undeclared exception!
      try { 
        parse3.remove(3);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 3, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetHeadReturningParseWhereGetHeadIndexIsPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("|$P");
      Span span0 = new Span(1, 55);
      parse0.getPreviousPunctuationSet();
      parse0.setNextPunctuation((Collection<Parse>) null);
      parse0.compareTo(parse0);
      span0.toString();
      Parse parse1 = new Parse("i1eR04l", span0, "RG", (-1168.284713588), 1);
      parse0.isChunk();
      Parse parse2 = Parse.parseParse("-LRB-wX:8Q");
      parse2.addPreviousPunctuation(parse1);
      Parse parse3 = parse1.getHead();
      parse3.setType("-LRB-wX:8Q");
      assertEquals("-LRB-wX:8Q", parse3.getType());
      
      parse2.getTagNodes();
      assertEquals("TOP", parse2.getType());
  }

  @Test(timeout = 4000)
  public void testGetHeadReturningParseWhereGetProbIsZero()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Span span0 = new Span(0, 0);
      Parse parse0 = Parse.parseParse("Parse.insert:subPart contains con");
      parse0.setLabel((String) null);
      Parse.fixPossesives(parse0);
      parse0.isChunk();
      Parse parse1 = new Parse("NP", span0, "Parse.insert:subPart contains con", 0, (-1271));
      Parse.pruneParse(parse1);
      parse1.addPreviousPunctuation(parse0);
      parse1.getHead();
      boolean boolean0 = parse1.isPosTag();
      assertFalse(boolean0);
      assertEquals((-1271), parse1.getHeadIndex());
      assertEquals(0.0, parse1.getProb(), 0.01);
      assertEquals("Parse.insert:subPart contains con", parse1.getType());
  }

  @Test(timeout = 4000)
  public void testGetHeadReturningParseWhereGetHeadIndexIsNegative()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse0.add(parse0, headRules0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]");
      Span span0 = new Span(59, 59, 0.0);
      Parse parse2 = new Parse("-LSB-wX:8Q", span0, "-LSB-wX:8Q", 2, (-1194));
      parse2.addPreviousPunctuation(parse1);
      parse2.updateHeads(headRules0);
      parse2.getHead();
      // Undeclared exception!
      try { 
        parse2.cloneRoot(parse0, 147);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 147, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testAddPreviousPunctuationWithParseWhereCompleteIsTrueAndParseWhereGetChildCountIsPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse.fixPossesives(parse0);
      parse0.isChunk();
      parse1.addPreviousPunctuation(parse0);
      assertEquals(0, parse0.getHeadIndex());
      
      Parse parse2 = parse1.getHead();
      assertEquals("TOP", parse2.getType());
      assertFalse(parse2.isPosTag());
  }

  @Test(timeout = 4000)
  public void testGetTagNodes()  throws Throwable  {
      Parse parse0 = Parse.parseParse("(Lw;9_j6Ki021");
      Parse parse1 = Parse.parseParse("(Lw;9_j6Ki021");
      parse0.insert(parse1);
      Parse[] parseArray0 = parse0.getTagNodes();
      assertEquals(0, parse0.getHeadIndex());
      assertEquals(0, parseArray0.length);
      assertEquals("TOP", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testCloneTakingParseReturningParseWhereCompleteIsTrue()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      Parse parse3 = parse0.clone(parse1);
      parse3.toString();
      parse2.show();
      parse2.indexOf(parse3);
      parse3.toString();
      assertNotSame(parse3, parse0);
      assertEquals(1.0, parse3.getProb(), 0.01);
      assertTrue(parse3.equals((Object)parse0));
      assertEquals("TOP", parse3.getType());
      assertEquals(0, parse3.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetCommonParentReturningParseWhereCompleteIsTrue()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      StringWriter stringWriter0 = new StringWriter(0);
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      headRules0.serialize(stringWriter0);
      parse0.showCodeTree();
      parse0.getChildCount();
      Parse parse1 = Parse.parseParse("(!ixI\")2sE?", (GapLabeler) headRules0);
      assertTrue(parse1.equals((Object)parse0));
      
      parse1.insert(parse0);
      parse1.insert(parse0);
      parse1.remove(0);
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      parse0.updateHeads(ancoraSpanishHeadRules0);
      Parse parse2 = parse1.getCommonParent(parse0);
      assertNotSame(parse0, parse2);
  }

  @Test(timeout = 4000)
  public void testAddPreviousPunctuationAndIsChunkTakingNoArguments()  throws Throwable  {
      Parse parse0 = Parse.parseParse("m6bvt*[1be;+~J");
      Parse.fixPossesives(parse0);
      parse0.isChunk();
      parse0.addPreviousPunctuation(parse0);
      parse0.addPreviousPunctuation(parse0);
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetDerivation()  throws Throwable  {
      Parse parse0 = Parse.parseParse("(VFc7ixI\")Ws-?");
      parse0.getTokenNodes();
      parse0.getDerivation();
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetSpan()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%F+i-R)mIft\"^nMte");
      assertEquals("TOP", parse0.getType());
      
      parse0.getSpan();
      assertEquals("", parse0.getText());
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetCoveredTextReturningNonEmptyString()  throws Throwable  {
      Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      Span span0 = new Span(0, 80);
      Parse.parseParse("Parse.insert:subPart contains con");
      Parse parse0 = new Parse("K!5=:8(F~+5", span0, (String) null, 0, 0);
      Parse parse1 = Parse.parseParse("^[^ =-]+-([^ =-]+)");
      String string0 = parse1.getCoveredText();
      assertEquals(0, parse1.getHeadIndex());
      assertEquals("=-]+ ", string0);
      assertFalse(parse1.isPosTag());
      assertEquals("TOP", parse1.getType());
      assertEquals(1, parse1.getChildCount());
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringThrowsIndexOutOfBoundsException()  throws Throwable  {
      StringReader stringReader0 = new StringReader("");
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(stringReader0);
      Parse[] parseArray0 = new Parse[2];
      Parse parse0 = Parse.parseParse("", (GapLabeler) headRules0);
      parseArray0[0] = parse0;
      Parse parse1 = Parse.parseParse("rZWv~", (GapLabeler) headRules0);
      parseArray0[1] = parse1;
      parse1.addPreviousPunctuation(parse1);
      Parse parse2 = headRules0.getHead(parseArray0, "");
      parse2.getPreviousPunctuationSet();
      parse0.isChunk();
      // Undeclared exception!
      try { 
        parse2.expandTopNode(parse0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetTypeReturningEmptyString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      Parse.parseParse("");
      Parse.parseParse("(!ixI\")2sE?");
      parse0.setType("");
      StringBuffer stringBuffer0 = new StringBuffer();
      parse0.show(stringBuffer0);
      assertEquals("( )", stringBuffer0.toString());
      
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse.pruneParse(parse0);
      String string0 = parse0.getType();
      assertEquals("", string0);
  }

  @Test(timeout = 4000)
  public void testGetChildrenReturningNonEmptyArray()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Parse.insert:con contains subPart");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Parse.insert:con contains subPart", (GapLabeler) headRules0);
      parse1.add(parse0, headRules0);
      Parse parse2 = Parse.parseParse("");
      parse1.getChildren();
      assertEquals(0, parse1.getHeadIndex());
      
      opennlp.tools.parser.lang.en.HeadRules headRules1 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse3 = Parse.parseParse("!ixI\"", (GapLabeler) headRules0);
      double double0 = parse2.getTagSequenceProb();
      assertEquals(0.0, double0, 0.01);
      
      parse3.getCoveredText();
      assertEquals(1.0, parse3.getProb(), 0.01);
      assertEquals("TOP", parse3.getType());
  }

  @Test(timeout = 4000)
  public void testIsPosTagAndGetTokenNodes()  throws Throwable  {
      Parse parse0 = Parse.parseParse("9GlK:w<rOS(wX:8Q");
      Parse parse1 = Parse.parseParse("9GlK:w<rOS(wX:8Q");
      Parse parse2 = (Parse)parse1.clone();
      parse2.isPosTag();
      Parse[] parseArray0 = parse2.getTokenNodes();
      assertEquals(0, parseArray0.length);
      assertTrue(parse2.equals((Object)parse0));
      assertEquals("TOP", parse2.getType());
  }

  @Test(timeout = 4000)
  public void testCloneTakingParseReturningParseWhereIsPosTagIsFalse()  throws Throwable  {
      Parse parse0 = Parse.parseParse("s;565");
      StringReader stringReader0 = new StringReader("s;565");
      Parse parse1 = parse0.clone(parse0);
      parse1.toString();
      parse0.toString();
      String string0 = "NN";
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = null;
      try {
        ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(stringReader0);
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.StringTokenizer", e);
      }
  }

  @Test(timeout = 4000)
  public void testCloneTakingParseAndFixPossesivesAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%VXEi-R)mIfr\"^nMJe");
      Parse parse1 = parse0.clone(parse0);
      Parse.fixPossesives(parse1);
      assertEquals("TOP", parse1.getType());
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertNotSame(parse1, parse0);
      assertEquals(0, parse1.getHeadIndex());
      assertEquals("", parse1.getText());
      assertNotSame(parse0, parse1);
  }

  @Test(timeout = 4000)
  public void testCloneRootAndInsert()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Writer writer0 = Writer.nullWriter();
      headRules0.serialize(writer0);
      parse0.add(parse0, headRules0);
      parse0.setType("Vo+EBpfSF\"]");
      Span span0 = new Span(0, 80);
      Parse parse1 = parse0.cloneRoot(parse0, 0);
      parse1.setParent(parse0);
      parse0.insert(parse1);
      assertEquals("Vo+EBpfSF\"]", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testEqualsAndParseParseTakingString0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("c/HcrG,yqC\"4");
      boolean boolean0 = parse0.equals(parse0);
      assertTrue(boolean0);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals(1.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndToStringPennTreebank1()  throws Throwable  {
      Parse parse0 = Parse.parseParse("f(#WY66Xd}^t");
      String string0 = parse0.toStringPennTreebank();
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("(TOP )", string0);
  }

  @Test(timeout = 4000)
  public void testGetTypeAndToStringPennTreebank()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([GH =-=I;)");
      Span span0 = new Span(2, 2, "^[^C=-]+-([GH =-=I;)", 2);
      Parse parse1 = new Parse("^[^C=-]+-([GH =-=I;)", span0, "^[^C=-]+-([GH =-=I;)", 2, 2);
      parse0.insert(parse1);
      Span[] spanArray0 = new Span[3];
      spanArray0[0] = span0;
      Parse[] parseArray0 = new Parse[3];
      parseArray0[0] = parse1;
      Parse.parseParse("dIOF6GT");
      parseArray0[1] = parse0;
      parseArray0[2] = parse1;
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(TOP ([GH =-(^[^C=-]+-([GH =-=I;) )=I;) )", string0);
      
      parse0.getType();
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertFalse(parse0.isPosTag());
      assertEquals("=-=I; ", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndShowTakingNoArguments0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[' =-]+-([^ =]+)");
      parse0.show();
      assertFalse(parse0.isPosTag());
      assertEquals("TOP", parse0.getType());
      assertEquals("=]+ ", parse0.getText());
      assertEquals(0, parse0.getHeadIndex());
      assertTrue(parse0.complete());
  }

  @Test(timeout = 4000)
  public void testRemove()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      StringWriter stringWriter0 = new StringWriter(0);
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      headRules0.serialize(stringWriter0);
      parse0.showCodeTree();
      parse0.getChildCount();
      Parse parse1 = Parse.parseParse("(!ixI\")2sE?", (GapLabeler) headRules0);
      parse1.insert(parse0);
      parse1.insert(parse0);
      parse1.remove(0);
      String string0 = parse0.getType();
      assertEquals("TOP", string0);
      
      parse0.getTokenNodes();
      assertEquals("", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testFixPossesivesThrowsTooManyResourcesExceptionAndRemoveWithZero()  throws Throwable  {
      Parse parse0 = Parse.parseParse("stack.size={}");
      StringWriter stringWriter0 = new StringWriter(0);
      parse0.showCodeTree();
      parse0.getChildCount();
      parse0.insert(parse0);
      parse0.insert(parse0);
      parse0.remove(0);
      // Undeclared exception!
      Parse.fixPossesives(parse0);
  }

  @Test(timeout = 4000)
  public void testAddNamesWithEmptyArrayAndAddNames()  throws Throwable  {
      Span[] spanArray0 = new Span[0];
      Parse[] parseArray0 = new Parse[0];
      Parse.addNames("'%W>%{C[,U", spanArray0, parseArray0);
      assertEquals(0, spanArray0.length);
  }

  @Test(timeout = 4000)
  public void testAddNamesWithNull()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      parse0.show();
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse.parseParse("Vo+EBpfSF\"]");
      Parse.fixPossesives(parse0);
      Span span0 = new Span(93, 93, 102);
      Span span1 = new Span(span0, (double) 102);
      Span[] spanArray0 = new Span[0];
      Parse.addNames("{(\"rEQ~vwaOE_}G", spanArray0, (Parse[]) null);
      assertEquals(0, spanArray0.length);
  }

  @Test(timeout = 4000)
  public void testComplete()  throws Throwable  {
      Parse parse0 = Parse.parseParse("s;b565");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("D#st\"", (GapLabeler) headRules0);
      parse1.add(parse0, headRules0);
      Parse parse2 = Parse.parseParse("D#st\"");
      parse2.getCommonParent(parse0);
      Span span0 = new Span(0, 0, (-1350.1170182));
      Span span1 = new Span(span0, 1444);
      Parse parse3 = new Parse("Parse.getTagSequenceProb: Wrong base case!", span1, "-RRB-", (-1350.1170182), 0);
      parse3.hashCode();
      Object object0 = parse1.clone();
      parse2.equals(object0);
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      parse1.updateHeads(ancoraSpanishHeadRules0);
      assertTrue(parse1.complete());
      
      boolean boolean0 = parse0.complete();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCompleteReturningTrue()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader.nullReader();
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      parse2.setType("Vo+EBpfSF\"]");
      opennlp.tools.parser.lang.en.HeadRules headRules1 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse.parseParse("s", (GapLabeler) headRules1);
      Span span0 = new Span(0, 4);
      Span span1 = new Span(span0, 4);
      Parse parse3 = new Parse("~nLyKz", span1, "s", 127.74673868, 4);
      parse1.hashCode();
      Parse parse4 = new Parse("~nLyKz", span0, "``", 127.74673868, (Parse) null);
      parse4.equals("~nLyKz");
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      parse2.updateHeads(ancoraSpanishHeadRules0);
      boolean boolean0 = parse0.complete();
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testCompleteAndParseParseTakingString0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =?-=}Q)");
      boolean boolean0 = parse0.complete();
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
      assertEquals("=?-=}Q ", parse0.getText());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetHeadIndexReturningZero()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      parse2.setType("Vo+EBpfSF\"]");
      Span span0 = new Span(0, 80);
      Parse parse3 = new Parse((String) null, span0, "Parse.insert:subPart contains con", (-1350.1170182), 80);
      parse3.hashCode();
      parse0.equals(parse3);
      parse2.updateHeads(headRules0);
      assertEquals("Vo+EBpfSF\"]", parse2.getType());
      
      parse1.getHeadIndex();
      assertTrue(parse1.equals((Object)parse2));
  }

  @Test(timeout = 4000)
  public void testEqualsReturningTrue()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      Span span0 = new Span(199, 199, "", (-2220.3));
      Parse parse1 = Parse.parseParse("(!ixI\")2sE?");
      parse0.showCodeTree();
      parse0.getTokenNodes();
      parse1.setParent(parse0);
      parse1.getCoveredText();
      parse0.getParent();
      parse1.hashCode();
      boolean boolean0 = parse1.equals(parse0);
      assertTrue(boolean0);
      
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      parse0.updateHeads(ancoraSpanishHeadRules0);
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringReturningParseWhereCompleteIsTrue()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      parse2.setType("Vo+EBpfSF\"]");
      Span span0 = new Span(0, 80);
      Parse parse3 = new Parse((String) null, span0, "Parse.insert:subPart contains con", (-1350.1170182), 80);
      parse3.hashCode();
      parse2.equals(reader0);
      assertEquals("Vo+EBpfSF\"]", parse2.getType());
      
      Parse parse4 = new Parse("K!5=:8(F~+5", span0, (String) null, 2159.78924187, 60);
      Parse parse5 = Parse.parseParse("^[^ =-]+-([^ =-]+)");
      parse0.equals(parse5);
      parse3.updateHeads(headRules0);
      parse1.getCoveredText();
      assertFalse(parse1.equals((Object)parse5));
  }

  @Test(timeout = 4000)
  public void testPruneParseThrowsNullPointerExceptionAndIsFlat()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse0.add(parse0, headRules0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]");
      parse1.setType((String) null);
      parse1.getText();
      parse0.isFlat();
      // Undeclared exception!
      try { 
        Parse.pruneParse(parse0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testIsPosTagAndParseParseTakingString0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =?-=}Q)");
      parse0.isPosTag();
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("=?-=}Q ", parse0.getText());
      assertEquals("TOP", parse0.getType());
      assertEquals(1, parse0.getChildCount());
  }

  @Test(timeout = 4000)
  public void testGetLabelAndParseParseTaking2Arguments()  throws Throwable  {
      Parse parse0 = new Parse("*\"=1}+s}?", (Span) null, "2:c3WMOl", 0.0, 372);
      char[] charArray0 = new char[6];
      charArray0[0] = '`';
      String string0 = parse0.getLabel();
      assertNull(string0);
      
      Parse[] parseArray0 = parse0.getTokenNodes();
      assertEquals(0, parseArray0.length);
      assertEquals(372, parse0.getHeadIndex());
      
      charArray0[1] = '<';
      charArray0[2] = '#';
      charArray0[3] = 'A';
      charArray0[4] = ':';
      charArray0[5] = ':';
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse1 = Parse.parseParse("0", (GapLabeler) ancoraSpanishHeadRules0);
      assertEquals(1.0, parse1.getProb(), 0.01);
      assertEquals("", parse1.getText());
      assertEquals("TOP", parse1.getType());
  }

  @Test(timeout = 4000)
  public void testGetLabelAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%VXEi-R)mIfr\"^nMte");
      String string0 = parse0.getLabel();
      assertEquals("", parse0.getText());
      assertEquals("TOP", parse0.getType());
      assertNull(string0);
      assertEquals(1.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testAddNames1()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([GH =-=I;)");
      Span span0 = new Span(2, 2, "^[^C=-]+-([GH =-=I;)", 2);
      Parse parse1 = new Parse("^[^C=-]+-([GH =-=I;)", span0, "^[^C=-]+-([GH =-=I;)", 2, 2);
      parse0.insert(parse1);
      Span[] spanArray0 = new Span[3];
      spanArray0[0] = span0;
      spanArray0[1] = span0;
      spanArray0[2] = span0;
      Parse[] parseArray0 = new Parse[3];
      parseArray0[0] = parse1;
      parseArray0[1] = parse0;
      parseArray0[2] = parse1;
      Parse.addNames("^[^C=-]+-([GH =-=I;)", spanArray0, parseArray0);
      assertEquals(3, spanArray0.length);
  }

  @Test(timeout = 4000)
  public void testAddNamesWithEmptyArrayAndAddNamesThrowsNullPointerException()  throws Throwable  {
      Span[] spanArray0 = new Span[1];
      Parse[] parseArray0 = new Parse[0];
      // Undeclared exception!
      try { 
        Parse.addNames("^[^C=-]+-([GH =-=I<)", spanArray0, parseArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Span.getStart()\" because \"nameTokenSpan\" is null
         //
         verifyException("opennlp.tools.parser.Parse", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetParentReturningParseWhereIsPosTagIsFalse()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      Span span0 = new Span(199, 199, "", (-2220.3));
      Parse parse1 = Parse.parseParse("(!ixI\")2sE?");
      parse0.showCodeTree();
      parse1.getTokenNodes();
      parse1.setParent(parse0);
      parse0.getCoveredText();
      Parse parse2 = parse1.getParent();
      // Undeclared exception!
      try { 
        parse2.cloneRoot(parse0, 15);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 15, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndUpdateHeads()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      Parse parse0 = Parse.parseParse("^%[^ =-(7]+-([^ =-+)");
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse0.updateHeads(headRules0);
      assertFalse(parse0.isPosTag());
      assertEquals(0, parse0.getHeadIndex());
      assertTrue(parse0.complete());
      assertEquals("=-+ ", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testCompleteReturningFalse()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      parse2.setType("Vo+EBpfSF\"]");
      Span span0 = new Span(0, 80);
      Parse parse3 = new Parse((String) null, span0, "Parse.insert:subPart contains con", (-1350.1170182), 80);
      parse3.hashCode();
      parse2.equals(reader0);
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      parse0.updateHeads(ancoraSpanishHeadRules0);
      boolean boolean0 = parse1.complete();
      assertFalse(parse1.equals((Object)parse0));
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCompleteAndParseParseTakingString1()  throws Throwable  {
      Parse parse0 = Parse.parseParse("/qKz=ESj");
      boolean boolean0 = parse0.complete();
      assertEquals("", parse0.getText());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
      assertFalse(boolean0);
      assertEquals(1.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testCloneRootWithNull()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([Gl =TtIQ)");
      // Undeclared exception!
      try { 
        parse0.cloneRoot((Parse) null, 40);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 40, Size: 1
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testCloneRootAndCloneRootThrowsIndexOutOfBoundsException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("9Gl::wRrOS(wX:PQ");
      Parse parse1 = Parse.parseParse("9Gl::wRrOS(wX:PQ");
      StringWriter stringWriter0 = new StringWriter(199);
      StringWriter stringWriter1 = stringWriter0.append('1');
      StringWriter stringWriter2 = stringWriter1.append((CharSequence) "9Gl::wRrOS(wX:PQ");
      StringBuffer stringBuffer0 = stringWriter2.getBuffer();
      parse1.setDerivation(stringBuffer0);
      Span span0 = new Span(199, 275, "(!ixI\")2sE?", (-2220.4536514734104));
      Parse parse2 = new Parse("9Gl::wRrOS(wX:PQ", span0, "(!ixI\")2sE?", 275, 1044);
      Parse parse3 = parse1.getCommonParent(parse0);
      // Undeclared exception!
      try { 
        parse2.cloneRoot(parse3, 486);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 486, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetProbReturningPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("9Gl::wRrOS(wX:PQ");
      Parse parse1 = Parse.parseParse("9Gl::wRrOS(wX:PQ");
      Span span0 = new Span(199, 199, "(!ixI\")2sE?", (-2220.4536514734104));
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse[] parseArray0 = new Parse[8];
      parseArray0[0] = parse0;
      parseArray0[1] = parse1;
      parseArray0[2] = parse0;
      parseArray0[3] = parse1;
      Parse parse2 = Parse.parseParse("(Qb");
      parseArray0[4] = parse2;
      parseArray0[5] = parse1;
      Parse parse3 = new Parse("`a'cfbCl7*", span0, "):FZjJeJ", 199, parse2);
      parseArray0[6] = parse3;
      parseArray0[7] = parse0;
      Parse parse4 = headRules0.getHead(parseArray0, "`a'cfbCl7*");
      Parse.fixPossesives(parse4);
      parse0.addPreviousPunctuation(parse0);
      parse1.getCoveredText();
      double double0 = parse1.getProb();
      assertEquals("", parse1.getText());
      assertEquals(1.0, double0, 0.01);
      assertEquals("TOP", parse1.getType());
      assertEquals(0, parse1.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testInsertAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      parse0.insert(parse0);
      parse0.insert(parse0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]");
      assertEquals(1.0, parse1.getProb(), 0.01);
      assertEquals("TOP", parse1.getType());
      assertEquals("", parse1.getText());
      assertEquals(0, parse1.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testIsPosTagAndParseParseTakingString1()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%VX$i-R)mIfr\"^nMte");
      parse0.isPosTag();
      assertEquals("TOP", parse0.getType());
      assertEquals("", parse0.getText());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals(1.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testGetTagSequenceProbAndParseParseTakingString0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^%[^ =-(7]+-([^ =-+)");
      assertEquals("TOP", parse0.getType());
      assertEquals("=-+ ", parse0.getText());
      
      parse0.getTagSequenceProb();
      assertEquals("TOP", parse0.getType());
      assertEquals("=-+ ", parse0.getText());
      assertTrue(parse0.complete());
  }

  @Test(timeout = 4000)
  public void testGetProb()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Reader reader1 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      ancoraSpanishHeadRules0.labelGaps(stack0);
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader1);
      Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules1 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Span span0 = new Span(0, 0, "Lf'=Bi:Occd^bX}Dna");
      Parse parse0 = new Parse("Lf'=Bi:Occd^bX}Dna", span0, "Lf'=Bi:Occd^bX}Dna", 0, 0);
      double double0 = parse0.getProb();
      assertEquals("Lf'=Bi:Occd^bX}Dna", parse0.getText());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals(0.0, double0, 0.01);
      assertEquals("Lf'=Bi:Occd^bX}Dna", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testCloneTakingParseThrowsIndexOutOfBoundsExceptionAndUpdateHeads()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse0 = Parse.parseParse("", (GapLabeler) headRules0);
      StringWriter stringWriter0 = new StringWriter(0);
      headRules0.serialize(stringWriter0);
      parse0.showCodeTree();
      parse0.getChildCount();
      Parse parse1 = Parse.parseParse("", (GapLabeler) headRules0);
      parse0.insert(parse1);
      parse1.equals(stringWriter0);
      parse1.updateHeads(headRules0);
      Parse parse2 = Parse.parseParse("");
      // Undeclared exception!
      try { 
        parse0.clone(parse2);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: -1, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsChunkTakingBooleanAndGetTagSequenceProbAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^CE-]+W([G =-a+Q)");
      parse0.isChunk(true);
      double double0 = parse0.getTagSequenceProb();
      assertEquals(0.0, double0, 0.01);
      assertTrue(parse0.complete());
      assertFalse(parse0.isPosTag());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
      assertEquals("=-a+Q ", parse0.toString());
  }

  @Test(timeout = 4000)
  public void testIsChunkTakingBooleanAndIsChunkTakingBoolean()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse0 = Parse.parseParse("", (GapLabeler) headRules0);
      StringWriter stringWriter0 = new StringWriter(0);
      headRules0.serialize(stringWriter0);
      parse0.showCodeTree();
      parse0.getChildCount();
      Parse parse1 = Parse.parseParse("", (GapLabeler) headRules0);
      parse0.insert(parse1);
      parse1.setParent(parse0);
      Stack<Constituent> stack0 = new Stack<Constituent>();
      headRules0.labelGaps(stack0);
      parse1.getCoveredText();
      parse1.isChunk(true);
      assertTrue(parse1.isChunk());
  }

  @Test(timeout = 4000)
  public void testGetCommonParentReturningParseWhereIsPosTagIsFalse()  throws Throwable  {
      Parse parse0 = Parse.parseParse("9Gl::wRrOS(wX:PQ");
      Parse parse1 = Parse.parseParse("9Gl::wRrOS(wX:PQ");
      Span span0 = new Span(199, 275, "(!ixI\")2sE?", (-2220.4536514734104));
      Parse parse2 = new Parse("9Gl::wRrOS(wX:PQ", span0, "(!ixI\")2sE?", 275, 1044);
      Parse parse3 = parse1.getCommonParent(parse0);
      assertEquals("", parse3.getText());
      assertFalse(parse3.equals((Object)parse2));
      assertNotNull(parse3);
      assertNotSame(parse3, parse1);
      assertEquals(0, parse3.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testCompareToReturningPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Span span0 = new Span(4432, 4432);
      Parse parse1 = new Parse("Vo+EBpfSF\"]", span0, (String) null, (-3567.1342356), (-277));
      parse0.getPreviousPunctuationSet();
      parse1.setNextPunctuation((Collection<Parse>) null);
      parse1.compareTo(parse0);
      Parse.parseParse("k(}?716:^");
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse2 = Parse.parseParse("}C0L", (GapLabeler) ancoraSpanishHeadRules0);
      parse2.show();
      Parse parse3 = new Parse("RG", span0, "-RSB-", 1, 10);
      parse2.getDerivation();
      // Undeclared exception!
      try { 
        parse3.show((StringBuffer) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testIndexOfAndAdd()  throws Throwable  {
      Parse parse0 = Parse.parseParse("VP+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse0.add(parse0, headRules0);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("", parse0.getText());
      assertEquals(1.0, parse0.getProb(), 0.01);
      
      Parse parse1 = Parse.parseParse("VP+EBpfSF\"]");
      int int0 = parse0.indexOf(parse1);
      assertEquals("", parse1.getText());
      assertEquals("TOP", parse1.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals(1.0, parse1.getProb(), 0.01);
      assertEquals((-1), int0);
  }

  @Test(timeout = 4000)
  public void testRemoveThrowsIndexOutOfBoundsExceptionAndGetCommonParent()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader.nullReader();
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      headRules0.labelGaps(stack0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      parse2.setType("Vo+EBpfSF\"]");
      parse2.getCommonParent(parse0);
      Span span0 = new Span(0, 80);
      Parse parse3 = new Parse((String) null, span0, "Parse.insert:subPart contains con", (-1350.1170182), 80);
      // Undeclared exception!
      try { 
        parse3.remove(0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetCommonParent()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      Span span0 = new Span(199, 199, "", (-2220.3));
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[7];
      parseArray0[0] = parse0;
      parseArray0[1] = parse0;
      parseArray0[2] = parse0;
      parseArray0[3] = parse0;
      Parse parse1 = new Parse("", span0, "biJq$`xbJ|aQ^Vr2>5", 199, parse0);
      assertEquals(0, parse1.getHeadIndex());
      
      parseArray0[4] = parse1;
      parseArray0[5] = parse0;
      parseArray0[6] = parse0;
      Parse parse2 = ancoraSpanishHeadRules0.getHead(parseArray0, "");
      Parse parse3 = parse0.getCommonParent(parse2);
      assertNull(parse3);
      
      String string0 = parse0.getText();
      assertEquals("", string0);
      
      boolean boolean0 = parse0.isFlat();
      assertTrue(boolean0);
      
      Parse.pruneParse(parse0);
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetCommonParentAndParseParseTakingString0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([GH =-=I<)");
      Parse parse1 = parse0.getCommonParent(parse0);
      assertEquals(0, parse0.getHeadIndex());
      assertNull(parse1);
      assertEquals(1, parse0.getChildCount());
      assertEquals("TOP", parse0.getType());
      assertFalse(parse0.isPosTag());
      assertEquals("=-=I< ", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testShowTakingNoArgumentsThrowsNullPointerException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Ao`1*Kov&");
      Span span0 = new Span(30, 30, (String) null, (-2220.4536514734104));
      parse0.updateHeads((HeadRules) null);
      parse0.getType();
      Parse parse1 = new Parse("h.2uK;s];m#Y\"y^iE", span0, "NC.*S.*", (-2220.4536514734104), 199);
      parse1.getText();
      Parse parse2 = new Parse("h.2uK;s];m#Y\"y^iE", span0, (String) null, 30, 86);
      parse1.setParent(parse2);
      // Undeclared exception!
      try { 
        parse2.show();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testGetHeadReturningParseWhereCompleteIsTrue()  throws Throwable  {
      Parse parse0 = Parse.parseParse("|$P");
      Span span0 = new Span(1, 75);
      parse0.getPreviousPunctuationSet();
      parse0.setNextPunctuation((Collection<Parse>) null);
      StringWriter stringWriter0 = new StringWriter(32);
      Stack<Constituent> stack0 = new Stack<Constituent>();
      Reader.nullReader();
      parse0.showCodeTree();
      parse0.getChildCount();
      parse0.insert(parse0);
      Parse parse1 = parse0.getHead();
      assertEquals("", parse1.getText());
      assertEquals("TOP", parse1.getType());
      assertEquals(0, parse1.getHeadIndex());
      assertEquals(1.0, parse1.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testEqualsWithNonNull()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader.nullReader();
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      String string0 = null;
      parse2.setType((String) null);
      Span span0 = new Span(0, 80);
      Parse parse3 = new Parse((String) null, span0, "Parse.insert:subPart contains con", (-1350.1170182), 80);
      parse3.hashCode();
      Object object0 = new Object();
      parse3.equals(object0);
      parse1.getText();
      Parse[] parseArray0 = null;
      // Undeclared exception!
      try { 
        headRules0.getHead((Parse[]) null, "0%B/{h_63)MXyK");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot load from object array because \"constituents\" is null
         //
         verifyException("opennlp.tools.parser.lang.en.HeadRules", e);
      }
  }

  @Test(timeout = 4000)
  public void testInsertWithParseWhereGetProbIsNegative()  throws Throwable  {
      Parse parse0 = Parse.parseParse("|$P");
      Span span0 = new Span(1, 75);
      Parse parse1 = new Parse((String) null, span0, "|$P", (-3478.97005), 1);
      parse1.getPreviousPunctuationSet();
      parse0.setNextPunctuation((Collection<Parse>) null);
      StringWriter stringWriter0 = new StringWriter(32);
      Stack<Constituent> stack0 = new Stack<Constituent>();
      Reader.nullReader();
      parse0.showCodeTree();
      parse0.getChildCount();
      // Undeclared exception!
      try { 
        parse0.insert(parse1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Inserting constituent not contained in the sentence!
         //
         verifyException("opennlp.tools.parser.Parse", e);
      }
  }

  @Test(timeout = 4000)
  public void testInsertThrowsIllegalArgumentException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[C([+-([H =N==5)");
      Parse parse1 = Parse.parseParse("}#'z?qww>}");
      // Undeclared exception!
      try { 
        parse1.insert(parse0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Inserting constituent not contained in the sentence!
         //
         verifyException("opennlp.tools.parser.Parse", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetTextReturningNull()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader.nullReader();
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      assertTrue(parse1.equals((Object)parse0));
      
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      parse2.setType((String) null);
      Span span0 = new Span(0, 80);
      Parse parse3 = new Parse((String) null, span0, "Parse.insert:subPart contains con", (-1350.1170182), 80);
      parse3.hashCode();
      boolean boolean0 = parse0.equals(parse3);
      assertFalse(boolean0);
      
      parse3.getText();
      parse1.isFlat();
      Parse.pruneParse(parse1);
      assertTrue(parse1.equals((Object)parse2));
  }

  @Test(timeout = 4000)
  public void testPruneParseThrowsNullPointerExceptionAndPruneParse()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader.nullReader();
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      assertTrue(parse1.equals((Object)parse0));
      
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      parse2.setType((String) null);
      Span span0 = new Span(0, 80);
      Parse parse3 = new Parse((String) null, span0, "Parse.insert:subPart contains con", (-1350.1170182), 80);
      parse3.hashCode();
      boolean boolean0 = parse0.equals(parse3);
      assertFalse(boolean0);
      
      parse0.getText();
      boolean boolean1 = parse3.isFlat();
      assertTrue(boolean1);
      
      // Undeclared exception!
      try { 
        Parse.pruneParse(parse0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testPruneParseThrowsNullPointerException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("VP+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse0.add(parse0, headRules0);
      // Undeclared exception!
      try { 
        Parse.pruneParse(parse0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndPruneParse()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =-=+Q)");
      assertEquals("TOP", parse0.getType());
      
      Parse.pruneParse(parse0);
      assertFalse(parse0.isPosTag());
      assertTrue(parse0.complete());
      assertEquals("=-=+Q ", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testAdjoinRootThrowsIndexOutOfBoundsException()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[4];
      Parse parse0 = Parse.parseParse("G?5/F");
      parseArray0[0] = parse0;
      Parse parse1 = Parse.parseParse("G?5/F", (GapLabeler) ancoraSpanishHeadRules0);
      parseArray0[1] = parse1;
      Span span0 = new Span(0, 0, 0);
      Span span1 = new Span(span0, 0);
      Parse parse2 = new Parse("G?5/F", span1, "G?5/F", (-1.0), 0);
      parseArray0[2] = parse2;
      Parse parse3 = new Parse("G?5/F", span0, "[([ej5,~&xbr", 0, parse0);
      parseArray0[3] = parse3;
      Parse parse4 = ancoraSpanishHeadRules0.getHead(parseArray0, "Q17> ");
      Parse.useFunctionTags(false);
      parse2.getCoveredText();
      Parse parse5 = ancoraSpanishHeadRules0.getHead(parseArray0, "[([ej5,~&xbr");
      parse2.indexOf(parse5);
      parse1.getCoveredText();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      // Undeclared exception!
      try { 
        parse1.adjoinRoot(parse4, headRules0, 0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTaking2ArgumentsThrowsNullPointerExceptionAndGetTagSequenceProb()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader.nullReader();
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      parse2.setType("Vo+EBpfSF\"]");
      opennlp.tools.parser.lang.en.HeadRules headRules1 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse.parseParse("s", (GapLabeler) headRules1);
      parse0.getTagSequenceProb();
      Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules2 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      headRules2.labelGaps(stack0);
      headRules0.labelGaps(stack0);
      // Undeclared exception!
      try { 
        Parse.parseParse((String) null, (GapLabeler) headRules2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCompareToWithParseWhereGetHeadIndexIsPositiveAndParseWhereGetProbIsNegative()  throws Throwable  {
      Parse parse0 = Parse.parseParse("|$P");
      Span span0 = new Span(1, 75);
      Parse parse1 = new Parse((String) null, span0, "|$P", (-3478.97005), 1);
      parse1.getPreviousPunctuationSet();
      parse0.setNextPunctuation((Collection<Parse>) null);
      parse0.compareTo(parse1);
      parse1.clone();
      Parse parse2 = Parse.parseParse("");
      parse0.show();
      Parse parse3 = new Parse("i1eR04l", span0, "RG", (-1168.284713588), 83);
      parse0.getDerivation();
      parse2.getTagSequenceProb();
      String string0 = "NC.*P.*";
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = null;
      try {
        ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules((Reader) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.io.Reader", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetTagSequenceProbAndGetCoveredText()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Span span0 = new Span(0, 0);
      Parse parse0 = Parse.parseParse("Parse.insert:subPart contains con");
      Parse parse1 = Parse.parseParse("^[^ =-]+-([^ =-]+)");
      parse0.updateHeads(headRules0);
      opennlp.tools.parser.lang.en.HeadRules headRules1 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      double double0 = parse1.getTagSequenceProb();
      assertEquals(0.0, double0, 0.01);
      assertEquals("=-]+ ", parse1.toString());
      
      Parse parse2 = new Parse("x%rc eK/", span0, "^[^ =-]+-([^ =-]+)", 0.0, parse0);
      parse2.getCoveredText();
      assertEquals("^[^ =-]+-([^ =-]+)", parse2.getType());
      assertEquals(0, parse2.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetTagSequenceProbAndParseParseTakingString1()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpvS\"]");
      double double0 = parse0.getTagSequenceProb();
      assertEquals("", parse0.getText());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void testSetParentAndGetCoveredText()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      Span span0 = new Span(199, 199, "", (-2220.3));
      Parse parse1 = Parse.parseParse("(!ixI\")2sE?");
      parse1.getTokenNodes();
      parse1.setParent(parse0);
      parse0.getCoveredText();
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
      assertEquals("", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testGetCoveredTextReturningEmptyString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      Span span0 = new Span(199, 199, "", (-2220.3));
      Parse.pruneParse(parse0);
      String string0 = parse0.getText();
      assertEquals("", string0);
      
      parse0.show();
      Parse.useFunctionTags(true);
      parse0.getCoveredText();
      parse0.getTagNodes();
      assertEquals(0, parse0.getHeadIndex());
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testIsFlat()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      parse2.setType((String) null);
      parse2.getText();
      parse0.isFlat();
      // Undeclared exception!
      try { 
        Parse.pruneParse(parse0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testIsFlatAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =?-=}Q)");
      boolean boolean0 = parse0.isFlat();
      assertEquals("=?-=}Q ", parse0.getText());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testUpdateSpanThrowsIndexOutOfBoundsException()  throws Throwable  {
      Span span0 = new Span(591, 591, 0.0);
      Span span1 = new Span(span0, (double) 591);
      Parse parse0 = new Parse("7+]i@B)pwg(m3ZXO'", span0, "^o4SR7vK", (-1.0), 591);
      Parse parse1 = new Parse("|$P", span1, (String) null, 0.0, parse0);
      // Undeclared exception!
      try { 
        parse1.updateSpan();
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testAddProbWithNegative()  throws Throwable  {
      Parse parse0 = Parse.parseParse("}>");
      parse0.addProb((-1.0));
      // Undeclared exception!
      try { 
        parse0.expandTopNode(parse0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testAddProb()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse0 = Parse.parseParse("", (GapLabeler) headRules0);
      StringWriter stringWriter0 = new StringWriter(0);
      Stack<Constituent> stack0 = new Stack<Constituent>();
      headRules0.labelGaps(stack0);
      headRules0.serialize(stringWriter0);
      parse0.showCodeTree();
      parse0.getChildCount();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[7];
      parseArray0[0] = parse0;
      parseArray0[1] = parse0;
      parseArray0[0] = parse0;
      parseArray0[3] = parse0;
      parseArray0[4] = parse0;
      parseArray0[5] = parse0;
      parseArray0[6] = parse0;
      Parse parse1 = ancoraSpanishHeadRules0.getHead(parseArray0, "");
      parse0.addPreviousPunctuation(parse1);
      parse1.showCodeTree();
      parse0.addProb(0);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testParseParseTakingString1()  throws Throwable  {
      String string0 = "&O?T(rG,RDVu{p:h=";
      Parse.parseParse("&O?T(rG,RDVu{p:h=");
      String string1 = "";
      int int0 = 927;
      Span span0 = null;
      try {
        span0 = new Span(927, 10);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // start index must not be larger than end index: start=927, end=10
         //
         verifyException("opennlp.tools.util.Span", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingString2()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%F+i,R)mIft\"^nMte");
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
      assertEquals("", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testCompareToReturningNegativeAndGetDerivationReturningNull()  throws Throwable  {
      Parse parse0 = Parse.parseParse("|$P");
      Span span0 = new Span(1, 75);
      Parse parse1 = new Parse((String) null, span0, "|$P", (-3478.97005), 1);
      parse1.getPreviousPunctuationSet();
      parse0.setNextPunctuation((Collection<Parse>) null);
      parse0.compareTo(parse1);
      Parse.parseParse("");
      parse0.show();
      Parse parse2 = new Parse("i1eR04l", span0, "RG", (-1168.284713588), 83);
      parse0.getDerivation();
      // Undeclared exception!
      try { 
        parse2.show((StringBuffer) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetHeadIndexAndGetHeadIndex()  throws Throwable  {
      Parse.parseParse("");
      Span span0 = new Span(199, 199, "", (-2220.3));
      Parse parse0 = new Parse("(!ixI\")2sE?", span0, "", 0.0, 0);
      parse0.showCodeTree();
      assertEquals("", parse0.getType());
      
      Parse parse1 = new Parse("", span0, "", 0.0, 199);
      int int0 = parse1.getHeadIndex();
      assertFalse(parse1.equals((Object)parse0));
      assertEquals(199, int0);
      assertEquals(0.0, parse1.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testGetHeadIndexAndParseParseTakingStringWithNonEmptyString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^?^=-]+-w([G =-=+Q)");
      int int0 = parse0.getHeadIndex();
      assertEquals("=-=+Q ", parse0.getText());
      assertFalse(parse0.isPosTag());
      assertEquals("TOP", parse0.getType());
      assertEquals(0, int0);
      assertTrue(parse0.complete());
  }

  @Test(timeout = 4000)
  public void testGetDerivationAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("=-=I<");
      parse0.getDerivation();
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testGetDerivationAndCompareTo()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader.nullReader();
      StringBuffer stringBuffer0 = new StringBuffer("3eSW}:#`.kmsErKc");
      stringBuffer0.trimToSize();
      parse0.setDerivation(stringBuffer0);
      parse0.getChildren();
      parse0.getChildren();
      stringBuffer0.setCharAt(2, '}');
      parse0.clone();
      parse0.getSpan();
      parse0.getTokenNodes();
      GapLabeler gapLabeler0 = null;
      parse0.getDerivation();
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) null);
      List.of(parse1, parse1, parse1, parse0, parse0, parse1, parse0, parse1);
      parse0.compareTo(parse1);
      // Undeclared exception!
      try { 
        stringBuffer0.insert(41, 913L);
        fail("Expecting exception: StringIndexOutOfBoundsException");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }

  @Test(timeout = 4000)
  public void testGetTextAndEquals()  throws Throwable  {
      Parse parse0 = Parse.parseParse("|$P");
      parse0.setType("EbS9~lneuC%j");
      Span span0 = new Span(1, 1);
      Parse parse1 = new Parse("0dC)7wO<8", span0, "|$P", 1, 75);
      parse1.getChildren();
      Object object0 = parse1.clone();
      parse0.equals(object0);
      parse0.getText();
      assertEquals("EbS9~lneuC%j", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testIsChunkTakingNoArgumentsAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("m6bvt*[1be;+~J");
      parse0.isChunk();
      assertEquals("", parse0.getText());
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testIsChunkTakingNoArguments()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) ancoraSpanishHeadRules0);
      parse0.addNextPunctuation(parse1);
      Reader reader1 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      ancoraSpanishHeadRules0.labelGaps(stack0);
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader1);
      headRules0.labelGaps(stack0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      assertTrue(parse2.equals((Object)parse0));
      
      parse0.add(parse2, headRules0);
      parse1.toString();
      Parse parse3 = Parse.parseParse("Vo+EBpfSF\"]");
      parse3.setType((String) null);
      Span span0 = new Span(0, 80);
      Parse parse4 = new Parse((String) null, span0, "Parse.insert:subPart contains con", (-1350.1170182), 80);
      boolean boolean0 = parse0.equals(parse4);
      assertFalse(boolean0);
      
      parse0.getText();
      parse4.isChunk();
      assertFalse(parse4.equals((Object)parse1));
  }

  @Test(timeout = 4000)
  public void testUseFunctionTagsAndUseFunctionTags()  throws Throwable  {
      Parse parse0 = new Parse("*\"=1}+s}?", (Span) null, "2:c3WMOl", 0.0, 372);
      char[] charArray0 = new char[6];
      Parse parse1 = Parse.parseParse("2:c3WMOl");
      parse0.indexOf(parse1);
      Parse.parseParse("~{+P");
      charArray0[0] = '`';
      parse0.getChildren();
      charArray0[1] = '<';
      charArray0[2] = '#';
      charArray0[3] = 'A';
      charArray0[4] = ':';
      charArray0[5] = ':';
      Parse.useFunctionTags(true);
  }

  @Test(timeout = 4000)
  public void testUseFunctionTagsAndUseFunctionTagsWithFalse()  throws Throwable  {
      Parse.useFunctionTags(false);
  }

  @Test(timeout = 4000)
  public void testGetHeadAndGetHead()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      Parse parse1 = parse0.getHead();
      assertEquals(0, parse1.getHeadIndex());
      assertEquals("TOP", parse1.getType());
      assertEquals("", parse1.getText());
      assertEquals(1.0, parse1.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testSetLabelAndIsPosTag()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =?-=}Q)");
      parse0.setLabel("^[^C=-]+-([G =?-=}Q)");
      boolean boolean0 = parse0.isPosTag();
      assertFalse(boolean0);
      assertEquals("TOP", parse0.getType());
      assertEquals("=?-=}Q ", parse0.getText());
      assertTrue(parse0.complete());
      assertEquals("^[^C=-]+-([G =?-=}Q)", parse0.getLabel());
  }

  @Test(timeout = 4000)
  public void testSetLabelAndAdjoinThrowsIndexOutOfBoundsException()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse[] parseArray0 = new Parse[9];
      Span span0 = new Span(918, 918);
      Parse parse0 = Parse.parseParse("");
      Parse parse1 = new Parse("", span0, "8`;0~+<(\"?", 0.0, parse0);
      parseArray0[0] = parse1;
      Parse parse2 = Parse.parseParse("%5]?':\"{\"a5f=", (GapLabeler) headRules0);
      parseArray0[1] = parse2;
      Parse parse3 = Parse.parseParse("%5]?':\"{\"a5f=", (GapLabeler) headRules0);
      parseArray0[2] = parse3;
      Parse parse4 = Parse.parseParse("");
      parse4.setLabel("TK");
      Parse parse5 = new Parse("", span0, "TK", 918, parse4);
      opennlp.tools.parser.lang.en.HeadRules headRules1 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      // Undeclared exception!
      try { 
        parse3.adjoin(parse5, headRules1);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: -1, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testShowTakingNoArgumentsAndShowTakingNoArguments()  throws Throwable  {
      Parse parse0 = Parse.parseParse("|$P");
      parse0.show();
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testIsChunkTakingBooleanWithFalse()  throws Throwable  {
      Parse parse0 = Parse.parseParse("m6bvt*[1be;+~J");
      parse0.setLabel("m6bvt*[1be;+~J");
      Parse.fixPossesives(parse0);
      parse0.isChunk(false);
      boolean boolean0 = parse0.isChunk();
      assertFalse(boolean0);
      
      parse0.addPreviousPunctuation(parse0);
      Parse parse1 = parse0.getHead();
      parse0.addPreviousPunctuation(parse1);
      assertEquals("", parse1.getText());
      assertEquals("m6bvt*[1be;+~J", parse1.getLabel());
      assertEquals("TOP", parse1.getType());
      assertEquals(0, parse1.getHeadIndex());
      assertEquals(1.0, parse1.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testExpandTopNodeThrowsIndexOutOfBoundsExceptionAndAddPreviousPunctuation()  throws Throwable  {
      Parse parse0 = Parse.parseParse("[+-([H");
      parse0.addPreviousPunctuation(parse0);
      // Undeclared exception!
      try { 
        parse0.expandTopNode(parse0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testAddPreviousPunctuationAndShowCodeTree()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse0 = Parse.parseParse("", (GapLabeler) headRules0);
      StringWriter stringWriter0 = new StringWriter(0);
      Stack<Constituent> stack0 = new Stack<Constituent>();
      headRules0.labelGaps(stack0);
      headRules0.serialize(stringWriter0);
      parse0.showCodeTree();
      parse0.getChildCount();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[5];
      parseArray0[0] = parse0;
      parseArray0[1] = parse0;
      parseArray0[2] = parse0;
      parseArray0[3] = parse0;
      parseArray0[4] = parse0;
      ancoraSpanishHeadRules0.getHead(parseArray0, "");
      parse0.addPreviousPunctuation(parse0);
      parse0.showCodeTree();
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testGetTypeAndRemove()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse0 = Parse.parseParse("", (GapLabeler) headRules0);
      StringWriter stringWriter0 = new StringWriter(0);
      Stack<Constituent> stack0 = new Stack<Constituent>();
      headRules0.labelGaps(stack0);
      headRules0.serialize(stringWriter0);
      parse0.showCodeTree();
      parse0.getChildCount();
      Parse parse1 = Parse.parseParse("", (GapLabeler) headRules0);
      parse0.insert(parse1);
      parse0.remove(0);
      String string0 = parse0.getType();
      assertEquals("", parse0.getText());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", string0);
      assertEquals(1.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testFixPossesivesAndRemove()  throws Throwable  {
      Parse parse0 = Parse.parseParse("4SB-[-X([ +NU=-)");
      assertEquals(1, parse0.getChildCount());
      
      parse0.remove(0);
      Parse.fixPossesives(parse0);
      assertEquals(0, parse0.getChildCount());
      assertEquals("+NU=- ", parse0.getCoveredText());
  }

  @Test(timeout = 4000)
  public void testAdjoinThrowsIndexOutOfBoundsException()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse[] parseArray0 = new Parse[9];
      String string0 = "";
      Span span0 = new Span(918, 918);
      Parse parse0 = Parse.parseParse("");
      Parse parse1 = new Parse("", span0, "8`;0~+<(\"?", 0.0, parse0);
      parseArray0[0] = parse1;
      String string1 = "%5]?':\"{\"a5f=";
      Parse parse2 = Parse.parseParse("%5]?':\"{\"a5f=", (GapLabeler) headRules0);
      parseArray0[1] = parse2;
      Parse parse3 = Parse.parseParse("%5]?':\"{\"a5f=", (GapLabeler) headRules0);
      parseArray0[2] = parse3;
      String string2 = "";
      Parse parse4 = Parse.parseParse("");
      Parse parse5 = new Parse("", span0, "TK", 918, parse4);
      opennlp.tools.parser.lang.en.HeadRules headRules1 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      // Undeclared exception!
      try { 
        parse3.adjoin(parse5, headRules1);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: -1, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testSetDerivationWithStringBufferWhereLengthIsZero()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =?-=}Q)");
      StringBuffer stringBuffer0 = new StringBuffer();
      parse0.setDerivation(stringBuffer0);
      Parse parse1 = (Parse)parse0.clone();
      assertEquals("=?-=}Q ", parse1.getText());
      assertTrue(parse1.complete());
      assertEquals(0, parse1.getHeadIndex());
      assertEquals("TOP", parse1.getType());
      assertFalse(parse1.isPosTag());
      assertTrue(parse1.equals((Object)parse0));
  }

  @Test(timeout = 4000)
  public void testCompareTo()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader.nullReader();
      StringBuffer stringBuffer0 = new StringBuffer("3eSW}:#`.kmsErKc");
      stringBuffer0.trimToSize();
      parse0.setDerivation(stringBuffer0);
      parse0.getChildren();
      parse0.getChildren();
      stringBuffer0.setCharAt(2, '}');
      parse0.clone();
      parse0.getSpan();
      parse0.getTokenNodes();
      GapLabeler gapLabeler0 = null;
      stringBuffer0.appendCodePoint(2);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) null);
      List.of(parse1, parse1, parse1, parse0, parse0, parse1, parse0, parse1);
      parse0.compareTo(parse1);
      // Undeclared exception!
      try { 
        stringBuffer0.insert(41, 913L);
        fail("Expecting exception: StringIndexOutOfBoundsException");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }

  @Test(timeout = 4000)
  public void testUpdateHeadsAndParseParseTakingStringThrowsEmptyStackException()  throws Throwable  {
      Parse.parseParse("*\"|=1}+s}?");
      Span span0 = new Span(59, 924);
      Parse.parseParse("-RCB-}?716:^");
      Parse parse0 = new Parse("Parse.insert:subPart contains con", span0, "*\"|=1}+s}?", 59, (-1));
      Parse parse1 = Parse.parseParse("^[^ ='^]+-([^ =-]+)");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse1.updateHeads(headRules0);
      // Undeclared exception!
      try { 
        Parse.parseParse("-LSB-VFc7ixI\")Ws-?");
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testUpdateHeadsThrowsNullPointerException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =?-=}Q)");
      // Undeclared exception!
      try { 
        parse0.updateHeads((HeadRules) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.parser.HeadRules.getHead(opennlp.tools.parser.Parse[], String)\" because \"rules\" is null
         //
         verifyException("opennlp.tools.parser.Parse", e);
      }
  }

  @Test(timeout = 4000)
  public void testSetChildThrowsIndexOutOfBoundsException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("g`FGjN<1(?nQ)\"a;");
      // Undeclared exception!
      try { 
        parse0.setChild(66, "g`FGjN<1(?nQ)\"a;");
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 66, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testInsertThrowsIndexOutOfBoundsException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("F>q");
      parse0.showCodeTree();
      parse0.getTagNodes();
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse.parseParse("", (GapLabeler) headRules0);
      Span span0 = new Span(100, 100, "");
      Parse parse1 = new Parse("F>q", span0, "F>q", 100, parse0);
      parse1.getTagNodes();
      Writer writer0 = Writer.nullWriter();
      headRules0.serialize(writer0);
      Parse.parseParse("NNP");
      parse1.updateHeads(headRules0);
      parse0.getParent();
      // Undeclared exception!
      try { 
        parse0.setChild(100, "*%3pr39SC@y)y{%*gpy");
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 100, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTaking2ArgumentsThrowsNullPointerExceptionAndParseParseTaking2Arguments()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("K(", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse.parseParse("NP");
      Parse parse2 = new Parse("-RRB-[^ =-]+)", (Span) null, "-RRB-[^ =-]+)", (-13), (-13));
      parse2.getChildren();
      String string0 = "s";
      opennlp.tools.parser.lang.en.HeadRules headRules1 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      StringWriter stringWriter0 = new StringWriter();
      headRules0.serialize(stringWriter0);
      String string1 = null;
      // Undeclared exception!
      try { 
        Parse.parseParse((String) null, (GapLabeler) headRules0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCloneTakingParseThrowsIndexOutOfBoundsExceptionAndParseParseTakingStringWithNonEmptyString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%VXEi-R)mIfr\"^nMJe");
      Parse parse1 = Parse.parseParse("b(%VXEi-R)mIfr\"^nMJe");
      // Undeclared exception!
      try { 
        parse0.clone(parse1);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: -1, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesParseTaking5Arguments()  throws Throwable  {
      Parse parse0 = new Parse("-LSB-3CSM-cD~", (Span) null, "-LSB-3CSM-cD~", 0.0, (Parse) null);
      assertEquals("-LSB-3CSM-cD~", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("-LSB-3CSM-cD~", parse0.getText());
      assertEquals(0.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testCloneTakingParseAndCloneTakingParseThrowsIndexOutOfBoundsException()  throws Throwable  {
      int int0 = 0;
      Span span0 = new Span(0, 0, "", 636.5068174421347);
      Span span1 = new Span(span0, 1.0);
      span1.toString();
      Parse parse0 = new Parse("]7gaL|-", span1, "NNPS", 636.5068174421347, (Parse) null);
      // Undeclared exception!
      try { 
        parse0.clone((Parse) null);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: -1, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testInsertAndInsert()  throws Throwable  {
      Parse parse0 = Parse.parseParse("s;b565");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("D#st\"", (GapLabeler) headRules0);
      parse1.add(parse0, headRules0);
      Parse parse2 = Parse.parseParse("D#st\"");
      parse1.setType("6c]F`i9");
      parse1.getText();
      Parse.pruneParse(parse2);
      parse1.insert(parse0);
      assertFalse(parse1.complete());
  }

  @Test(timeout = 4000)
  public void testGetChildCount()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse0 = Parse.parseParse("", (GapLabeler) headRules0);
      StringWriter stringWriter0 = new StringWriter(0);
      Stack<Constituent> stack0 = new Stack<Constituent>();
      headRules0.labelGaps(stack0);
      headRules0.serialize(stringWriter0);
      parse0.showCodeTree();
      parse0.getChildCount();
      Parse parse1 = Parse.parseParse("*Mk>Ldo C,PC", (GapLabeler) headRules0);
      parse0.insert(parse1);
      // Undeclared exception!
      try { 
        parse1.remove(7);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 7, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetChildCountAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("NN");
      parse0.getChildCount();
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testPruneParse()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      assertEquals("TOP", parse1.getType());
      
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      parse1.setType((String) null);
      String string0 = parse2.getText();
      assertEquals("", string0);
      
      boolean boolean0 = parse0.isFlat();
      assertFalse(boolean0);
      
      Parse.pruneParse(parse0);
      assertEquals(0, parse0.getHeadIndex());
      assertEquals(1.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testShowTakingNoArgumentsAndShowCodeTree()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      Parse parse0 = Parse.parseParse("Parse.inse%t:subPart contains con");
      Parse parse1 = Parse.parseParse("^[^ =-]+-([^ =-]+)");
      parse1.showCodeTree();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[2];
      parseArray0[0] = parse0;
      parseArray0[1] = parse0;
      Parse parse2 = ancoraSpanishHeadRules0.getHead(parseArray0, "^[^ =-]+-([^ =-]+)");
      parse2.show();
      Reader reader1 = Reader.nullReader();
      Reader reader2 = Reader.nullReader();
      assertNotSame(reader2, reader1);
  }

  @Test(timeout = 4000)
  public void testPruneParseWithParseWhereCompleteIsFalseAndParseWhereGetChildCountIsZero()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%VXEi-R)mIfr\"^nMte");
      Parse.pruneParse(parse0);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testPruneParseWithNull()  throws Throwable  {
      // Undeclared exception!
      try { 
        Parse.pruneParse((Parse) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testShowCodeTree()  throws Throwable  {
      String string0 = "F>q";
      Parse parse0 = Parse.parseParse("F>q");
      parse0.showCodeTree();
      String string1 = "";
      Parse[] parseArray0 = parse0.getTagNodes();
      Parse.pruneParse(parse0);
      // Undeclared exception!
      try { 
        Parse.addNames("AQC.*", (Span[]) null, parseArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot read the array length because \"<local3>\" is null
         //
         verifyException("opennlp.tools.parser.Parse", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetTagNodesReturningNonEmptyArray()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      Parse parse0 = Parse.parseParse("Parse.insert:subPart contains con");
      Parse parse1 = Parse.parseParse("^[^ =-]+-([^ =-]+)");
      Parse[] parseArray0 = parse1.getTagNodes();
      assertEquals(1, parseArray0.length);
      
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse0.show();
      Reader.nullReader();
      Reader.nullReader();
      Parse.fixPossesives(parse1);
      assertEquals("=-]+ ", parse1.getText());
      assertEquals(0, parse1.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testSetDerivationWithStringBufferWhereLengthIsPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("9GlK:w<rOS(wX:8Q");
      StringBuffer stringBuffer0 = new StringBuffer((CharSequence) "9GlK:w<rOS(wX:8Q");
      parse0.setDerivation(stringBuffer0);
      assertEquals("", parse0.getText());
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetTagNodesAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("GVo+EBpvSF\"]");
      Parse[] parseArray0 = parse0.getTagNodes();
      assertEquals("", parse0.getText());
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals(0, parseArray0.length);
  }

  @Test(timeout = 4000)
  public void testFixPossesivesAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^%[^ =-(7]+-([^ =-+)");
      Parse.fixPossesives(parse0);
      assertEquals("=-+ ", parse0.getText());
      assertFalse(parse0.isPosTag());
      assertEquals("TOP", parse0.getType());
      assertTrue(parse0.complete());
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals(1, parse0.getChildCount());
  }

  @Test(timeout = 4000)
  public void testGetChildrenAndSetDerivation()  throws Throwable  {
      String string0 = "|+!&\\^k ";
      Parse parse0 = Parse.parseParse("|+!&^k ");
      Parse.fixPossesives(parse0);
      StringBuffer stringBuffer0 = new StringBuffer("3eSW}:#`.kmsErKc");
      stringBuffer0.trimToSize();
      parse0.setDerivation(stringBuffer0);
      parse0.getChildren();
      parse0.getChildren();
      // Undeclared exception!
      try { 
        stringBuffer0.setCharAt((-2141), ':');
        fail("Expecting exception: StringIndexOutOfBoundsException");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCloneTakingNoArgumentsAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%VXi-R)m'Ift\"^nMte");
      Parse parse1 = (Parse)parse0.clone();
      assertTrue(parse1.equals((Object)parse0));
      assertEquals("", parse0.getText());
      assertNotSame(parse1, parse0);
      assertEquals("TOP", parse1.getType());
  }

  @Test(timeout = 4000)
  public void testFailsToCreateParseTaking5ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse[] parseArray0 = new Parse[9];
      String string0 = "";
      Span span0 = new Span(918, 918);
      Parse parse0 = Parse.parseParse("");
      Parse parse1 = new Parse("", span0, "8`;0~+<(\"?", 0.0, parse0);
      parseArray0[0] = parse1;
      String string1 = "%5]?':\"{\"a5f=";
      Parse parse2 = Parse.parseParse("%5]?':\"{\"a5f=", (GapLabeler) headRules0);
      parseArray0[1] = parse2;
      Parse parse3 = Parse.parseParse("%5]?':\"{\"a5f=", (GapLabeler) headRules0);
      parseArray0[2] = parse3;
      String string2 = "";
      Parse parse4 = Parse.parseParse("");
      parseArray0[3] = parse4;
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray1 = new Parse[0];
      // Undeclared exception!
      try { 
        ancoraSpanishHeadRules0.getHead(parseArray1, (String) null);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("opennlp.tools.parser.lang.es.AncoraSpanishHeadRules", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetCoveredTextThrowsNullPointerException()  throws Throwable  {
      Span span0 = null;
      String string0 = "gz8pKJ+7k;P( S";
      Parse parse0 = new Parse("POS", (Span) null, "gz8pKJ+7k;P( S", 1541.4, (-450));
      // Undeclared exception!
      try { 
        parse0.getCoveredText();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testShowTakingNoArgumentsAndToString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse1 = Parse.parseParse("", (GapLabeler) ancoraSpanishHeadRules0);
      parse1.addNextPunctuation(parse0);
      Reader reader1 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader1);
      Parse.parseParse("", (GapLabeler) headRules0);
      parse0.add(parse1, ancoraSpanishHeadRules0);
      parse0.toString();
      parse0.show();
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testSetPrevPunctuationWithNull()  throws Throwable  {
      Parse parse0 = Parse.parseParse("g`F_jN<1(?nQ)\"a;");
      parse0.getPreviousPunctuationSet();
      parse0.setPrevPunctuation((Collection<Parse>) null);
      assertEquals("TOP", parse0.getType());
      assertEquals("", parse0.getText());
      assertEquals(1.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testGetPreviousPunctuationSetAndSetNextPunctuation()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =-=+Q)");
      parse0.getPreviousPunctuationSet();
      assertEquals("=-=+Q ", parse0.getText());
      assertFalse(parse0.isPosTag());
      assertEquals("TOP", parse0.getType());
      assertEquals(1, parse0.getChildCount());
      
      parse0.setNextPunctuation((Collection<Parse>) null);
      assertEquals("TOP", parse0.getType());
      assertFalse(parse0.isPosTag());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals(1, parse0.getChildCount());
      assertEquals("=-=+Q ", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testSetParentThrowsNoSuchElementException()  throws Throwable  {
      String string0 = "f_n0'e''Ct_U";
      Parse parse0 = Parse.parseParse("f_n0'e''Ct_U");
      StringBuffer stringBuffer0 = new StringBuffer();
      stringBuffer0.append((Object) null);
      stringBuffer0.isEmpty();
      parse0.show(stringBuffer0);
      parse0.getPreviousPunctuationSet();
      parse0.setPrevPunctuation((Collection<Parse>) null);
      parse0.getPreviousPunctuationSet();
      parse0.setNextPunctuation((Collection<Parse>) null);
      String string1 = "";
      StringReader stringReader0 = new StringReader("bPKCF05L>xvJCcx");
      char[] charArray0 = new char[2];
      charArray0[0] = '^';
      charArray0[1] = '!';
      stringReader0.read(charArray0);
      opennlp.tools.parser.lang.en.HeadRules headRules0 = null;
      try {
        headRules0 = new opennlp.tools.parser.lang.en.HeadRules(stringReader0);
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.StringTokenizer", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndShowTakingNoArguments1()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpvS\"]");
      parse0.show();
      assertEquals("", parse0.getText());
      assertEquals("TOP", parse0.getType());
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testGetTokenNodesAndParseParseTakingString0()  throws Throwable  {
      Parse parse0 = Parse.parseParse("9GlK:w<rOS(wX:8Q");
      parse0.getTokenNodes();
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("", parse0.getText());
      assertEquals("TOP", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testSetParentWithNull()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      parse0.add(parse1, headRules0);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]");
      parse2.setType("Vo+EBpfSF\"]");
      assertEquals("Vo+EBpfSF\"]", parse2.getType());
      
      Span span0 = new Span(0, 80);
      Parse parse3 = Parse.parseParse("0fpIw{}XL5[Z+V*m-qS");
      parse0.getTokenNodes();
      parse1.setParent((Parse) null);
      parse0.getCoveredText();
      parse3.isChunk();
      assertEquals("TOP", parse3.getType());
  }

  @Test(timeout = 4000)
  public void testGetTokenNodes()  throws Throwable  {
      Parse parse0 = new Parse(")RC[(GpN!2X :Re;j", (Span) null, ")RC[(GpN!2X :Re;j", 0.0, 30);
      parse0.getTokenNodes();
      Parse.parseParse("p]>`[IFA+Qa1");
      String string0 = "NP";
      StringReader stringReader0 = new StringReader("NP");
      int int0 = 5;
      StringWriter stringWriter0 = new StringWriter(5);
      int int1 = 999;
      // Undeclared exception!
      try { 
        stringWriter0.append((CharSequence) "NP", 999, 5);
        fail("Expecting exception: StringIndexOutOfBoundsException");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }

  @Test(timeout = 4000)
  public void testAdd()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Rn9@2bBuBC(vQc0F");
      Span span0 = new Span(2, 2, "dkV>NZ?;}");
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse parse1 = Parse.parseParse("dkV>NZ?;}", (GapLabeler) headRules0);
      parse0.addPreviousPunctuation(parse1);
      parse0.show();
      Span[] spanArray0 = new Span[3];
      spanArray0[0] = span0;
      spanArray0[1] = span0;
      Parse parse2 = Parse.parseParse("dkV>NZ?;}", (GapLabeler) headRules0);
      parse2.add(parse0, headRules0);
      Reader.nullReader();
      Parse[] parseArray0 = new Parse[1];
      parseArray0[0] = parse0;
      Parse parse3 = headRules0.getHead(parseArray0, "dkV>NZ?;}");
      Parse parse4 = new Parse("Rn9@2bBuBC(vQc0F", span0, "Rn9@2bBuBC(vQc0F", 0.0, parse3);
      Parse.pruneParse(parse4);
      // Undeclared exception!
      try { 
        parse0.adjoinRoot(parse1, headRules0, 2);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 2, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateParseTaking5ArgumentsThrowsIllegalArgumentException()  throws Throwable  {
      String string0 = "-NONE-AL";
      Parse parse0 = Parse.parseParse("-NONE-AL");
      Parse.fixPossesives(parse0);
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse[] parseArray0 = new Parse[4];
      parseArray0[0] = parse0;
      parseArray0[1] = parse0;
      parseArray0[2] = parse0;
      parseArray0[3] = parse0;
      String string1 = "-RRB-%F+i-R)mIft\"^nMte";
      Parse parse1 = ancoraSpanishHeadRules0.getHead(parseArray0, "-RRB-%F+i-R)mIft\"^nMte");
      parse0.addNextPunctuation(parse1);
      parse0.addNextPunctuation(parse0);
      parse0.getTagNodes();
      int int0 = (-1276);
      Span span0 = null;
      try {
        span0 = new Span((-1276), 7);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // start index must be zero or greater: -1276
         //
         verifyException("opennlp.tools.util.Span", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndToString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%F+i-R)mIft\"^nMte");
      parse0.toString();
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("", parse0.getText());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testGetNextPunctuationSetAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("-RSB7]+x(<^=-e+ ");
      parse0.getNextPunctuationSet();
      assertEquals("", parse0.getText());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
      assertEquals(1.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testGetText()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      parse0.setType("Vo+EBpfSF\"]");
      parse0.getText();
      assertEquals("Vo+EBpfSF\"]", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testFixPossesivesAndSetType()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =-0=}Q)");
      parse0.setType("^[^C=-]+-([G =-0=}Q)");
      Parse.fixPossesives(parse0);
      assertEquals("^[^C=-]+-([G =-0=}Q)", parse0.getType());
      assertEquals("=-0=}Q ", parse0.toString());
  }

  @Test(timeout = 4000)
  public void testSetNextPunctuation()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      AncoraSpanishHeadRules ancoraSpanishHeadRules0 = new AncoraSpanishHeadRules(reader0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) ancoraSpanishHeadRules0);
      parse0.addNextPunctuation(parse1);
      parse0.hashCode();
      Reader reader1 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      Span span0 = new Span(0, 80, (String) null);
      Constituent constituent0 = new Constituent("4", span0);
      constituent0.setLabel("Vo+EBpfSF\"]");
      stack0.add(constituent0);
      ancoraSpanishHeadRules0.labelGaps(stack0);
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader1);
      Parse parse2 = Parse.parseParse("Vo+EBpfSF\"]", (GapLabeler) headRules0);
      assertTrue(parse2.equals((Object)parse0));
      
      parse0.add(parse2, headRules0);
      parse1.toString();
      Parse parse3 = Parse.parseParse("Vo+EBpfSF\"]");
      parse3.setType((String) null);
      Span span1 = new Span(0, 80);
      Parse parse4 = new Parse((String) null, span1, "Parse.insert:subPart contains con", (-1350.1170182), 80);
      boolean boolean0 = parse0.equals(parse4);
      assertFalse(boolean0);
      
      parse0.getText();
      Parse parse5 = new Parse("4", span0, "4", 2581.031, 1620);
      parse5.getNextPunctuationSet();
      parse0.setNextPunctuation((Collection<Parse>) null);
      assertEquals(1.0, parse0.getProb(), 0.01);
  }

  @Test(timeout = 4000)
  public void testEquals()  throws Throwable  {
      Parse.parseParse("9GlK:w<rOS(wX:8Q");
      Parse parse0 = Parse.parseParse("9GlK:w<rOS(wX:8Q");
      boolean boolean0 = parse0.equals(parse0);
      assertTrue(boolean0);
      
      Parse parse1 = Parse.parseParse("9GlK:w<rOS(wX:8Q");
      assertEquals("TOP", parse1.getType());
      assertEquals(1.0, parse1.getProb(), 0.01);
      assertEquals("", parse1.getText());
  }

  @Test(timeout = 4000)
  public void testAddNextPunctuationAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("GVo+EBpvSF\"]");
      parse0.addNextPunctuation(parse0);
      assertEquals("", parse0.getText());
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals(0, parse0.getHeadIndex());
      assertEquals("TOP", parse0.getType());
  }

  @Test(timeout = 4000)
  public void testGetCommonParentAndParseParseTakingStringAndGetCommonParentWithParseWhereCompleteIsFalse()  throws Throwable  {
      Parse parse0 = Parse.parseParse("vCG-]+K([G[ =_I!)");
      Parse parse1 = Parse.parseParse("Gw");
      Parse parse2 = parse0.getCommonParent(parse1);
      assertEquals(0, parse1.getHeadIndex());
      assertEquals("TOP", parse1.getType());
      assertNull(parse2);
      assertEquals("=_I! ", parse0.getText());
      assertEquals(1, parse0.getChildCount());
  }

  @Test(timeout = 4000)
  public void testIndexOfWithParseWhereCompleteIsTrueAndParseWhereGetChildCountIsPositive()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([G =?-=}Q)");
      Parse parse1 = Parse.parseParse("^[^C=-]+-([G =?-=}Q)");
      int int0 = parse0.indexOf(parse1);
      assertTrue(parse1.equals((Object)parse0));
      assertEquals(1.0, parse1.getProb(), 0.01);
      assertEquals(1, parse1.getChildCount());
      assertEquals("TOP", parse1.getType());
      assertEquals((-1), int0);
      assertFalse(parse1.isPosTag());
      assertEquals("=?-=}Q ", parse1.getText());
  }

  @Test(timeout = 4000)
  public void testGetCommonParentWithNull()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[7C=-]+-(,GH =-=LQ)");
      parse0.getCommonParent((Parse) null);
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals(1, parse0.getChildCount());
      assertFalse(parse0.isPosTag());
      assertEquals("=-=LQ ", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testGetCommonParentAndParseParseTakingString1()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^[^C=-]+-([GH =-=I<)");
      Parse parse1 = Parse.parseParse("^[^C=-]+-([GH =-=I<)");
      Parse parse2 = parse0.getCommonParent(parse1);
      assertNotNull(parse2);
      assertEquals("TOP", parse2.getType());
      assertFalse(parse2.isPosTag());
      assertEquals(1.0, parse2.getProb(), 0.01);
      assertTrue(parse2.complete());
      assertEquals("=-=I< ", parse2.toString());
  }

  @Test(timeout = 4000)
  public void testGetParent()  throws Throwable  {
      Parse parse0 = Parse.parseParse("(!ixI\")2sE?");
      assertEquals("TOP", parse0.getType());
      assertEquals("", parse0.getText());
      assertEquals(0, parse0.getHeadIndex());
      
      parse0.getParent();
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("", parse0.getText());
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testEqualsAndParseParseTakingString1()  throws Throwable  {
      Parse parse0 = Parse.parseParse("GVo+EBpvSF\"]");
      boolean boolean0 = parse0.equals("GVo+EBpvSF\"]");
      assertFalse(boolean0);
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("", parse0.getText());
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringAndShowCodeTree1()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^%[^ =-(7]+-([^ =-+)");
      parse0.showCodeTree();
      assertEquals("=-+ ", parse0.getText());
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
      assertEquals(1, parse0.getChildCount());
  }

  @Test(timeout = 4000)
  public void testGetCommonParentWithParseWhereGetProbIsZero()  throws Throwable  {
      Parse parse0 = Parse.parseParse("");
      Span span0 = new Span(199, 199, "", (-2220.3));
      Parse parse1 = new Parse("(!ixI\")2sE?", span0, "", 0.0, 0);
      Parse parse2 = parse0.getCommonParent(parse1);
      assertEquals(0, parse1.getHeadIndex());
      assertEquals(0.0, parse1.getProb(), 0.01);
      assertEquals("(!ixI\")2sE?", parse1.getText());
      assertNull(parse2);
      assertEquals("", parse1.getType());
      assertFalse(parse0.equals((Object)parse1));
  }

  @Test(timeout = 4000)
  public void testGetTokenNodesAndParseParseTakingString1()  throws Throwable  {
      Parse parse0 = Parse.parseParse("^{[2 =(7]+-D([^ =-+)");
      Parse[] parseArray0 = parse0.getTokenNodes();
      assertTrue(parse0.complete());
      assertEquals(1, parseArray0.length);
      assertEquals("=-+ ", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testGetHeadAndParseParseTakingStringWithNonEmptyString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("b(%VXEi-R)mIfr\"^nMJe");
      Parse parse1 = parse0.getHead();
      assertEquals("", parse1.getText());
      assertEquals("TOP", parse1.getType());
  }

  @Test(timeout = 4000)
  public void testRemoveThrowsIndexOutOfBoundsExceptionAndParseParseTaking2Arguments()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Parse[] parseArray0 = new Parse[4];
      Parse parse0 = Parse.parseParse("POS");
      parseArray0[0] = parse0;
      Parse parse1 = Parse.parseParse("POS");
      parseArray0[1] = parse1;
      Span span0 = new Span(0, 0, 0.0);
      Parse parse2 = new Parse("POS", span0, "uQTpN$~j#G%6m:tT7N$", 0, 0);
      parseArray0[2] = parse2;
      Parse parse3 = Parse.parseParse("27,wPS4~Ez {M>", (GapLabeler) headRules0);
      parseArray0[3] = parse3;
      Parse parse4 = headRules0.getHead(parseArray0, "27,wPS4~Ez {M>");
      // Undeclared exception!
      try { 
        parse4.remove(0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTaking2ArgumentsThrowsEmptyStackExceptionAndParseParseTaking2Arguments()  throws Throwable  {
      Span span0 = new Span(1, 1);
      Parse parse0 = new Parse(")", span0, "-NONE-[HH @-=I)", 1, (-292));
      parse0.toStringPennTreebank();
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      // Undeclared exception!
      try { 
        Parse.parseParse("(-NONE-[HH @-=I) )", (GapLabeler) headRules0);
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTaking2ArgumentsThrowsEmptyStackExceptionAndGetChildCount()  throws Throwable  {
      Reader reader0 = Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      Span span0 = new Span(927, 927);
      StringBuffer stringBuffer0 = new StringBuffer((CharSequence) "");
      stringBuffer0.append((double) 927);
      Parse parse0 = Parse.parseParse("", (GapLabeler) headRules0);
      parse0.getChildCount();
      Reader.nullReader();
      opennlp.tools.parser.lang.en.HeadRules headRules1 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      // Undeclared exception!
      try { 
        Parse.parseParse("v^)", (GapLabeler) headRules1);
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetLabelAndParseParseTakingStringAndToStringPennTreebank()  throws Throwable  {
      Span span0 = new Span(1, 1);
      Parse parse0 = new Parse("-RSB-[:+-([H #NF=.)", span0, "-RSB-[:+-([H #NF=.)", 1, 1);
      Parse parse1 = new Parse("Hv:C~aNMC5r", span0, "[HH @-", 1, parse0);
      String string0 = parse0.toStringPennTreebank();
      assertEquals("(-RSB-[:+-([H #NF=.) )", string0);
      
      Parse parse2 = Parse.parseParse("(-RSB-[:+-([H #NF=.) )");
      assertEquals("#NF=. ", parse2.getText());
      assertEquals(1, parse2.getChildCount());
      assertFalse(parse2.isPosTag());
      
      String string1 = parse1.getLabel();
      assertEquals(1, parse1.getHeadIndex());
      assertNull(string1);
  }

  @Test(timeout = 4000)
  public void testSetDerivationThrowsNegativeArraySizeException()  throws Throwable  {
      String string0 = "&O?T(rG,RDVu{p:h=";
      Parse.parseParse("&O?T(rG,RDVu{p:h=");
      StringBuffer stringBuffer0 = null;
      try {
        stringBuffer0 = new StringBuffer((-2442));
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // -2442
         //
         verifyException("java.lang.AbstractStringBuilder", e);
      }
  }

  @Test(timeout = 4000)
  public void testExpandTopNode()  throws Throwable  {
      Parse parse0 = Parse.parseParse("Vo+EBpfSF\"]");
      Reader reader0 = Reader.nullReader();
      Stack<Constituent> stack0 = new Stack<Constituent>();
      opennlp.tools.parser.lang.en.HeadRules headRules0 = new opennlp.tools.parser.lang.en.HeadRules(reader0);
      parse0.add(parse0, headRules0);
      Parse parse1 = Parse.parseParse("Vo+EBpfSF\"]");
      assertEquals("TOP", parse1.getType());
      
      parse1.setType((String) null);
      boolean boolean0 = parse0.isFlat();
      assertFalse(boolean0);
      
      parse0.expandTopNode(parse1);
      Parse.pruneParse(parse0);
      String string0 = parse0.getLabel();
      assertEquals(0, parse0.getHeadIndex());
      assertNull(string0);
      assertEquals("", parse0.getText());
  }

  @Test(timeout = 4000)
  public void testParseParseTakingStringThrowsEmptyStackException1()  throws Throwable  {
      Span span0 = new Span(1, 1);
      Parse parse0 = new Parse(")", span0, "-NONE-[HH @-=I)", (-1.0), (-283));
      parse0.toStringPennTreebank();
      // Undeclared exception!
      try { 
        Parse.parseParse("(-NONE-[HH @-=I) )");
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testIndexOfAndParseParseTakingString()  throws Throwable  {
      Parse parse0 = Parse.parseParse("VP+EBpfSF\"]");
      parse0.indexOf(parse0);
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
      assertEquals("", parse0.getText());
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testExpandTopNodeThrowsIndexOutOfBoundsException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("R9@2BuB(QVF");
      // Undeclared exception!
      try { 
        parse0.expandTopNode(parse0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }

  @Test(timeout = 4000)
  public void testParseParseTakingString3()  throws Throwable  {
      Parse parse0 = Parse.parseParse("/$0<|;T");
      assertEquals("", parse0.getText());
      assertEquals(1.0, parse0.getProb(), 0.01);
      assertEquals("TOP", parse0.getType());
      assertEquals(0, parse0.getHeadIndex());
  }

  @Test(timeout = 4000)
  public void testIndexOfAndExpandTopNodeThrowsIndexOutOfBoundsException()  throws Throwable  {
      Parse parse0 = Parse.parseParse("*\"=1}+s}?");
      double double0 = 0.0;
      int int0 = 372;
      Parse parse1 = new Parse("*\"=1}+s}?", (Span) null, "2:c3WMOl", 0.0, 372);
      parse1.indexOf(parse0);
      // Undeclared exception!
      try { 
        parse0.expandTopNode(parse1);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.LinkedList", e);
      }
  }
}
