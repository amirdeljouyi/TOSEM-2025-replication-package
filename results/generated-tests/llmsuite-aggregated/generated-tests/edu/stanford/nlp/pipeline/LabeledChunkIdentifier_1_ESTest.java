/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Jun 11 22:02:44 GMT 2025
 */

package edu.stanford.nlp.pipeline;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.AbstractSequenceClassifier;
import edu.stanford.nlp.ie.NERClassifierCombiner;
import edu.stanford.nlp.ie.PresetSequenceClassifier;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.StringLabel;
import edu.stanford.nlp.ling.Tag;
import edu.stanford.nlp.pipeline.LabeledChunkIdentifier;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.sequences.TrueCasingForNISTDocumentReaderAndWriter;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.util.ArrayCoreMap;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.Filters;
import edu.stanford.nlp.util.Pair;
import java.io.IOException;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.Stack;
import java.util.Vector;
import java.util.function.Predicate;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.mock.java.util.MockRandom;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.EvoSuiteURL;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.testdata.NetworkHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class LabeledChunkIdentifier_1_ESTest extends LabeledChunkIdentifier_1_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testGetDefaultPosTagReturningEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "Hl");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("Hl");
      labeledChunkIdentifier_LabelTagType0.type = null;
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier0.setNegLabel("I");
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      labeledChunkIdentifier0.setDefaultPosTag("");
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      labeledChunkIdentifier0.getTagType(")}");
      labeledChunkIdentifier0.getDefaultPosTag();
      labeledChunkIdentifier0.getDefaultPosTag();
      labeledChunkIdentifier0.getDefaultPosTag();
      assertTrue(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetDefaultPosTag()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply(".");
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag(".");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>((-29.058969465307293));
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-2084327801), (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertTrue(list1.isEmpty());
      
      String string0 = labeledChunkIdentifier0.getDefaultPosTag();
      assertEquals("I", string0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsAndSetDefaultNegTagWithNonEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("E");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("]");
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-5814), class0, class0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals(1, list1.size());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsThrowsNullPointerException()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      FileSystemHandling.shouldAllThrowIOExceptions();
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultPosTag("yQ#6NMxt1M'2>O^5bo'");
      labeledChunkIdentifier0.getTagType("_M4'SY$_E7R@\"Q|0M");
      labeledChunkIdentifier0.setDefaultPosTag("O0X}.JzS:X");
      labeledChunkIdentifier0.setDefaultPosTag((String) null);
      labeledChunkIdentifier0.getDefaultPosTag();
      labeledChunkIdentifier0.getTagType((String) null);
      System.setCurrentTimeMillis((-260L));
      StringLabel stringLabel0 = new StringLabel();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      treeGraphNode0.taggedYield(null);
      int int0 = 20;
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<Object> class1 = Object.class;
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      treeGraphNode0.isBinarized();
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = null;
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) null, 20, class0, class0, class1, class2, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.pipeline.LabeledChunkIdentifier", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndGetTagTypeWithNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>((-2505.2869091434945));
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("-PWEB", "B", "-PWEB");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType((String) null);
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertTrue(boolean0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testSetIgnoreProvidedTagAndGetTagTypeThrowsIllegalStateException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      assertTrue(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("n)-<}JTr<NA;9ny&0&");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagReturningNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      Vector<CoreLabel> vector0 = new Vector<CoreLabel>();
      labeledChunkIdentifier0.setDefaultPosTag((String) null);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<CoreLabel> class1 = CoreLabel.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      labeledChunkIdentifier0.setDefaultNegTag((String) null);
      Filters.RandomFilter<ArrayCoreMap> filters_RandomFilter1 = new Filters.RandomFilter<ArrayCoreMap>(1332.600655591331);
      MockRandom mockRandom0 = new MockRandom(1295);
      Filters.RandomFilter<Object> filters_RandomFilter2 = new Filters.RandomFilter<Object>(1295, mockRandom0);
      Predicate<Object> predicate0 = Predicate.not(filters_RandomFilter2);
      filters_RandomFilter1.or(predicate0);
      Predicate.not(filters_RandomFilter1);
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) vector0, 1295, (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      labeledChunkIdentifier0.getDefaultNegTag();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagAndIsEndOfChunk()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getDefaultNegTag();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", string0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("O", "F", "F");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("F");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType2 = new LabeledChunkIdentifier.LabelTagType("O", "O", "ICH.");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType2);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertTrue(boolean0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetNegLabelReturningEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getDefaultNegTag();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      labeledChunkIdentifier0.setNegLabel("");
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      labeledChunkIdentifier0.getTagType((String) null);
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      ArrayList<CoreLabel> arrayList0 = new ArrayList<CoreLabel>();
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList0, 512, (Class) class0, (Class) class1);
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList0, 512, (Class) class0, (Class) class2);
      labeledChunkIdentifier0.getNegLabel();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsAndGetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("S");
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      labeledChunkIdentifier1.setDefaultNegTag("7<+MLyTJ92");
      labeledChunkIdentifier1.getTagType("7<+MLyTJ92");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("mP~@(& 9+FcHA");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("A,91+{q=j", "7<+MLyTJ92", ".");
      Class<CoreAnnotations.DistSimAnnotation> class0 = CoreAnnotations.DistSimAnnotation.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-14482067), class0, class0);
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      Random.setNextRandom((-75999875));
      labeledChunkIdentifier0.getNegLabel();
      Class<Object> class1 = Object.class;
      Class<Object> class2 = Object.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(0.0);
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-14482067), (Class) class0, (Class) class1, (Class) class0, (Class) class2, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagReturningEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultPosTag("");
      labeledChunkIdentifier0.setDefaultNegTag("");
      labeledChunkIdentifier0.setDefaultNegTag("");
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("");
      labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier_LabelTagType0.label = "4B#nIf5f;4t'<dW";
      labeledChunkIdentifier0.setDefaultNegTag((String) null);
      labeledChunkIdentifier0.setDefaultNegTag("");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("", "4B#nIf5f;4t'<dW", "");
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier0.setNegLabel("");
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier0.getDefaultNegTag();
      assertTrue(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("E-ORG", "E", "ORG");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("S-ORG", "S", "ORG");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("S", "E", "S");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndCreatesLabeledChunkIdentifierTakingNoArguments0()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("u\"i", "B", "u\"i");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("B");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments0()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("S", "S", "S");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("S");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsThrowsClassCastExceptionAndGetAnnotatedChunksTaking7ArgumentsWithPositive()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      labeledChunkIdentifier1.setDefaultNegTag("S");
      LabeledChunkIdentifier labeledChunkIdentifier2 = new LabeledChunkIdentifier();
      labeledChunkIdentifier2.setDefaultNegTag("7<+MLyTJ92");
      labeledChunkIdentifier2.getTagType("7<+MLyTJ92");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("mP~@(& 9+FcHA");
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, ".");
      Object object0 = new Object();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("7<+MLyTJ92", "[", (-1791584229), (-1791584229));
      Pair<ArrayCoreMap, Object> pair0 = new Pair<ArrayCoreMap, Object>(coreLabel0, "7<+MLyTJ92");
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(pair0);
      Predicate<Pair<CoreLabel, CoreLabel>>[] predicateArray0 = (Predicate<Pair<CoreLabel, CoreLabel>>[]) Array.newInstance(Predicate.class, 3);
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(0.0);
      predicateArray0[0] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0;
      predicateArray0[1] = predicate0;
      predicateArray0[2] = predicate0;
      Filters.ConjFilter<Pair<CoreLabel, CoreLabel>> filters_ConjFilter0 = new Filters.ConjFilter<Pair<CoreLabel, CoreLabel>>(predicateArray0);
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Class<Object> class2 = Object.class;
      labeledChunkIdentifier2.getAnnotatedChunks(list0, 311, class1, class2, class2, class0, predicate0);
      Class<Object> class3 = Object.class;
      // Undeclared exception!
      try { 
        labeledChunkIdentifier2.getAnnotatedChunks(list0, (-24589507), (Class) class3, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // class edu.stanford.nlp.pipeline.Annotation cannot be cast to class java.lang.String (edu.stanford.nlp.pipeline.Annotation is in unnamed module of loader org.evosuite.instrumentation.InstrumentingClassLoader @305dfc23; java.lang.String is in module java.base of loader 'bootstrap')
         //
         verifyException("edu.stanford.nlp.pipeline.LabeledChunkIdentifier", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkThrowsNullPointerException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      labeledChunkIdentifier1.setDefaultNegTag("S");
      LabeledChunkIdentifier labeledChunkIdentifier2 = new LabeledChunkIdentifier();
      labeledChunkIdentifier2.setDefaultNegTag("7<+MLyTJ92");
      labeledChunkIdentifier2.getTagType("7<+MLyTJ92");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("mP~@(& 9+FcHA");
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, ".");
      labeledChunkIdentifier1.getTagType("A,91+{q=j");
      Class<CoreAnnotations.DistSimAnnotation> class0 = CoreAnnotations.DistSimAnnotation.class;
      labeledChunkIdentifier1.getAnnotatedChunks(list0, (-14482067), class0, class0);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("7<+MLyTJ92", "A,91+{q=j", "7<+MLyTJ92");
      // Undeclared exception!
      try { 
        LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, (LabeledChunkIdentifier.LabelTagType) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetAnnotatedChunksTaking4Arguments0()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply(" s,G>2{FRgMc_");
      Class<CoreAnnotations.TextAnnotation> class0 = CoreAnnotations.TextAnnotation.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1156), class0, class0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsThrowsClassCastExceptionAndGetAnnotatedChunksTaking7ArgumentsWithNegative()  throws Throwable  {
      Random.setNextRandom((-126));
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "Expected left paren!");
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("u.cr$Xe0E4wT)57%qE");
      labeledChunkIdentifier0.setDefaultNegTag("mKQG");
      labeledChunkIdentifier0.setDefaultNegTag("u.cr$Xe0E4wT)57%qE");
      labeledChunkIdentifier0.getTagType("[");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("[");
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "v^bR53gIRW2$j/)pO6");
      Predicate<Pair<CoreLabel, CoreLabel>>[] predicateArray0 = (Predicate<Pair<CoreLabel, CoreLabel>>[]) Array.newInstance(Predicate.class, 1);
      Object object0 = new Object();
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(object0);
      predicateArray0[0] = predicate0;
      Filters.ConjFilter<Pair<CoreLabel, CoreLabel>> filters_ConjFilter0 = new Filters.ConjFilter<Pair<CoreLabel, CoreLabel>>(predicateArray0);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1791584229), (Class) class0, (Class) class0, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_ConjFilter0);
      Class<Object> class1 = Object.class;
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1982487857), class1, class0, predicate0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // class edu.stanford.nlp.pipeline.Annotation cannot be cast to class java.lang.String (edu.stanford.nlp.pipeline.Annotation is in unnamed module of loader org.evosuite.instrumentation.InstrumentingClassLoader @305dfc23; java.lang.String is in module java.base of loader 'bootstrap')
         //
         verifyException("edu.stanford.nlp.pipeline.LabeledChunkIdentifier", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5Arguments()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("-");
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("-");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>((-29.058969465307293));
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-2084327801), (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndCreatesLabeledChunkIdentifierTakingNoArguments1()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("u\"i", "B", "u\"i");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("u\"i");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "B", "B");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("L", "[", "L");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull2()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "B", "B");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndCreatesLabeledChunkIdentifierTakingNoArguments2()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("]", "]", "]");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("]");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertTrue(boolean0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull3()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("]", "]", "]");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull4()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("L", "L", "S");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6ArgumentsReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getDefaultPosTag();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", string0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      stack0.add(coreLabel0);
      Class<CoreLabel> class0 = CoreLabel.class;
      stack0.add(coreLabel0);
      labeledChunkIdentifier0.setDefaultNegTag("I");
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, 3089, (Class) class0, (Class) class0);
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      List<CoreMap> list0 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, 3089, (Class) class0, (Class) class1, (Class) class1, (Class) class1);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments2()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("L", "L", "D");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsAndGetDefaultPosTagAndIsStartOfChunk()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getDefaultPosTag();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      stack0.stream();
      labeledChunkIdentifier0.setNegLabel("I");
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("");
      CoreLabel coreLabel0 = new CoreLabel();
      stack0.add(coreLabel0);
      LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, labeledChunkIdentifier_LabelTagType0);
      Class<Object> class0 = Object.class;
      List<CoreMap> list0 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, (-822), (Class) class0, (Class) class0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNull0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("I-LOC", "I", "LOC");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNull1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("S", "S", "S");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel coreLabel0 = new CoreLabel();
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      stack0.add(coreLabel0);
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier1.getDefaultNegTag());
      
      labeledChunkIdentifier1.setDefaultNegTag("U");
      LabeledChunkIdentifier labeledChunkIdentifier2 = new LabeledChunkIdentifier();
      Class<Object> class0 = Object.class;
      Class<Object> class1 = Object.class;
      labeledChunkIdentifier2.getAnnotatedChunks((List<CoreLabel>) stack0, (-2098684729), (Class) class0, (Class) class1);
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      Class<Object> class3 = Object.class;
      labeledChunkIdentifier2.getAnnotatedChunks((List<CoreLabel>) stack0, (-2098684729), (Class) class2, (Class) class3);
      Class<ArrayCoreMap> class4 = ArrayCoreMap.class;
      Class<Object> class5 = Object.class;
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(labeledChunkIdentifier1);
      labeledChunkIdentifier1.getAnnotatedChunks((List<CoreLabel>) stack0, (-135), (Class) class4, (Class) class5, predicate0);
      assertEquals("O", labeledChunkIdentifier1.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testSetDefaultNegTagWithEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getDefaultPosTag();
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      labeledChunkIdentifier0.setNegLabel("I");
      labeledChunkIdentifier0.getTagType("");
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.setIsMWT(true);
      stack0.add(coreLabel0);
      labeledChunkIdentifier0.setDefaultNegTag("");
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, 2, (Class) class0, (Class) class0);
      Class<Object> class1 = Object.class;
      Class<Object> class2 = Object.class;
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(null);
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, 3507, (Class) class0, (Class) class1, (Class) class2, (Class) class0, predicate0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsAndIsIgnoreProvidedTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      MockRandom mockRandom0 = new MockRandom();
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(2477.3, mockRandom0);
      Filters.RandomFilter<Object> filters_RandomFilter1 = new Filters.RandomFilter<Object>(2567.60381117, mockRandom0);
      labeledChunkIdentifier0.getTagType("!Y(zMov~?C&");
      filters_RandomFilter0.or(filters_RandomFilter1);
      Tag tag0 = new Tag();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      ArrayList<CoreLabel> arrayList0 = new ArrayList<CoreLabel>();
      ArrayList<CoreLabel> arrayList1 = treeGraphNode1.yieldHasWord(arrayList0);
      ArrayList<CoreLabel> arrayList2 = treeGraphNode1.yieldHasWord(arrayList1);
      Class<Object> class0 = Object.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList2, 2, (Class) class0, (Class) class1, (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      labeledChunkIdentifier0.getDefaultPosTag();
      Random.setNextRandom((-566));
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunk()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType(".");
      labeledChunkIdentifier_LabelTagType0.tag = ".";
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments3()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("Tq|&!'", "[", "Tq|&!'");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetTagTypeReturningNonNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      labeledChunkIdentifier0.setNegLabel("<tE$II");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("<tE$II");
      labeledChunkIdentifier_LabelTagType0.toString();
      CoreLabel coreLabel0 = new CoreLabel();
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(true);
      CoreLabel coreLabel1 = coreLabelTokenFactory0.makeToken("S", "<tE$II", 57, 57);
      stack0.add(coreLabel1);
      labeledChunkIdentifier0.setDefaultNegTag("O");
      Class<Object> class0 = Object.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      List<CoreMap> list0 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, (-1842221031), (Class) class0, (Class) class1);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetTagTypeAndGetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getNegLabel();
      assertEquals("O", string0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.getTagType("O");
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndCreatesLabeledChunkIdentifierTakingNoArguments3()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("vNcG]6D", "E", "-x\u0003c");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("S");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertTrue(boolean0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagTypeWithEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("", "[...]", "[...]");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertTrue(boolean0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkReturningTrue()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "U", "U");
      labeledChunkIdentifier0.getTagType("U");
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull5()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "U", "U");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull6()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("S", "S", "S");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagTypeWithNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType((String) null);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertFalse(boolean0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments1()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("S", "S", "tansfer");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("S");
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNull2()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("alignmentPruneThreshold", "alignmentPruneThreshold", "alignmentPruneThreshold");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetAnnotatedChunksTaking4Arguments1()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("zSWNar+H)bcIKfM?");
      Class<CoreAnnotations.TextAnnotation> class0 = CoreAnnotations.TextAnnotation.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-2925), class0, class0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(list1.isEmpty());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getDefaultPosTag();
      assertEquals("I", string0);
      
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      labeledChunkIdentifier0.setNegLabel("I");
      labeledChunkIdentifier0.getTagType("");
      CoreLabel coreLabel0 = new CoreLabel();
      stack0.add(coreLabel0);
      labeledChunkIdentifier0.setDefaultNegTag("");
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      List<CoreMap> list0 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, 2, (Class) class0, (Class) class0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getDefaultPosTag();
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      stack0.add(coreLabel0);
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<CoreLabel> class1 = CoreLabel.class;
      Class<Object> class2 = Object.class;
      Class<Object> class3 = Object.class;
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual("I");
      List<CoreMap> list0 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, 567, (Class) class0, (Class) class1, (Class) class2, (Class) class3, predicate0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetAnnotatedChunksTaking5Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel coreLabel0 = new CoreLabel();
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      Class<Object> class0 = Object.class;
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(labeledChunkIdentifier0);
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-2011), class0, class0, predicate0);
      assertTrue(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsWithZero()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("}ar,CuZ%.n:A{C4");
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<Object> class1 = Object.class;
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      MockRandom mockRandom0 = new MockRandom();
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(2477.3, mockRandom0);
      Filters.RandomFilter<Object> filters_RandomFilter1 = new Filters.RandomFilter<Object>(0.0, mockRandom0);
      labeledChunkIdentifier0.getTagType("8");
      filters_RandomFilter0.or(filters_RandomFilter1);
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 0, (Class) class0, (Class) class0, (Class) class1, (Class) class2, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertTrue(list1.isEmpty());
      
      boolean boolean0 = labeledChunkIdentifier0.isIgnoreProvidedTag();
      assertFalse(boolean0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments4()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "U", "U");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkReturningTrueAndIsIgnoreProvidedTagReturningTrue()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("U");
      labeledChunkIdentifier_LabelTagType0.tag = "U";
      labeledChunkIdentifier_LabelTagType0.type = "U";
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier_LabelTagType0.tag = "U";
      labeledChunkIdentifier_LabelTagType0.type = "DnN";
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier0.setNegLabel("");
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      labeledChunkIdentifier_LabelTagType0.toString();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType((String) null);
      labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType1);
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      labeledChunkIdentifier_LabelTagType1.typeMatches(labeledChunkIdentifier_LabelTagType0);
      ArrayList<CoreLabel> arrayList0 = new ArrayList<CoreLabel>();
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList0, 512, (Class) class0, (Class) class1);
      assertTrue(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsWithEmptyList()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>();
      Class<Object> class0 = Object.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, (-2028433617), (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      labeledChunkIdentifier0.setNegLabel((String) null);
      labeledChunkIdentifier0.getNegLabel();
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier1.getNegLabel());
      
      labeledChunkIdentifier1.setNegLabel("C'f9f&f!R");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier1.getTagType("_P|dB(");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("L", (String) null, "L");
      labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType1);
      labeledChunkIdentifier1.getDefaultNegTag();
      Vector<CoreLabel> vector0 = new Vector<CoreLabel>();
      Class<Object> class0 = Object.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      labeledChunkIdentifier1.getAnnotatedChunks((List<CoreLabel>) vector0, 732, (Class) class0, (Class) class1, (Class) class0, (Class) class0);
      labeledChunkIdentifier1.setNegLabel("l#8Tq=,Vw");
      labeledChunkIdentifier1.setNegLabel("CT");
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      Object object0 = new Object();
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(object0);
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) vector0, 732, (Class) class1, (Class) class2, predicate0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testSetDefaultNegTagWithNullAndSetDefaultPosTagWithEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultPosTag("");
      String string0 = "";
      labeledChunkIdentifier0.setDefaultNegTag("");
      labeledChunkIdentifier0.setDefaultNegTag("");
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType((String) null);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("", "", (String) null);
      labeledChunkIdentifier_LabelTagType1.label = "N}4g%A#oy6o6";
      labeledChunkIdentifier_LabelTagType0.type = "";
      labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType1);
      labeledChunkIdentifier_LabelTagType0.label = "4B#nIf5f;4t'<dW";
      labeledChunkIdentifier0.setDefaultNegTag((String) null);
      labeledChunkIdentifier0.setDefaultNegTag((String) null);
      labeledChunkIdentifier0.getTagType((String) null);
      // Undeclared exception!
      try { 
        LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testTypeMatches()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("New chunk started, prev chunk not ended yet!", "New chunk started, prev chunk not ended yet!", "New chunk started, prev chunk not ended yet!");
      boolean boolean0 = labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagTypeWithNonEmptyString0()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("<tE$II");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testSetIgnoreProvidedTagAndToString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("meagre");
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("meagre", "meagre", "lc\"Jg'<]$@");
      String string0 = labeledChunkIdentifier_LabelTagType0.toString();
      assertEquals("(meagre,meagre,lc\"Jg'<]$@)", string0);
  }

  @Test(timeout = 4000)
  public void testToString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = "p5 b<<jTzP6;K";
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("p5 b<<jTzP6;K");
      labeledChunkIdentifier_LabelTagType0.toString();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = null;
      try {
        presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>((Properties) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.sequences.SeqClassifierFlags", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesLabelTagTypeTaking3ArgumentsAndToString()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "U", "U");
      String string0 = labeledChunkIdentifier_LabelTagType0.toString();
      assertEquals("(U,U,U)", string0);
  }

  @Test(timeout = 4000)
  public void testSetDefaultPosTagWithNonEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      labeledChunkIdentifier0.setDefaultPosTag("4Q8");
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndIsIgnoreProvidedTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      boolean boolean0 = labeledChunkIdentifier0.isIgnoreProvidedTag();
      assertFalse(boolean0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testIsIgnoreProvidedTagAndSetDefaultPosTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultPosTag("%{1");
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      labeledChunkIdentifier0.setNegLabel("%{1");
      ArrayList<CoreLabel> arrayList0 = new ArrayList<CoreLabel>();
      int int0 = 1065;
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.category();
      arrayList0.add(coreLabel0);
      AbstractSequenceClassifier<CoreLabel>[] abstractSequenceClassifierArray0 = (AbstractSequenceClassifier<CoreLabel>[]) Array.newInstance(AbstractSequenceClassifier.class, 3);
      String[] stringArray0 = new String[8];
      stringArray0[0] = "gsC%6RChH;T\"";
      stringArray0[1] = "";
      stringArray0[2] = null;
      stringArray0[3] = "%{1";
      stringArray0[4] = "%{1";
      stringArray0[5] = null;
      stringArray0[6] = "%{1";
      stringArray0[7] = null;
      NERClassifierCombiner nERClassifierCombiner0 = null;
      try {
        nERClassifierCombiner0 = new NERClassifierCombiner(true, true, stringArray0);
        fail("Expecting exception: IOException");
      
      } catch(Throwable e) {
         //
         // Couldn't load classifier from gsC%6RChH;T\"
         //
         verifyException("edu.stanford.nlp.ie.ClassifierCombiner", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsWithNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      stack0.add(coreLabel0);
      labeledChunkIdentifier0.setNegLabel("ai~");
      Class<Object> class0 = Object.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      List<CoreMap> list0 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, 567, (Class) class0, (Class) class1, (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagAndGetDefaultNegTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getDefaultNegTag();
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      String string0 = "Mj#6QR";
      Properties properties0 = new Properties();
      Properties properties1 = new Properties(properties0);
      try { 
        NERClassifierCombiner.getClassifier("O", properties1);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Unable to open \"O\" as class path, filename or URL
         //
         verifyException("edu.stanford.nlp.io.IOUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndIsEndOfChunkAndSetDefaultNegTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("y{V");
      LabeledChunkIdentifier.isEndOfChunk((LabeledChunkIdentifier.LabelTagType) null, (LabeledChunkIdentifier.LabelTagType) null);
      LabeledChunkIdentifier.isEndOfChunk((LabeledChunkIdentifier.LabelTagType) null, (LabeledChunkIdentifier.LabelTagType) null);
      AbstractSequenceClassifier<CoreLabel>[] abstractSequenceClassifierArray0 = (AbstractSequenceClassifier<CoreLabel>[]) Array.newInstance(AbstractSequenceClassifier.class, 6);
      NERClassifierCombiner.Language nERClassifierCombiner_Language0 = NERClassifierCombiner.Language.CHINESE;
      Properties properties0 = new Properties();
      String[] stringArray0 = new String[6];
      stringArray0[0] = "y{V";
      stringArray0[1] = "y{%";
      stringArray0[2] = "y{%";
      stringArray0[3] = "y{V";
      stringArray0[4] = "y{V";
      stringArray0[5] = "y{V";
      NERClassifierCombiner nERClassifierCombiner0 = null;
      try {
        nERClassifierCombiner0 = new NERClassifierCombiner(false, nERClassifierCombiner_Language0, false, properties0, stringArray0);
        fail("Expecting exception: IOException");
      
      } catch(Throwable e) {
         //
         // Couldn't load classifier from y{V
         //
         verifyException("edu.stanford.nlp.ie.ClassifierCombiner", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetTagTypeAndGetTagTypeThrowsIllegalStateException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = "Cc%)-H?u/e6{{";
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("Cc%)-H?u/e6{{");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetTagType()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getTagType("q[2+oPJ5':o");
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndSetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      labeledChunkIdentifier0.setNegLabel("0]|45|jT9v=8B");
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testGetTagTypeThrowsIllegalStateException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("Cc%)-H?u/e6{{");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkThrowsNullPointerException()  throws Throwable  {
      // Undeclared exception!
      try { 
        LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, (LabeledChunkIdentifier.LabelTagType) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.pipeline.LabeledChunkIdentifier", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      Class<Object> class0 = Object.class;
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) null, (-2764), class0, class0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.pipeline.LabeledChunkIdentifier", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsWithPositive()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel coreLabel0 = new CoreLabel(2);
      List<CoreLabel> list0 = List.of(coreLabel0);
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 2, class0, class0);
      assertTrue(list1.isEmpty());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndSetDefaultNegTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("U");
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsAndSetDefaultNegTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getNegLabel();
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      labeledChunkIdentifier0.setNegLabel("O");
      labeledChunkIdentifier0.getTagType("");
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      CoreLabel coreLabel0 = new CoreLabel();
      stack0.add(coreLabel0);
      labeledChunkIdentifier0.setDefaultNegTag("");
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      List<CoreMap> list0 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, 2, (Class) class0, (Class) class0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndGetTagTypeWithNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType((String) null);
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertFalse(boolean0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndIsStartOfChunk()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("New chunk started, prev chunk not ended yet!", "New chunk started, prev chunk not ended yet!", "New chunk started, prev chunk not ended yet!");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndIsEndOfChunkWithNullAndIsEndOfChunkWithNull()  throws Throwable  {
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk((LabeledChunkIdentifier.LabelTagType) null, (LabeledChunkIdentifier.LabelTagType) null);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsWithEmptyList()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      ArrayList<CoreLabel> arrayList0 = new ArrayList<CoreLabel>();
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList0, (-5243), (Class) class0, (Class) class0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndCallsGetAnnotatedChunksTaking7Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getDefaultPosTag();
      assertEquals("I", string0);
      
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Filters.RandomFilter<Object> filters_RandomFilter0 = new Filters.RandomFilter<Object>((-5015.1));
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.not(filters_RandomFilter0);
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, 505, (Class) class0, (Class) class1, (Class) class0, (Class) class0, predicate0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetDefaultPosTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      String string0 = labeledChunkIdentifier0.getDefaultPosTag();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", string0);
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("F", "B", "B");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments5()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("New chunk started, prev chunk not ended yet!", "New chunk started, prev chunk not ended yet!", "New chunk started, prev chunk not ended yet!");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagTypeWithNonEmptyString1()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType(".");
      labeledChunkIdentifier_LabelTagType0.tag = ".";
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(boolean0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndIsEndOfChunk()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType((String) null, "E", "E");
      labeledChunkIdentifier_LabelTagType0.label = ".";
      labeledChunkIdentifier_LabelTagType0.label = "E";
      labeledChunkIdentifier_LabelTagType0.tag = "E";
      labeledChunkIdentifier_LabelTagType0.tag = ".";
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType(".", ".", "E");
      assertFalse(labeledChunkIdentifier_LabelTagType1.equals((Object)labeledChunkIdentifier_LabelTagType0));
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments6()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("S", "S", "S");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }
}
