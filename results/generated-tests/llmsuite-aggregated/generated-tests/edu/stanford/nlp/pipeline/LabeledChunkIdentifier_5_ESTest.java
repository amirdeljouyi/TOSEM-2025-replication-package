/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Jun 11 22:03:45 GMT 2025
 */

package edu.stanford.nlp.pipeline;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.NERClassifierCombiner;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.pipeline.LabeledChunkIdentifier;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.sequences.SeqClassifierFlags;
import edu.stanford.nlp.sequences.TrueCasingForNISTDocumentReaderAndWriter;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.util.ArrayCoreMap;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.Filters;
import edu.stanford.nlp.util.Pair;
import java.io.IOException;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.Stack;
import java.util.Vector;
import java.util.function.Predicate;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class LabeledChunkIdentifier_5_ESTest extends LabeledChunkIdentifier_5_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsWithZero()  throws Throwable  {
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      List<CoreLabel> list0 = List.of(seqClassifierFlags0.pad, seqClassifierFlags0.pad);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("[");
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<Object> class1 = Object.class;
      Class<Object> class2 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 0, (Class) class2, (Class) class0, (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagType0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("M", "B", "B");
      labeledChunkIdentifier_LabelTagType0.type = "O";
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("O");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertTrue(boolean0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsAndGetAnnotatedChunksTaking5ArgumentsWithZero0()  throws Throwable  {
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      List<CoreLabel> list0 = List.of(seqClassifierFlags0.pad, seqClassifierFlags0.pad);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("]");
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 0, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunk0()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      Properties properties0 = new Properties();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("S", "S", "f9G#/] EH!yraMIO");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagReturningNull()  throws Throwable  {
      Random.setNextRandom((-3185));
      System.setCurrentTimeMillis((-3185));
      Random.setNextRandom(1732);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setIgnoreProvidedTag(false);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag((String) null);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      labeledChunkIdentifier0.setDefaultPosTag((String) null);
      labeledChunkIdentifier0.getDefaultNegTag();
      Random.setNextRandom((-3185));
      labeledChunkIdentifier0.getTagType((String) null);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkThrowsNullPointerExceptionAndCreatesLabelTagTypeTaking3Arguments()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType((String) null, "E", (String) null);
      // Undeclared exception!
      try { 
        LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("S", "S", "S");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("L", "L", "L");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagType1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("p", "B", "B");
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("B");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("S", "S", "S");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("L", "L", "L");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments2()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "B");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndGetTagType()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "U", "U");
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("U");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertTrue(boolean0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments2()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "B");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndToString()  throws Throwable  {
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("4", "B", "4");
      String string0 = labeledChunkIdentifier_LabelTagType0.toString();
      assertEquals("(4,B,4)", string0);
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("4", "4", "@6");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagReturningEmptyString()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("");
      Vector<CoreLabel> vector0 = new Vector<CoreLabel>();
      int int0 = 2999;
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<Object> class1 = Object.class;
      Class<CoreLabel> class2 = CoreLabel.class;
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(labeledChunkIdentifier0);
      Filters.RandomFilter<Object> filters_RandomFilter0 = new Filters.RandomFilter<Object>();
      predicate0.and(filters_RandomFilter0);
      Predicate.not(filters_RandomFilter0);
      filters_RandomFilter0.negate();
      Predicate.not(filters_RandomFilter0);
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) vector0, 2999, (Class) class0, (Class) class1, (Class) class0, (Class) class2, predicate0);
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier0.getTagType("");
      Class<Object> class3 = Object.class;
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      String[] stringArray0 = new String[0];
      String[] stringArray1 = new String[3];
      stringArray1[0] = "";
      stringArray1[1] = "I";
      coreLabelTokenFactory0.makeToken("[", 2999, 2999);
      stringArray1[2] = "A6#~h+U~l";
      // Undeclared exception!
      try { 
        coreLabelTokenFactory0.makeToken(stringArray0, stringArray1);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Argument array lengths differ: [] vs. [, I, A6#~h+U~l]
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsThrowsClassCastException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel coreLabel0 = new CoreLabel();
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      Object object0 = new Object();
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<Object> class1 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1248), class0, class1);
      labeledChunkIdentifier0.setDefaultNegTag("rI5vSv|fLn");
      labeledChunkIdentifier0.setDefaultNegTag(" (r/4Z");
      labeledChunkIdentifier0.setDefaultPosTag("zrQ\"%{.");
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Vector<Predicate<Pair<CoreLabel, CoreLabel>>> vector0 = new Vector<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(vector0);
      Class<CoreLabel> class2 = CoreLabel.class;
      Class<ArrayCoreMap> class3 = ArrayCoreMap.class;
      Class<Object> class4 = Object.class;
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks(list0, (-4268), (Class) class2, (Class) class0, (Class) class3, (Class) class4, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // class edu.stanford.nlp.pipeline.Annotation cannot be cast to class java.lang.String (edu.stanford.nlp.pipeline.Annotation is in unnamed module of loader org.evosuite.instrumentation.InstrumentingClassLoader @258ed55d; java.lang.String is in module java.base of loader 'bootstrap')
         //
         verifyException("edu.stanford.nlp.pipeline.LabeledChunkIdentifier", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabeledChunkIdentifierTakingNoArgumentsAndCreatesLabelTagTypeTaking3Arguments0()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType((String) null, "E", "E");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel[] coreLabelArray0 = new CoreLabel[2];
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      coreLabelArray0[0] = coreLabel0;
      CoreLabel.wordFromString((String) null);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType((String) null, "[", "[");
      labeledChunkIdentifier_LabelTagType0.toString();
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier1.getTagType("[");
      labeledChunkIdentifier0.setDefaultNegTag("(null,[,[)");
      labeledChunkIdentifier0.setDefaultNegTag("[");
      LabeledChunkIdentifier labeledChunkIdentifier2 = new LabeledChunkIdentifier();
      labeledChunkIdentifier1.setDefaultNegTag("(null,[,[)");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType2 = labeledChunkIdentifier0.getTagType((String) null);
      labeledChunkIdentifier_LabelTagType2.label = null;
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType2);
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>();
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(0.0);
      CoreLabel coreLabel1 = new CoreLabel((CoreMap) coreLabel0);
      linkedList0.add(coreLabel1);
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      List<CoreMap> list0 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, (-1982791734), (Class) class0, (Class) class0, (Class) class1, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      Class<Object> class2 = Object.class;
      Class<Object> class3 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, (-1909602278), (Class) class2, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertFalse(linkedList0.contains(coreLabel0));
      assertFalse(list1.equals((Object)list0));
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsWithNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>();
      Class<CoreLabel.OutputFormat> class0 = CoreLabel.OutputFormat.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      Class<ArrayCoreMap> class3 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 0, (Class) class0, (Class) class1, (Class) class2, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      CoreLabel coreLabel0 = new CoreLabel(1004);
      linkedList0.listIterator();
      coreLabel0.setIndex(0);
      linkedList0.add(coreLabel0);
      linkedList0.spliterator();
      Class<ArrayCoreMap> class4 = ArrayCoreMap.class;
      Class<Object> class5 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 0, (Class) class4, (Class) class5);
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)3;
      byteArray0[1] = (byte) (-38);
      byteArray0[2] = (byte)21;
      byteArray0[3] = (byte) (-118);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      List.of();
      labeledChunkIdentifier0.setDefaultNegTag("richochet");
      labeledChunkIdentifier0.setDefaultPosTag("I");
      Class<ArrayCoreMap> class6 = ArrayCoreMap.class;
      Class<Object> class7 = Object.class;
      Class<ArrayCoreMap> class8 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 0, (Class) class6, (Class) class7, (Class) class8, (Class) class1);
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      Class<Object> class9 = Object.class;
      Class<ArrayCoreMap> class10 = ArrayCoreMap.class;
      labeledChunkIdentifier1.getAnnotatedChunks((List<CoreLabel>) linkedList0, (-1032), (Class) class9, (Class) class1, (Class) class1, (Class) class10, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("I");
      assertNotNull(labeledChunkIdentifier_LabelTagType0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsAndGetAnnotatedChunksTaking5ArgumentsWithZero1()  throws Throwable  {
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      List<CoreLabel> list0 = List.of(seqClassifierFlags0.pad, seqClassifierFlags0.pad);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("E");
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      Class<Object> class0 = Object.class;
      Class<Object> class1 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 0, (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsThrowsNullPointerException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel[] coreLabelArray0 = new CoreLabel[2];
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      coreLabelArray0[0] = coreLabel0;
      CoreLabel coreLabel1 = CoreLabel.wordFromString((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel1);
      CoreLabel coreLabel2 = treeGraphNode0.label();
      coreLabelArray0[1] = coreLabel2;
      List<CoreLabel> list0 = List.of(coreLabelArray0);
      Class<Object> class0 = Object.class;
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 922, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      labeledChunkIdentifier0.setDefaultNegTag("0dUBER:e^Az9[gBGI$-");
      coreLabelTokenFactory0.makeToken(coreLabel2);
      labeledChunkIdentifier0.setDefaultNegTag("useFeaturesCpC4gram");
      labeledChunkIdentifier0.setDefaultPosTag((String) null);
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack1 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Class<Object> class1 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 1916, (Class) class1, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("dRH|Vd'^^\"1>60");
      labeledChunkIdentifier0.getDefaultNegTag();
      System.setCurrentTimeMillis(0L);
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier0.getDefaultPosTag();
      Class<Object> class2 = Object.class;
      Class<ArrayCoreMap> class3 = ArrayCoreMap.class;
      Predicate<Pair<CoreLabel, CoreLabel>>[] predicateArray0 = (Predicate<Pair<CoreLabel, CoreLabel>>[]) Array.newInstance(Predicate.class, 8);
      predicateArray0[0] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0;
      predicateArray0[1] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0;
      predicateArray0[2] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0;
      predicateArray0[3] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0;
      predicateArray0[4] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0;
      predicateArray0[5] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0;
      Filters.ConjFilter<Pair<CoreLabel, CoreLabel>> filters_ConjFilter0 = new Filters.ConjFilter<Pair<CoreLabel, CoreLabel>>(predicateArray0);
      predicateArray0[6] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_ConjFilter0;
      predicateArray0[7] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0;
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter1 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(predicateArray0);
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) null, 182, (Class) class1, (Class) class2, (Class) class0, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.pipeline.LabeledChunkIdentifier", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel[] coreLabelArray0 = new CoreLabel[2];
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      coreLabelArray0[0] = coreLabel0;
      CoreLabel coreLabel1 = CoreLabel.wordFromString((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel1);
      CoreLabel coreLabel2 = treeGraphNode0.label();
      coreLabelArray0[1] = coreLabel2;
      List.of(coreLabelArray0);
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>();
      linkedList0.add(coreLabel0);
      linkedList0.spliterator();
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      List<CoreMap> list0 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 0, (Class) class0, (Class) class1);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("richochet");
      labeledChunkIdentifier0.setDefaultNegTag((String) null);
      labeledChunkIdentifier0.setDefaultPosTag("I");
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack1 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Vector<Predicate<Pair<CoreLabel, CoreLabel>>> vector0 = new Vector<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(vector0);
      Class<Object> class2 = Object.class;
      Class<Object> class3 = Object.class;
      Class<CoreLabel> class4 = CoreLabel.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 1413, (Class) class1, (Class) class3, (Class) class4, (Class) class2, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      assertFalse(list1.equals((Object)list0));
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments3()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("I-MISC", "I", "MISC");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("O", "O", "O");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testSetIgnoreProvidedTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      assertTrue(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("Xd0KDmuuF-moeX'");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabeledChunkIdentifierTakingNoArgumentsAndCreatesLabelTagTypeTaking3Arguments1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("[", "[", "\"'4Tc=");
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments3()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("p", "[", "[");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6ArgumentsWithEmptyListAndNegative()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      IndexedWord indexedWord0 = new IndexedWord("[", 2, 442);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      List<CoreLabel> list0 = treeGraphNode0.taggedLabeledYield();
      List<CoreLabel> list1 = treeGraphNode0.yield(list0);
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<CoreLabel> class1 = CoreLabel.class;
      Class<Object> class2 = Object.class;
      Class<Object> class3 = Object.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      labeledChunkIdentifier0.getAnnotatedChunks(list1, 2, (Class) class0, (Class) class1, (Class) class2, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      labeledChunkIdentifier0.getTagType(")]u>WI85cAUu]Km");
      labeledChunkIdentifier0.getDefaultNegTag();
      ArrayList<CoreLabel> arrayList0 = new ArrayList<CoreLabel>();
      Class<Object> class4 = Object.class;
      Class<CoreLabel> class5 = CoreLabel.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList0, (-2147483645), (Class) class2, (Class) class1, (Class) class4, (Class) class5);
      Class<ArrayCoreMap> class6 = ArrayCoreMap.class;
      List<CoreMap> list2 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-596), class4, class6);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertTrue(list2.isEmpty());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>();
      Class<CoreLabel.OutputFormat> class0 = CoreLabel.OutputFormat.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      Class<ArrayCoreMap> class3 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 0, (Class) class0, (Class) class1, (Class) class2, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      CoreLabel coreLabel0 = new CoreLabel(1004);
      linkedList0.listIterator();
      coreLabel0.setAfter("");
      coreLabel0.setIndex(0);
      labeledChunkIdentifier0.getTagType("");
      linkedList0.add(coreLabel0);
      linkedList0.spliterator();
      Class<ArrayCoreMap> class4 = ArrayCoreMap.class;
      Class<Object> class5 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 0, (Class) class4, (Class) class5);
      labeledChunkIdentifier0.setDefaultNegTag("richochet");
      labeledChunkIdentifier0.setDefaultNegTag("]");
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      labeledChunkIdentifier0.setDefaultPosTag("I");
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, (-1994176844), (Class) class1, (Class) class5, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      Class<ArrayCoreMap> class6 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, (-4248), (Class) class6, (Class) class6, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      List<CoreMap> list0 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, (-1944), (Class) class6, (Class) class4);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNull()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("I-LOC", "I", "LOC");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsAndGetAnnotatedChunksTaking5Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel[] coreLabelArray0 = new CoreLabel[2];
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      coreLabelArray0[0] = coreLabel0;
      CoreLabel coreLabel1 = CoreLabel.wordFromString((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel1);
      CoreLabel coreLabel2 = treeGraphNode0.label();
      coreLabelArray0[1] = coreLabel2;
      List<CoreLabel> list0 = List.of(coreLabelArray0);
      Class<Object> class0 = Object.class;
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 922, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals(0, list1.size());
      
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 40, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType(")]u>WI85cAUu]Km");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
      
      Class<Object> class1 = Object.class;
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      Class<CoreLabel> class3 = CoreLabel.class;
      Class<ArrayCoreMap> class4 = ArrayCoreMap.class;
      List<CoreMap> list2 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-162), (Class) class1, (Class) class2, (Class) class3, (Class) class4, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      assertTrue(list0.contains(coreLabel1));
      assertTrue(list2.equals((Object)list1));
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagAndSetDefaultPosTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel[] coreLabelArray0 = new CoreLabel[2];
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      coreLabelArray0[0] = coreLabel0;
      CoreLabel coreLabel1 = CoreLabel.wordFromString((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel1);
      CoreLabel coreLabel2 = treeGraphNode0.label();
      coreLabelArray0[1] = coreLabel2;
      List<CoreLabel> list0 = List.of(coreLabelArray0);
      Class<Object> class0 = Object.class;
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      Class<CoreLabel> class1 = CoreLabel.class;
      Class<CoreLabel> class2 = CoreLabel.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 922, class1, class2);
      labeledChunkIdentifier0.setDefaultNegTag("0dUBER:e^Az9[gBGI$-");
      labeledChunkIdentifier0.setDefaultNegTag(".");
      labeledChunkIdentifier0.setDefaultPosTag("24y");
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack1 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter1 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack1);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-3482), (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter1);
      labeledChunkIdentifier0.getTagType("24y");
      String string0 = labeledChunkIdentifier0.getDefaultNegTag();
      assertEquals(".", string0);
  }

  @Test(timeout = 4000)
  public void testGetTagTypeAndGetAnnotatedChunksTaking5ArgumentsAndSetDefaultNegTag()  throws Throwable  {
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      List<CoreLabel> list0 = List.of(seqClassifierFlags0.pad, seqClassifierFlags0.pad);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag(".");
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1), (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      labeledChunkIdentifier0.getTagType((String) null);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsWithPositive()  throws Throwable  {
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      List<CoreLabel> list0 = List.of(seqClassifierFlags0.pad, seqClassifierFlags0.pad);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag((String) null);
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 25, (Class) class0, (Class) class0, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      assertEquals(2, list1.size());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments4()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("E", ".", "E");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments4()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("/", "/", "/");
      labeledChunkIdentifier_LabelTagType0.tag = ".";
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>();
      Class<CoreLabel.OutputFormat> class0 = CoreLabel.OutputFormat.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      Class<ArrayCoreMap> class3 = ArrayCoreMap.class;
      List<CoreMap> list0 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 0, (Class) class0, (Class) class1, (Class) class2, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      CoreLabel coreLabel0 = new CoreLabel(1004);
      linkedList0.listIterator();
      coreLabel0.setAfter("");
      coreLabel0.setIndex(0);
      labeledChunkIdentifier0.getTagType("");
      linkedList0.add(coreLabel0);
      linkedList0.spliterator();
      Class<ArrayCoreMap> class4 = ArrayCoreMap.class;
      Class<Object> class5 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 0, (Class) class4, (Class) class5);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("richochet");
      labeledChunkIdentifier0.setDefaultNegTag("]");
      labeledChunkIdentifier0.setDefaultPosTag("I");
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      Class<Object> class6 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, (-1994176844), (Class) class1, (Class) class6, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      assertFalse(list1.equals((Object)list0));
  }

  @Test(timeout = 4000)
  public void testIsIgnoreProvidedTagReturningTrue()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("nl4\"lya_n", "WM0y0lF~^", "nl4\"lya_n");
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier_LabelTagType0.toString();
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setNegLabel("M6`d");
      labeledChunkIdentifier0.getNegLabel();
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      labeledChunkIdentifier0.getTagType((String) null);
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier0.setNegLabel("(nl4\"lya_n,WM0y0lF~^,nl4\"lya_n)");
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier1.getNegLabel());
      
      labeledChunkIdentifier1.setNegLabel("Bs=@Z()cGhO:V");
      assertEquals("O", labeledChunkIdentifier1.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testGetTagTypeThrowsIllegalStateException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("&}AF:-U");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetTagTypeThrowsNullPointerException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("New chunk started, prev chunk not ended yet!");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("New chunk started, prev chunk not ended yet!", "New chunk started, prev chunk not ended yet!", "New chunk started, prev chunk not ended yet!");
      labeledChunkIdentifier_LabelTagType1.toString();
      labeledChunkIdentifier_LabelTagType1.toString();
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier_LabelTagType1.toString();
      labeledChunkIdentifier0.setNegLabel((String) null);
      labeledChunkIdentifier0.getNegLabel();
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("trainspot");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testGetDefaultPosTagReturningEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultPosTag("e+`) S5e#\"i");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("", "", "");
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      String string0 = labeledChunkIdentifier_LabelTagType0.toString();
      LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier0.setDefaultPosTag("");
      String string1 = labeledChunkIdentifier0.getDefaultPosTag();
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkThrowsNullPointerExceptionAndCreatesLabeledChunkIdentifierTakingNoArguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel[] coreLabelArray0 = new CoreLabel[2];
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      coreLabelArray0[0] = coreLabel0;
      String string0 = null;
      CoreLabel coreLabel1 = CoreLabel.wordFromString((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel1);
      CoreLabel coreLabel2 = treeGraphNode0.label();
      coreLabelArray0[1] = coreLabel2;
      // Undeclared exception!
      try { 
        LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, (LabeledChunkIdentifier.LabelTagType) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments5()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("]", "]", "]");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6ArgumentsWithPositive()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply(",uDi $GN`Wy");
      Class<CoreAnnotations.TextAnnotation> class0 = CoreAnnotations.TextAnnotation.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 40, class0, class0, class0, class0);
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsAndIsStartOfChunk()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>();
      Class<CoreLabel.OutputFormat> class0 = CoreLabel.OutputFormat.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      Class<ArrayCoreMap> class3 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 0, (Class) class0, (Class) class1, (Class) class2, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      CoreLabel coreLabel0 = new CoreLabel(1004);
      linkedList0.listIterator();
      coreLabel0.setAfter("");
      coreLabel0.setIndex(0);
      labeledChunkIdentifier0.getTagType("");
      boolean boolean0 = linkedList0.add(coreLabel0);
      linkedList0.spliterator();
      Class<ArrayCoreMap> class4 = ArrayCoreMap.class;
      Class<Object> class5 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 0, (Class) class4, (Class) class5);
      labeledChunkIdentifier0.setDefaultNegTag("richochet");
      labeledChunkIdentifier0.setDefaultNegTag("]");
      labeledChunkIdentifier0.setDefaultPosTag("I");
      Class<ArrayCoreMap> class6 = ArrayCoreMap.class;
      Class<Object> class7 = Object.class;
      Class<ArrayCoreMap> class8 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 0, (Class) class6, (Class) class7, (Class) class8, (Class) class1);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("Kw2YJ*/ <", "`{2$p/+?", "");
      boolean boolean1 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void testGetNegLabelReturningNonEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      Vector<CoreLabel> vector0 = new Vector<CoreLabel>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      vector0.iterator();
      labeledChunkIdentifier0.setNegLabel("[");
      coreLabel0.setEmptyIndex((-537));
      vector0.add(coreLabel0);
      vector0.add(coreLabel0);
      ArrayCoreMap[] arrayCoreMapArray0 = new ArrayCoreMap[2];
      arrayCoreMapArray0[0] = (ArrayCoreMap) coreLabel0;
      arrayCoreMapArray0[1] = (ArrayCoreMap) coreLabel0;
      String[] stringArray0 = new String[5];
      stringArray0[0] = "[";
      stringArray0[1] = "[";
      stringArray0[2] = "[";
      stringArray0[3] = "[";
      stringArray0[4] = "[";
      coreLabel0.toShorterString(stringArray0);
      vector0.toArray(arrayCoreMapArray0);
      Class<CoreLabel.OutputFormat> class0 = CoreLabel.OutputFormat.class;
      List.of(arrayCoreMapArray0[1], arrayCoreMapArray0[0]);
      Class<CoreLabel.OutputFormat> class1 = CoreLabel.OutputFormat.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) vector0, 699, (Class) class0, (Class) class0, (Class) class0, (Class) class1);
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier0.getNegLabel();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testSetDefaultNegTagWithEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType((String) null);
      labeledChunkIdentifier0.setNegLabel("O");
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier0.setNegLabel("O");
      labeledChunkIdentifier_LabelTagType0.tag = "gzZnz";
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("m[3HkQk20Q/,Ul}*u", "#A(9%ivRo;4u)qyO|b", "O");
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType1);
      labeledChunkIdentifier0.setDefaultNegTag("");
      labeledChunkIdentifier0.setDefaultNegTag("m[3HkQk20Q/,Ul}*u");
      String[] stringArray0 = new String[6];
      stringArray0[0] = "m[3HkQk20Q/,Ul}*u";
      stringArray0[1] = "gzZnz";
      stringArray0[2] = "gzZnz";
      stringArray0[3] = null;
      stringArray0[4] = null;
      stringArray0[5] = "gzZnz";
      NERClassifierCombiner nERClassifierCombiner0 = null;
      try {
        nERClassifierCombiner0 = new NERClassifierCombiner(stringArray0);
        fail("Expecting exception: IOException");
      
      } catch(Throwable e) {
         //
         // Couldn't load classifier from m[3HkQk20Q/,Ul}*u
         //
         verifyException("edu.stanford.nlp.ie.ClassifierCombiner", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkReturningFalse()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultPosTag("stab");
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("_X>CG4");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("A![s)jC*!5:");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetDefaultPosTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getDefaultPosTag();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", string0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsWithEmptyList()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>();
      Class<Object> class0 = Object.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 1228, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testSetDefaultPosTagWithNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel[] coreLabelArray0 = new CoreLabel[2];
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      coreLabelArray0[0] = coreLabel0;
      CoreLabel coreLabel1 = CoreLabel.wordFromString((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel1);
      CoreLabel coreLabel2 = treeGraphNode0.label();
      coreLabelArray0[1] = coreLabel2;
      List<CoreLabel> list0 = List.of(coreLabelArray0);
      Class<Object> class0 = Object.class;
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 922, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      assertEquals(0, list1.size());
      
      labeledChunkIdentifier0.setDefaultNegTag("0dUBER:e^Az9[gBGI$-");
      coreLabelTokenFactory0.makeToken(coreLabel2);
      labeledChunkIdentifier0.setDefaultNegTag("useFeaturesCpC4gram");
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      labeledChunkIdentifier0.setDefaultPosTag((String) null);
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack1 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter1 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      Class<Object> class1 = Object.class;
      List<CoreMap> list2 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 1916, (Class) class1, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter1);
      assertEquals(2, list2.size());
      
      labeledChunkIdentifier0.getTagType("dRH|Vd'^^\"1>60");
      labeledChunkIdentifier0.getDefaultNegTag();
      System.setCurrentTimeMillis(0L);
      Class<Object> class2 = Object.class;
      List<CoreMap> list3 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1880542264), class2, class2);
      assertTrue(list3.equals((Object)list1));
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsAndGetDefaultPosTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      WordTag wordTag0 = new WordTag("", "");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.getChildrenAsList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordTag0, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      ArrayList<CoreLabel> arrayList0 = new ArrayList<CoreLabel>();
      ArrayList<CoreLabel> arrayList1 = treeGraphNode2.yieldHasWord(arrayList0);
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<CoreLabel> class1 = CoreLabel.class;
      Predicate<Pair<CoreLabel, CoreLabel>>[] predicateArray0 = (Predicate<Pair<CoreLabel, CoreLabel>>[]) Array.newInstance(Predicate.class, 7);
      Vector<Predicate<Pair<CoreLabel, CoreLabel>>> vector0 = new Vector<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(vector0);
      predicateArray0[0] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0;
      Filters.ConjFilter<Pair<CoreLabel, CoreLabel>> filters_ConjFilter0 = new Filters.ConjFilter<Pair<CoreLabel, CoreLabel>>(vector0);
      predicateArray0[1] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_ConjFilter0;
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter1 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(vector0);
      predicateArray0[2] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter1;
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter2 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(predicateArray0);
      predicateArray0[3] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter2;
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(true);
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(coreLabel0);
      predicateArray0[4] = predicate0;
      Filters.ConjFilter<Pair<CoreLabel, CoreLabel>> filters_ConjFilter1 = new Filters.ConjFilter<Pair<CoreLabel, CoreLabel>>(vector0);
      predicateArray0[5] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_ConjFilter1;
      Object object0 = new Object();
      Pair<ArrayCoreMap, CoreLabel> pair0 = Pair.makePair(coreLabel0, coreLabel0);
      Pair<Object, Object> pair1 = Pair.makePair(object0, pair0);
      Predicate<Pair<CoreLabel, CoreLabel>> predicate1 = Predicate.isEqual(pair1);
      predicateArray0[6] = predicate1;
      Filters.ConjFilter<Pair<CoreLabel, CoreLabel>> filters_ConjFilter2 = new Filters.ConjFilter<Pair<CoreLabel, CoreLabel>>(predicateArray0);
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList1, 440, (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_ConjFilter2);
      assertTrue(list1.isEmpty());
      
      labeledChunkIdentifier0.setNegLabel("");
      labeledChunkIdentifier0.getDefaultPosTag();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetAnnotatedChunksTaking5Arguments()  throws Throwable  {
      Properties properties0 = new Properties();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags(properties0);
      List<CoreLabel> list0 = List.of(seqClassifierFlags0.pad, seqClassifierFlags0.pad);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      Class<CoreLabel> class0 = CoreLabel.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 1, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals(0, list1.size());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkWithNullAndNull()  throws Throwable  {
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk((LabeledChunkIdentifier.LabelTagType) null, (LabeledChunkIdentifier.LabelTagType) null);
      assertFalse(boolean0);
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("", "", "\u6628\u65E5");
      labeledChunkIdentifier_LabelTagType0.tag = "";
      labeledChunkIdentifier_LabelTagType0.label = null;
      labeledChunkIdentifier_LabelTagType0.type = "\u6628\u65E5";
      labeledChunkIdentifier_LabelTagType0.label = "\u6628\u65E5";
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultPosTag("\u6628\u65E5");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("");
      labeledChunkIdentifier_LabelTagType1.toString();
      labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType1);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("");
      labeledChunkIdentifier0.getTagType("");
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testTypeMatches()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("Seralizing classifier to ", "Seralizing classifier to ", "Seralizing classifier to ");
      boolean boolean0 = labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetTagType0()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getTagType("O");
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagTypeWithNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType((String) null);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkThrowsNullPointerException()  throws Throwable  {
      // Undeclared exception!
      try { 
        LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, (LabeledChunkIdentifier.LabelTagType) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsWithEmptyList()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      Class<CoreLabel> class0 = CoreLabel.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, (-78), (Class) class0, (Class) class0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsAndGetAnnotatedChunksTaking6Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("CNqEESNB", "CNqEESNB", 1034, 1034);
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<Object> class1 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 1034, class0, class1);
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("4L*iW", "4L*iW", "4L*iW");
      labeledChunkIdentifier_LabelTagType0.toString();
      Class<CoreLabel> class2 = CoreLabel.class;
      List<CoreMap> list2 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 1034, class0, class1, class0, class2);
      assertNotSame(list2, list1);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4Arguments()  throws Throwable  {
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      List<CoreLabel> list0 = List.of(seqClassifierFlags0.pad, seqClassifierFlags0.pad);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, Integer.MAX_VALUE, class0, class0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals(0, list1.size());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndGetTagTypeAndIsEndOfChunk0()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("e", "S", "e");
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier1.getTagType("multiThreadClassifier");
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      boolean boolean1 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunk1()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType((String) null, "E", "@2@m6*/w}Ajmy#");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments6()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("Unclosed paren in encoded map: ", "Unclosed paren in encoded map: ", "Unclosed paren in encoded map: ");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("L", "Unclosed paren in encoded map: ", "L");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndSetDefaultNegTag()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("nl4\"lya_n", "WM0y0lF~^", "nl4\"lya_n");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("~`j", "~`j", "gBJs$!~xyUhI(\":YV\"");
      labeledChunkIdentifier_LabelTagType1.tag = "gBJs$!~xyUhI(\":YV\"";
      String string0 = labeledChunkIdentifier_LabelTagType1.toString();
      assertEquals("(~`j,gBJs$!~xyUhI(\":YV\",gBJs$!~xyUhI(\":YV\")", string0);
      
      labeledChunkIdentifier_LabelTagType1.label = "";
      labeledChunkIdentifier_LabelTagType1.toString();
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType1);
      assertFalse(boolean0);
      
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getTagType("(,gBJs$!~xyUhI(\":YV\",gBJs$!~xyUhI(\":YV\")");
      labeledChunkIdentifier0.setDefaultNegTag("");
      labeledChunkIdentifier0.setDefaultNegTag("");
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      labeledChunkIdentifier1.setDefaultNegTag((String) null);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType2 = labeledChunkIdentifier1.getTagType("~`j");
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType2, labeledChunkIdentifier_LabelTagType0);
      assertEquals("O", labeledChunkIdentifier1.getNegLabel());
      assertFalse(labeledChunkIdentifier1.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments7()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("/", "/", "/");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndSetDefaultNegTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("'j`Ko+d1m}pc,+f");
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments8()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "U", "U");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments5()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("Serializing classifier to ", "Serializing classifier to ", "Serializing classifier to ");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetTagTypeReturningNonNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel[] coreLabelArray0 = new CoreLabel[2];
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken();
      coreLabelArray0[0] = coreLabel0;
      CoreLabel coreLabel1 = CoreLabel.wordFromString((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel1);
      CoreLabel coreLabel2 = treeGraphNode0.label();
      coreLabelArray0[1] = coreLabel2;
      List<CoreLabel> list0 = List.of(coreLabelArray0);
      Class<Object> class0 = Object.class;
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 922, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      labeledChunkIdentifier0.getTagType("G]T{1UYy;{LU3");
      labeledChunkIdentifier0.getTagType("G]T{1UYy;{LU3");
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("WAt-*(}&r*w*g/pR");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsWithNegativeAndSetDefaultNegTagWithNull()  throws Throwable  {
      Properties properties0 = new Properties();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      CoreLabel coreLabel0 = seqClassifierFlags0.pad;
      List<CoreLabel> list0 = List.of(seqClassifierFlags0.pad, coreLabel0);
      Class<Object> class0 = Object.class;
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1), class0, class0);
      labeledChunkIdentifier0.setDefaultNegTag((String) null);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("", "B", "I");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType(".", "4", (String) null);
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      labeledChunkIdentifier1.setIgnoreProvidedTag(true);
      LabeledChunkIdentifier labeledChunkIdentifier2 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier2.getDefaultPosTag();
      assertEquals("I", string0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndToString()  throws Throwable  {
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("4", "B", "4");
      labeledChunkIdentifier_LabelTagType0.toString();
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
      
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("4");
      String string0 = labeledChunkIdentifier_LabelTagType1.toString();
      assertEquals("(4,I,4)", string0);
      
      boolean boolean1 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean1);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndGetTagTypeAndIsEndOfChunk1()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("m0g+AmzRa)wy", "m0g+AmzRa)wy", "m0g+AmzRa)wy");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("4>`+1P!#,ga=hIJSX");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      boolean boolean1 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean1 == boolean0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void testGetTagTypeAndGetTagTypeThrowsIllegalStateException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("'Mt~fO]cBvzLq:J}");
      CoreLabel coreLabel1 = new CoreLabel(370);
      List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel1);
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack0 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack0);
      coreLabel1.isNewline();
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("$b$D-");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getDefaultNegTag();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", string0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      List<CoreLabel> list0 = null;
      int int0 = 0;
      Class<Object> class0 = Object.class;
      labeledChunkIdentifier0.getTagType("O");
      Class<Object> class1 = Object.class;
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) null, 0, class0, class1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.pipeline.LabeledChunkIdentifier", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesLabelTagTypeTaking3ArgumentsAndToString()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "U", "U");
      String string0 = labeledChunkIdentifier_LabelTagType0.toString();
      assertEquals("(U,U,U)", string0);
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetTagType1()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getTagType("coif");
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testIsIgnoreProvidedTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      boolean boolean0 = labeledChunkIdentifier0.isIgnoreProvidedTag();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(boolean0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetTagType()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("e");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testIsIgnoreProvidedTagAndIsEndOfChunk()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getDefaultNegTag();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("New chunk started, prev chunk not ended yet!");
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier_LabelTagType0.type = "";
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier_LabelTagType0.toString();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      labeledChunkIdentifier0.setNegLabel("");
      labeledChunkIdentifier0.getNegLabel();
      labeledChunkIdentifier_LabelTagType0.label = "";
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier0.setIgnoreProvidedTag(false);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("J^{4FVPnQ?fSqg");
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      labeledChunkIdentifier_LabelTagType1.toString();
      labeledChunkIdentifier0.setNegLabel("J\"$$q-&6XBT4eA ");
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      labeledChunkIdentifier_LabelTagType0.toString();
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      labeledChunkIdentifier0.setNegLabel("");
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments6()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "U", "U");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getNegLabel();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", string0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testSetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      labeledChunkIdentifier0.setNegLabel("L");
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testSetNegLabelAndSetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setNegLabel("/u/nlp/data/dist.male.first");
      // Undeclared exception!
      try { 
        WordTag.valueOf((String) null, (String) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.WordTag", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      labeledChunkIdentifier0.setDefaultPosTag("");
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }
}
