/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Jun 11 22:03:49 GMT 2025
 */

package edu.stanford.nlp.pipeline;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ling.BasicDocument;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.pipeline.LabeledChunkIdentifier;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.sequences.TrueCasingForNISTDocumentReaderAndWriter;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.util.ArrayCoreMap;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.Filters;
import edu.stanford.nlp.util.Pair;
import java.io.StringReader;
import java.lang.reflect.Array;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Stack;
import java.util.Vector;
import java.util.function.Predicate;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.mock.java.net.MockURI;
import org.evosuite.runtime.mock.java.util.MockRandom;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class LabeledChunkIdentifier_2_ESTest extends LabeledChunkIdentifier_2_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagTypeAndCreatesLabelTagTypeTaking3ArgumentsAndGetTagTypeWithNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "B");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType((String) null);
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetDefaultPosTagReturningEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("ibvut must be sorted!");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<Object> class0 = Object.class;
      labeledChunkIdentifier0.setDefaultPosTag("");
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-2573), (Class) class0, (Class) class0, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      labeledChunkIdentifier0.getDefaultPosTag();
      Random.setNextRandom((-2573));
  }

  @Test(timeout = 4000)
  public void testGetNegLabelReturningNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      labeledChunkIdentifier0.setNegLabel((String) null);
      labeledChunkIdentifier0.getNegLabel();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testGetNegLabelReturningEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier1.getNegLabel());
      
      labeledChunkIdentifier1.setNegLabel("");
      labeledChunkIdentifier1.getNegLabel();
      assertFalse(labeledChunkIdentifier1.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetDefaultPosTagReturningNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      labeledChunkIdentifier0.setDefaultPosTag((String) null);
      Class<Object> class0 = Object.class;
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      Class<String> class1 = String.class;
      Class<Object> class2 = Object.class;
      Filters.RandomFilter<Object> filters_RandomFilter0 = new Filters.RandomFilter<Object>();
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.not(filters_RandomFilter0);
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, (-1372), (Class) class1, (Class) class0, (Class) class0, (Class) class2, predicate0);
      labeledChunkIdentifier0.getDefaultPosTag();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsWithPositive()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("$", "B", ".");
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      labeledChunkIdentifier1.setDefaultNegTag(".");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("HCk");
      Morphology morphology0 = new Morphology();
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>((-1173.749));
      Class<Object> class0 = Object.class;
      Class<Object> class1 = Object.class;
      Class<Object> class2 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier1.getAnnotatedChunks(list0, 2234, (Class) class1, (Class) class0, (Class) class2, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertTrue(list1.isEmpty());
      
      System.setCurrentTimeMillis(339L);
      Class<Object> class3 = Object.class;
      labeledChunkIdentifier1.getAnnotatedChunks(list0, 2234, (Class) class3, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 2234, class0, class1);
      labeledChunkIdentifier1.getDefaultPosTag();
      assertFalse(labeledChunkIdentifier1.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier1.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsAndGetDefaultPosTagAndSetDefaultNegTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("$", "B", ".");
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      labeledChunkIdentifier1.setDefaultNegTag(".");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply(".");
      Morphology morphology0 = new Morphology();
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>((-1173.749));
      Class<Object> class0 = Object.class;
      System.setCurrentTimeMillis(2234);
      Class<Object> class1 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier1.getAnnotatedChunks(list0, 2234, (Class) class1, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals(0, list1.size());
      
      labeledChunkIdentifier1.getDefaultPosTag();
      assertFalse(labeledChunkIdentifier1.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier1.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "U", "U");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7Arguments0()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("L");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("wY4|[z) |g8i5h~8");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-2034616337), (Class) class0, (Class) class0, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals(2, list1.size());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("[", "[", "[");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagTypeAndCreatesLabelTagTypeTaking3Arguments0()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "B");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("B");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagTypeAndCreatesLabelTagTypeTaking3Arguments1()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "B");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("B");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertFalse(boolean0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagReturningNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("-i", "NP-2", "-i");
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier0.setDefaultNegTag((String) null);
      labeledChunkIdentifier0.getTagType("P$iaFMnr/}Z8xO3uK");
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("I");
      Morphology morphology0 = new Morphology();
      Morphology morphology1 = new Morphology();
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>((-2791.677281641968));
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      Class<Object> class0 = Object.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      labeledChunkIdentifier0.setNegLabel("9");
      Class<CoreLabel> class2 = CoreLabel.class;
      Class<ArrayCoreMap> class3 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-8323580), (Class) class1, (Class) class0, (Class) class2, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      labeledChunkIdentifier0.getDefaultNegTag();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "B");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments2()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "B");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsThrowsIllegalStateException()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("/^ADP/< (^A`VP/ ++ (/^(,|CC|CNJP)BA [$+ (RBadv [ < ~ot |B<Xzhen Y) | + (ADVP=adv <: RB)])) : (=adv $+ /^P-AD|ADVP|PP/deX)");
      Class<CoreAnnotations.TextAnnotation> class0 = CoreAnnotations.TextAnnotation.class;
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks(list0, 20, class0, class0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7Arguments1()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("S");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("S");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-2034521371), (Class) class0, (Class) class0, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals(1, list1.size());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7Arguments2()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("L");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("L");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-2034616337), (Class) class0, (Class) class0, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments3()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("E", "E", "E");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("U", "U", "U");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull2()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("E", "E", "E");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments4()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("]", "]", "]");
      labeledChunkIdentifier_LabelTagType0.tag = "L";
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("]", "L", "]");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6ArgumentsReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("]", "]", "]");
      labeledChunkIdentifier_LabelTagType0.tag = "]";
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("]");
      labeledChunkIdentifier0.getTagType("]");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("A");
      StringReader stringReader0 = new StringReader("]");
      Morphology morphology0 = new Morphology(stringReader0, (-1));
      trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.andThen(morphology0);
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>((-466.90778669));
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      Class<CoreLabel> class3 = CoreLabel.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1953096232), (Class) class0, (Class) class1, (Class) class2, (Class) class3, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      Random.setNextRandom((-2629));
      Class<Object> class4 = Object.class;
      Class<Object> class5 = Object.class;
      Class<Object> class6 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 46, class4, class5, class0, class6);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments5()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("u.\\d", ".", "u.\\d");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments6()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("S", "S", "S");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull3()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("E-ORG", "E", "ORG");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("S-ORG", "S", "ORG");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsAndGetTagTypeAndIsStartOfChunk()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("U");
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier0.setDefaultNegTag("X?e");
      labeledChunkIdentifier0.getTagType("lFr8J");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("^");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(1295.645385768);
      Class<Object> class0 = Object.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Class<Object> class2 = Object.class;
      Predicate<Pair<CoreLabel, CoreLabel>> predicate0 = Predicate.isEqual(trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1484), class0, class1, class1, class2, predicate0);
      Random.setNextRandom((-5956));
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsAndGetAnnotatedChunksTaking7ArgumentsWithPositive()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("/^ADVP/ < (/^ADVP/ $++ (/^(,|CC|CONJP)BA [$+ (RB=adv [ < ~ot |B<3then ]) | $+ (ADVP=adv <: RB)])) : (=adv $+ /^NP-ADV|ADVP|PP/=dest)");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("/^ADVP/ < (/^ADVP/ $++ (/^(,|CC|CONJP)BA [$+ (RB=adv [ < ~ot |B<3then ]) | $+ (ADVP=adv <: RB)])) : (=adv $+ /^NP-ADV|ADVP|PP/=dest)");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 1676, (Class) class0, (Class) class0, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("]");
      labeledChunkIdentifier_LabelTagType0.tag = "]";
      labeledChunkIdentifier_LabelTagType0.type = "]";
      labeledChunkIdentifier_LabelTagType0.tag = "]";
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("]");
      labeledChunkIdentifier0.getTagType("]");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("]");
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<Object> class1 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 1527, class0, class1);
      labeledChunkIdentifier0.setDefaultNegTag("I");
      Class<Object> class2 = Object.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 1527, (Class) class2, (Class) class2, (Class) class0, (Class) class2, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      Class<ArrayCoreMap> class3 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 390, (Class) class3, (Class) class2, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6ArgumentsThrowsClassCastException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("]");
      labeledChunkIdentifier_LabelTagType0.tag = "]";
      labeledChunkIdentifier_LabelTagType0.type = "]";
      labeledChunkIdentifier_LabelTagType0.tag = "]";
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier0.setDefaultNegTag("]");
      labeledChunkIdentifier0.getTagType("]");
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("]");
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<Object> class1 = Object.class;
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("(useCRFforUnsup,,idyl)");
      Class<Object> class2 = Object.class;
      MockRandom mockRandom0 = new MockRandom(1527);
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(2390.68, mockRandom0);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 1527, (Class) class0, (Class) class1, (Class) class2, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      Random.setNextRandom(1527);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 1527, (Class) class1, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      Class<Object> class3 = Object.class;
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks(list0, 1527, class1, class3, class2, class2);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // class edu.stanford.nlp.pipeline.Annotation cannot be cast to class java.lang.String (edu.stanford.nlp.pipeline.Annotation is in unnamed module of loader org.evosuite.instrumentation.InstrumentingClassLoader @5aae7c6c; java.lang.String is in module java.base of loader 'bootstrap')
         //
         verifyException("edu.stanford.nlp.pipeline.LabeledChunkIdentifier", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetTagTypeThrowsIllegalStateException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType(" fold cross-validation");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull4()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("[", "[", "[");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsWithNegative()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("cb^yb\"kFWCao0F2b");
      Class<CoreAnnotations.TextAnnotation> class0 = CoreAnnotations.TextAnnotation.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-158), class0, class0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals(1, list1.size());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagTypeAndCreatesLabelTagTypeTaking3Arguments2()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("O", "O", "O");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("j{#DwHW5@gJ{");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertTrue(boolean0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsReturningListWhereIsEmptyIsTrueAndListWhereSizeIsZero()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("disembed");
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<CoreLabel> class1 = CoreLabel.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-220), class0, class0, class1, class0);
      assertEquals(0, list1.size());
      
      labeledChunkIdentifier0.getTagType("(45[{XzlV)");
      Class<Object> class2 = Object.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>((-1.0));
      Class<Object> class3 = Object.class;
      Class<ArrayCoreMap> class4 = ArrayCoreMap.class;
      List<CoreMap> list2 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-220), (Class) class3, (Class) class0, (Class) class2, (Class) class4, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals(0, list2.size());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNull0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("I-LOC", "I", "LOC");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagReturningEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("[");
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("I");
      ArrayList<CoreLabel> arrayList0 = new ArrayList<CoreLabel>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      coreLabelTokenFactory0.makeToken("Vngg8W", "?Dh)*K&O8eM&~+ZZ)V", 826, (-937));
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("I", "I", (-937), (-937));
      Vector<CoreLabel> vector0 = new Vector<CoreLabel>();
      vector0.add(coreLabel0);
      Class<Object> class0 = Object.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) arrayList0, 579, (Class) class0, (Class) class1, (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier0.setDefaultNegTag("I");
      labeledChunkIdentifier_LabelTagType0.label = "cancelled";
      labeledChunkIdentifier0.setIgnoreProvidedTag(false);
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      labeledChunkIdentifier0.setDefaultNegTag("'&kL7~.3@k8MKpFg");
      labeledChunkIdentifier0.getTagType("I");
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetTagTypeThrowsIllegalStateExceptionAndGetTagType()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("(45Q{X*lV)", "S", "oZn5ccbt+\ne!-");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("(45Q{X*lV)");
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType("oZn5ccbt+\ne!-");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkReturningTrue()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("(45[{XzlV)");
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<Object> class1 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks(list0, 350, class0, class0, class0, class1);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("(45[{XzlV)");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("Americanize[capitalizeTimex is ", "I", "~:X~|3ddBV0otnc;d");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagType0()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("B");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("I");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertTrue(boolean0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetAnnotatedChunksTaking7Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("input must be sorted!");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1363), (Class) class0, (Class) class0, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertTrue(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType((String) null);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("O", (String) null, (String) null);
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsWithNullAndGetTagTypeWithEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getTagType("");
      labeledChunkIdentifier0.getTagType(".");
      Vector<CoreLabel> vector0 = new Vector<CoreLabel>();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(true);
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("++B o5A;x3Ik5cJ7|", "`9ul?", (-1), (-1));
      vector0.add(coreLabel0);
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<Object> class1 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) vector0, 579, (Class) class0, (Class) class0, (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      labeledChunkIdentifier0.getDefaultNegTag();
      labeledChunkIdentifier0.setDefaultNegTag(".");
      labeledChunkIdentifier0.getDefaultPosTag();
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      Class<Object> class2 = Object.class;
      Class<Word> class3 = Word.class;
      Class<Word> class4 = Word.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) vector0, (-2876), (Class) class2, (Class) class3, (Class) class0, (Class) class4, (Predicate<Pair<CoreLabel, CoreLabel>>) null);
      assertTrue(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNull1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType(".-PER", ".", "PER");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsAndGetDefaultPosTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setDefaultNegTag("=f.YXg>l5-m`vt0");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("input must be sorted!");
      Class<CoreLabel> class0 = CoreLabel.class;
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      Class<Object> class1 = Object.class;
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      LinkedList<Predicate<Pair<CoreLabel, CoreLabel>>> linkedList0 = new LinkedList<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(linkedList0);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1574), (Class) class0, (Class) class1, (Class) class2, (Class) class2, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0);
      String string0 = labeledChunkIdentifier1.getDefaultPosTag();
      assertEquals("I", string0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkWithNullAndNull()  throws Throwable  {
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk((LabeledChunkIdentifier.LabelTagType) null, (LabeledChunkIdentifier.LabelTagType) null);
      assertFalse(boolean0);
      
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getTagType((String) null);
      String[] stringArray0 = new String[7];
      stringArray0[0] = "O";
      stringArray0[1] = null;
      stringArray0[2] = "O";
      stringArray0[3] = "O";
      stringArray0[4] = "O";
      stringArray0[5] = "O";
      stringArray0[6] = "O";
      CoreLabel coreLabel0 = null;
      try {
        coreLabel0 = new CoreLabel(stringArray0, stringArray0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Unknown key O
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagType1()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("runnel");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(boolean0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndIsEndOfChunkAndToString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("");
      labeledChunkIdentifier_LabelTagType0.type = ")[0eSw";
      LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      BasicDocument<CoreLabel> basicDocument0 = new BasicDocument<CoreLabel>();
      basicDocument0.blankDocument();
      int int0 = 51;
      labeledChunkIdentifier_LabelTagType0.toString();
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      try { 
        MockURI.URI((String) null, ")[0eSw", (String) null, "j1cu`gp7KojK=MOEN");
        fail("Expecting exception: URISyntaxException");
      
      } catch(URISyntaxException e) {
         //
         // Illegal character in hostname at index 2: //)[0eSw#j1cu%60gp7KojK=MOEN
         //
         verifyException("java.net.URI$Parser", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagAndSetIgnoreProvidedTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getDefaultNegTag();
      assertEquals("O", string0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType((String) null);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("Q6IH.i[q", "O", "Q6IH.i[q");
      labeledChunkIdentifier_LabelTagType1.label = "";
      labeledChunkIdentifier_LabelTagType0.label = "Q6IH.i[q";
      boolean boolean0 = labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType1);
      assertFalse(boolean0);
      
      labeledChunkIdentifier0.setIgnoreProvidedTag(false);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkReturningTrue()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("]");
      labeledChunkIdentifier_LabelTagType0.tag = "]";
      labeledChunkIdentifier_LabelTagType0.type = "]";
      labeledChunkIdentifier_LabelTagType0.tag = "]";
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      labeledChunkIdentifier0.setDefaultNegTag("]");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("");
      ArrayList<CoreLabel> arrayList0 = new ArrayList<CoreLabel>();
      labeledChunkIdentifier_LabelTagType1.label = "]";
      int int0 = 0;
      Tree.valueOf("]");
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode((Label) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel$CoreLabelFactory", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateLabeledChunkIdentifierTakingNoArgumentsThrowsNullPointerException()  throws Throwable  {
      // Undeclared exception!
      try { 
        LabeledChunkIdentifier.isStartOfChunk((LabeledChunkIdentifier.LabelTagType) null, (LabeledChunkIdentifier.LabelTagType) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testGetDefaultNegTagAndSetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setNegLabel("L");
      labeledChunkIdentifier0.getDefaultNegTag();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("");
      labeledChunkIdentifier0.setNegLabel("O");
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6ArgumentsThrowsNullPointerException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("New chunk started, prev chunk not ended yet!");
      labeledChunkIdentifier_LabelTagType0.toString();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("", "I", "New chunk started, prev chunk not ended yet!");
      labeledChunkIdentifier_LabelTagType1.tag = "";
      labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType1);
      labeledChunkIdentifier0.getDefaultPosTag();
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Class<Object> class2 = Object.class;
      Class<Object> class3 = Object.class;
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) null, 3030, class0, class1, class2, class3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.pipeline.LabeledChunkIdentifier", e);
      }
  }

  @Test(timeout = 4000)
  public void testToString()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("", "", "");
      String string0 = labeledChunkIdentifier_LabelTagType0.toString();
      assertEquals("(,,)", string0);
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6ArgumentsWithPositive()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("(45[{XzlV)");
      Class<CoreLabel> class0 = CoreLabel.class;
      Class<Object> class1 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 350, class0, class0, class0, class1);
      assertEquals(0, list1.size());
      
      labeledChunkIdentifier0.getTagType("(45[{XzlV)");
      Class<CoreLabel> class2 = CoreLabel.class;
      Class<ArrayCoreMap> class3 = ArrayCoreMap.class;
      Class<Object> class4 = Object.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(0.95);
      labeledChunkIdentifier0.getAnnotatedChunks(list0, (-3956), (Class) class0, (Class) class2, (Class) class3, (Class) class4, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      Class<Object> class0 = Object.class;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(1197707441);
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) null, 1197707441, (Class) class0, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.pipeline.LabeledChunkIdentifier", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking5Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("RB_q2x(b>0", "kGft$0, WujkGbLv", "RB_q2x(b>0");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
      
      labeledChunkIdentifier0.setIgnoreProvidedTag(false);
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      Class<Object> class0 = Object.class;
      Class<ArrayCoreMap> class1 = ArrayCoreMap.class;
      Predicate<Pair<CoreLabel, CoreLabel>>[] predicateArray0 = (Predicate<Pair<CoreLabel, CoreLabel>>[]) Array.newInstance(Predicate.class, 9);
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>((-2297.518));
      predicateArray0[0] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter1 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      predicateArray0[1] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter1;
      Stack<Predicate<Pair<CoreLabel, CoreLabel>>> stack1 = new Stack<Predicate<Pair<CoreLabel, CoreLabel>>>();
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter0 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack1);
      predicateArray0[2] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter0;
      MockRandom mockRandom0 = new MockRandom(0);
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter2 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(0.0, mockRandom0);
      predicateArray0[3] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter2;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter3 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(0.0);
      predicateArray0[4] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter3;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter4 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(0);
      predicateArray0[5] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter4;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter5 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(0.0, mockRandom0);
      predicateArray0[6] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter5;
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter1 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(stack1);
      predicateArray0[7] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter1;
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter6 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>();
      predicateArray0[8] = (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter6;
      Filters.DisjFilter<Pair<CoreLabel, CoreLabel>> filters_DisjFilter2 = new Filters.DisjFilter<Pair<CoreLabel, CoreLabel>>(predicateArray0);
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, 0, (Class) class0, (Class) class1, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_DisjFilter2);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments7()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("n", "n", "n");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndIsStartOfChunkAndCreatesLabelTagTypeTaking3Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("B", "B", "ndkfTk*E9EPYt_");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
      
      boolean boolean1 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndGetTagTypeAndGetTagTypeWithNull()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType((String) null);
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6ArgumentsAndGetAnnotatedChunksTaking6ArgumentsWithNonEmptyList()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      CoreLabel coreLabel0 = new CoreLabel();
      List<CoreLabel> list0 = List.of(coreLabel0);
      Class<Object> class0 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, (-1841781662), class0, class0, class0, class0);
      assertEquals(0, list1.size());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndCreatesLabelTagTypeTaking3Arguments8()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("]", "]", "]");
      boolean boolean0 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndGetTagTypeWithNonEmptyString()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("O");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesLabelTagTypeTaking3Arguments0()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("", "B", (String) null);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = new LabeledChunkIdentifier.LabelTagType("B", "*S;I$", (String) null);
      labeledChunkIdentifier_LabelTagType1.tag = "*S;I$";
      labeledChunkIdentifier_LabelTagType1.label = "L";
      // Undeclared exception!
      try { 
        labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull5()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("", "", "");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkAndIsStartOfChunk()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("(45[{XzlV)", "S", "oZn5ccbt+\ne!-");
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("(45[{XzlV)");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType1);
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      Tree.valueOf("p/,aVka");
      boolean boolean1 = LabeledChunkIdentifier.isEndOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean1 == boolean0);
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void testGetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getNegLabel();
      assertEquals("O", string0);
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.getTagType("O");
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testGetTagType()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType(" fold cross-validation");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking7ArgumentsAndGetAnnotatedChunksTaking7Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag("]");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser1 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser1.apply(" ]");
      Filters.RandomFilter<Pair<CoreLabel, CoreLabel>> filters_RandomFilter0 = new Filters.RandomFilter<Pair<CoreLabel, CoreLabel>>(0.0);
      Class<ArrayCoreMap> class0 = ArrayCoreMap.class;
      Class<Object> class1 = Object.class;
      Class<Object> class2 = Object.class;
      List<CoreMap> list1 = labeledChunkIdentifier0.getAnnotatedChunks(list0, 3001, (Class) class1, (Class) class1, (Class) class2, (Class) class0, (Predicate<Pair<CoreLabel, CoreLabel>>) filters_RandomFilter0);
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testSetDefaultPosTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      
      labeledChunkIdentifier0.setDefaultPosTag("7");
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testSetNegLabel()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      
      labeledChunkIdentifier0.setNegLabel("New chu<k started, prev chunk not ended yet!");
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetDefaultPosTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = labeledChunkIdentifier0.getDefaultPosTag();
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", string0);
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndGetTagType()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.getTagType("z{*QxM%'G7us");
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsIgnoreProvidedTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      boolean boolean0 = labeledChunkIdentifier0.isIgnoreProvidedTag();
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
      assertFalse(boolean0);
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
  }

  @Test(timeout = 4000)
  public void testSetIgnoreProvidedTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setIgnoreProvidedTag(false);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testTypeMatches()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("E", "E", "E");
      boolean boolean0 = labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testCreatesLabelTagTypeTaking3Arguments1()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("s", "s", "s");
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking4ArgumentsWithEmptyList()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      Class<Object> class0 = Object.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) stack0, (-36466703), (Class) class0, (Class) class0);
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      assertFalse(labeledChunkIdentifier0.isIgnoreProvidedTag());
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
      assertEquals("I", labeledChunkIdentifier0.getDefaultPosTag());
  }

  @Test(timeout = 4000)
  public void testIsEndOfChunkThrowsIllegalStateException()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      String string0 = "m#Tp4hh\\uF+ty'4K";
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType(string0);
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      LabeledChunkIdentifier labeledChunkIdentifier1 = new LabeledChunkIdentifier();
      labeledChunkIdentifier1.setNegLabel("New chunk started, prev chunk not ended yet!");
      labeledChunkIdentifier_LabelTagType0.toString();
      // Undeclared exception!
      try { 
        labeledChunkIdentifier0.getTagType(" fold cross-validation");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesLabeledChunkIdentifierTakingNoArgumentsAndSetDefaultNegTag()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      assertEquals("O", labeledChunkIdentifier0.getDefaultNegTag());
      
      labeledChunkIdentifier0.setDefaultNegTag(" fold cross-vliaton");
      assertEquals("O", labeledChunkIdentifier0.getNegLabel());
  }

  @Test(timeout = 4000)
  public void testGetAnnotatedChunksTaking6Arguments()  throws Throwable  {
      LabeledChunkIdentifier labeledChunkIdentifier0 = new LabeledChunkIdentifier();
      labeledChunkIdentifier0.setIgnoreProvidedTag(true);
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = labeledChunkIdentifier0.getTagType("_?j]_|N~99(O");
      labeledChunkIdentifier0.setDefaultNegTag("_?j]_|N~99(O");
      labeledChunkIdentifier0.setNegLabel("lsg&&lZfgv2&6");
      labeledChunkIdentifier_LabelTagType0.type = "lsg&&lZfgv2&6";
      labeledChunkIdentifier0.setDefaultPosTag("lsg&&lZfgv2&6");
      labeledChunkIdentifier0.getDefaultPosTag();
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType1 = labeledChunkIdentifier0.getTagType("lsg&&lZfgv2&6");
      labeledChunkIdentifier_LabelTagType0.tag = "oI.DdG)g~_^I_j^9JL";
      labeledChunkIdentifier_LabelTagType1.type = "endFold";
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType2 = labeledChunkIdentifier0.getTagType("endFold");
      labeledChunkIdentifier_LabelTagType0.typeMatches(labeledChunkIdentifier_LabelTagType1);
      labeledChunkIdentifier0.getNegLabel();
      labeledChunkIdentifier0.setDefaultPosTag("");
      labeledChunkIdentifier0.setDefaultNegTag("hn2,HngGT{>~fc");
      labeledChunkIdentifier0.getNegLabel();
      labeledChunkIdentifier0.getNegLabel();
      labeledChunkIdentifier0.setDefaultPosTag("endFold");
      labeledChunkIdentifier0.isIgnoreProvidedTag();
      labeledChunkIdentifier0.setDefaultPosTag("endFold");
      LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType1, labeledChunkIdentifier_LabelTagType2);
      PriorityQueue<CoreLabel> priorityQueue0 = new PriorityQueue<CoreLabel>();
      LinkedList<CoreLabel> linkedList0 = new LinkedList<CoreLabel>(priorityQueue0);
      Class<Object> class0 = Object.class;
      Class<Object> class1 = Object.class;
      Class<ArrayCoreMap> class2 = ArrayCoreMap.class;
      labeledChunkIdentifier0.getAnnotatedChunks((List<CoreLabel>) linkedList0, 40, (Class) class0, (Class) class0, (Class) class1, (Class) class2);
      assertTrue(labeledChunkIdentifier0.isIgnoreProvidedTag());
  }

  @Test(timeout = 4000)
  public void testIsStartOfChunkAndCreatesLabelTagTypeTaking3ArgumentsAndIsStartOfChunkWithNonNull6()  throws Throwable  {
      LabeledChunkIdentifier.LabelTagType labeledChunkIdentifier_LabelTagType0 = new LabeledChunkIdentifier.LabelTagType("]", "]", "]");
      boolean boolean0 = LabeledChunkIdentifier.isStartOfChunk(labeledChunkIdentifier_LabelTagType0, labeledChunkIdentifier_LabelTagType0);
      assertTrue(boolean0);
  }
}
