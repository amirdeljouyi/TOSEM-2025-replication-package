/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Jun 11 21:15:47 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.StringLabel;
import edu.stanford.nlp.ling.StringLabelFactory;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.TaggedWordFactory;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.ling.WordTagFactory;
import edu.stanford.nlp.objectbank.IdentityFunction;
import edu.stanford.nlp.parser.lexparser.BinaryGrammar;
import edu.stanford.nlp.parser.lexparser.ChineseLexiconAndWordSegmenter;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HebrewTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HungarianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ItalianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.NegraPennTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.SpanishUnknownWordModelTrainer;
import edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor;
import edu.stanford.nlp.parser.lexparser.TestOptions;
import edu.stanford.nlp.parser.lexparser.TrainOptions;
import edu.stanford.nlp.parser.lexparser.UnaryGrammar;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.sequences.SeqClassifierFlags;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.trees.BasicCategoryTreeTransformer;
import edu.stanford.nlp.trees.CollinsHeadFinder;
import edu.stanford.nlp.trees.CoordinationTransformer;
import edu.stanford.nlp.trees.DependencyTreeTransformer;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.LabeledScoredTreeReaderFactory;
import edu.stanford.nlp.trees.MemoryTreebank;
import edu.stanford.nlp.trees.NPTmpRetainingTreeNormalizer;
import edu.stanford.nlp.trees.PennTreebankLanguagePack;
import edu.stanford.nlp.trees.QPTreeTransformer;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.SimpleTreeFactory;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeGraphNodeFactory;
import edu.stanford.nlp.trees.TreeLemmatizer;
import edu.stanford.nlp.trees.TreeReaderFactory;
import edu.stanford.nlp.trees.TreebankLanguagePack;
import edu.stanford.nlp.util.DeltaIndex;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.ThreeDimensionalMap;
import edu.stanford.nlp.util.Triple;
import edu.stanford.nlp.util.TwoDimensionalMap;
import java.io.BufferedReader;
import java.io.Reader;
import java.io.StringReader;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.SortedSet;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.function.Consumer;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.util.MockRandom;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class SplittingGrammarExtractor_1_ESTest extends SplittingGrammarExtractor_1_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      double[][] doubleArray0 = new double[2][0];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = Double.NEGATIVE_INFINITY;
      doubleArray1[1] = 0.0;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[7];
      doubleArray2[0] = Double.NEGATIVE_INFINITY;
      doubleArray2[1] = Double.NEGATIVE_INFINITY;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = (double) 100;
      doubleArray2[4] = (double) 100;
      doubleArray2[5] = 0.0;
      doubleArray2[6] = (double) 100;
      doubleArray0[1] = doubleArray2;
      twoDimensionalMap0.put("UNARY:", (String) null, doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(splittingGrammarExtractor1.equals((Object)splittingGrammarExtractor0));
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsAndDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.DEBUG();
      double[][][] doubleArray0 = new double[1][1][8];
      threeDimensionalMap0.put("HB +Zs*KQQO~K", "HB +Zs*KQQO~K", "HB +Zs*KQQO~K", doubleArray0);
      MapFactory.identityHashMapFactory();
      StringLabel stringLabel0 = new StringLabel("HB +Zs*KQQO~K");
      IndexedWord indexedWord0 = new IndexedWord(stringLabel0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      TaggedWord taggedWord0 = new TaggedWord(indexedWord0, wordLemmaTag0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[11];
      wordLemmaTag0.setFromString("k(BW.]XH;J");
      doubleArray1[0] = (double) 100;
      identityHashMap0.put(labeledScoredTreeNode0, doubleArray1);
      splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      assertFalse(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsWithNonEmptyMapAndNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      double[][][] doubleArray0 = new double[1][6][8];
      threeDimensionalMap0.put("HB +Zs*KQQO~K", "HB +Zs*KQQO~K", "HB +Zs*KQQO~K", doubleArray0);
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.identityHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, (MapFactory<String, double[][]>) null);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      StringLabel stringLabel0 = new StringLabel("HB +Zs*KQQO~K");
      IndexedWord indexedWord0 = new IndexedWord(stringLabel0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      TaggedWord taggedWord0 = new TaggedWord(indexedWord0, wordLemmaTag0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(taggedWord0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndExtractTakingCollectionAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      assertFalse(list0.isEmpty());
      
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondence0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      CoreLabel coreLabel0 = new CoreLabel(100);
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options.LexOptions options_LexOptions0 = new Options.LexOptions();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recountTree(tree0, true, identityHashMap0, identityHashMap0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 1;
      doubleArray0[3] = 0.0;
      doubleArray0[0] = (double) 0;
      doubleArray0[5] = (double) 100;
      doubleArray0[6] = (double) 1;
      Comparator<CoreLabel> comparator0 = (Comparator<CoreLabel>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel, String> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap3);
      Map<String, double[]> map1 = mapFactory0.setMap(map0);
      Map<String, double[]> map2 = mapFactory0.setMap(map1);
      Map<String, double[]> map3 = mapFactory0.setMap(map2);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, (-52468), identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null, map3, twoDimensionalMap0, threeDimensionalMap0);
      Map<String, int[]> map4 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      assertEquals(3, map4.size());
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondence1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      CoreLabel coreLabel0 = new CoreLabel(100);
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options.LexOptions options_LexOptions0 = new Options.LexOptions();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recountTree(tree0, true, identityHashMap0, identityHashMap0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 1;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 0;
      doubleArray0[5] = (double) 100;
      doubleArray0[6] = (double) 1;
      Comparator<CoreLabel> comparator0 = (Comparator<CoreLabel>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel, String> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap3);
      Map<String, double[]> map1 = mapFactory0.setMap(map0);
      Map<String, double[]> map2 = mapFactory0.setMap(map1);
      Map<String, double[]> map3 = mapFactory0.setMap(map2);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, (-52468), identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null, map3, twoDimensionalMap0, threeDimensionalMap0);
      Map<String, int[]> map4 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      assertEquals(3, map4.size());
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N Eog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      assertFalse(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testSplitBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.valueIterator();
      double[][] doubleArray0 = new double[2][1];
      twoDimensionalMap0.put("M5SU", "M5SU", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      WordTag wordTag0 = Morphology.stemStatic(".$$.", "Vp>/G|[+_<z,H");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordTag0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.recountInside(labeledScoredTreeNode0, true, 3385300, identityHashMap0);
      assertEquals(3385301, int0);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException0()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("(A (B b)2C c))");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Trees should have been binarized, expected 1 or 2 children
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndExtractTakingCollection0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list0, (double) 100, (Collection<Tree>) tree0, (double) 100);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP R+NUEg)!)");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndSplitBetasAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 4;
      intArray0[1] = 4;
      hashMap0.put("X", intArray0);
      int[] intArray1 = new int[2];
      intArray1[0] = 0;
      intArray1[1] = 0;
      hashMap0.put("Y", intArray1);
      double[] doubleArray1 = new double[2];
      Math.log(0.6);
      doubleArray1[0] = (-0.5108256237659907);
      Math.log(0.4);
      doubleArray1[1] = (-0.916290731874155);
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3, doubleArray1, hashMap0);
      identityHashMap2.containsKey(tree0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 4;
      intArray0[1] = 4;
      hashMap0.put("X", intArray0);
      int[] intArray1 = new int[2];
      intArray1[0] = 0;
      intArray1[1] = 0;
      hashMap0.put("Y", intArray1);
      double[] doubleArray1 = new double[2];
      Math.log(0);
      doubleArray1[0] = Double.NEGATIVE_INFINITY;
      Math.log(0.4);
      doubleArray1[1] = (-0.916290731874155);
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3, doubleArray1, hashMap0);
      identityHashMap2.containsKey(tree0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = null;
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 0;
      intArray0[1] = 0;
      hashMap0.put("X", intArray0);
      int[] intArray1 = new int[2];
      intArray1[0] = 0;
      intArray1[1] = 0;
      hashMap0.put("Y", intArray1);
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap6 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 78, identityHashMap0, identityHashMap6);
      assertFalse(identityHashMap0.equals((Object)identityHashMap2));
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("(X (Y y))");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = (-8);
      intArray0[1] = 0;
      hashMap0.put("Y", intArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap6 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 78, identityHashMap0, identityHashMap6);
      assertTrue(identityHashMap6.equals((Object)identityHashMap5));
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndExtractTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      CoreLabel coreLabel0 = new CoreLabel(100);
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0, (double) 100, (Collection<Tree>) list0, (-3833.779380144285));
      splittingGrammarExtractor0.buildGrammars();
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      CollinsHeadFinder collinsHeadFinder0 = new CollinsHeadFinder(pennTreebankLanguagePack0);
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, false, (-3234), true, collinsHeadFinder0);
      LabelFactory labelFactory0 = CategoryWordTag.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      double[][][] doubleArray0 = new double[1][2][8];
      identityHashMap2.put(tree0, doubleArray0);
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap1, identityHashMap2);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Options options2 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options2);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.outputTransitions(tree0, 88, identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndPositive()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      identityHashMap1.entrySet();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (-1584.92875116716);
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = (double) 100;
      doubleArray0[6] = (double) 100;
      hashMap0.put(":t&Tn6g&", doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap2, identityHashMap5, (Map<String, double[]>) null, twoDimensionalMap1, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NN cat))");
      tree0.label();
      Tree tree1 = Tree.valueOf("(S (NN cat))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      identityHashMap1.entrySet();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor2.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor4 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recurseOutside(tree1, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndExtractTaking4ArgumentsWithZero0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NN cat))");
      tree0.label();
      Tree tree1 = Tree.valueOf("(S (NN cat))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree1, linkedList0);
      treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode0, linkedList0);
      MockRandom mockRandom0 = new MockRandom();
      MapFactory.treeMapFactory(null);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) tree1, 483.498209);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NN cat))");
      tree0.label();
      Tree.valueOf("(S (NN cat))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      identityHashMap1.entrySet();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor2.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 3.0E9;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap5 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recalculateTemporaryBetas(tree0, doubleArray0, (-1583), identityHashMap5, identityHashMap4, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      String string0 = "(A (B b) (C c7))";
      Tree tree0 = Tree.valueOf("(A (B b) (C c7))");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      identityHashMap2.entrySet();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap3, (IdentityHashMap<Tree, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.outputTransitions(tree0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      splittingGrammarExtractor0.extract((Collection<Tree>) list0, 1.0E-4, (Collection<Tree>) memoryTreebank0, 9.501079298424031E-6);
      assertEquals("UTF-8", memoryTreebank0.encoding());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndExtractTaking4ArgumentsWithZero1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      Object[] objectArray0 = new Object[3];
      objectArray0[0] = (Object) "(ROOT (NP (+N dog)))";
      Object object0 = new Object();
      objectArray0[1] = object0;
      objectArray0[2] = (Object) "(ROOT (NP (+N dog)))";
      List<?> list1 = new Stack<Object>();
      StringLabel stringLabel0 = new StringLabel((String) null);
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      simpleTreeFactory0.newTreeNode((Label) tree0, list0);
      Collections.singletonList((Object) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list0, 0.0, (Collection<Tree>) list0, 0.0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 4 out of bounds for length 4
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("( (B b) (C c))");
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (-2.0), (Collection<Tree>) tree0, (-2.0));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsWithFalse()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordTag wordTag0 = WordTag.valueOf("6O^1v;V");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordTag0, list0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[11];
      hashMap0.put("6O^1v;V", doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountTree((Tree) labeledScoredTreeNode0, false, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
      assertEquals(Double.NaN, labeledScoredTreeNode0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recountTree(tree0, true, identityHashMap0, identityHashMap0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) identityHashMap2, twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap2, (Map<String, double[]>) identityHashMap2, identityHashMap0, identityHashMap0);
      assertEquals(3, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsAndRecountOutsideTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, (Tree) simpleTree0, (Tree) simpleTree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      tree0.label();
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      arrayList0.retainAll(tree0);
      splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      tree0.setValue("A");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (-286.0), (Collection<Tree>) tree0, 13.591409142295225);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      Options options1 = new Options(options0.tlpParams);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<Object>, Object> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      hashMap1.put("*", doubleArray0);
      MapFactory<Object, String> mapFactory1 = MapFactory.linkedHashMapFactory();
      Map<String, double[]> map0 = mapFactory1.setMap(hashMap0);
      mapFactory0.setMap(map0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      twoDimensionalMap0.size();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, doubleArray0, 0, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(hashMap0.isEmpty());
      assertEquals(1, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      Label label0 = tree0.label();
      label0.setValue("A");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = Double.POSITIVE_INFINITY;
      doubleArray0[2] = (-771.644);
      doubleArray0[3] = (double) 100;
      IdentityHashMap<String, double[]> identityHashMap4 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap2, identityHashMap3, (Map<String, double[]>) identityHashMap4, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      Label label0 = tree0.label();
      label0.setValue("A");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.0;
      double[] doubleArray1 = new double[1];
      tree0.taggedLabeledYield();
      doubleArray1[0] = (-0.31062865162166214);
      byte[] byteArray0 = new byte[8];
      byteArray0[0] = (byte)55;
      byteArray0[1] = (byte)95;
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree0, true, 1218, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningZero()  throws Throwable  {
      Options options0 = new Options();
      WordTagFactory wordTagFactory0 = new WordTagFactory('(');
      Label label0 = wordTagFactory0.newLabel("Long Track");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.recountInside(labeledScoredTreeNode0, false, (-1), identityHashMap0);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecalculateBetasWithTrue()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.iteration = (-1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[7][5][9];
      threeDimensionalMap0.put("(=9m", "(=9m", "%t40", doubleArray0);
      threeDimensionalMap0.size();
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollection0()  throws Throwable  {
      Options options0 = new Options();
      PriorityQueue<Tree> priorityQueue0 = new PriorityQueue<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.iteration = (-1657);
      splittingGrammarExtractor0.extract((Collection<Tree>) priorityQueue0);
      assertEquals(0, priorityQueue0.size());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testState0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String[] stringArray0 = new String[2];
      stringArray0[0] = "ROOT";
      stringArray0[1] = "S";
      Arrays.asList(stringArray0);
      String string0 = splittingGrammarExtractor0.state("ROOT", 2);
      assertEquals("ROOT", string0);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(A (B b))");
      Label label0 = tree0.label();
      label0.setValue("A");
      double[][] doubleArray0 = new double[1][1];
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = 0.0;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      identityHashMap1.put(tree0, doubleArray2);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("( (B b) (C c))");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (double) 100, (Collection<Tree>) tree0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(P (C x))");
      Label label0 = tree0.label();
      label0.setValue("P");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[2];
      Math.log(0.5);
      doubleArray1[0] = (-0.6931471805599453);
      Math.log(0.5);
      doubleArray1[1] = (-0.6931471805599453);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree0, false, 0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recountTree(tree0, true, identityHashMap0, identityHashMap0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, map0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      boolean boolean0 = identityHashMap2.containsKey(identityHashMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      options0.genStop = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      Map<String, int[]> map0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 0;
      intArray0[1] = 0;
      map0.put("X", intArray0);
      int[] intArray1 = new int[2];
      intArray1[0] = 0;
      intArray1[1] = 0;
      map0.put("Y", intArray1);
      double[] doubleArray1 = new double[2];
      Math.log(0.6);
      doubleArray1[0] = (-0.5108256237659907);
      Math.log(0.4);
      doubleArray1[1] = (-0.916290731874155);
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3, doubleArray1, map0);
      boolean boolean0 = identityHashMap2.containsKey(tree0);
      assertEquals(1, identityHashMap2.size());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitionsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, (double[]) null, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitionsWithNonEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("(A (B b)(C c))");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      double[] doubleArray0 = new double[1];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndTestConvergenceAndOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][1];
      twoDimensionalMap0.put("MMSU", "MMSU", doubleArray0);
      double[][][] doubleArray1 = new double[0][1][6];
      threeDimensionalMap0.put("MMSU", "Bc%\"^c", "Bc%\"^c", doubleArray1);
      threeDimensionalMap0.size();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNullAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      splittingGrammarExtractor0.outputBetas();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recountTree(tree0, true, identityHashMap0, identityHashMap0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      assertEquals(3, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesReturningEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Writer writer0 = Writer.nullWriter();
      options0.writeData(writer0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[][] doubleArray0 = new double[0][5];
      twoDimensionalMap0.put("MMSU", "(/9|", doubleArray0);
      TwoDimensionalMap.hashMap();
      twoDimensionalMap0.getMap("MMSU");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap1.size();
      splittingGrammarExtractor0.recalculateBetas(false);
      splittingGrammarExtractor0.mergeStates();
      double[] doubleArray1 = splittingGrammarExtractor0.neginfDoubles(0);
      assertEquals(0, doubleArray1.length);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][1];
      twoDimensionalMap0.contains("sJ", "");
      twoDimensionalMap0.put("MMSU", "", doubleArray0);
      options0.useSmoothTagProjection = true;
      double[][][] doubleArray1 = new double[7][0][1];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      splittingGrammarExtractor0.splitBetas();
      doubleArray1[3] = null;
      doubleArray1[4] = doubleArray0;
      doubleArray1[5] = null;
      doubleArray1[6] = doubleArray0;
      threeDimensionalMap0.put("+'jV!fl;Lk", "", "`qA+\"*t", doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      assertFalse(threeDimensionalMap1.equals((Object)threeDimensionalMap0));
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndRecalculateTemporaryBetasTaking8ArgumentsWithNegativeAndRecalculateTemporaryBetasTaking8ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<Object>, Object> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.0;
      hashMap0.put((String) null, doubleArray0);
      mapFactory0.setMap(hashMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.hashMap();
      StringReader stringReader0 = new StringReader("un");
      Morphology morphology0 = new Morphology(stringReader0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, doubleArray0, (-3411), identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndMergeStatesAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][1];
      twoDimensionalMap0.put("MMSU", "", doubleArray0);
      double[][][] doubleArray1 = new double[0][1][6];
      threeDimensionalMap0.put("MMSU", "Bc%\"^c", "Bc%\"^c", doubleArray1);
      threeDimensionalMap0.size();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithPositive()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<Object>, Object> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.0;
      hashMap0.put("iUnA*,8vQF6)G", doubleArray0);
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      StringReader stringReader0 = new StringReader("iUnA*,8vQF6)G");
      Morphology morphology0 = new Morphology(stringReader0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, doubleArray0, Integer.MAX_VALUE, identityHashMap1, identityHashMap2, map0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRescaleTemporaryBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[1][3];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("(/9|", "(/9|", doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray2 = new double[9][7][0];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = null;
      doubleArray2[2] = null;
      doubleArray2[3] = doubleArray0;
      doubleArray2[4] = doubleArray0;
      doubleArray2[5] = null;
      doubleArray2[6] = null;
      double[][] doubleArray3 = new double[3][2];
      doubleArray3[0] = doubleArray1;
      doubleArray3[1] = doubleArray1;
      doubleArray3[2] = doubleArray1;
      doubleArray2[7] = doubleArray3;
      doubleArray2[8] = doubleArray0;
      threeDimensionalMap0.put("R};_1p", "R};_1p", "R};_1p", doubleArray2);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(threeDimensionalMap0.equals((Object)threeDimensionalMap1));
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndRecalculateBetasAndRescaleTemporaryBetas()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][6][5];
      threeDimensionalMap0.put("Found ", "_/Z0%}xO`9Et", "_/Z0%}xO`9Et", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
      Random.setNextRandom(1153);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndTestConvergence()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][6][5];
      threeDimensionalMap0.put("Found ", "_/Z0%}xO`9Et", "_/Z0%}xO`9Et", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
      
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("blat");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      hashMap0.put("blat", doubleArray0);
      MapFactory<CoreLabel.GenericAnnotation<Object>, Object> mapFactory0 = MapFactory.identityHashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      Map<String, double[]> map1 = mapFactory0.setMap(map0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<Object>, String> mapFactory1 = MapFactory.treeMapFactory(comparator0);
      Map<String, double[]> map2 = mapFactory1.setMap(map0);
      splittingGrammarExtractor1.countMergeEffects((Tree) treeGraphNode0, map0, map2, identityHashMap0, identityHashMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor2.binaryBetas;
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor3.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, false, map1, twoDimensionalMap0, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap1);
      assertFalse(splittingGrammarExtractor0.equals((Object)splittingGrammarExtractor1));
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("blat");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      hashMap0.put("blat", doubleArray0);
      MapFactory<CoreLabel.GenericAnnotation<Object>, Object> mapFactory0 = MapFactory.identityHashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      mapFactory0.setMap(map0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<Object>, String> mapFactory1 = MapFactory.treeMapFactory(comparator0);
      Map<String, double[]> map1 = mapFactory1.setMap(map0);
      splittingGrammarExtractor1.countMergeEffects((Tree) treeGraphNode0, map1, map0, identityHashMap0, identityHashMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndExtractTakingCollection1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N Eog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list0, 17.7, (Collection<Tree>) list0, 490.6969);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 4 out of bounds for length 4
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndExtractTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      Collections.singletonList(splittingGrammarExtractor0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) tree0, (-2.0));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.getMap("ROOT PROBABILITY: ");
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      labeledScoredTreeNode0.isPhrasal();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 0;
      doubleArray0[3] = (double) 3;
      IdentityHashMap<String, int[]> identityHashMap4 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode0, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap3, doubleArray0, identityHashMap4);
      assertNotSame(identityHashMap2, identityHashMap3);
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsWithEmptyMapAndEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Options options2 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      simpleTreeFactory0.newTreeNode("&cprOLNl[", list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.outputTransitions((Tree) labeledScoredTreeNode0, 100, identityHashMap0, identityHashMap1);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.recountTree((Tree) labeledScoredTreeNode0, true, identityHashMap2, identityHashMap2, identityHashMap0, identityHashMap1);
      assertEquals(0, identityHashMap1.size());
      assertTrue(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testMergeStatesAndSplitBetas()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      options0.useSmoothTagProjection = true;
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("blat");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      treeGraphNode0.dominationPath(labeledScoredTreeNode0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      Options options1 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.recountInside(labeledScoredTreeNode0, true, 62, identityHashMap1);
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.recurseOutside(labeledScoredTreeNode0, identityHashMap3, identityHashMap3);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor1.mergeStates();
      assertFalse(splittingGrammarExtractor1.equals((Object)splittingGrammarExtractor0));
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsAndCountMergeEffectsTaking3Arguments()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      List<Tree> list1 = List.of(treeGraphNode0, treeGraphNode0);
      LabeledScoredTreeNode labeledScoredTreeNode1 = new LabeledScoredTreeNode(label0, list0);
      SimpleTree simpleTree0 = new SimpleTree(treeGraphNode0, list1);
      MapFactory<CoreLabel.GenericAnnotation<Object>, String> mapFactory0 = MapFactory.linkedHashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(null);
      splittingGrammarExtractor1.countMergeEffects((Tree) labeledScoredTreeNode1, (Map<String, double[]>) null, map0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsAndCountMergeEffectsTaking3ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag("+&*/", "+&*/");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      assertTrue(hashMap1.equals((Object)hashMap0));
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6Arguments()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.recalculateMergedBetas(hashMap0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      LabelFactory labelFactory0 = WordTag.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Stack<Tree> stack0 = new Stack<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((String) null, (List<Tree>) stack0);
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.0;
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap2, identityHashMap3, identityHashMap2, identityHashMap3, doubleArray0, hashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recountTree((Tree) labeledScoredTreeNode0, false, identityHashMap1, identityHashMap1, identityHashMap2, identityHashMap3);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsWithNullAndRecalculateBetas()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      List<Tree> list1 = List.of(labeledScoredTreeNode0, treeGraphNode0);
      LabeledScoredTreeNode labeledScoredTreeNode1 = new LabeledScoredTreeNode(label0, list0);
      SimpleTree simpleTree0 = new SimpleTree(treeGraphNode0, list1);
      MapFactory<CoreLabel.GenericAnnotation<Object>, String> mapFactory0 = MapFactory.linkedHashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) null, map0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningNegative()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
      
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<Object>, Object> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.0;
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      Map<String, double[]> map1 = mapFactory0.setMap(map0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordTagFactory0);
      Tree tree0 = treeGraphNode0.deepCopy((TreeFactory) labeledScoredTreeFactory0, (LabelFactory) wordTagFactory0);
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor3.countMergeEffects((Tree) treeGraphNode0, map1, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap1);
      treeGraphNode0.dominationPath(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      Options options2 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor4 = new SplittingGrammarExtractor(options2);
      options2.rerankerKBest = (-4199);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor4.recountInside(labeledScoredTreeNode0, false, (-4087), identityHashMap3);
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor3.recountTree((Tree) labeledScoredTreeNode0, false, identityHashMap4, identityHashMap5);
      assertEquals(0, identityHashMap4.size());
      assertTrue(identityHashMap5.isEmpty());
      assertTrue(identityHashMap4.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNull()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<Object>, Object> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.0;
      hashMap0.put("iUnA*,8vQF6)G", doubleArray0);
      mapFactory0.setMap(hashMap0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      Reader reader0 = Reader.nullReader();
      Morphology morphology0 = new Morphology(reader0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(morphology0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor3.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, (double[]) null, 91, identityHashMap2, identityHashMap3, (Map<String, double[]>) hashMap0, twoDimensionalMap1, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsWithNullAndNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("-IN-SENT", "l1.r7EA");
      IndexedWord indexedWord0 = new IndexedWord(wordLemmaTag0);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(indexedWord0, linkedList0);
      List<Tree> list0 = List.of(labeledScoredTreeNode0, labeledScoredTreeNode0);
      LabeledScoredTreeNode labeledScoredTreeNode1 = new LabeledScoredTreeNode(indexedWord0, list0);
      SimpleTree simpleTree0 = new SimpleTree(labeledScoredTreeNode1, list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) null, (Map<String, double[]>) null);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "(A (B b) (C c))");
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      CollinsHeadFinder collinsHeadFinder0 = new CollinsHeadFinder(pennTreebankLanguagePack0);
      ClassicCounter<Tree> classicCounter0 = ClassicCounter.identityHashMapCounter();
      splittingGrammarExtractor0.treeWeights = (Counter<Tree>) classicCounter0;
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, false, (-3234), true, collinsHeadFinder0);
      LabelFactory labelFactory0 = CategoryWordTag.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      double[][][] doubleArray0 = new double[1][2][8];
      identityHashMap2.put(tree0, doubleArray0);
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap1, identityHashMap2);
      splittingGrammarExtractor0.recalculateBetas(true);
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap1, identityHashMap2);
      assertTrue(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndOutputTransitionsTaking4ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag("*", "*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordTag0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.outputTransitions((Tree) labeledScoredTreeNode0, 100, identityHashMap0, identityHashMap1);
      assertTrue(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndRecalculateBetasAndRecountOutsideTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode0, list0);
      Options options1 = new Options(options0.tlpParams);
      options1.directional = true;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      Options options2 = new Options();
      Options options3 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options3);
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Tree tree0 = simpleTreeFactory0.newTreeNode("*", list0);
      splittingGrammarExtractor2.recountOutside(tree0, identityHashMap0, identityHashMap0);
      System.setCurrentTimeMillis(100);
      LabeledScoredTreeNode labeledScoredTreeNode1 = new LabeledScoredTreeNode(treeGraphNode0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor2.outputTransitions((Tree) labeledScoredTreeNode1, 2, identityHashMap1, identityHashMap2);
      assertTrue(labeledScoredTreeNode1.equals((Object)labeledScoredTreeNode0));
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NN cat))");
      Label label0 = tree0.label();
      label0.setValue("S");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments0()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("blat");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = 0.0;
      hashMap0.put("blat", doubleArray0);
      MapFactory<CoreLabel.GenericAnnotation<Object>, Object> mapFactory0 = MapFactory.identityHashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      mapFactory0.setMap(map0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNull()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      Options options2 = new Options();
      Options options3 = new Options(options1.tlpParams);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countOriginalStates();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<Object, CoreLabel.GenericAnnotation<String>> mapFactory0 = MapFactory.linkedHashMapFactory();
      Map<String, int[]> map0 = mapFactory0.setMap(null, 100);
      splittingGrammarExtractor1.mergeTransitions(labeledScoredTreeNode0, identityHashMap3, identityHashMap4, identityHashMap3, identityHashMap4, (double[]) null, map0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("JJR", list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap5.entrySet();
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = (double) 100;
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap3, identityHashMap4, identityHashMap3, identityHashMap5, doubleArray0, (Map<String, int[]>) null);
      assertEquals(Double.NaN, tree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitionsWithNull()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("AP(BZ b)(C c))");
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, (double[]) null, identityHashMap0);
      assertEquals(0, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[5][5][9];
      threeDimensionalMap0.put("E6V')", "E6V')", "%t40", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceReturningFalse()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][6][5];
      threeDimensionalMap0.put("Found ", "Found ", "Found ", doubleArray0);
      String[] stringArray0 = new String[9];
      stringArray0[0] = "Found ";
      stringArray0[1] = "Found ";
      stringArray0[2] = "Found ";
      stringArray0[3] = "Found ";
      options0.setOptionsOrWarn(stringArray0, (-1497), (-1497));
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      System.setCurrentTimeMillis(0L);
      splittingGrammarExtractor0.splitBetas();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(stringLabelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("Found ", (List<Tree>) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor0.countOriginalStates();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap2);
      assertEquals(0, identityHashMap2.size());
  }

  @Test(timeout = 4000)
  public void testRecountInsideWithFalse()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<Object>, Object> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = (double) 100;
      doubleArray0[6] = (double) '{';
      doubleArray0[7] = 0.0;
      doubleArray0[8] = (double) '{';
      hashMap0.put("*", doubleArray0);
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      mapFactory0.setMap(map0);
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, map0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap1);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(labeledScoredTreeNode0, false, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap0()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag("+&*/", "+&*/");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      hashMap0.put("+&*/", doubleArray0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) identityHashMap1, identityHashMap2, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments1()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<Object>, Object> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 0.0;
      MockRandom mockRandom0 = (MockRandom)splittingGrammarExtractor1.random;
      splittingGrammarExtractor0.random = (java.util.Random) mockRandom0;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = (double) 100;
      doubleArray0[6] = (double) '{';
      doubleArray0[7] = 0.0;
      doubleArray0[8] = (double) '{';
      hashMap0.put("*", doubleArray0);
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      mapFactory0.setMap(map0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, map0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap1()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag("+&*/");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      hashMap0.put("+&*/", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap2()  throws Throwable  {
      Options options0 = new Options();
      WordTag wordTag0 = new WordTag("N&B*", "N&B*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordTag0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      hashMap0.put("N&B*", doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInside()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("*");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<Object>, Object> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = (double) 100;
      doubleArray0[6] = (double) '{';
      doubleArray0[7] = 0.0;
      doubleArray0[8] = (double) '{';
      hashMap0.put("*", doubleArray0);
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      Map<String, double[]> map1 = mapFactory0.setMap(map0);
      splittingGrammarExtractor1.countMergeEffects((Tree) treeGraphNode0, map1, map1, identityHashMap1, identityHashMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(labeledScoredTreeNode0, true, 100, identityHashMap2);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeAndRecountTreeTaking4Arguments()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("blat");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode0.dominationPath(labeledScoredTreeNode0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      Options options1 = new Options();
      UnaryGrammar unaryGrammar0 = mock(UnaryGrammar.class, new ViolatedAssumptionAnswer());
      BinaryGrammar binaryGrammar0 = mock(BinaryGrammar.class, new ViolatedAssumptionAnswer());
      Pair<UnaryGrammar, BinaryGrammar> pair0 = new Pair<UnaryGrammar, BinaryGrammar>(unaryGrammar0, binaryGrammar0);
      splittingGrammarExtractor0.bgug = pair0;
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(labeledScoredTreeNode0, true, 62, identityHashMap1);
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountTree((Tree) labeledScoredTreeNode0, false, identityHashMap4, identityHashMap5);
      splittingGrammarExtractor0.getStateSplitCount((Tree) treeGraphNode0);
      splittingGrammarExtractor0.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0, (double) 0, (Collection<Tree>) null, (-558.4253114619244));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[4][1];
      double[] doubleArray1 = new double[3];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = 0.0;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[6];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = (double) 100;
      doubleArray2[4] = 0.0;
      doubleArray2[5] = (double) 100;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[0];
      doubleArray0[2] = doubleArray3;
      twoDimensionalMap0.put("(/9|", "Lexicon log prob ", doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas1()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[1][3];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("(/9|", "(/9|", doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      double[][] doubleArray0 = new double[1][3];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("(/9|", "Lexicon log prob ", doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor1.countOriginalStates();
      System.setCurrentTimeMillis((-711L));
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsRuntimeException()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory('{');
      Label label0 = wordTagFactory0.newLabel(":{9gZH>!iXit`'DagU");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.recountWeights(labeledScoredTreeNode0, identityHashMap0, identityHashMap2, identityHashMap3, identityHashMap4);
      IdentityHashMap<Tree, double[]> identityHashMap5 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        ChineseLexiconAndWordSegmenter.getSegmenterDataFromFile("4#)", options0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // java.io.FileNotFoundException
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ChineseLexiconAndWordSegmenter", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (+N dog)))");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments2()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      WordTagFactory wordTagFactory0 = new WordTagFactory('{');
      Label label0 = wordTagFactory0.newLabel(":{9gZH>!iXit`'DagU");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<Object>, Object> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      Map<String, double[]> map1 = mapFactory0.setMap(map0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects((Tree) labeledScoredTreeNode0, map0, map1, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndSplitBetas()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][6][5];
      threeDimensionalMap0.put("Found ", "_/Z0%}xO`9Et", "_/Z0%}xO`9Et", doubleArray0);
      String[] stringArray0 = new String[4];
      stringArray0[0] = "_/Z0%}xO`9Et";
      stringArray0[1] = "Found ";
      stringArray0[2] = "Found ";
      stringArray0[3] = "_/Z0%}xO`9Et";
      options0.setOptionsOrWarn(stringArray0, (-1497), (-1497));
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      System.setCurrentTimeMillis(0L);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
      
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.put((String) null, (String) null, (double[][]) null);
      threeDimensionalMap0.remove(": ^0", "Found ", ": ^0");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      Label label0 = taggedWordFactory0.newLabel("&X?m");
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(label0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap2, identityHashMap2, identityHashMap1, identityHashMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("(AP(B b)(C c))");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsAndOutputTransitionsTaking3ArgumentsWithTreeWhereScoreIsPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newLeaf("Ceci");
      Tree tree1 = hebrewTreebankParserParams0.transformTree(tree0, tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree1, identityHashMap0, identityHashMap1);
      assertSame(tree0, tree1);
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeReturningZero()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory('-');
      Label label0 = taggedWordFactory0.newLabel("-MWAdvS", 100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      Tree tree0 = treeGraphNode0.skipRoot();
      splittingGrammarExtractor0.getStateSplitCount(tree0);
      SimpleTree simpleTree0 = new SimpleTree();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, (Tree) simpleTree0, (Tree) simpleTree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      UnaryGrammar unaryGrammar0 = mock(UnaryGrammar.class, new ViolatedAssumptionAnswer());
      BinaryGrammar binaryGrammar0 = mock(BinaryGrammar.class, new ViolatedAssumptionAnswer());
      Pair<UnaryGrammar, BinaryGrammar> pair0 = new Pair<UnaryGrammar, BinaryGrammar>(unaryGrammar0, binaryGrammar0);
      splittingGrammarExtractor0.bgug = pair0;
      splittingGrammarExtractor0.countOriginalStates();
      TreeSet<SimpleTree> treeSet0 = new TreeSet<SimpleTree>();
      PriorityQueue<Tree> priorityQueue0 = new PriorityQueue<Tree>((SortedSet<? extends Tree>) treeSet0);
      splittingGrammarExtractor0.saveTrees(priorityQueue0, 1.0, priorityQueue0, (-359.3844929143));
      assertEquals(0, priorityQueue0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningZero()  throws Throwable  {
      SimpleTree simpleTree0 = new SimpleTree();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.weakHashMapFactory();
      MapFactory<TaggedWord, Object> mapFactory0 = MapFactory.linkedHashMapFactory();
      options0.newTestOptions();
      Map<String, double[]> map0 = mapFactory0.setMap(null, 363);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateTemporaryBetas(false, map0, twoDimensionalMap0, threeDimensionalMap0);
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = (double) 1;
      doubleArray0[1] = (double) 3;
      doubleArray0[2] = (double) 3;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 3;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      int int0 = splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 0, identityHashMap0, identityHashMap1, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4ArgumentsWithZeroAndExtractTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) arrayList0, 0.0, (Collection<Tree>) arrayList0, (-459.0));
      assertTrue(arrayList0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[7][3][9];
      threeDimensionalMap0.put(" Lg Split -> ", " Lg Split -> ", " Lg Split -> ", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[7][8][9];
      threeDimensionalMap0.put((String) null, "qP+tX47=+", "qP+tX47=+", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNull()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SimpleTree simpleTree0 = new SimpleTree();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(hashMap0);
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor2.saveTrees(arrayList0, 1.0, (Collection<Tree>) null, 100);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.outputTransitions((Tree) simpleTree0, 100, identityHashMap2, (IdentityHashMap<Tree, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithZero()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      TestOptions testOptions0 = new TestOptions();
      options0.testOptions = testOptions0;
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>(hashMap0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[7];
      splittingGrammarExtractor0.neginfDoubles(100);
      splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) hashMap0, identityHashMap2, identityHashMap2);
      splittingGrammarExtractor0.saveTrees(simpleTree0, 0.0, arrayList0, 0.0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(": ^0", 100);
      splittingGrammarExtractor0.recalculateBetas(true);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[0][8][0];
      threeDimensionalMap0.put("Found ", "_/Z0%}xO`9Et", "Found ", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningNegative()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>(identityHashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap4 = new IdentityHashMap<String, double[]>();
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.treeMapFactory();
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 100;
      identityHashMap4.put("o=j~~73^f%", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, (double[]) null, (-2121677399), identityHashMap2, identityHashMap3, (Map<String, double[]>) identityHashMap4, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals((-2121677399), int0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(": ^0", 100);
      splittingGrammarExtractor0.recalculateBetas(true);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove(": ^0", "Found ", ": ^0");
      threeDimensionalMap0.put(": ^0", "7/R9d>[lDld\"^SS )", "7/R9d>[lDld\"^SS )", (double[][][]) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.identityHashMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>(hashMap0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) 100;
      identityHashMap2.put(simpleTree0, doubleArray0);
      splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap0, identityHashMap2, identityHashMap2);
      splittingGrammarExtractor0.saveTrees(arrayList0, 100.0, simpleTree0, 100.0);
      assertTrue(arrayList0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsWithNullAndNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      threeDimensionalMap0.get(".$$.", "KEk@", "KEk@");
      threeDimensionalMap0.getTwoDimensionalMap("~{B'9et,OXQ>0-");
      splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      StringLabel stringLabel0 = new StringLabel("KEk@", 100, (-2121677399));
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(stringLabel0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      wordLemmaTag0.labelFactory();
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode1.localTree();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, (Tree) treeGraphNode0, (IdentityHashMap<Tree, double[]>) null, (IdentityHashMap<Tree, double[]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      threeDimensionalMap0.get(".$$.", "KEk@", "KEk@");
      threeDimensionalMap0.getTwoDimensionalMap("~{B'9et,OXQ>0-");
      splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      boolean boolean0 = splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      assertTrue(boolean0);
      
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      IndexedWord indexedWord0 = IndexedWord.NO_WORD;
      Label label0 = stringLabelFactory0.newLabel((Label) indexedWord0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(label0, list0);
      Tree tree0 = treeGraphNode1.skipRoot();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, (-2686), identityHashMap0, identityHashMap1);
      assertTrue(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndSplitBetasAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(": ^0", 100);
      splittingGrammarExtractor0.recalculateBetas(true);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove(": ^0", "Found ", ": ^0");
      threeDimensionalMap0.secondKeySet();
      options0.setOptionsOrWarn((String[]) null, 1115, 98);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      System.setCurrentTimeMillis(100);
      splittingGrammarExtractor0.splitBetas();
      PriorityQueue<Tree> priorityQueue0 = new PriorityQueue<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) priorityQueue0, (double) 100, (Collection<Tree>) priorityQueue0, 0.0);
      assertEquals(0, priorityQueue0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsWithNull()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      options0.distance = false;
      SimpleTree simpleTree0 = new SimpleTree();
      splittingGrammarExtractor0.countOriginalStates();
      MapFactory<Triple<CoreLabel, CoreLabel, Object>, String> mapFactory0 = MapFactory.arrayMapFactory();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      mapFactory0.setMap(identityHashMap1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.mergeTransitions(simpleTree0, identityHashMap2, (IdentityHashMap<Tree, double[][][]>) null, identityHashMap2, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, identityHashMap3);
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitionsWithEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, hashMap0);
      assertTrue(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithNullAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SimpleTree simpleTree0 = new SimpleTree();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      Options options0 = new Options();
      simpleTree0.indentedXMLPrint();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, identityHashMap0, identityHashMap1);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 100, identityHashMap2, (IdentityHashMap<Tree, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithNullAndNull()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) null, 100, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerExceptionAndExtractTakingCollection()  throws Throwable  {
      SimpleTree simpleTree0 = new SimpleTree();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.memoryTreebank();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options(negraPennTreebankParserParams0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.extract((Collection<Tree>) arrayList0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, (Tree) simpleTree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndTestConvergence()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.getTwoDimensionalMap("~{B'9et,OXQ>0-");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithZero()  throws Throwable  {
      SimpleTree simpleTree0 = new SimpleTree();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options.LexOptions options_LexOptions0 = new Options.LexOptions();
      options0.lexOptions = options_LexOptions0;
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap0, identityHashMap0, identityHashMap3, identityHashMap4);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 0, identityHashMap2, identityHashMap4);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      WordTagFactory wordTagFactory0 = new WordTagFactory('A');
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordTagFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("oBXI]_aMkqyvpjyN#", (List<Tree>) null);
      Tree tree1 = negraPennTreebankParserParams0.transformTree(tree0, tree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree1, true, 1053, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.recalculateBetas(false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.remove("''", "''");
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte) (-1);
      byteArray0[1] = (byte) (-102);
      byteArray0[2] = (byte)75;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      englishTreebankParserParams0.treebank();
      byteArray0[3] = (byte)92;
      byteArray0[4] = (byte) (-73);
      byteArray0[5] = (byte)1;
      byteArray0[6] = (byte)123;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.countOriginalStates();
      MapFactory<Triple<CoreLabel, CoreLabel, Object>, String> mapFactory0 = MapFactory.arrayMapFactory();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map0, twoDimensionalMap0, threeDimensionalMap0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      treeGraphNode0.getNodeNumber((byte)75);
      italianTreebankParserParams0.transformTree((Tree) null, (Tree) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) null, true, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[11][6][8];
      threeDimensionalMap0.put("+&*/", "+&*/", "+&*/", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndRescaleTemporaryBetasAndTestConvergence()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
      
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][6][5];
      double[][] doubleArray1 = new double[1][1];
      double[] doubleArray2 = new double[4];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = (double) 100;
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("Found ", "_/Z0%}xO`9Et", "_/Z0%}xO`9Et", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean1 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas3()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[9][1][0];
      threeDimensionalMap0.put("(9*", "(9*", "(9*", doubleArray0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas4()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("utf-8", "utf-8", "utf-8");
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndBuildGrammars()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.recalculateBetas(false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.remove("''", "''");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.buildGrammars();
      System.setCurrentTimeMillis((-2844L));
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("(AP(B b)(C c))");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (double) 100, (Collection<Tree>) tree0, (double) 100);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashSet<Tree> hashSet0 = new HashSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) hashSet0, (double) 100, (Collection<Tree>) hashSet0, 0.0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithEmptyArray()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>(identityHashMap0);
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap4 = new IdentityHashMap<String, double[]>();
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.treeMapFactory();
      mapFactory1.newMap(1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 1, identityHashMap2, identityHashMap3, (Map<String, double[]>) identityHashMap4, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(1, int0);
      
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0, (-56.2277), (Collection<Tree>) simpleTree0, (double) 1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideWithNonEmptyMapAndNonEmptyMap()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags();
      seqClassifierFlags0.featureCountThresh = 100;
      List<String> list0 = seqClassifierFlags0.comboProps;
      splittingGrammarExtractor0.startSymbols = list0;
      options0.freeDependencies = false;
      System.setCurrentTimeMillis(650L);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.countOriginalStates();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(seqClassifierFlags0.pad);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = 1.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 25;
      doubleArray0[5] = 0.1;
      doubleArray0[6] = 1.0;
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      splittingGrammarExtractor0.recurseOutside(treeGraphNode0, identityHashMap0, identityHashMap0);
      assertEquals(1, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      Label label0 = tree0.label();
      label0.setValue("A");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.0;
      double[] doubleArray1 = new double[1];
      tree0.taggedLabeledYield();
      doubleArray1[0] = (-0.31062865162166214);
      byte[] byteArray0 = new byte[8];
      byteArray0[0] = (byte)55;
      byteArray0[1] = (byte)95;
      byteArray0[2] = (byte)101;
      splittingGrammarExtractor0.buildStateIndex();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.getTwoDimensionalMap((String) null);
      splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) null, 1.0E-4, (Collection<Tree>) null, (double) 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsWithEmptyMap()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SimpleTree simpleTree0 = new SimpleTree();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, identityHashMap0, identityHashMap1);
      assertFalse(identityHashMap1.isEmpty());
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsAndRecountOutsideTaking3ArgumentsWithTreeWhereScoreIsPositive()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      assertFalse(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, (double[]) null, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testSaveTreesAndSaveTreesThrowsNullPointerException()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TrainOptions trainOptions0 = options0.newTrainOptions();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      trainOptions0.tagSelectiveSplitCutOff = 1960.564762058437;
      englishTreebankParserParams0.collinizer();
      FileSystemHandling.shouldAllThrowIOExceptions();
      MapFactory.hashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.saveTrees((Collection<Tree>) null, 0.0, (Collection<Tree>) null, 15);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollection1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      PriorityQueue<Tree> priorityQueue0 = new PriorityQueue<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) priorityQueue0);
      assertEquals(0, priorityQueue0.size());
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndExtractTakingCollectionThrowsRuntimeException()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<Triple<TaggedWord, Object, String>, TaggedWord> mapFactory0 = MapFactory.weakHashMapFactory();
      MapFactory<TaggedWord, Object> mapFactory1 = MapFactory.linkedHashMapFactory();
      options0.newTestOptions();
      Map<String, double[]> map0 = mapFactory1.setMap(null, (-1955504473));
      Map<String, double[]> map1 = mapFactory1.setMap(map0, (-409));
      Map<String, double[]> map2 = mapFactory0.setMap(map1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) null, map2, (Map<String, double[]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException3()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.outputTransitions((Tree) simpleTree0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsWithEmptyMapAndEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(": ", 0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      LabelFactory labelFactory0 = CoreLabel.factory();
      TreeFactory treeFactory0 = TreeGraphNode.factory(labelFactory0);
      Tree tree0 = treeGraphNode0.treeSkeletonConstituentCopy(treeFactory0, labelFactory0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, (Tree) treeGraphNode0, (Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments3()  throws Throwable  {
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeNode labeledScoredTreeNode1 = new LabeledScoredTreeNode(labeledScoredTreeNode0, list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode1, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNonEmptyMapAndNonEmptyMap()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 0.0;
      identityHashMap0.put(simpleTree0, doubleArray0);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      treeGraphNode0.parent((Tree) simpleTree0);
      Tree tree0 = treeGraphNode0.localTree();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
      assertEquals(1, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      Label label0 = tree0.label();
      label0.setValue("A");
      double[][][] doubleArray0 = new double[1][1][1];
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = 0.0;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = 0.0;
      identityHashMap1.put(tree0, doubleArray3);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNonEmptyMap()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      MapFactory.hashMapFactory();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "t^T/yqn\"j@R<");
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[3][2][6];
      double[][] doubleArray1 = new double[1][7];
      double[] doubleArray2 = new double[7];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = 0.0;
      doubleArray2[4] = 0.0;
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = 0.0;
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray3 = new double[8][8];
      doubleArray3[0] = doubleArray2;
      doubleArray3[1] = doubleArray2;
      doubleArray3[2] = doubleArray2;
      doubleArray3[3] = doubleArray2;
      doubleArray3[4] = doubleArray2;
      doubleArray3[5] = doubleArray2;
      doubleArray3[6] = doubleArray2;
      doubleArray3[7] = doubleArray2;
      doubleArray0[1] = doubleArray3;
      double[][] doubleArray4 = new double[1][9];
      doubleArray4[0] = doubleArray2;
      doubleArray0[2] = doubleArray4;
      identityHashMap2.put(simpleTree0, doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap3, identityHashMap3, identityHashMap1, identityHashMap2);
      assertTrue(identityHashMap3.equals((Object)identityHashMap0));
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(labeledScoredTreeNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String[] stringArray0 = new String[4];
      stringArray0[0] = "M)7x$7,_%s>2+N";
      stringArray0[1] = "";
      stringArray0[2] = "";
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      stringArray0[3] = ",x%<[^G4wA#";
      options0.setOptions(stringArray0, 100, (-1435778559));
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.countOriginalStates();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor1.outputBetas();
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      splittingGrammarExtractor1.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.splitBetas();
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer(treebankLanguagePack0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf((String) null);
      Tree tree1 = basicCategoryTreeTransformer0.transformHelper(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>(identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountTree(tree1, false, identityHashMap0, identityHashMap2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      String[] stringArray0 = new String[5];
      stringArray0[0] = "u6.vT]?=)iEI";
      stringArray0[1] = "u6.vT]?=)iEI";
      stringArray0[2] = "7E!~^MI";
      options0.newTrainOptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.recalculateBetas(false);
      MapFactory.hashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.saveTrees((Collection<Tree>) null, 100, (Collection<Tree>) null, 841.06509515693);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsAndOutputTransitionsTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      englishTreebankParserParams0.display();
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.recalculateBetas(false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.remove("Mb_xriA+D^Q");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      LabelFactory labelFactory0 = Word.factory();
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer();
      LabeledScoredTreeReaderFactory labeledScoredTreeReaderFactory0 = new LabeledScoredTreeReaderFactory(labelFactory0, nPTmpRetainingTreeNormalizer0);
      Tree.valueOf("cQaPxa=,=`7;O/ik", (TreeReaderFactory) labeledScoredTreeReaderFactory0);
      negraPennTreebankParserParams0.transformTree((Tree) null, (Tree) null);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) null, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException4()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsWithNull()  throws Throwable  {
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Options options0 = new Options();
      String[] stringArray0 = new String[8];
      stringArray0[0] = "7E!~^MI";
      stringArray0[1] = "Z/xFaiI2a\"2PM8h";
      stringArray0[2] = "7E!~^MI";
      stringArray0[3] = "v{vC]L|Bwcj_A5Ty";
      stringArray0[4] = "7E!~^MI";
      stringArray0[5] = "u6.vT]?=)iEI";
      stringArray0[6] = "A8v%z:";
      stringArray0[7] = "B3@KJ>018,NUzDqZSJ:";
      options0.setOptions(stringArray0, (-2081), (-2081));
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      splittingGrammarExtractor1.countOriginalStates();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor1.outputBetas();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("zI2od98e5dD5~zek-6?");
      MemoryTreebank memoryTreebank0 = negraPennTreebankParserParams0.memoryTreebank();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) coreLabel0, (List<Tree>) memoryTreebank0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree(tree0, true, identityHashMap0, identityHashMap0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerExceptionAndBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Integer integer0 = new Integer((-2013265918));
      Double double0 = new Double((-1057.4361));
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("W}^J9::U", integer0, double0);
      arrayList0.add(triple0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Integer integer0 = new Integer((-1827));
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("/aG/}", integer0, 0.0);
      arrayList0.add(triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStateThrowsNullPointerException()  throws Throwable  {
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options(negraPennTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      splittingGrammarExtractor0.buildStateIndex();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.state((String) null, (-1));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testBuildStateIndex()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testUseNewBetasWithFalse()  throws Throwable  {
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("P{AiMjl(yF", 4410);
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      twoDimensionalMap0.forEach(consumer0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStatesAndRecountOutsideTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      byte[] byteArray0 = new byte[8];
      byteArray0[0] = (byte) (-1);
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      byteArray0[1] = (byte) (-95);
      byteArray0[2] = (byte)77;
      byteArray0[3] = (byte)55;
      byteArray0[4] = (byte)87;
      byteArray0[5] = (byte) (-65);
      byteArray0[6] = (byte)2;
      byteArray0[7] = (byte)66;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      SimpleTree simpleTree0 = new SimpleTree();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountOutside((Tree) simpleTree0, (Tree) simpleTree0, (Tree) simpleTree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testMergeStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(100);
      assertEquals(100, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesAndNeginfDoubles()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, (String) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.neginfDoubles(100);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      // Undeclared exception!
      try { 
        chineseTreebankParserParams0.memoryTreebank();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.trees.international.pennchinese.CTBErrorCorrectingTreeNormalizer
         //
         verifyException("edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceAndRecalculateMergedBetas0()  throws Throwable  {
      Options options0 = new Options();
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Integer integer0 = new Integer(100);
      Double double0 = new Double((-4695.938));
      Triple<String, Integer, Double> triple0 = Triple.makeTriple(".$$.", integer0, double0);
      arrayList0.add(triple0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      DependencyTreeTransformer dependencyTreeTransformer0 = null;
      try {
        dependencyTreeTransformer0 = new DependencyTreeTransformer();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      arrayList0.add((Triple<String, Integer, Double>) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceWithNonEmptyList()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("`%cJ<5[a!PL@", 100, 0.0);
      arrayList0.add(triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecalculateBetasWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][4][0];
      threeDimensionalMap0.put("(9*", "(9*", "(9*", doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNullAndRecountWeightsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      String[] stringArray0 = new String[5];
      stringArray0[0] = "u6.vT]?=)iEI";
      stringArray0[1] = "u6.vT]?=)iEI";
      stringArray0[2] = "7E!~^MI";
      stringArray0[3] = "@HBa";
      stringArray0[4] = ",x%<[^G4wA#";
      options0.setOptions(stringArray0, 2, (-1));
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      MapFactory<CoreLabel, Object> mapFactory0 = MapFactory.linkedHashMapFactory();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Map<String, int[]> map0 = mapFactory0.setMap(hashMap0, 2);
      Map<String, int[]> map1 = mapFactory0.setMap(map0, (-406));
      splittingGrammarExtractor0.recalculateMergedBetas(map1);
      splittingGrammarExtractor0.outputBetas();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights((Tree) null, (IdentityHashMap<Tree, double[]>) null, (IdentityHashMap<Tree, double[]>) null, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      String[] stringArray0 = new String[5];
      stringArray0[0] = "u6.vT]?=)iEI";
      stringArray0[1] = "u6.vT]?=)iEI";
      stringArray0[2] = "7E!~^MI";
      stringArray0[3] = "@HBa";
      stringArray0[4] = ",x%<[^G4wA#";
      options0.setOptions(stringArray0, 2, (-1));
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      MapFactory.linkedHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      MapFactory<SplittingGrammarExtractor, SplittingGrammarExtractor> mapFactory0 = MapFactory.arrayMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap0, 0);
      mapFactory0.setMap(map0, 1);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) null, (Map<String, double[]>) identityHashMap0, map0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsAndRecountOutsideTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      threeDimensionalMap0.getTwoDimensionalMap("in$`aTVJvlw");
      splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDEBUGAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.getMap("ROOT PROBABILITY: ");
      threeDimensionalMap0.contains("ROOT PROBABILITY: ", "PXS2]'l8vI]ZR", "ROOT PROBABILITY: ");
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateBetas(true);
      splittingGrammarExtractor0.recalculateBetas(true);
      splittingGrammarExtractor0.DEBUG();
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) simpleTree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[7][8][9];
      threeDimensionalMap0.put((String) null, "", "", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      double[] doubleArray1 = splittingGrammarExtractor0.neginfDoubles(100);
      assertEquals(100, doubleArray1.length);
      
      Comparator<String> comparator0 = (Comparator<String>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      MapFactory<String, double[][]> mapFactory1 = MapFactory.identityHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap1, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTree()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(": ", 0);
      MapFactory.hashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      StringReader stringReader0 = new StringReader(": ^0");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0);
      char[] charArray0 = new char[1];
      charArray0[0] = 'I';
      bufferedReader0.read(charArray0);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.DEBUG();
      splittingGrammarExtractor0.state("", (-1435329071));
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>(0);
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      twoDimensionalMap0.forEach(consumer0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceAndRecalculateMergedBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      assertEquals(0, map0.size());
      
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      DependencyTreeTransformer dependencyTreeTransformer0 = null;
      try {
        dependencyTreeTransformer0 = new DependencyTreeTransformer();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndSplitBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(": ^0", 100);
      splittingGrammarExtractor0.recalculateBetas(true);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove(": ^0", "Found ", ": ^0");
      options0.setOptionsOrWarn((String[]) null, 1115, 98);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      System.setCurrentTimeMillis(100);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      List<? extends HasWord> list0 = new Stack<IndexedWord>();
      Options options1 = new Options(negraPennTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.recalculateBetas(false);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount("}4");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testSplitBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringAndBuildGrammarsThrowsNullPointerException()  throws Throwable  {
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      negraPennTreebankParserParams0.defaultTestSentence();
      Options options0 = new Options(negraPennTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = "/Qr$f8wv";
      splittingGrammarExtractor0.getStateSplitCount("/Qr$f8wv");
      splittingGrammarExtractor0.recalculateBetas(true);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      assertEquals(0, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      String[] stringArray0 = new String[5];
      stringArray0[0] = "u6.vT]?=)iEI";
      stringArray0[1] = "";
      stringArray0[2] = "7E!~^MI";
      stringArray0[3] = "@HBa";
      stringArray0[4] = ",x%<[^G4wA#";
      options0.setOptions(stringArray0, 2, (-1));
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      MapFactory<CoreLabel, Object> mapFactory0 = MapFactory.linkedHashMapFactory();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Map<String, int[]> map0 = mapFactory0.setMap(hashMap0, 2);
      Map<String, int[]> map1 = mapFactory0.setMap(map0, (-406));
      splittingGrammarExtractor0.recalculateMergedBetas(map1);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollection2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      Label label0 = tree0.label();
      label0.setValue("ROOT");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testStateAndCountOriginalStatesAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(".$$.", 1654);
      SimpleTree simpleTree0 = new SimpleTree();
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(": ", 0);
      MapFactory<SplittingGrammarExtractor, SplittingGrammarExtractor> mapFactory0 = MapFactory.hashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0, 0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testState1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = splittingGrammarExtractor0.state("UNARY:", 100);
      assertEquals("UNARY:^100", string0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRecalculateBetasAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(": ^0", 100);
      splittingGrammarExtractor0.recalculateBetas(true);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove(": ^0", "Found ", ": ^0");
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndOutputBetas()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      IdentityFunction<double[][]> identityFunction0 = new IdentityFunction<double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(identityFunction0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
      QPTreeTransformer qPTreeTransformer0 = null;
      try {
        qPTreeTransformer0 = new QPTreeTransformer(true);
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsAndRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<SplittingGrammarExtractor, SplittingGrammarExtractor> mapFactory0 = MapFactory.arrayMapFactory();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap0, 100);
      Map<String, double[]> map1 = mapFactory0.setMap(map0, 100);
      Map<String, double[]> map2 = mapFactory0.setMap(map1, 0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, map2, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(map1.equals((Object)map2));
  }

  @Test(timeout = 4000)
  public void testDEBUGAndDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, false, 0, false);
      Tree tree0 = null;
      // Undeclared exception!
      try { 
        nPTmpRetainingTreeNormalizer0.apply((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.trees.BobChrisTreeNormalizer", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashIndex<String> hashIndex0 = new HashIndex<String>(0);
      HashIndex<String> hashIndex1 = new HashIndex<String>((Index<? extends String>) hashIndex0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(hashIndex1, hashIndex0);
      splittingGrammarExtractor0.tempTagIndex = (Index<String>) deltaIndex0;
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeLemmatizer treeLemmatizer0 = new TreeLemmatizer();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      // Undeclared exception!
      try { 
        CoordinationTransformer.gappingTransform(labeledScoredTreeNode0);
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateSplittingGrammarExtractorThrowsNullPointerException()  throws Throwable  {
      SplittingGrammarExtractor splittingGrammarExtractor0 = null;
      try {
        splittingGrammarExtractor0 = new SplittingGrammarExtractor((Options) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }
}
