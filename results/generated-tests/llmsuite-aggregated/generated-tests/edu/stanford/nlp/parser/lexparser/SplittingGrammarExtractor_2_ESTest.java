/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Jun 11 21:16:40 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CategoryWordTagFactory;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.StringLabel;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.WordFactory;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordLemmaTagFactory;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.parser.lexparser.ArabicTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HebrewTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HungarianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor;
import edu.stanford.nlp.parser.lexparser.TrainOptions;
import edu.stanford.nlp.parser.lexparser.TreebankLangParserParams;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.trees.BobChrisTreeNormalizer;
import edu.stanford.nlp.trees.CompositeTreeTransformer;
import edu.stanford.nlp.trees.CoordinationTransformer;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.MemoryTreebank;
import edu.stanford.nlp.trees.NPTmpRetainingTreeNormalizer;
import edu.stanford.nlp.trees.PennTreebankLanguagePack;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.SimpleTreeFactory;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeGraphNodeFactory;
import edu.stanford.nlp.trees.TreeLeafLabelTransformer;
import edu.stanford.nlp.trees.TreeReaderFactory;
import edu.stanford.nlp.trees.TreebankLanguagePack;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.ThreeDimensionalMap;
import edu.stanford.nlp.util.Triple;
import edu.stanford.nlp.util.TwoDimensionalMap;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.Vector;
import java.util.function.Function;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.util.SystemInUtil;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class SplittingGrammarExtractor_2_ESTest extends SplittingGrammarExtractor_2_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[5][6];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[6];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = Double.POSITIVE_INFINITY;
      doubleArray2[4] = 0.0;
      doubleArray2[5] = (double) 100;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[2];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = 0.0;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[11];
      doubleArray4[0] = Double.POSITIVE_INFINITY;
      doubleArray4[1] = (double) 100;
      doubleArray4[2] = (double) 100;
      doubleArray4[3] = Double.POSITIVE_INFINITY;
      doubleArray4[4] = 0.0;
      doubleArray4[5] = 0.0;
      doubleArray4[6] = 0.0;
      doubleArray4[7] = Double.POSITIVE_INFINITY;
      doubleArray4[8] = 0.0;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[0];
      doubleArray0[4] = doubleArray5;
      twoDimensionalMap0.put("'>7iVI/zU", "bop", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerExceptionAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[4][3];
      twoDimensionalMap0.put("Itera2(~ions", "Itera2(~ions", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      MemoryTreebank memoryTreebank0 = hebrewTreebankParserParams0.memoryTreebank();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("Itera2(~ions", (List<Tree>) memoryTreebank0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndRecountInsideAndRecountInsideWithTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("Determined head (case 3) for ");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, true, 9, identityHashMap0);
      assertEquals(10, int0);
  }

  @Test(timeout = 4000)
  public void testSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      arrayList0.add("j.DqreY}'0P5");
      double[][][] doubleArray0 = new double[2][1][4];
      threeDimensionalMap0.put("j.DqreY}'0P5", "j.DqreY}'0P5", "VP|NP|ADJP|PP|ADVP|UCP|IP|QP < (CC=target)", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndRecountInside0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("Determined head (case 3) for ");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, false, 9, identityHashMap0);
      assertEquals(10, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("Determined head (case 3) for ");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, false, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (-526.405);
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.0;
      String[] stringArray0 = new String[0];
      options0.setOptions(stringArray0);
      doubleArray0[5] = 0.0;
      doubleArray0[6] = 0.0;
      doubleArray0[7] = (double) 100;
      doubleArray0[8] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap4 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 8, identityHashMap2, identityHashMap3, (Map<String, double[]>) identityHashMap4, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      assertArrayEquals(new double[] {0.0, 100.0, (-526.405), 0.0, 0.0, 0.0, 0.0, 100.0, 100.0}, doubleArray0, 0.01);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[9][2][5];
      threeDimensionalMap0.put("@ \"7", "@ \"7", "@ \"7", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[6][4][5];
      threeDimensionalMap0.put("@ \"7", "@ \"7", "@ \"7", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory();
      Label label0 = wordLemmaTagFactory0.newLabel("@ \"7");
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(label0, (List<Tree>) null);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[9];
      doubleArray1[0] = 76.18009172947146;
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = (double) 100;
      doubleArray1[4] = (double) 100;
      doubleArray1[5] = 0.0;
      doubleArray1[6] = (double) 100;
      doubleArray1[7] = (double) 100;
      doubleArray1[8] = 0.0;
      identityHashMap0.put(labeledScoredTreeNode0, doubleArray1);
      splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      assertEquals(Double.NaN, labeledScoredTreeNode0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsAndRecountOutsideTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.hashMapFactory();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) null, (Tree) null, (IdentityHashMap<Tree, double[]>) null, (IdentityHashMap<Tree, double[]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[1][10][4];
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      twoDimensionalMap0.contains("__ < E(@PUfC < \") $ (@PUC < \"))", "<");
      identityHashMap2.put(tree0, doubleArray0);
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      identityHashMap3.put(tree0, doubleArray1);
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap3, identityHashMap3);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap3, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      CoreLabel coreLabel0 = new CoreLabel();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      List<Tree> list1 = List.of(tree0);
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list1);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[8][5];
      doubleArray1[0] = doubleArray0;
      identityHashMap2.put(tree1, doubleArray1);
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap2, identityHashMap0, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      int int0 = splittingGrammarExtractor0.iteration;
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap5 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recountWeights(tree1, identityHashMap4, identityHashMap4, identityHashMap5, identityHashMap0);
      assertFalse(identityHashMap5.isEmpty());
      assertEquals(0, identityHashMap4.size());
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][5][4];
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap2.put(tree0, doubleArray0);
      double[] doubleArray1 = new double[1];
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap3, identityHashMap3, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNonEmptyMapAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[2][10][4];
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap2.put(tree0, doubleArray0);
      double[] doubleArray1 = new double[5];
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, (-2165), identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      identityHashMap3.put(tree0, doubleArray1);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap3, identityHashMap3, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithNegative0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("/^(?:((?:[-a-zA-Z|]|\\$)+))$/");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (-530.94975), (Collection<Tree>) tree0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasThrowsRuntimeExceptionAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("/f");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      tree0.value();
      List<Tree> list0 = treeGraphNode0.getLeaves();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.trees = list0;
      splittingGrammarExtractor0.countOriginalStates();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexAndBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][4];
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = (double) 100;
      options0.useUnigramWordSmoothing = true;
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = (double) 100;
      doubleArray1[4] = (double) 100;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("gz=Y(I/IN0g'5w?}vZX", "micro", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = (double) 100;
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.DEBUG();
      MapFactory<Object, SemanticGraph.OutputFormat> mapFactory0 = MapFactory.hashMapFactory();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Map<String, int[]> map0 = mapFactory0.setMap(hashMap0);
      mapFactory0.setMap(map0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence((List<Triple<String, Integer, Double>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      assertFalse(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndDEBUGAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.DEBUG();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsWithFalseAndNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      Label label0 = tree0.label();
      label0.setValue("ROOT");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      assertFalse(list0.isEmpty());
      
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.DEBUG();
      MapFactory<CoreLabel, Triple<CoreLabel, Object, Object>> mapFactory0 = MapFactory.arrayMapFactory();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, map0, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndRecountInside1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      Label label0 = tree0.label();
      label0.setValue("ROOT");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      MapFactory.treeMapFactory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>(504);
      int int0 = splittingGrammarExtractor0.recountInside(tree0, false, 1, identityHashMap0);
      assertEquals(2, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasThrowsNullPointerException()  throws Throwable  {
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "q;at'PT^c04os87*)");
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      Label label0 = tree0.label();
      label0.setValue("ROOT");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      MapFactory.treeMapFactory();
      MapFactory.linkedHashMapFactory();
      double[][] doubleArray1 = new double[3][5];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      MapFactory<IndexedWord, String> mapFactory0 = MapFactory.arrayMapFactory();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[3];
      intArray0[0] = 100;
      intArray0[1] = 100;
      intArray0[2] = 222;
      hashMap0.put("A_+^\"|hm+!oZyhe", intArray0);
      Map<String, int[]> map0 = mapFactory0.setMap(hashMap0, 100);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateMergedBetas(map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndBuildGrammarsAndExtractTakingCollection()  throws Throwable  {
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "q;at'PT^c04os87*)");
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      Label label0 = tree0.label();
      label0.setValue("ROOT");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.treeMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.linkedHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      splittingGrammarExtractor0.buildGrammars();
      twoDimensionalMap0.remove("t%nga6 pwn|-");
      double[][] doubleArray1 = new double[3][5];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      twoDimensionalMap0.put("while", "ROOT", doubleArray1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideWithNullAndCountMergeEffectsTaking5ArgumentsAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateBetas(true);
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap.identityHashMap();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, (List<Tree>) vector0);
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      MapFactory.linkedHashMapFactory();
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      identityHashMap0.put("__ < E(@PUfC < \") $ (@PUC < \"))", doubleArray0);
      doubleArray0[3] = (double) 100;
      identityHashMap2.put("__ < E(@PUfC < \") $ (@PUC < \"))", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects(tree1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap2, identityHashMap3, identityHashMap3);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(tree0, (IdentityHashMap<Tree, double[]>) null, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStatesAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[9][3];
      twoDimensionalMap0.put("ROOT", "e-u2zPnf(AriIxK\nG", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.mergeStates();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[2][10][4];
      splittingGrammarExtractor0.recalculateBetas(true);
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      identityHashMap0.clone();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap2.put(tree0, doubleArray0);
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = 1.0;
      doubleArray1[1] = (double) (-3);
      doubleArray1[2] = 0.001208650973866179;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = 1.0;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, (-2165), identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, (-3), identityHashMap3, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(1, identityHashMap0.size());
      assertEquals((-3), int0);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][5][4];
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap2.put(tree0, doubleArray0);
      double[] doubleArray1 = new double[1];
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 2147483609, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap3, identityHashMap3, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideWithZero()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(".$$.");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = SplittingGrammarExtractor.MIN_DEBUG_ITERATION;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int1 = splittingGrammarExtractor0.recountInside(tree1, true, 0, identityHashMap0);
      assertEquals(1, int1);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndRecalculateBetasAndExtractTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[2][10][4];
      splittingGrammarExtractor0.recalculateBetas(true);
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap.identityHashMap();
      identityHashMap0.clone();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap2.put(tree0, doubleArray0);
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = 1.0;
      doubleArray1[1] = (double) (-3);
      doubleArray1[2] = 0.001208650973866179;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = 1.0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (double) (-3), (Collection<Tree>) tree0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][10][4];
      splittingGrammarExtractor0.recalculateBetas(true);
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      identityHashMap0.clone();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap2.put(tree0, doubleArray0);
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = 1.0;
      doubleArray1[1] = (double) (-3);
      doubleArray1[2] = 0.001208650973866179;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = 1.0;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, (-2165), identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateBetas(true);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      identityHashMap3.put(tree0, doubleArray1);
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap3, identityHashMap3);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap3, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[1][10][4];
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap2.put(tree0, doubleArray0);
      double[] doubleArray1 = new double[5];
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, (-2165), identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      identityHashMap3.put(tree0, doubleArray1);
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap3, identityHashMap3);
      assertFalse(identityHashMap3.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][10][4];
      threeDimensionalMap0.put("__ < E(@PUfC < \") $ (@PUC < \"))", "__ < E(@PUfC < \") $ (@PUC < \"))", "__ < E(@PUfC < \") $ (@PUC < \"))", doubleArray0);
      splittingGrammarExtractor0.recalculateBetas(true);
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      identityHashMap0.clone();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap2.put(tree0, doubleArray0);
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = 1.0;
      doubleArray1[1] = (double) (-3);
      doubleArray1[2] = 0.001208650973866179;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = 1.0;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, (-2165), identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
      
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap3, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@ $7");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      identityHashMap0.put("@ $7", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndRecalculateTemporaryBetasTaking8ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][5][4];
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap2.put(tree0, doubleArray0);
      double[] doubleArray1 = new double[1];
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap3, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][10][4];
      splittingGrammarExtractor0.DEBUG();
      Tree tree0 = Tree.valueOf("__ < ((@PUNC < \") $ (@PUNC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      threeDimensionalMap0.get("__ < ((@PUNC < \") $ (@PUNC < \"))", "__ < ((@PUNC < \") $ (@PUNC < \"))");
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNullAndNull()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(".$$.");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[4];
      intArray0[0] = 100;
      intArray0[1] = 100;
      intArray0[2] = 100;
      intArray0[3] = 100;
      hashMap0.put("X", intArray0);
      hashMap0.put("X", intArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = 0.0;
      splittingGrammarExtractor0.trees = list0;
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, hashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.trees = list0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[9][2][5];
      threeDimensionalMap0.put("i*a", "i*a", "i*a", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerExceptionAndUseNewBetasWithTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[10][0];
      twoDimensionalMap0.put("X*Mh", "X*Mh", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Index<String> index0 = splittingGrammarExtractor0.tempTagIndex;
      splittingGrammarExtractor0.wordIndex = null;
      twoDimensionalMap0.put("X*Mh", "@ Yq:%~ELi7.Z1l'O", (double[][]) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerExceptionAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      labeledScoredTreeFactory0.newLeaf(".$$.");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      double[][] doubleArray0 = new double[1][6];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put(".$$.", ".$$.", doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor1.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap1);
      twoDimensionalMap0.put("@ Yq:%~ELi7.Z1l'O", ".$$.", (double[][]) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      double[][] doubleArray0 = new double[20][6];
      double[] doubleArray1 = new double[1];
      twoDimensionalMap0.put(".$$.", ".$$.", doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor1.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap1);
      twoDimensionalMap0.put("@ Yq:%~ELi7.Z1l'O", ".$$.", (double[][]) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      CoreLabel coreLabel0 = new CoreLabel(100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      List<Tree> list1 = List.of(tree0);
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list1);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[1][5];
      doubleArray1[0] = doubleArray0;
      identityHashMap2.put(tree1, doubleArray1);
      tree1.constituents();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap2, identityHashMap0, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 101, identityHashMap2, identityHashMap0, (Map<String, double[]>) identityHashMap3, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap5 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(tree1, false, (-3151), identityHashMap5);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, false, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][] doubleArray0 = new double[2][3];
      twoDimensionalMap0.put("<fc", "l$4f83fpsTi", doubleArray0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      double[][][] doubleArray1 = new double[3][6][1];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = null;
      threeDimensionalMap0.put("6", "up", "fingertip", doubleArray1);
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap1.remove((String) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      CoreLabel coreLabel0 = new CoreLabel(100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      List<Tree> list1 = List.of(tree0);
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list1);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[1][5];
      doubleArray1[0] = doubleArray0;
      identityHashMap2.put(tree1, doubleArray1);
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap2, identityHashMap0, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 101, identityHashMap2, identityHashMap0, (Map<String, double[]>) identityHashMap3, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap5 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree1, false, (-3151), identityHashMap5);
      assertEquals((-3150), int0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      identityHashMap0.put(tree0, doubleArray0);
      Math.log((-1177.435377));
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.outputTransitions(tree0, 2379, identityHashMap0, identityHashMap1);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      assertEquals(0, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsAndBuildStateIndex()  throws Throwable  {
      Options options0 = new Options();
      CoreLabel coreLabel0 = new CoreLabel(100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      List<Tree> list1 = List.of(tree0);
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list1);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[1][5];
      doubleArray1[0] = doubleArray0;
      identityHashMap2.put(tree1, doubleArray1);
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap2, identityHashMap0, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      identityHashMap0.get(identityHashMap1);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.buildStateIndex();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, tree1, identityHashMap3, identityHashMap3);
      System.setCurrentTimeMillis(101);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndOutputBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      CoreLabel coreLabel0 = new CoreLabel(100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      List<Tree> list1 = List.of(tree0);
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list1);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      treeGraphNodeFactory0.newLeaf((Label) coreLabel0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[1][5];
      doubleArray1[0] = doubleArray0;
      identityHashMap2.put(tree1, doubleArray1);
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 100, identityHashMap2, identityHashMap0, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      identityHashMap0.get(identityHashMap1);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
      int int1 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, (-1733), identityHashMap2, identityHashMap0, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(int1 == int0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndBuildGrammars()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      CoreLabel coreLabel0 = new CoreLabel();
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      assertFalse(list0.isEmpty());
      
      splittingGrammarExtractor0.buildGrammars();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      System.setCurrentTimeMillis((-2107L));
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list0, 0.0, (Collection<Tree>) tree0, 1.22695948018281E-4);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[7][0];
      twoDimensionalMap0.put("X*Mh", "X*Mh", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("bowel");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.siblings(treeGraphNode0);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(categoryWordTag0, (List<Tree>) null);
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndExtractTaking4ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 0;
      intArray0[1] = 0;
      hashMap0.put("X", intArray0);
      int[] intArray1 = new int[2];
      intArray1[0] = 0;
      intArray1[1] = 0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.1, (Collection<Tree>) tree0, 0.95);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 0;
      intArray0[1] = 0;
      hashMap0.put("X", intArray0);
      int[] intArray1 = new int[2];
      intArray1[0] = 0;
      intArray1[1] = 0;
      hashMap0.put("Y", intArray1);
      double[] doubleArray1 = new double[2];
      Math.log(0.6);
      doubleArray1[0] = (-0.5108256237659907);
      Math.log(0.4);
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 0, identityHashMap0, identityHashMap4);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      Math.log((-1882.22962));
      Math.log((-1882.22962));
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, (-1890), identityHashMap0, identityHashMap3);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      assertEquals(0, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      WordFactory wordFactory0 = new WordFactory();
      Label label0 = wordFactory0.newLabel(" -> ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, false, (-1), identityHashMap0);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      labeledScoredTreeNode0.addChild((Tree) labeledScoredTreeNode0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = 0.0;
      MapFactory.linkedHashMapFactory();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.recalculateBetas(true);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithZero0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(".$$.");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree1, 0.0, (Collection<Tree>) tree1, 1169.5302);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.dominationPath(treeGraphNode0);
      LabeledScoredTreeNode labeledScoredTreeNode1 = new LabeledScoredTreeNode(labeledScoredTreeNode0, list0);
      labeledScoredTreeNode1.addChild((Tree) labeledScoredTreeNode0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<Object, SemanticGraph.OutputFormat> mapFactory0 = MapFactory.linkedHashMapFactory();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Map<String, int[]> map0 = mapFactory0.setMap(hashMap0);
      mapFactory0.setMap(hashMap0);
      double[] doubleArray0 = new double[0];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode1, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, doubleArray0, map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = new CoreLabel(100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      List<Tree> list1 = List.of(tree0);
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list1);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[1][5];
      doubleArray1[0] = doubleArray0;
      identityHashMap2.put(tree1, doubleArray1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 34, identityHashMap2, identityHashMap0, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][1][4];
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $(@+UC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap2.put(tree0, doubleArray0);
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap1, identityHashMap2);
      double[] doubleArray1 = new double[1];
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap3, identityHashMap3, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      String string0 = "__ < ((@PUNC < \") $ (@PUNC < \"))";
      double[][][] doubleArray0 = new double[2][10][4];
      threeDimensionalMap0.put("__ < ((@PUNC < \") $ (@PUNC < \"))", "__ < ((@PUNC < \") $ (@PUNC < \"))", "__ < ((@PUNC < \") $ (@PUNC < \"))", doubleArray0);
      splittingGrammarExtractor0.recalculateBetas(true);
      Tree tree0 = Tree.valueOf("__ < ((@PUNC < \") $ (@PUNC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap.identityHashMap();
      identityHashMap0.clone();
      double[] doubleArray1 = new double[5];
      identityHashMap2.put(tree0, doubleArray0);
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = (double) 100;
      double double0 = 1.0;
      doubleArray1[3] = 1.0;
      String[] stringArray0 = new String[5];
      stringArray0[0] = "__ < ((@PUNC < \") $ (@PUNC < \"))";
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      identityHashMap0.put(tree0, doubleArray0);
      SystemInUtil.addInputLine("p/O\" GT");
      Math.log((-1177.435377));
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.outputTransitions(tree0, 2379, identityHashMap0, identityHashMap1);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      assertEquals(0, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      String string0 = "__ < ((@PUNC < \") $ (@PUNC < \"))";
      double[][][] doubleArray0 = new double[2][10][4];
      FileSystemHandling.shouldAllThrowIOExceptions();
      Tree tree0 = Tree.valueOf("__ < ((@PUNC < \") $ (@PUNC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>(100);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      String[] stringArray0 = new String[5];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][1][4];
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $(@+UC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap2.put(tree0, doubleArray0);
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap1, identityHashMap2);
      double[] doubleArray1 = new double[7];
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap3, identityHashMap3, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndRecalculateBetasAndExtractTaking4ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][10][4];
      threeDimensionalMap0.put("__ < ((@PUNC < \") $ (@PUNC < \"))", "__ < ((@PUNC < \") $ (@PUNC < \"))", "__ < ((@PUNC < \") $ (@PUNC < \"))", doubleArray0);
      splittingGrammarExtractor0.recalculateBetas(true);
      Tree tree0 = Tree.valueOf("__ < ((@PUNC < \") $ (@PUNC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap.identityHashMap();
      identityHashMap0.clone();
      double[] doubleArray1 = new double[5];
      identityHashMap2.put(tree0, doubleArray0);
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 1.0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 1.0, (Collection<Tree>) tree0, 2633.000000000001);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Trees should have been binarized, expected 1 or 2 children
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NP (DT t.e))k(VP (VBZ Gngs)))");
      Set<Tree> set0 = new LinkedHashSet<Tree>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Trees should have been binarized, expected 1 or 2 children
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken(" -> ", 100, 100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (-1902.999);
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      identityHashMap1.put(" -> ", doubleArray0);
      double[] doubleArray1 = new double[1];
      twoDimensionalMap0.clear();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 100, identityHashMap2, identityHashMap0, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndExtractTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("Determined h4ad (case 3) foW ");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      assertFalse(list0.isEmpty());
      
      splittingGrammarExtractor0.extract((Collection<Tree>) list0, 361.32094977933, (Collection<Tree>) list0, 361.32094977933);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][10][4];
      threeDimensionalMap0.put("__ < ((@PUNC < \") $ (@PUNC < \"))", "__ < ((@PUNC < \") $ (@PUNC < \"))", "__ < ((@PUNC < \") $ (@PUNC < \"))", doubleArray0);
      splittingGrammarExtractor0.recalculateBetas(true);
      Tree tree0 = Tree.valueOf("__ < ((@PUNC < \") $ (@PUNC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = (double) 100;
      identityHashMap2.put(tree0, doubleArray0);
      doubleArray1[1] = (double) 34;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 1.0;
      doubleArray1[4] = 0.0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, (-3), identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][5][4];
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap2.put(tree0, doubleArray0);
      double[] doubleArray1 = new double[8];
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(1, identityHashMap0.size());
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndNull()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Tree tree0 = chineseTreebankParserParams0.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      labeledScoredTreeNode0.addChild(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      identityHashMap2.get(chineseTreebankParserParams0);
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = (double) 3;
      doubleArray0[1] = 5.0;
      doubleArray0[2] = (double) 0;
      doubleArray0[3] = (double) 0;
      doubleArray0[4] = 5.0;
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, doubleArray0, (-3343), identityHashMap3, (IdentityHashMap<Tree, double[][][]>) null, (Map<String, double[]>) null, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerExceptionAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      CoreLabel coreLabel0 = new CoreLabel();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree0, true, 2447, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][10][4];
      threeDimensionalMap0.put("__ < ((@PUNC < \") $ (@PUNC < \"))", "__ < ((@PUNC < \") $ (@PUNC < \"))", "__ < ((@PUNC < \") $ (@PUNC < \"))", doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      Morphology morphology0 = new Morphology();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(morphology0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap1, threeDimensionalMap0);
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      NPTmpRetainingTreeNormalizer.NPTmpRetainingTreeReaderFactory nPTmpRetainingTreeNormalizer_NPTmpRetainingTreeReaderFactory0 = new NPTmpRetainingTreeNormalizer.NPTmpRetainingTreeReaderFactory();
      Tree tree0 = Tree.valueOf("__ < ((@PUNC < \") $ (@PUNC < \"))", (TreeReaderFactory) nPTmpRetainingTreeNormalizer_NPTmpRetainingTreeReaderFactory0);
      Tree tree1 = hungarianTreebankParserParams0.transformTree(tree0, tree0);
      double[] doubleArray1 = new double[8];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = (double) 100;
      doubleArray1[5] = 0.0;
      doubleArray1[6] = (double) 100;
      doubleArray1[7] = (double) 100;
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray1, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap1, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException4()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      Tree tree0 = Tree.valueOf("__ < E(@PUfC < \") $ (@PUC < \"))");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[6];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap1, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsAndRecountOutsideTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.state("\u00CC", 15);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStateAndStateWithNonEmptyString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String[] stringArray0 = new String[2];
      stringArray0[0] = "ROOT";
      stringArray0[1] = "S";
      Arrays.asList(stringArray0);
      String string0 = splittingGrammarExtractor0.state("ROOT", 2);
      assertEquals("ROOT", string0);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNonEmptyMapAndRecountWeightsWithEmptyMapAndRecountWeightsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(A (B b))");
      Label label0 = tree0.label();
      label0.setValue("A");
      double[][] doubleArray0 = new double[1][1];
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = 0.0;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      identityHashMap1.put(tree0, doubleArray2);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndRecountWeightsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      Label label0 = tree0.label();
      label0.setValue("A");
      double[][][] doubleArray0 = new double[1][1][1];
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = 0.0;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = 0.0;
      identityHashMap1.put(tree0, doubleArray3);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecountWeightsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NP (DT t.e)) (VP (VBZ sngs)))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      hashMap0.put("X", intArray0);
      int[] intArray1 = new int[5];
      intArray1[0] = 100;
      intArray1[1] = 100;
      intArray1[2] = 100;
      intArray1[3] = 100;
      intArray1[4] = 100;
      hashMap0.put("X", intArray1);
      hashMap0.put("Y", intArray0);
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3, doubleArray1, hashMap0);
      splittingGrammarExtractor0.countOriginalStates();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap1, (Map<String, double[]>) hashMap1, identityHashMap4, identityHashMap4);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      hashMap0.put("X", intArray0);
      hashMap0.put("Y", intArray0);
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3, doubleArray1, hashMap0);
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      assertEquals(2, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceReturningMapWhereIsEmptyIsFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = "(ROOT (NP (NN dog)))";
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitionsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      Map<String, int[]> map0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 0;
      intArray0[1] = 0;
      map0.put("X", intArray0);
      int[] intArray1 = new int[2];
      intArray1[0] = 0;
      intArray1[1] = 0;
      map0.put("Y", intArray1);
      double[] doubleArray1 = new double[2];
      Math.log(0.6);
      doubleArray1[0] = (-0.5108256237659907);
      Math.log(0.4);
      doubleArray1[1] = (-0.916290731874155);
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3, doubleArray1, map0);
      boolean boolean0 = identityHashMap2.containsKey(tree0);
      assertEquals(1, identityHashMap2.size());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      Collections.singletonList(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, (double[]) null, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@ \"7");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.recountInside(tree1, false, (-1840700268), identityHashMap0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken(" -> ", 2633, 2633);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Object[] objectArray0 = new Object[9];
      objectArray0[0] = (Object) " -> ";
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor1.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      MapFactory<CoreLabel.GenericAnnotation<Object>, CoreLabel> mapFactory0 = MapFactory.hashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      mapFactory0.setMap(hashMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = 2.5066282746310007;
      doubleArray0[5] = (-905.0292743585);
      doubleArray0[6] = (double) 2633;
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor1.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, identityHashMap2);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap3, identityHashMap4);
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("Determined head (case 3) for ");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInsideWithTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("@ \"7");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.recountInside(tree1, true, 100, identityHashMap1);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      assertEquals(0, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[3][0];
      double[] doubleArray1 = new double[2];
      options0.baseParserWeight = (double) 100;
      doubleArray1[1] = 100.0;
      twoDimensionalMap0.put("{c,`KBqn", "i*a", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      boolean boolean1 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsAndCountMergeEffectsTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("yzlJ4e8KZSLKKx");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = Double.NEGATIVE_INFINITY;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 379.7026799323167;
      splittingGrammarExtractor2.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 100, identityHashMap0, identityHashMap3, (Map<String, double[]>) identityHashMap2, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      splittingGrammarExtractor1.countMergeEffects(tree1, (Map<String, double[]>) identityHashMap2, (Map<String, double[]>) identityHashMap2);
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor2);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("Determined head (case 3) for ");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      FileSystemHandling.shouldAllThrowIOExceptions();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0);
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      TreeGraphNodeFactory treeGraphNodeFactory1 = new TreeGraphNodeFactory();
      assertFalse(treeGraphNodeFactory1.equals((Object)treeGraphNodeFactory0));
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerExceptionAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken(" -> ", 100, 100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      List.of(tree0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.parent();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>(identityHashMap1);
      splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 34, identityHashMap3, identityHashMap4, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap5 = new IdentityHashMap<Tree, double[]>(35);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode1, tree0, (Tree) treeGraphNode0, identityHashMap5, identityHashMap5);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer((TreebankLanguagePack) null);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      IndexedWord indexedWord0 = new IndexedWord("++I", 100, 100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("++I", list0);
      Tree tree1 = bobChrisTreeNormalizer0.normalizeWholeTree(tree0, labeledScoredTreeFactory0);
      MapFactory<Object, CoreLabel> mapFactory0 = MapFactory.weakHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap1, 100);
      mapFactory0.setMap(null);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(tree1, identityHashMap2, identityHashMap2, identityHashMap3, identityHashMap4);
      options0.newTrainOptions();
      IdentityHashMap<Tree, double[]> identityHashMap5 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree1, map0, map0, identityHashMap5, identityHashMap5);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningPositive()  throws Throwable  {
      Options options0 = new Options();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken(" -> ", 100, 100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[6];
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      double[][] doubleArray1 = new double[4][1];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[3] = doubleArray0;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(tree0, false, 1085, identityHashMap2);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer((TreebankLanguagePack) null);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      IndexedWord indexedWord0 = new IndexedWord("++I", 926, 926);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("++I", list0);
      Tree tree1 = bobChrisTreeNormalizer0.normalizeWholeTree(tree0, labeledScoredTreeFactory0);
      MapFactory<Object, CoreLabel> mapFactory0 = MapFactory.weakHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap1, 100);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree1, map0, map0, identityHashMap2, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("Determined head (case 3) for ");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerExceptionAndRecountInsideWithFalseAndRecountInsideWithNegative()  throws Throwable  {
      Options options0 = new Options();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken(" -> ", 2647, 2647);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(" -> ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      tree0.addChild(tree1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree0, false, (-1073741824), identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.iteration = (-50);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException5()  throws Throwable  {
      Options options0 = new Options();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken(" -> ", 2647, 2647);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      labeledScoredTreeFactory0.newLeaf(" -> ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = (double) 2647;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 3966.9765826;
      doubleArray0[4] = (-1.0);
      doubleArray0[5] = (-1471.626704);
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 2647, identityHashMap0, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithNegative1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(".$$.");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list0);
      labeledScoredTreeFactory0.newLeaf(".$$.");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree1, (double) 100, (Collection<Tree>) tree1, Double.NEGATIVE_INFINITY);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6Arguments()  throws Throwable  {
      Options options0 = new Options();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken(" -> ", 2647, 2647);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      labeledScoredTreeFactory0.newLeaf(" -> ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      labeledScoredTreeFactory0.newLeaf(" -> ");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (double) 2647;
      doubleArray0[1] = (double) 2647;
      identityHashMap1.getOrDefault(coreLabel0, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountTree(tree0, false, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3);
      assertEquals(1, identityHashMap1.size());
      assertFalse(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInsideWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("Determinid head (case 3) for ");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, false, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningZero()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("RrtKh#WA2HUM");
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = (double) 100;
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.hashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, (MapFactory<String, double[][]>) null);
      int int0 = splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, doubleArray0, 0, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap1, threeDimensionalMap0);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerExceptionAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      chineseTreebankParserParams0.markCC = false;
      LabeledScoredTreeNode labeledScoredTreeNode1 = new LabeledScoredTreeNode();
      labeledScoredTreeNode0.addChild((Tree) labeledScoredTreeNode1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[1];
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      doubleArray0[0] = 5.0;
      identityHashMap0.put(labeledScoredTreeNode1, doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountInside(labeledScoredTreeNode0, true, 100, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndTestConvergenceAndUseNewBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[2][7];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) 100;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[3];
      doubleArray2[0] = (-1903.205025575759);
      doubleArray2[1] = 0.0;
      doubleArray2[2] = 0.0;
      doubleArray0[1] = doubleArray2;
      twoDimensionalMap0.put("", "VPpart", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap1);
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecurseOutside0()  throws Throwable  {
      Random.setNextRandom((-2622));
      Options options0 = new Options();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken(" -> ", 2647, 2647);
      LabelFactory labelFactory0 = coreLabel0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      labeledScoredTreeFactory0.newLeaf(" -> ");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      labeledScoredTreeFactory0.newLeaf(" -> ");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("", list0);
      splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap0, identityHashMap0);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testMergeStates0()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Morphology morphology0 = new Morphology();
      twoDimensionalMap0.transform(morphology0);
      double[][] doubleArray0 = new double[1][7];
      double[] doubleArray1 = new double[7];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = 0.0;
      doubleArray1[5] = (double) 100;
      doubleArray1[6] = (double) 100;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("VPpart", "VPpart", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.mergeStates();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndTestConvergenceWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("Error loading segmenter, exiting...", "Error loading segmenter, exiting...", "@ \"x");
      double[][][] doubleArray0 = new double[5][7][0];
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = (double) 100;
      doubleArray1[5] = 280.4;
      double[] doubleArray2 = new double[8];
      doubleArray2[0] = 280.4;
      doubleArray2[1] = 0.0;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = (-1536.95856697);
      doubleArray2[4] = 2047.080759619999;
      doubleArray2[5] = 280.4;
      doubleArray2[6] = (double) 100;
      doubleArray2[7] = 0.0;
      double[] doubleArray3 = new double[0];
      double[][] doubleArray4 = new double[3][7];
      doubleArray4[1] = doubleArray2;
      doubleArray4[2] = doubleArray1;
      doubleArray0[1] = doubleArray4;
      double[][] doubleArray5 = new double[3][1];
      doubleArray5[0] = doubleArray3;
      doubleArray5[1] = doubleArray3;
      doubleArray5[2] = doubleArray1;
      doubleArray0[4] = doubleArray5;
      double[][] doubleArray6 = new double[3][6];
      doubleArray6[0] = doubleArray1;
      doubleArray6[1] = doubleArray2;
      doubleArray6[2] = doubleArray3;
      doubleArray0[3] = doubleArray6;
      double[][] doubleArray7 = new double[5][6];
      doubleArray7[0] = doubleArray3;
      doubleArray7[1] = doubleArray3;
      doubleArray7[2] = doubleArray3;
      doubleArray7[3] = doubleArray1;
      doubleArray7[4] = doubleArray2;
      doubleArray0[4] = doubleArray7;
      threeDimensionalMap0.put("@ \"x", "\"+7", "\"+7", doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("Error loading segmenter, exiting...", "Error loading segmenter, exiting...", "@ \"x");
      double[][][] doubleArray0 = new double[5][7][0];
      double[][] doubleArray1 = new double[3][9];
      double[] doubleArray2 = new double[6];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = 0.0;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      doubleArray2[4] = (double) 100;
      doubleArray2[5] = 280.4;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[8];
      doubleArray3[0] = 280.4;
      doubleArray3[1] = 0.0;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = (-1536.95856697);
      doubleArray3[4] = 2047.080759619999;
      doubleArray3[5] = 280.4;
      doubleArray3[6] = (double) 100;
      doubleArray3[7] = 0.0;
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[0];
      doubleArray1[2] = doubleArray4;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray5 = new double[3][7];
      doubleArray1[2] = doubleArray3;
      doubleArray5[1] = doubleArray3;
      doubleArray5[2] = doubleArray2;
      doubleArray0[1] = doubleArray5;
      double[][] doubleArray6 = new double[3][1];
      doubleArray6[0] = doubleArray4;
      doubleArray6[1] = doubleArray4;
      doubleArray6[2] = doubleArray2;
      doubleArray0[4] = doubleArray6;
      double[][] doubleArray7 = new double[3][6];
      doubleArray7[0] = doubleArray2;
      doubleArray7[1] = doubleArray3;
      doubleArray7[2] = doubleArray4;
      doubleArray0[3] = doubleArray7;
      double[][] doubleArray8 = new double[5][6];
      doubleArray8[0] = doubleArray4;
      doubleArray8[1] = doubleArray4;
      doubleArray8[2] = doubleArray4;
      doubleArray8[3] = doubleArray2;
      doubleArray8[4] = doubleArray3;
      doubleArray0[4] = doubleArray8;
      threeDimensionalMap0.put("@ \"x", "\"+7", "\"+7", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithZero1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("ZMeJ#h1G");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list0);
      labeledScoredTreeFactory0.newLeaf("}j");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree1, 0.0, (Collection<Tree>) list0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) tree0, 0.0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceThrowsArrayIndexOutOfBoundsExceptionAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      String string0 = "Error loading segmenter, exiting...";
      threeDimensionalMap0.remove("Error loading segmenter, exiting...", "Error loading segmenter, exiting...", "@ \"x");
      double[][][] doubleArray0 = new double[5][7][0];
      double[][] doubleArray1 = new double[3][9];
      double[] doubleArray2 = new double[6];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = 0.0;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      doubleArray2[4] = (double) 100;
      doubleArray2[5] = 280.4;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[8];
      doubleArray3[0] = 280.4;
      doubleArray3[1] = 0.0;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = (-1536.95856697);
      doubleArray3[4] = 2047.080759619999;
      doubleArray3[5] = 280.4;
      doubleArray3[6] = (double) 100;
      doubleArray3[7] = 0.0;
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[0];
      doubleArray1[2] = doubleArray4;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray5 = new double[3][7];
      doubleArray5[0] = doubleArray3;
      doubleArray5[1] = doubleArray3;
      doubleArray5[2] = doubleArray2;
      doubleArray0[1] = doubleArray5;
      double[][] doubleArray6 = new double[3][1];
      doubleArray6[0] = doubleArray4;
      doubleArray6[1] = doubleArray4;
      doubleArray6[2] = doubleArray2;
      doubleArray0[2] = doubleArray6;
      double[][] doubleArray7 = new double[3][6];
      doubleArray7[0] = doubleArray2;
      doubleArray7[1] = doubleArray3;
      doubleArray7[2] = doubleArray4;
      doubleArray0[3] = doubleArray7;
      double[][] doubleArray8 = new double[5][6];
      doubleArray8[0] = doubleArray4;
      doubleArray8[1] = doubleArray4;
      doubleArray8[2] = doubleArray4;
      doubleArray8[3] = doubleArray2;
      doubleArray8[4] = doubleArray3;
      doubleArray0[4] = doubleArray8;
      threeDimensionalMap0.put("@ \"x", "\"+7", "\"+7", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = null;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CompositeTreeTransformer compositeTreeTransformer0 = new CompositeTreeTransformer();
      compositeTreeTransformer0.transformTree((Tree) null);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, true);
      double[][] doubleArray0 = new double[3][1];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      doubleArray0[0] = doubleArray1;
      options0.useSmoothTagProjection = false;
      double[] doubleArray2 = new double[5];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = (double) 100;
      doubleArray2[4] = (double) 100;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[5];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = (double) 100;
      doubleArray3[3] = (double) 100;
      doubleArray3[4] = 0.0;
      doubleArray0[2] = doubleArray3;
      identityHashMap1.put((Tree) null, doubleArray0);
      double[][] doubleArray4 = new double[0][3];
      identityHashMap1.putIfAbsent((Tree) null, doubleArray4);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) null, false, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStates1()  throws Throwable  {
      Random.setNextRandom((-2622));
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Morphology morphology0 = new Morphology();
      twoDimensionalMap0.transform(morphology0);
      double[][] doubleArray0 = new double[18][0];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      double[] doubleArray2 = new double[6];
      doubleArray2[0] = 0.0;
      doubleArray0[2] = doubleArray2;
      twoDimensionalMap0.put("VPpart", "VPpart", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.splitBetas();
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor3.mergeStates();
      assertNotSame(splittingGrammarExtractor3, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexAndRecalculateBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][1][1];
      double[][] doubleArray1 = new double[1][5];
      double[] doubleArray2 = new double[7];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (-2154.9200376);
      doubleArray2[3] = (double) 100;
      doubleArray2[4] = (double) 100;
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = 0.0;
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("p$a*L@;$ax8Qkp", "@'", "lam", doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateBetas(false);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor1.buildStateIndex();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndSplitBetas()  throws Throwable  {
      Random.setNextRandom((-2622));
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      Morphology morphology0 = new Morphology();
      twoDimensionalMap0.transform(morphology0);
      double[][] doubleArray0 = new double[18][0];
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray2 = new double[2][0][5];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      splittingGrammarExtractor0.binaryBetas = threeDimensionalMap0;
      threeDimensionalMap0.put("  Transitions:", "  Transitions:", "", doubleArray2);
      splittingGrammarExtractor0.recalculateBetas(false);
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.splitBetas();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[14][17][2];
      threeDimensionalMap0.put("X", "X", "X", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndMergeStatesAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][7][2];
      double[][] doubleArray1 = new double[1][4];
      double[] doubleArray2 = new double[17];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = 0.0;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      doubleArray2[4] = (double) 100;
      doubleArray2[5] = (double) 100;
      doubleArray1[0] = doubleArray2;
      double[][] doubleArray3 = new double[2][1];
      doubleArray3[0] = doubleArray2;
      threeDimensionalMap0.put("&V0r9D OD", (String) null, "&V0r9D OD", doubleArray0);
      splittingGrammarExtractor0.recalculateBetas(true);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.splitBetas();
      splittingGrammarExtractor0.mergeStates();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndOutputBetasAndRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[1][3][5];
      double[][] doubleArray1 = new double[1][4];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("-------------------", "QA", "-WCStackedNERTag", doubleArray0);
      Options options1 = new Options();
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      SimpleTree simpleTree0 = new SimpleTree();
      Tree tree0 = hungarianTreebankParserParams0.transformTree(simpleTree0, simpleTree0);
      // Undeclared exception!
      try { 
        CoordinationTransformer.UCPtransform(tree0);
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[17][0];
      double[][][] doubleArray1 = new double[1][8][2];
      doubleArray1[0] = doubleArray0;
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray1);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][0];
      twoDimensionalMap0.put("", "", doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("Determined h4ad (case 3) foW ");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      System.setCurrentTimeMillis(0L);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateMergedBetas(identityHashMap0);
      LabelFactory labelFactory0 = IndexedWord.factory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newLeaf((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree1, 1163, identityHashMap1, identityHashMap2);
      assertNotSame(treeGraphNode0, tree1);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NN cat))");
      Label label0 = tree0.label();
      label0.setValue("S");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetas1()  throws Throwable  {
      System.setCurrentTimeMillis((-3479L));
      Random.setNextRandom((-2622));
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      Morphology morphology0 = new Morphology();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(morphology0);
      double[][] doubleArray0 = new double[6][0];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) (-2622);
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = (double) 100;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[2];
      doubleArray3[0] = 0.0;
      doubleArray3[1] = (double) 100;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[4];
      doubleArray4[0] = (double) (-2622);
      doubleArray4[1] = (double) (-3479L);
      doubleArray4[2] = 0.0;
      doubleArray4[3] = 2672.6;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[8];
      doubleArray5[0] = 873.1895080292097;
      doubleArray5[1] = 2672.6;
      doubleArray5[2] = (double) (-3479L);
      doubleArray5[3] = (double) (-2622);
      doubleArray5[4] = (double) (-3479L);
      doubleArray5[5] = (double) 100;
      doubleArray5[6] = (double) (-3479L);
      doubleArray5[7] = 0.0;
      doubleArray0[4] = doubleArray5;
      double[] doubleArray6 = new double[3];
      doubleArray6[0] = (double) 100;
      doubleArray6[1] = (double) (-3479L);
      doubleArray6[2] = (double) 100;
      doubleArray0[5] = doubleArray6;
      twoDimensionalMap1.put("  Transitions:", "  Transitions:", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap1, threeDimensionalMap0);
      Random.setNextRandom(100);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[27][3][2];
      threeDimensionalMap0.put("BW@O", "BW@O", "BW@O", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndOutputBetasAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.linkedHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.identityHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[6][4][2];
      threeDimensionalMap1.put("LEXICON", "LEXICON", "snowcem", doubleArray0);
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(twoDimensionalMap0.equals((Object)twoDimensionalMap1));
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideWithNullAndOutputBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("slashTags", "slashTags");
      threeDimensionalMap0.getTwoDimensionalMap("Dj|~wO&Q");
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.outputBetas();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside((Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndTestConvergenceAndUseNewBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Morphology morphology0 = new Morphology();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(morphology0);
      double[][] doubleArray0 = new double[18][0];
      double[] doubleArray1 = new double[9];
      doubleArray1[0] = (double) 100;
      double[] doubleArray2 = new double[6];
      doubleArray2[0] = 0.0;
      doubleArray0[2] = doubleArray1;
      twoDimensionalMap0.put("VPpart", "VPpart", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.linkedHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.get("~A", "~A");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.recalculateBetas(false);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.get("a ", "a ");
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndBuildStateIndexAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ArrayList<String> arrayList0 = new ArrayList<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) arrayList0;
      splittingGrammarExtractor0.buildStateIndex();
      double[][] doubleArray0 = new double[20][0];
      arrayList0.add("; ");
      twoDimensionalMap0.put("; ", "2o<<sC*IVMFT#", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesReturningEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)0;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      MapFactory.linkedHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles((byte)0);
      assertEquals(0, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNegativeAndNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.linkedHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.get("R~A", "R~A");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("R~A");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tree0, 280.4);
      labeledScoredTreeNode0.getSpan();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      treeGraphNode0.parent(tree0);
      splittingGrammarExtractor0.saveTrees(labeledScoredTreeNode0, (-1494.6034101), (Collection<Tree>) null, 100);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) tree0, (-1016.85688418), (Collection<Tree>) labeledScoredTreeNode0, 1337.8551);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndBuildMergeCorrespondenceAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.linkedHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.get("R~A", "R~A");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      threeDimensionalMap0.getTwoDimensionalMap("strap");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor2.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      MapFactory<Object, CoreLabel.GenericAnnotation<Object>> mapFactory0 = MapFactory.identityHashMapFactory();
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor2.buildMergeCorrespondence(arrayList0);
      Map<String, int[]> map1 = mapFactory0.setMap(map0);
      splittingGrammarExtractor2.recalculateMergedBetas(map1);
      assertTrue(map1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.get("{8$<5z_*$b)aC", "{8$<5z_*$b)aC");
      splittingGrammarExtractor0.outputBetas();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.dominationPath(treeGraphNode0);
      LabeledScoredTreeNode labeledScoredTreeNode1 = new LabeledScoredTreeNode(labeledScoredTreeNode0, list0);
      labeledScoredTreeNode1.addChild((Tree) labeledScoredTreeNode0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<Object, SemanticGraph.OutputFormat> mapFactory0 = MapFactory.linkedHashMapFactory();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Map<String, int[]> map0 = mapFactory0.setMap(hashMap0);
      mapFactory0.setMap(hashMap0);
      double[] doubleArray0 = new double[0];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode1, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, doubleArray0, map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndRescaleTemporaryBetas()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.getStateSplitCount("hFa'+.)JP");
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      WordFactory wordFactory0 = new WordFactory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(wordFactory0);
      WordTag wordTag0 = new WordTag("hFa'+.)JP");
      StringLabel stringLabel0 = new StringLabel(wordTag0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("UY4EiEOg", "7OQ).~#dX>E9|", (String) null);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(stringLabel0, categoryWordTag0);
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) wordLemmaTag0, (List<Tree>) null);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = (double) 100;
      doubleArray0[6] = (double) 100;
      doubleArray0[7] = (double) 0;
      doubleArray0[8] = 0.0;
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, hashMap0);
      assertEquals(Double.NaN, tree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitionsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode0, identityHashMap2, identityHashMap1, identityHashMap2, identityHashMap1, (double[]) null, identityHashMap0);
      assertTrue(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerExceptionAndBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor1.state("WDWos5?a,lh&YM", 100);
      Double double0 = new Double(0.0);
      Integer integer0 = new Integer((-1435));
      Triple<String, Integer, Double> triple0 = Triple.makeTriple(":", integer0, 0.0);
      Integer integer1 = new Integer(2);
      Double double1 = new Double(100);
      Triple<String, Integer, Double> triple1 = Triple.makeTriple("WDWos5?a,lh&YM", integer1, double1);
      List<Triple<String, Integer, Double>> list0 = List.of(triple1, triple1, triple0, triple0, triple1, triple0, triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.buildMergeCorrespondence(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Integer integer0 = new Integer((-896));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("j{", integer0, (Double) 0.0);
      stack0.add(triple0);
      Object object0 = new Object();
      stack0.removeElement(object0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndExtractTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Vector<Tree> vector0 = new Vector<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.extract((Collection<Tree>) vector0, (double) 100, (Collection<Tree>) vector0, 0.0);
      splittingGrammarExtractor0.DEBUG();
      splittingGrammarExtractor0.buildGrammars();
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf(".$$.");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects(tree1, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap1);
      assertNotSame(tree1, treeGraphNode0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("RrVKh#WA2HUM");
      MapFactory.linkedHashMapFactory();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateBetas(true);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap1, identityHashMap2);
      assertEquals(Double.NaN, tree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) identityHashMap0, (Map<String, double[]>) identityHashMap0, identityHashMap1, identityHashMap2);
      assertTrue(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsWithNullAndOutputTransitionsTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.linkedHashMapFactory();
      CoreLabel coreLabel0 = new CoreLabel(100);
      CoreLabel coreLabel1 = new CoreLabel(coreLabel0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(coreLabel1);
      coreLabel1.setIsNewline(true);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1);
      assertEquals(0, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndOutputBetasAndCountOriginalStatesAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("8_E@>O90.dmnf1F");
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      tree0.getSpan();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("8_E@>O90.dmnf1F", (String) null, "  Transitions:");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testOutputBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][7][2];
      threeDimensionalMap0.put("\u00CC", "\u00CC", "\u00CC", doubleArray0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsAndOutputTransitionsTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.linkedHashMapFactory();
      splittingGrammarExtractor0.state("A_+^\"|hm+!oZyhe", 100);
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Tree tree0 = simpleTreeFactory0.newLeaf("A_+^\"|hm+!oZyhe");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NP (DT t.e)) (VP (VBZ sngs)))");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.get("[14a#", "");
      threeDimensionalMap0.getTwoDimensionalMap("S:/ry-");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      threeDimensionalMap0.remove("a6y^uuE#", "", "OP+");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      String[] stringArray0 = new String[5];
      stringArray0[0] = "a6y^uuE#";
      stringArray0[1] = "[14a#";
      stringArray0[2] = "OP+";
      stringArray0[3] = "a6y^uuE#";
      stringArray0[4] = "^";
      CoreLabel coreLabel0 = null;
      try {
        coreLabel0 = new CoreLabel(stringArray0, stringArray0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Unknown key a6y^uuE#
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.get("R~A", "R~A");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("8_E@>O90.dmnf1F");
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      tree0.getSpan();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("8_E@>O90.dmnf1F", (String) null, "  Transitions:");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTree()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("8_E@>O90.dmnf1F");
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap1, identityHashMap1, identityHashMap2, identityHashMap3);
      splittingGrammarExtractor0.saveTrees(tree0, 100, tree0, 0.0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount(tree0);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][7][2];
      threeDimensionalMap0.put("\u00CC", "\u00CC", "\u00CC", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerExceptionAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Tree tree0 = simpleTreeFactory0.newLeaf("^");
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      options0.tlpParams = (TreebankLangParserParams) englishTreebankParserParams0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      CompositeTreeTransformer compositeTreeTransformer0 = new CompositeTreeTransformer();
      Tree tree1 = compositeTreeTransformer0.transformTree(tree0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.remove("^", "7#fT", "s:oMf@'!Q@Yk");
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree1, tree0, identityHashMap2, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.get("N");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      SimpleTreeFactory simpleTreeFactory1 = new SimpleTreeFactory();
      Tree tree0 = simpleTreeFactory0.newLeaf("");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      CompositeTreeTransformer compositeTreeTransformer0 = new CompositeTreeTransformer();
      compositeTreeTransformer0.transformTree(tree0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, (double[]) null, (-2812), identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(twoDimensionalMap0.equals((Object)twoDimensionalMap1));
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsAndBuildStateIndex()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabelFactory labelFactory0 = TaggedWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("GXSV", (List<Tree>) vector0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, identityHashMap0, identityHashMap0);
      assertEquals(1, identityHashMap0.size());
      
      tree0.getSpan();
      Tree tree1 = labeledScoredTreeFactory0.newLeaf((Label) tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[2][8];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[5];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 1503.77;
      doubleArray0[1] = doubleArray2;
      identityHashMap1.put(tree1, doubleArray0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.extract((Collection<Tree>) vector0);
      splittingGrammarExtractor0.DEBUG();
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = new CoreLabel();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[][] doubleArray0 = new double[4][4];
      splittingGrammarExtractor0.buildStateIndex();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      coreLabel0.labelFactory();
      splittingGrammarExtractor0.DEBUG();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      SimpleTree simpleTree0 = new SimpleTree(coreLabel0, list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) simpleTree0, false, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndCountOriginalStatesAndOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.get("[14a#", "");
      threeDimensionalMap0.getTwoDimensionalMap("S:/ry-");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testOutputBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.getTwoDimensionalMap("Dj|~wO&Q");
      Morphology morphology0 = new Morphology();
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Tree tree0 = chineseTreebankParserParams0.transformTree(labeledScoredTreeNode0, labeledScoredTreeNode0);
      labeledScoredTreeNode0.addChild(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recountInside(labeledScoredTreeNode0, options0.genStop, options0.rerankerKBest, identityHashMap0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabelFactory labelFactory0 = TaggedWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("GXSV", (List<Tree>) vector0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, identityHashMap0, identityHashMap0);
      tree0.getSpan();
      labeledScoredTreeFactory0.newLeaf((Label) tree0);
      splittingGrammarExtractor0.saveTrees(vector0, 1337.8551, tree0, 0.0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree0, true, 57, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerExceptionAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.get("[14a#", "");
      threeDimensionalMap0.getTwoDimensionalMap("S:/ry-");
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      CoreLabel coreLabel0 = new CoreLabel();
      CoreLabel coreLabel1 = new CoreLabel(coreLabel0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(coreLabel1);
      coreLabel1.setIsNewline(false);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceReturningFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[9][3];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray1 = new double[2][5][3];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      threeDimensionalMap0.put("", "", "BINARY:", doubleArray1);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      Random.setNextRandom(100);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.put("7ex54N7#$Red!SpGy", (String) null, "7ex54N7#$Red!SpGy", (double[][][]) null);
      threeDimensionalMap0.remove(" !]:]g/Uo", " !]:]g/Uo", " !]:]g/Uo");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove(" !]:]g/Uo", " !]:]g/Uo", " !]:]g/Uo");
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(375);
      assertEquals(375, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesAndRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<CoreLabel, LinkedList<Object>> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory<Object, String> mapFactory1 = MapFactory.arrayMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory1.setMap(hashMap0);
      Map<String, double[]> map1 = mapFactory0.setMap(map0, 96);
      Map<String, double[]> map2 = mapFactory0.setMap(map1, 96);
      MapFactory<String, Map<String, double[][]>> mapFactory2 = MapFactory.weakHashMapFactory();
      Comparator<String> comparator0 = (Comparator<String>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      TrainOptions trainOptions0 = options0.newTrainOptions();
      options0.trainOptions = trainOptions0;
      MapFactory<String, double[][]> mapFactory3 = MapFactory.treeMapFactory(comparator0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory2, mapFactory3);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map2, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      splittingGrammarExtractor0.outputBetas();
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(1401);
      assertEquals(1401, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabelFactory labelFactory0 = TaggedWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, true);
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("GXSV", (List<Tree>) vector0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, identityHashMap0, identityHashMap0);
      tree0.getSpan();
      splittingGrammarExtractor0.saveTrees(vector0, 1337.8551, tree0, 0.0);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      identityHashMap1.clone();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndBuildGrammarsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWord.factory();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.DEBUG();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsAndOutputBetasAndRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<CoreLabel, LinkedList<Object>> mapFactory0 = MapFactory.identityHashMapFactory();
      MapFactory<Object, String> mapFactory1 = MapFactory.arrayMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory1.setMap(hashMap0);
      Map<String, double[]> map1 = mapFactory0.setMap(map0, 96);
      Map<String, double[]> map2 = mapFactory0.setMap(map1, 96);
      MapFactory<String, Map<String, double[][]>> mapFactory2 = MapFactory.weakHashMapFactory();
      Comparator<String> comparator0 = (Comparator<String>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<String, double[][]> mapFactory3 = MapFactory.treeMapFactory(comparator0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory2, mapFactory3);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map2, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceWithNonEmptyList()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("SIZING", (Integer) 100, (Double) 0.0);
      vector0.add(triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      CoreLabel coreLabel0 = new CoreLabel();
      CoreLabel coreLabel1 = new CoreLabel(coreLabel0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(coreLabel1);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceWithEmptyList()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = new CoreLabel();
      WordTag wordTag0 = new WordTag(coreLabel0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode1.deepCopy();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap0, identityHashMap2);
      double[][] doubleArray0 = new double[4][4];
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      splittingGrammarExtractor0.buildStateIndex();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap3, identityHashMap3, identityHashMap0, identityHashMap1);
      assertFalse(identityHashMap0.isEmpty());
      
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndCountOriginalStatesAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.linkedHashMapFactory();
      splittingGrammarExtractor0.state("A_+^\"|hm+!oZyhe", 100);
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Double double0 = new Double(100.0);
      Integer integer0 = new Integer(100);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple(null, integer0, double0);
      Triple<String, Integer, Double> triple1 = new Triple<String, Integer, Double>((String) null, integer0, (Double) 0.0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple0, triple0, triple1, triple1, triple0, triple1);
      splittingGrammarExtractor0.buildMergeCorrespondence(list0);
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Tree> stack0 = new Stack<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) stack0);
      assertEquals(0, stack0.size());
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndExtractTakingCollectionThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = new CoreLabel();
      WordTag wordTag0 = new WordTag(coreLabel0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode1.deepCopy();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap0, identityHashMap2);
      double[][] doubleArray0 = new double[4][4];
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      splittingGrammarExtractor0.buildStateIndex();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap3, identityHashMap3, identityHashMap0, identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabelFactory labelFactory0 = TaggedWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("GXSV", (List<Tree>) vector0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, identityHashMap0, identityHashMap0);
      tree0.getSpan();
      splittingGrammarExtractor0.saveTrees(vector0, 1337.8551, tree0, 0.0);
      splittingGrammarExtractor0.extract((Collection<Tree>) vector0, 0.0, (Collection<Tree>) vector0, (-4887.921334962));
      assertTrue(vector0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndTestConvergenceAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][2];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = (double) 100;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[3];
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (double) 100;
      doubleArray0[1] = doubleArray2;
      twoDimensionalMap0.put("@ \"7", "bootleg", doubleArray0);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[4][0];
      double[][][] doubleArray1 = new double[20][12][2];
      doubleArray1[0] = doubleArray0;
      threeDimensionalMap0.put("%imuPSh}+azfY#{", ".$$.", ".$$.", doubleArray1);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabelFactory labelFactory0 = TaggedWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      MapFactory<Object, SplittingGrammarExtractor> mapFactory0 = MapFactory.arrayMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(null, 100);
      Map<String, double[]> map1 = mapFactory0.setMap(map0, 71);
      mapFactory0.setMap(map1, 99);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("GXSV");
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 99;
      doubleArray0[1] = (double) 71;
      doubleArray0[2] = (double) 99;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 99, identityHashMap0, identityHashMap1, map1, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerExceptionAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = new CoreLabel(100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) coreLabel0, list0);
      List<Tree> list1 = List.of(tree0);
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list1);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[1][5];
      doubleArray1[0] = doubleArray0;
      identityHashMap2.put(tree1, doubleArray1);
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree1, doubleArray0, 34, identityHashMap2, identityHashMap0, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(true);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndOutputBetasAndRescaleTemporaryBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.linkedHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.get("~", "~");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      double[][][] doubleArray0 = new double[1][8][4];
      threeDimensionalMap0.put("i<9XhU,O>NdSG45", "UY4EiEOg", "~", doubleArray0);
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
      assertNotSame(twoDimensionalMap1, twoDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecalculateTemporaryBetasTaking8ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("RrtKh#WA2HUM");
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[8];
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      options0.useSmoothTagProjection = true;
      CategoryWordTagFactory categoryWordTagFactory0 = new CategoryWordTagFactory();
      Label label0 = categoryWordTagFactory0.newLabel("}8v4k#%C6^b", "<T}&Ip3G$X$", "}8v4k#%C6^b");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      treeGraphNode0.firstChild();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) null, false, (IdentityHashMap<Tree, double[][]>) null, (IdentityHashMap<Tree, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 6);
      Class<String> class0 = String.class;
      classArray0[0] = class0;
      Class<String> class1 = String.class;
      classArray0[1] = class1;
      Class<String> class2 = String.class;
      classArray0[2] = class2;
      Class<String> class3 = String.class;
      classArray0[3] = class3;
      Class<String> class4 = String.class;
      classArray0[4] = class4;
      Class<String> class5 = String.class;
      classArray0[5] = class5;
      String[] stringArray0 = new String[3];
      stringArray0[0] = "e6vW}*oTnLppc3$*Sp5";
      stringArray0[1] = "=";
      stringArray0[2] = "]_;=~c";
      CoreLabel coreLabel0 = null;
      try {
        coreLabel0 = new CoreLabel(classArray0, stringArray0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Argument array lengths differ: [class java.lang.String, class java.lang.String, class java.lang.String, class java.lang.String, class java.lang.String, class java.lang.String] vs. [e6vW}*oTnLppc3$*Sp5, =, ]_;=~c]
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndExtractTaking4ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NP (DT t.e)) (VP (VBZ sngs)))");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) tree0, 0.0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = new CoreLabel();
      WordTag wordTag0 = new WordTag(coreLabel0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode1.deepCopy();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "6SugG2%)v`D");
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap0, identityHashMap2);
      double[][] doubleArray0 = new double[4][4];
      identityHashMap0.put(treeGraphNode0, doubleArray0);
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap3, identityHashMap3, identityHashMap0, identityHashMap1);
      assertEquals(Double.NaN, treeGraphNode0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[8][3];
      twoDimensionalMap0.put("<fc", "l$4f83fpsTi", doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
      
      twoDimensionalMap0.put((String) null, "$ ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean1 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean1);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap.hashMap();
      options0.doDep = false;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsWithNullAndOutputTransitionsTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      FileSystemHandling.shouldAllThrowIOExceptions();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) null, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithPositive()  throws Throwable  {
      Options options0 = new Options();
      LabelFactory labelFactory0 = TaggedWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("GXSV", (List<Tree>) vector0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recountOutside(tree0, identityHashMap0, identityHashMap0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      labeledScoredTreeNode0.getSpan();
      Tree tree1 = labeledScoredTreeFactory0.newLeaf("Q,X3j");
      splittingGrammarExtractor0.saveTrees(tree1, 200.0, tree0, 100);
      assertNotSame(tree0, labeledScoredTreeNode0);
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNegativeAndZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabelFactory labelFactory0 = TaggedWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("GXSV", (List<Tree>) vector0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, identityHashMap0, identityHashMap0);
      tree0.getSpan();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      Tree tree1 = treeGraphNode0.deepCopy((TreeFactory) labeledScoredTreeFactory0);
      treeGraphNode0.preOrderNodeList();
      splittingGrammarExtractor0.saveTrees(vector0, 1416.2394580772748, tree1, (-7.0));
      splittingGrammarExtractor0.saveTrees(treeGraphNode0, 100, vector0, 0.0);
      assertEquals("[]", vector0.toString());
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasReturningFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
      
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testExtractTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Tree> stack0 = new Stack<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) stack0, (double) 100, (Collection<Tree>) stack0, (-1311.79466403));
      assertEquals("[]", stack0.toString());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsAndSaveTrees()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabelFactory labelFactory0 = TaggedWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("GXSV", (List<Tree>) vector0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, identityHashMap0, identityHashMap0);
      tree0.getSpan();
      splittingGrammarExtractor0.saveTrees(tree0, 0.0, tree0, (-4275.06));
      assertEquals(Double.NaN, tree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Vector<Tree> vector0 = new Vector<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) vector0, (double) 100, (Collection<Tree>) vector0, 0.0);
      assertEquals("[]", vector0.toString());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree1 = treeGraphNodeFactory0.newTreeNode((Label) tree0, list0);
      labeledScoredTreeFactory0.newLeaf("}j");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree1, (double) 100, (Collection<Tree>) list0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndRecountWeightsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(labeledScoredTreeNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      assertTrue(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testBuildStateIndex()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Tree tree0 = simpleTreeFactory0.newLeaf("The ");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testStateAndGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount("Found ");
      splittingGrammarExtractor0.getStateSplitCount(".$$.");
      splittingGrammarExtractor0.state(".$$.", 0);
      TreeLeafLabelTransformer treeLeafLabelTransformer0 = new TreeLeafLabelTransformer((Function<String, String>) null);
      // Undeclared exception!
      try { 
        treeLeafLabelTransformer0.transformTree((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.trees.TreeLeafLabelTransformer", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      String string0 = splittingGrammarExtractor0.state(".$$.", 1896);
      assertEquals(".$$.", string0);
  }

  @Test(timeout = 4000)
  public void testDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      assertTrue(boolean0);
      
      boolean boolean1 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean1);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideAndRecountOutsideTaking3ArgumentsAndRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabelFactory labelFactory0 = TaggedWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("GXSV", (List<Tree>) vector0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, identityHashMap0, identityHashMap0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap0, identityHashMap1);
      assertNotSame(identityHashMap0, identityHashMap1);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<SplittingGrammarExtractor, Object> mapFactory0 = MapFactory.linkedHashMapFactory();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) null, true, map0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStateThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      Options.LexOptions options_LexOptions0 = new Options.LexOptions();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      hebrewTreebankParserParams0.tlp = treebankLanguagePack0;
      options0.tlpParams = (TreebankLangParserParams) hebrewTreebankParserParams0;
      options0.lexOptions = options_LexOptions0;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.getStateSplitCount((String) null);
      splittingGrammarExtractor0.getStateSplitCount("/u/scr/nlp/deeplearning/datasets/turian/embeddings-scaled.EMBEDDING_SIZE=25.txt");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.state((String) null, (-4099));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount("'9CQqU$;%~il2,<");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testMergeStatesAndMergeStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsNullPointerException()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      Options options0 = new Options(hebrewTreebankParserParams0);
      String[] stringArray0 = new String[3];
      stringArray0[0] = "";
      stringArray0[1] = "G,j6s&O";
      stringArray0[2] = "";
      options0.setOptionsOrWarn(stringArray0, 0, (-2366));
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      options0.doDep = true;
      Function<String, String> function0 = options0.wordFunction;
      options0.wordFunction = null;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.op = options0;
      splittingGrammarExtractor0.countOriginalStates();
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.weakHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, (MapFactory<String, double[][]>) null);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecurseOutside1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recurseOutside(labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testStateAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = splittingGrammarExtractor0.state("", 0);
      assertEquals("^0", string0);
  }

  @Test(timeout = 4000)
  public void testState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = splittingGrammarExtractor0.state("", 100);
      assertEquals("^100", string0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsTooManyResourcesException()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions((Tree) null, 2146244686, identityHashMap1, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithNull()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = null;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) null, 100, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<Object, SplittingGrammarExtractor> mapFactory0 = MapFactory.arrayMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(null, 100);
      Map<String, double[]> map1 = mapFactory0.setMap(map0, 100);
      Map<String, double[]> map2 = mapFactory0.setMap(map1, 3780);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) null, doubleArray0, 100, identityHashMap0, identityHashMap1, map2, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabelFactory labelFactory0 = StringLabel.factory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      CoreLabel coreLabel0 = new CoreLabel();
      ArabicTreebankParserParams arabicTreebankParserParams0 = null;
      try {
        arabicTreebankParserParams0 = new ArabicTreebankParserParams();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.trees.tregex.TregexParser
         //
         verifyException("edu.stanford.nlp.trees.tregex.TregexPatternCompiler", e);
      }
  }
}
