/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Jun 11 21:16:25 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ling.CategoryWordTagFactory;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.StringLabel;
import edu.stanford.nlp.ling.Tag;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordLemmaTagFactory;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HebrewTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HungarianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ItalianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.NegraPennTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.SpanishUnknownWordModelTrainer;
import edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor;
import edu.stanford.nlp.parser.lexparser.TreebankLangParserParams;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.sentiment.CollapseUnaryTransformer;
import edu.stanford.nlp.trees.BasicCategoryTreeTransformer;
import edu.stanford.nlp.trees.CompositeTreeTransformer;
import edu.stanford.nlp.trees.Constituent;
import edu.stanford.nlp.trees.CoordinationTransformer;
import edu.stanford.nlp.trees.HeadFinder;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.MemoryTreebank;
import edu.stanford.nlp.trees.ModCollinsHeadFinder;
import edu.stanford.nlp.trees.PennTreebankLanguagePack;
import edu.stanford.nlp.trees.SimpleConstituentFactory;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeGraphNodeFactory;
import edu.stanford.nlp.trees.TreeTransformer;
import edu.stanford.nlp.trees.TreebankLanguagePack;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.ThreeDimensionalMap;
import edu.stanford.nlp.util.Triple;
import edu.stanford.nlp.util.TwoDimensionalMap;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.io.StringReader;
import java.nio.file.LinkOption;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Stack;
import java.util.Vector;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.EvoSuiteURL;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.testdata.NetworkHandling;
import org.evosuite.runtime.util.SystemInUtil;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class SplittingGrammarExtractor_4_ESTest extends SplittingGrammarExtractor_4_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeException0()  throws Throwable  {
      Options options0 = new Options();
      Word word0 = new Word("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = (-2);
      treeGraphNode1.insertDtr(treeGraphNode0, (-2));
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      Function<double[][], double[][]> function0 = Function.identity();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(function0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap2, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory.hashMapFactory();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      HashMap<String, int[]> hashMap1 = new HashMap<String, int[]>();
      String string0 = "rub";
      int[] intArray0 = new int[3];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1, (double) (-2), (Collection<Tree>) list0, (-1853.2));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeException1()  throws Throwable  {
      Options options0 = new Options();
      String string0 = "    ";
      Word word0 = new Word("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode1.insertDtr(treeGraphNode0, (-2));
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      Function<double[][], double[][]> function0 = Function.identity();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(function0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap2, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory.hashMapFactory();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      HashMap<String, int[]> hashMap1 = new HashMap<String, int[]>();
      int[] intArray0 = new int[3];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1, (double) (-2), (Collection<Tree>) list0, (-1853.2));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = new Word("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      splittingGrammarExtractor0.getStateSplitCount("..");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.remove("*I[", "..", "0F@5=xx}.`Q9}S<,e\"]R");
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>(100);
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      double[] doubleArray0 = new double[1];
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertArrayEquals(new double[] {0.0}, doubleArray0, 0.01);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndExtractTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 0;
      intArray0[1] = 0;
      hashMap0.put("X", intArray0);
      int[] intArray1 = new int[2];
      intArray1[0] = 0;
      intArray1[1] = 0;
      hashMap0.put("Y", intArray1);
      double[] doubleArray1 = new double[2];
      Math.log(0.6);
      doubleArray1[0] = (-0.5108256237659907);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (-3367.3297819), (Collection<Tree>) tree0, 2533.3);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndExtractTaking4ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Math.log(0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (double) 0, (Collection<Tree>) tree0, 0.1425471870622202);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndOutputTransitionsTaking4ArgumentsThrowsTooManyResourcesException()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("v>`Qgwo8\"=_sz", "v>`Qgwo8\"=_sz");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      Vector<Tree> vector0 = new Vector<Tree>(100, 100);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("v>`Qgwo8\"=_sz", 100);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.insertDtr(treeGraphNode1, (-2339));
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      double[][] doubleArray0 = new double[2][8];
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = (-742.12);
      doubleArray1[4] = (double) 100;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[7];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = 0.0;
      doubleArray2[2] = (-742.12);
      doubleArray2[3] = (double) 100;
      doubleArray2[4] = 1324.70211235762;
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = (double) (-2339);
      doubleArray0[1] = doubleArray2;
      identityHashMap2.put(treeGraphNode0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, identityHashMap2, identityHashMap1);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsTooManyResourcesException()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("v>`Qgwo8\"=_sz", "v>`Qgwo8\"=_sz");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      Vector<Tree> vector0 = new Vector<Tree>(100, 100);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("v>`Qgwo8\"=_sz", 100);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.insertDtr(treeGraphNode1, (-2339));
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[][] doubleArray0 = new double[2][8];
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) (-2339);
      doubleArray1[2] = (double) (-2339);
      doubleArray1[3] = (-2339.0);
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[7];
      doubleArray2[0] = 0.0;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = (double) 100;
      doubleArray2[4] = 1324.70211235762;
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = (double) (-2339);
      doubleArray0[1] = doubleArray2;
      identityHashMap1.put(treeGraphNode0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, identityHashMap1, identityHashMap0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndState()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("v>`Qgwo8\"=_sz", "v>`Qgwo8\"=_sz");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      Vector<Tree> vector0 = new Vector<Tree>(100, 100);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("v>`Qgwo8\"=_sz", 100);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode0.insertDtr(treeGraphNode1, (-2339));
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      Word word0 = new Word("    ", 100, 100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode1.insertDtr(treeGraphNode0, (-2));
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Function<double[][], double[][]> function0 = Function.identity();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(function0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap2, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory.hashMapFactory();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap3 = new TwoDimensionalMap<String, String, double[][]>();
      double[][][] doubleArray0 = new double[2][4][8];
      double[][] doubleArray1 = new double[9][2];
      double[] doubleArray2 = new double[8];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = 0.0;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      doubleArray2[4] = (double) 100;
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = (double) (-2);
      doubleArray2[7] = 0.0;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[4];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = 0.0;
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[9];
      doubleArray4[0] = (double) (-2);
      doubleArray4[1] = (double) (-2);
      doubleArray4[2] = 0.0;
      doubleArray4[3] = (double) (-2);
      doubleArray4[4] = 0.0;
      doubleArray4[5] = (double) (-2);
      doubleArray4[6] = (double) 100;
      doubleArray4[7] = 2411.8860741357717;
      doubleArray4[8] = (double) 100;
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[0];
      doubleArray1[3] = doubleArray5;
      double[] doubleArray6 = new double[0];
      doubleArray1[4] = doubleArray6;
      double[] doubleArray7 = new double[8];
      doubleArray7[0] = (double) 100;
      doubleArray7[1] = (double) (-2);
      doubleArray7[2] = 0.0;
      doubleArray7[3] = (double) 100;
      doubleArray7[4] = 2411.8860741357717;
      doubleArray7[5] = 2411.8860741357717;
      doubleArray7[6] = (double) (-2);
      doubleArray7[7] = (double) (-2);
      doubleArray1[5] = doubleArray7;
      double[] doubleArray8 = new double[9];
      doubleArray8[0] = 2411.8860741357717;
      doubleArray8[1] = (-1193.0);
      doubleArray8[2] = (double) (-2);
      doubleArray8[3] = 2411.8860741357717;
      doubleArray8[4] = 0.0;
      doubleArray8[5] = (double) 100;
      doubleArray8[6] = (double) (-2);
      doubleArray8[7] = 0.0;
      doubleArray8[8] = 2411.8860741357717;
      doubleArray1[6] = doubleArray8;
      double[] doubleArray9 = new double[0];
      doubleArray1[7] = doubleArray9;
      double[] doubleArray10 = new double[8];
      doubleArray10[0] = (double) 100;
      doubleArray10[1] = 3243.59737295;
      doubleArray10[2] = 0.0;
      doubleArray10[3] = (-1193.0);
      doubleArray10[4] = 2411.8860741357717;
      doubleArray10[5] = (-1193.0);
      doubleArray10[6] = (double) (-2);
      doubleArray10[7] = (double) 100;
      doubleArray1[8] = doubleArray10;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray11 = new double[0][1];
      doubleArray0[1] = doubleArray11;
      identityHashMap1.put(treeGraphNode1, doubleArray0);
      double[] doubleArray12 = new double[1];
      doubleArray12[0] = (double) (-2);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray12, (-2), identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      Word word0 = new Word("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = (-2);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      treeGraphNode0.toPrettyString((-2));
      treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.insertDtr(treeGraphNode0, (-2));
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recurseOutside(treeGraphNode1, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testDEBUGAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<String> stack0 = new Stack<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) stack0;
      double[][] doubleArray0 = new double[2][0];
      stack0.add("0:tO&");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.put("0:tO&", "0:tO&", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("v>`Qgwo8\"=_sz", "v>`Qgwo8\"=_sz");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      treeGraphNode0.subTreeList();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("v>`Qgwo8\"=_sz", 100);
      Tree tree0 = treeGraphNode0.skipRoot();
      tree0.yieldHasWord();
      treeGraphNode0.insertDtr(tree0, (-2339));
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[1];
      threeDimensionalMap0.thirdKeySet();
      int int0 = 2363;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[3][3];
      identityHashMap2.put(tree0, doubleArray1);
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testState0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String[] stringArray0 = new String[2];
      stringArray0[0] = "ROOT";
      stringArray0[1] = "S";
      Arrays.asList(stringArray0);
      String string0 = splittingGrammarExtractor0.state("ROOT", 2);
      assertEquals("ROOT", string0);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(A (B b) (C c))");
      Label label0 = tree0.label();
      label0.setValue("A");
      double[][][] doubleArray0 = new double[1][1][1];
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = 0.0;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = 0.0;
      identityHashMap1.put(tree0, doubleArray3);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 0;
      hashMap0.put("X", intArray0);
      hashMap0.put("Y", intArray0);
      double[] doubleArray1 = new double[2];
      Math.log(0.6);
      doubleArray1[0] = (-0.5108256237659907);
      Math.log(0.4);
      doubleArray1[1] = (-0.916290731874155);
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap2, doubleArray1, hashMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitionsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      Map<String, int[]> map0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 0;
      intArray0[1] = 0;
      map0.put("X", intArray0);
      int[] intArray1 = new int[2];
      intArray1[0] = 0;
      intArray1[1] = 0;
      map0.put("Y", intArray1);
      double[] doubleArray1 = new double[2];
      Math.log(0.6);
      doubleArray1[0] = (-0.5108256237659907);
      Math.log(0.4);
      doubleArray1[1] = (-0.916290731874155);
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3, doubleArray1, map0);
      boolean boolean0 = identityHashMap2.containsKey(tree0);
      assertFalse(identityHashMap2.isEmpty());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      Word word0 = new Word("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode1.insertDtr(treeGraphNode0, (-2));
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Function<double[][], double[][]> function0 = Function.identity();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(function0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap2, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory.hashMapFactory();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap3 = new TwoDimensionalMap<String, String, double[][]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) (-2);
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, Integer.MAX_VALUE, identityHashMap0, identityHashMap3, (Map<String, double[]>) hashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      Word word0 = new Word("    ", 100, 100);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode1.insertDtr(treeGraphNode0, (-2));
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Function<double[][], double[][]> function0 = Function.identity();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(function0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap2, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory.hashMapFactory();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap3 = new TwoDimensionalMap<String, String, double[][]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) (-2);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, (-2), identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndState()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("5v>`Qgwo8\"=_sz", "5v>`Qgwo8\"=_sz");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      treeGraphNode0.subTreeList();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("5v>`Qgwo8\"=_sz", 100);
      Tree tree0 = treeGraphNode0.skipRoot();
      treeGraphNode0.insertDtr(tree0, (-2339));
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[3][3];
      identityHashMap2.put(tree0, doubleArray1);
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      MapFactory<String, Object> mapFactory0 = MapFactory.identityHashMapFactory();
      Map<String, int[]> map0 = mapFactory0.setMap(null, 763);
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray2 = new double[5];
      doubleArray2[0] = 0.0;
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, (String) null);
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = (double) 2363;
      doubleArray2[4] = (double) (-2339);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode0, identityHashMap2, identityHashMap1, identityHashMap2, identityHashMap4, doubleArray2, map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("5v>`Qgwo8\"=_sz", "5v>`Qgwo8\"=_sz");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      treeGraphNode0.subTreeList();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode0.toPrettyString(100);
      Tree tree0 = treeGraphNode0.skipRoot();
      treeGraphNode0.insertDtr(tree0, (-2339));
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      Function.identity();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      MapFactory<Triple<Object, CoreLabel, String>, Object> mapFactory0 = MapFactory.weakHashMapFactory();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      Map<String, int[]> map0 = mapFactory0.setMap(hashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, doubleArray0, map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = new Word("    ");
      Word word1 = new Word("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word1);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(word1, list1);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountInside(treeGraphNode2, true, 100, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsTooManyResourcesException0()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("v>`Qgwo8\"=_sz", "v>`Qgwo8\"=_sz");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      Vector<Tree> vector0 = new Vector<Tree>(100, 100);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("v>`Qgwo8\"=_sz", 100);
      Tree tree0 = treeGraphNode0.skipRoot();
      treeGraphNode0.insertDtr(tree0, (-2339));
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[8];
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[3][3];
      identityHashMap1.put(tree0, doubleArray1);
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      // Undeclared exception!
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 2363, identityHashMap1, identityHashMap0, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsTooManyResourcesException1()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("5v>`Qgwo8\"=_sz", "5v>`Qgwo8\"=_sz");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      treeGraphNode0.subTreeList();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode0.toPrettyString(100);
      Tree tree0 = treeGraphNode0.skipRoot();
      treeGraphNode0.insertDtr(tree0, (-2339));
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[3][3];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      identityHashMap2.put(treeGraphNode0, doubleArray1);
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      // Undeclared exception!
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 2385, identityHashMap2, identityHashMap1, (Map<String, double[]>) identityHashMap3, twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("5v>`Qgwo8\"=_sz", "5v>`Qgwo8\"=_sz");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      treeGraphNode0.subTreeList();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode0.toPrettyString(100);
      Tree tree0 = treeGraphNode0.skipRoot();
      treeGraphNode0.insertDtr(tree0, (-2339));
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray1 = new double[3][3];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      identityHashMap2.put(treeGraphNode0, doubleArray1);
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 2385, identityHashMap2, identityHashMap1, (Map<String, double[]>) identityHashMap3, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      Word word0 = new Word("  +  ");
      TaggedWord taggedWord0 = new TaggedWord();
      Morphology morphology0 = new Morphology();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[2][7][1];
      double[][] doubleArray1 = new double[2][5];
      double[] doubleArray2 = new double[4];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = 0.0;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = (double) 100;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[4];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = (double) 100;
      doubleArray3[3] = (double) 100;
      doubleArray1[1] = doubleArray3;
      doubleArray0[0] = doubleArray1;
      doubleArray0[1] = doubleArray1;
      threeDimensionalMap0.put("emit", "  +  ", "emit", doubleArray0);
      TwoDimensionalMap<String, String, double[][][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      Integer integer0 = new Integer(1061);
      Double double0 = new Double((-1.6094379124341005));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("emit", integer0, double0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple0, triple0, triple0, triple0, triple0, triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(list0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][2];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray1 = new double[1][2][1];
      doubleArray1[0] = doubleArray0;
      threeDimensionalMap0.put("0:tO&", "printClassifierParam", "2@@u", doubleArray1);
      TwoDimensionalMap<String, String, double[][][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap2, threeDimensionalMap0);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      Random.setNextRandom(100);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNull()  throws Throwable  {
      Options options0 = new Options();
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "^");
      Word word0 = new Word("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode1.insertDtr(treeGraphNode0, (-2));
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      Function<double[][], double[][]> function0 = Function.identity();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(function0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap2, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) (-2);
      MapFactory<String, Object> mapFactory0 = MapFactory.hashMapFactory();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      Map<String, int[]> map0 = mapFactory0.setMap(identityHashMap2, 100);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode1, identityHashMap0, identityHashMap1, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      Word word0 = new Word("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode1.insertDtr(treeGraphNode0, (-2));
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      Function<double[][], double[][]> function0 = Function.identity();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(function0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap2, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory.hashMapFactory();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      HashMap<String, int[]> hashMap1 = new HashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode1, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, (double[]) null, hashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("5v>`Qgwo8\"=_sz", "5v>`Qgwo8\"=_sz");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      treeGraphNode0.subTreeList();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode0.toPrettyString(100);
      Tree tree0 = treeGraphNode0.skipRoot();
      treeGraphNode0.insertDtr(tree0, (-2339));
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      MapFactory.hashMapFactory();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(treeGraphNode0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap2, (IdentityHashMap<Tree, double[][]>) null, identityHashMap2, (double[]) null, hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[6][7];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = 0.0;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[4];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = (double) 100;
      doubleArray0[1] = doubleArray2;
      twoDimensionalMap0.put((String) null, "bu$U", doubleArray0);
      Options options1 = new Options();
      twoDimensionalMap0.put("Converged for cycle ");
      options1.langpack();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options2 = new Options();
      String[] stringArray0 = new String[1];
      stringArray0[0] = null;
      options2.setOptions(stringArray0, 100, 2);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWord taggedWord0 = new TaggedWord();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.getTwoDimensionalMap("O!JE^");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[4][2];
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, (String) null);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      twoDimensionalMap0.put(":tO&", "    ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.testMemoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0, memoryTreebank0);
      WordLemmaTagFactory wordLemmaTagFactory0 = new WordLemmaTagFactory('O');
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordLemmaTagFactory0);
      Tree tree0 = treeGraphNode0.deepCopy((TreeFactory) labeledScoredTreeFactory0, (LabelFactory) wordLemmaTagFactory0);
      MapFactory<double[], Object> mapFactory0 = MapFactory.weakHashMapFactory();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      Map<Tree, double[]> map0 = mapFactory0.setMap(identityHashMap1);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>(map0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree0, false, 100, identityHashMap2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException3()  throws Throwable  {
      TaggedWord taggedWord0 = new TaggedWord("ESS1=y.sG0G85ul$", "ESS1=y.sG0G85ul$");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      treeGraphNode0.subTreeList();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode0.insertDtr(treeGraphNode0, (-2));
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) (-2);
      doubleArray0[1] = (double) (-2);
      doubleArray0[2] = (double) (-2);
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) (-2);
      doubleArray0[5] = 3378.3417509310198;
      doubleArray0[6] = (double) (-2);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap1.put(treeGraphNode0, (double[][][]) null);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, (-2), identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInsideThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "^");
      Word word0 = new Word("    ");
      TaggedWord taggedWord0 = new TaggedWord("    ", "    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode1.toPrettyString(100);
      treeGraphNode1.insertDtr(treeGraphNode0, (-2));
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(treeGraphNode1, true, 100, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideWithNegative()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("0F@5xx}9}S<,e\"]R");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode1.insertDtr(treeGraphNode0, (-1));
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(treeGraphNode1, true, (-1), identityHashMap2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndDEBUG()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      WordTag wordTag0 = new WordTag((String) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][0];
      double[] doubleArray1 = new double[7];
      doubleArray1[0] = 5.0;
      doubleArray1[1] = 5.0;
      doubleArray1[2] = (double) 0;
      doubleArray1[3] = (double) 100;
      twoDimensionalMap0.put((String) null, "O!YJE^", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray2 = new double[8][0][8];
      doubleArray2[0] = doubleArray0;
      doubleArray2[2] = null;
      doubleArray2[3] = doubleArray0;
      doubleArray2[4] = doubleArray0;
      doubleArray2[5] = doubleArray0;
      doubleArray2[7] = null;
      threeDimensionalMap0.put((String) null, (String) null, "O!YJE^", doubleArray2);
      TwoDimensionalMap<String, String, double[][][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap2, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      boolean boolean1 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap2, threeDimensionalMap0);
      assertFalse(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[0][5][9];
      threeDimensionalMap0.put((String) null, (String) null, " -> ", doubleArray0);
      TwoDimensionalMap<String, String, double[][][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      options0.newTrainOptions();
      TaggedWord taggedWord0 = new TaggedWord("   5");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[10][7][4];
      doubleArray0[2] = doubleArray0[4];
      threeDimensionalMap0.put("@conj <: /^c[cs]/=c", "@conj <: /^c[cs]/=c", "   5", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testDEBUGAndRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
      
      Stack<String> stack0 = new Stack<String>();
      splittingGrammarExtractor0.startSymbols = (List<String>) stack0;
      double[][] doubleArray0 = new double[2][0];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray1 = new double[7][0][8];
      doubleArray1[0] = doubleArray0;
      threeDimensionalMap0.put("\"w)a", "\"w)a", "\"w)a", doubleArray1);
      boolean boolean1 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndExtractTakingCollectionAndOutputBetas()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.treebank();
      italianTreebankParserParams0.treeReaderFactory();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Double double0 = new Double(100);
      Double double1 = new Double(0.0);
      HashMap<Tree, Integer> hashMap0 = new HashMap<Tree, Integer>();
      italianTreebankParserParams0.treeTokenizerFactory();
      HashIndex<Tree> hashIndex0 = new HashIndex<Tree>(100);
      splittingGrammarExtractor0.extract((Collection<Tree>) hashIndex0);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.buildGrammars();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWord taggedWord0 = new TaggedWord();
      Morphology morphology0 = new Morphology();
      Word word0 = new Word("<featureFactory>");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.getTwoDimensionalMap("<featureFactory>");
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      MapFactory<String, CoreLabel> mapFactory0 = MapFactory.arrayMapFactory();
      mapFactory0.setMap(hashMap0);
      MapFactory.hashMapFactory();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      UnaryOperator.identity();
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 2468.0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) 100;
      hashMap0.put("<featureFactory>", doubleArray0);
      Options options1 = new Options(options0.tlpParams);
      Options options2 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options2);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>(100);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray1 = new double[9];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = (-5.395239384953E-6);
      doubleArray1[4] = (double) 100;
      doubleArray1[5] = (double) 100;
      doubleArray1[6] = 0.45;
      doubleArray1[7] = (double) 100;
      doubleArray1[8] = (double) 100;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray1, 97, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndDEBUG0()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      WordTag wordTag0 = new WordTag((String) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, (String) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][0];
      double[] doubleArray1 = new double[7];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 5.0;
      doubleArray1[2] = (double) 0;
      doubleArray1[3] = (double) 100;
      twoDimensionalMap0.put((String) null, "O!YJE^", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray2 = new double[8][0][8];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = null;
      doubleArray2[2] = null;
      doubleArray2[3] = doubleArray0;
      doubleArray2[4] = null;
      doubleArray2[5] = doubleArray0;
      doubleArray2[6] = doubleArray0;
      doubleArray2[7] = null;
      threeDimensionalMap0.put((String) null, (String) null, "O!YJE^", doubleArray2);
      threeDimensionalMap0.get((String) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<String> stack0 = new Stack<String>();
      double[][] doubleArray0 = new double[2][0];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray1 = new double[3][0][8];
      doubleArray1[0] = doubleArray0;
      threeDimensionalMap0.put((String) null, " (emove -coord1)\n", " (emove -coord1)\n", doubleArray1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = new Word("    ");
      TaggedWord taggedWord0 = new TaggedWord();
      Morphology morphology0 = new Morphology();
      Word word1 = morphology0.stem(word0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.getTwoDimensionalMap("O!YJE^");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      treeGraphNode0.toPrettyString((-1790));
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      MapFactory.hashMapFactory();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap1, threeDimensionalMap1);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor2.recountInside(treeGraphNode1, false, (-1790), identityHashMap3);
      splittingGrammarExtractor2.recalculateTemporaryBetas((Tree) treeGraphNode1, true, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.extract((Collection<Tree>) treeGraphNode1, 2932.1316, (Collection<Tree>) list0, 1.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      Word word0 = new Word("    ");
      TaggedWord taggedWord0 = new TaggedWord();
      Morphology morphology0 = new Morphology();
      Word word1 = morphology0.stem(word0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode1.toPrettyString(100);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      MapFactory.hashMapFactory();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      double double0 = (-202.9116318308382);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(treeGraphNode1, true, 100, identityHashMap3);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, false, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsAndBuildMergeCorrespondenceAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      Word word0 = new Word("    ");
      TaggedWord taggedWord0 = new TaggedWord();
      Morphology morphology0 = new Morphology();
      Word word1 = morphology0.stem(word0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountTree((Tree) treeGraphNode1, true, identityHashMap1, identityHashMap1, identityHashMap0, identityHashMap2);
      assertEquals(0, identityHashMap2.size());
      assertTrue(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][2];
      twoDimensionalMap0.put("0:tO&", "    ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = new Word("    ");
      TaggedWord taggedWord0 = new TaggedWord();
      Morphology morphology0 = new Morphology();
      Word word1 = morphology0.stem(word0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap1, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStateAndMergeStatesAndState()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      double[][] doubleArray0 = new double[6][7];
      options0.baseParserWeight = (double) 100;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.mergeStates();
      String string0 = splittingGrammarExtractor0.state(".$$.", 2282);
      assertEquals(".$$.", string0);
  }

  @Test(timeout = 4000)
  public void testState1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Vector<String> vector0 = new Vector<String>();
      String string0 = splittingGrammarExtractor0.state(".$$.", 2150);
      assertEquals(".$$.", string0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException4()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = new Word("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      hashMap0.put("    ", doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>(100);
      double[] doubleArray1 = new double[1];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray1, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithZero()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null);
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      MapFactory<String, CoreLabel> mapFactory0 = MapFactory.arrayMapFactory();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap1);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[0];
      MapFactory<String, Triple<LinkOption, String, Object>> mapFactory1 = MapFactory.weakHashMapFactory();
      Map<String, double[]> map1 = mapFactory1.setMap(map0, 100);
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, map1, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(1, int0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null);
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor2.splitBetas();
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor3.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      hungarianTreebankParserParams0.transformTree(treeGraphNode1, treeGraphNode1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor3.recountInside(treeGraphNode1, true, 3, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningPositive()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null);
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor2.splitBetas();
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor3.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      Tree tree0 = hungarianTreebankParserParams0.transformTree(treeGraphNode1, treeGraphNode1);
      splittingGrammarExtractor1.recountInside(tree0, false, 3, identityHashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recountInside(treeGraphNode1, true, (-266), (IdentityHashMap<Tree, double[]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndRecurseOutside()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null, 142, 0);
      TaggedWord taggedWord0 = new TaggedWord((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      ModCollinsHeadFinder modCollinsHeadFinder0 = new ModCollinsHeadFinder();
      word0.labelFactory();
      Tree tree0 = treeGraphNode1.headPreTerminal(modCollinsHeadFinder0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.recurseOutside(treeGraphNode1, identityHashMap1, identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap2, (Map<String, double[]>) identityHashMap2, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[6][7];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = 0.0;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[4];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = (double) 100;
      doubleArray0[1] = doubleArray2;
      twoDimensionalMap0.put((String) null, "bu$U", doubleArray0);
      twoDimensionalMap0.get("-X?v{ F3+qY|`-E5", "s2: ");
      threeDimensionalMap0.getTwoDimensionalMap("O!YJE^");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      twoDimensionalMap1.put((String) null, "-X?v{ F3+qY|`-E5", (double[][]) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][2];
      twoDimensionalMap0.put("    ", "    ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithNegative()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = new Word("x*jABMp{`!6R7>pc", 142, 100);
      TaggedWord taggedWord0 = new TaggedWord("x*jABMp{`!6R7>pc");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      HeadFinder headFinder0 = englishTreebankParserParams0.headFinder();
      Tree tree0 = treeGraphNode1.headPreTerminal(headFinder0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, (-2736), identityHashMap0, identityHashMap2);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<Object, String> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap3, (-2736));
      splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, false, map0, twoDimensionalMap1, threeDimensionalMap0);
      assertNotSame(twoDimensionalMap0, twoDimensionalMap1);
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsAndRecountTreeTaking6ArgumentsThrowsRuntimeException()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = new Word("~]@ux<>2$z2$F#", 93, 142);
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "~]@ux<>2$z2$F#");
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "bat");
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      Tree tree0 = treeGraphNode1.localTree();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor2.binaryBetas;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) treeGraphNode0, true, identityHashMap0, identityHashMap0, (IdentityHashMap<Tree, double[][]>) null, (IdentityHashMap<Tree, double[][][]>) null);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndOutputTransitionsTaking4ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      Word word0 = new Word("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode1.toPrettyString(100);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, identityHashMap1, identityHashMap0);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsAndCountMergeEffectsTaking3Arguments()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null, 142, 0);
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      assertNotSame(threeDimensionalMap1, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3Arguments()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null, 142, 0);
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      assertSame(threeDimensionalMap1, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[6][7];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = 0.0;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[4];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = (double) 100;
      doubleArray0[1] = doubleArray2;
      twoDimensionalMap0.put((String) null, "bu$U", doubleArray0);
      Options options1 = new Options();
      options1.langpack();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options2 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testRecountInsideWithFalse()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("0F@5=xx}.`Q9}S<,e\"]R");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(taggedWord0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode1, false, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInsideWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("0F@5=xx}9}S<,e\"]R");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode1, true, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word("Am<sb0OT", 1004, 1004);
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(taggedWord0, list0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      HeadFinder headFinder0 = englishTreebankParserParams0.headFinder();
      Tree tree0 = treeGraphNode1.headPreTerminal(headFinder0);
      simpleConstituentFactory0.newConstituent(1004, (-2385), (Label) tree0, (double) 142);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(tree0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      TreeGraphNode treeGraphNode3 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode3.indexSpans();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(75);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor3.recountWeights(treeGraphNode1, identityHashMap4, identityHashMap4, identityHashMap2, identityHashMap3);
      splittingGrammarExtractor0.recountTree((Tree) treeGraphNode3, false, identityHashMap2, identityHashMap0);
      System.setCurrentTimeMillis(1004);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      Word word0 = new Word("    ");
      Morphology morphology0 = new Morphology();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      word0.toString();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null, 142, 0);
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Index<String> index0 = spanishUnknownWordModelTrainer0.wordIndex;
      splittingGrammarExtractor0.wordIndex = null;
      MapFactory<double[][][], double[][][]> mapFactory0 = MapFactory.hashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map0, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1, 0.0, (Collection<Tree>) treeGraphNode0, 789.542665863299);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndRecountWeightsAndRescaleTemporaryBetas()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null, 142, 0);
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      HeadFinder headFinder0 = englishTreebankParserParams0.headFinder();
      Tree tree0 = treeGraphNode1.headPreTerminal(headFinder0);
      simpleConstituentFactory0.newConstituent(142, 0, (Label) tree0, 0.45);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      treeGraphNode0.indexSpans();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(142);
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = 5.0;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.recountWeights(treeGraphNode1, identityHashMap4, identityHashMap4, identityHashMap2, identityHashMap3);
      assertNotSame(treeGraphNode1, treeGraphNode2);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithPositive0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = new Word("    ");
      TaggedWord taggedWord0 = new TaggedWord();
      Morphology morphology0 = new Morphology();
      Word word1 = morphology0.stem(word0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word1);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      MapFactory.hashMapFactory();
      splittingGrammarExtractor1.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) treeGraphNode1, (-202.9116318308382), (Collection<Tree>) treeGraphNode0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNonEmptyMap()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null);
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      Options options1 = new Options();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) hashMap0, (Map<String, double[]>) identityHashMap2, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndNull()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null, 142, 0);
      TaggedWord taggedWord0 = new TaggedWord((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      treeGraphNode1.indexSpans();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory.arrayMapFactory();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, (double[]) null, 7, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException5()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null, 142, 0);
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      HeadFinder headFinder0 = englishTreebankParserParams0.headFinder();
      Tree tree0 = treeGraphNode1.headPreTerminal(headFinder0);
      simpleConstituentFactory0.newConstituent(142, 0, (Label) tree0, 0.45);
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(treeGraphNode0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      treeGraphNode0.indexSpans();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(142);
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = 5.0;
      doubleArray0[1] = 5.0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.45;
      MapFactory<String, CoreLabel> mapFactory0 = MapFactory.arrayMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, doubleArray0, 3, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, map0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithPositive1()  throws Throwable  {
      Options options0 = new Options();
      Word word0 = new Word("    ");
      Morphology morphology0 = new Morphology();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.hashMapFactory();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1, (double) 100, (Collection<Tree>) list0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5Arguments()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode1, false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(1, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitionsWithNullAndMergeTransitionsWithNull()  throws Throwable  {
      Options options0 = new Options();
      TaggedWord taggedWord0 = new TaggedWord("0F@5=xx}.`Q9}S<,e\"]R");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeTransitions(treeGraphNode1, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (double[]) null, hashMap0);
      assertNotSame(treeGraphNode0, treeGraphNode1);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndRecurseOutside()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.keySet();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap4, identityHashMap4, identityHashMap2, identityHashMap0);
      splittingGrammarExtractor0.recurseOutside(simpleTree0, identityHashMap4, identityHashMap4);
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndUseNewBetasWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[7][7];
      double[] doubleArray1 = new double[7];
      doubleArray1[3] = (double) 100;
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.splitBetas();
      assertNotSame(splittingGrammarExtractor1, splittingGrammarExtractor0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[4][7];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = 0.0;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[4];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = (double) 100;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[4];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = 0.0;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[9];
      doubleArray4[0] = (double) 100;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = 0.0;
      doubleArray4[3] = (double) 100;
      doubleArray4[4] = 0.0;
      doubleArray4[5] = (double) 100;
      doubleArray4[6] = 0.0;
      doubleArray4[7] = 0.0;
      doubleArray4[8] = 0.0;
      doubleArray0[3] = doubleArray4;
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      twoDimensionalMap0.get("s2: ", "s2: ");
      threeDimensionalMap0.getTwoDimensionalMap("s2: ");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = splittingGrammarExtractor0.binaryBetas;
      assertNotSame(threeDimensionalMap2, threeDimensionalMap1);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(",f`yka|\"Uo2V `b");
      Constituent constituent0 = simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(constituent0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      treeGraphNode0.indexSpans();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      StringLabel stringLabel0 = new StringLabel(constituent0);
      LabelFactory labelFactory0 = stringLabel0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      labeledScoredTreeFactory0.newLeaf("unban");
      Stack<Tree> stack0 = new Stack<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) stack0, (double) (-769), (Collection<Tree>) stack0, (double) 100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      assertTrue(twoDimensionalMap1.equals((Object)twoDimensionalMap0));
  }

  @Test(timeout = 4000)
  public void testTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[9][7];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = (double) 100;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[4];
      doubleArray2[3] = (double) 100;
      doubleArray0[1] = doubleArray1;
      threeDimensionalMap0.getTwoDimensionalMap("O!YJE^");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.put((String) null, "s2: ", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerExceptionAndMergeStates()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.put("/pj%F\"T?'", "gyV/1;&", (double[][]) null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.unaryBetas = twoDimensionalMap0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap2, threeDimensionalMap1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStatesAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[6][7];
      twoDimensionalMap0.put("#M4BXxAyGK3RD]", "#M4BXxAyGK3RD]", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testOutputBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.get("s2: ", "s2: ");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndUseNewBetasWithFalse()  throws Throwable  {
      Options options0 = new Options();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.get("dzdXfVu`f[_dE?V", "dzdXfVu`f[_dE?V");
      threeDimensionalMap0.getTwoDimensionalMap("dzdXfVu`f[_dE?V");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      Options options1 = new Options(options0.tlpParams);
      assertFalse(options1.equals((Object)options0));
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndSplitBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.get("", "");
      threeDimensionalMap0.getTwoDimensionalMap("\u00BE");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      StringReader stringReader0 = new StringReader("");
      Morphology morphology0 = new Morphology(stringReader0, 100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = twoDimensionalMap1.transform(morphology0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap2, threeDimensionalMap0);
      Options options1 = new Options();
      TreebankLanguagePack treebankLanguagePack0 = options1.langpack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap1);
      Options options2 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options2);
      splittingGrammarExtractor1.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNull()  throws Throwable  {
      Options options0 = new Options();
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(",fyka|\"Uo2V `b");
      Constituent constituent0 = simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(constituent0);
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      options0.tlpParams = (TreebankLangParserParams) hungarianTreebankParserParams0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
      treeGraphNode0.indexSpans();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>(1673);
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(100, int0);
      
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) identityHashMap2, (Map<String, double[]>) identityHashMap2, identityHashMap0, identityHashMap0);
      twoDimensionalMap0.remove("Found ");
      splittingGrammarExtractor0.saveTrees(treeGraphNode0, 100, (Collection<Tree>) null, 5449.86);
      assertEquals(Double.NaN, treeGraphNode0.score(), 0.01);
      
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndTestConvergenceAndCountOriginalStatesAndOutputBetas()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.getTwoDimensionalMap("->");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(",f`yka|\"Uo2V `b");
      Constituent constituent0 = simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(constituent0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      threeDimensionalMap0.remove((String) null, (String) null, (String) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
      treeGraphNode0.indexSpans();
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = new CoreLabel();
      Constituent constituent0 = simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(constituent0);
      Tree tree0 = treeGraphNode0.treeSkeletonCopy();
      MapFactory.weakHashMapFactory();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor1.mergeStates();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor1.recalculateMergedBetas(hashMap0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Tree tree1 = negraPennTreebankParserParams0.transformTree(tree0, treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      negraPennTreebankParserParams0.treeTokenizerFactory();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap3, identityHashMap3, identityHashMap1, identityHashMap2);
      splittingGrammarExtractor0.saveTrees(treeGraphNode0, 0.0, tree1, 1.0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor1.unaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountInside(tree1, true, (-769), identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndUseNewBetasWithTrue()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.getTwoDimensionalMap("->");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.get("", "");
      threeDimensionalMap1.getTwoDimensionalMap("\u00BE");
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      Options options1 = new Options();
      TreebankLanguagePack treebankLanguagePack0 = options1.langpack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      IndexedWord indexedWord0 = new IndexedWord();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor1.splitBetas();
      SimpleTree simpleTree0 = new SimpleTree(indexedWord0);
      int int0 = 2;
      CollapseUnaryTransformer collapseUnaryTransformer0 = new CollapseUnaryTransformer();
      // Undeclared exception!
      try { 
        collapseUnaryTransformer0.transformTree(simpleTree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.trees.Tree", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWord taggedWord0 = new TaggedWord("    ");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][2];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray1 = new double[8][4][4];
      doubleArray1[0] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      doubleArray1[3] = doubleArray0;
      doubleArray1[4] = doubleArray0;
      doubleArray1[6] = doubleArray0;
      doubleArray1[7] = doubleArray0;
      threeDimensionalMap0.put("ig&De]+zx=z\"oX&~I", "ig&De]+zx=z\"oX&~I", "    ", doubleArray1);
      TwoDimensionalMap<String, String, double[][][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.splitBetas();
      threeDimensionalMap0.secondKeySet();
      splittingGrammarExtractor0.state(" in ", 3741);
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4Arguments()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.getTwoDimensionalMap("->");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap1, threeDimensionalMap0);
      IndexedWord indexedWord0 = new IndexedWord();
      splittingGrammarExtractor0.state("->", 100);
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      MapFactory<Object, CoreLabel> mapFactory0 = MapFactory.arrayMapFactory();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap0, 100);
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map0, twoDimensionalMap0, threeDimensionalMap0);
      Tag tag0 = new Tag((String) null);
      LabelFactory labelFactory0 = tag0.labelFactory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newLeaf((String) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) tree0, 2839.7254569500956);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(",fyka|\"Uo2V `b");
      Constituent constituent0 = simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(constituent0);
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      options0.tlpParams = (TreebankLangParserParams) hungarianTreebankParserParams0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Tree tree0 = negraPennTreebankParserParams0.transformTree(treeGraphNode0, treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap4, identityHashMap1, identityHashMap2, identityHashMap5);
      splittingGrammarExtractor0.saveTrees(tree0, 2246.11, treeGraphNode0, (-155.324521));
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) treeGraphNode0, false, identityHashMap2, identityHashMap5);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndOutputBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.get("dzdXfVu`f[_dE?V", "dzdXfVu`f[_dE?V");
      threeDimensionalMap0.getTwoDimensionalMap("dzdXfVu`f[_dE?V");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
      
      splittingGrammarExtractor0.outputBetas();
      boolean boolean1 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndSplitBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWord taggedWord0 = new TaggedWord("    ", "    ");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.getTwoDimensionalMap("O!JE^");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[4][2];
      byte[] byteArray0 = new byte[6];
      byteArray0[0] = (byte)116;
      byteArray0[1] = (byte)79;
      byteArray0[2] = (byte) (-111);
      byteArray0[3] = (byte) (-111);
      byteArray0[4] = (byte) (-111);
      byteArray0[5] = (byte) (-111);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      double[][][] doubleArray1 = new double[1][8][8];
      doubleArray1[0] = doubleArray0;
      threeDimensionalMap0.put("    ", "    ", "O!JE^", doubleArray1);
      TwoDimensionalMap<String, String, double[][][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][][]>();
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[10][7][4];
      threeDimensionalMap0.put(" ' 5", " ' 5", " ' 5", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerExceptionAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      double[][] doubleArray0 = new double[1][6];
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = 2912.25474191;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("!5?/j-D(", "!5?/j-D(", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray2 = new double[2][2][4];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      threeDimensionalMap0.put("!5?/j-D(", ",", (String) null, doubleArray2);
      TwoDimensionalMap<String, String, double[][][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = splittingGrammarExtractor1.unaryBetas;
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.splitBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[4][7][4];
      threeDimensionalMap0.put(" ' 5", " ' 5", " ' 5", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithZero()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null, 142, 0);
      TaggedWord taggedWord0 = new TaggedWord((String) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      HeadFinder headFinder0 = englishTreebankParserParams0.headFinder();
      Tree tree0 = treeGraphNode1.headPreTerminal(headFinder0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 0, identityHashMap0, identityHashMap2);
      assertTrue(identityHashMap2.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNullAndNull()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Double double0 = Double.valueOf((-1.231739572450155));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 100, double0);
      linkedList0.offerFirst(triple0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MapFactory<String, List<Object>> mapFactory0 = MapFactory.weakHashMapFactory();
      HashMap<Tree, Integer> hashMap0 = new HashMap<Tree, Integer>();
      mapFactory0.setMap(hashMap0);
      HashIndex<Tree> hashIndex0 = new HashIndex<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) hashIndex0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.saveTrees(hashIndex0, 7.5, hashIndex0, (-1.231739572450155));
      Tree.valueOf(">");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights((Tree) null, identityHashMap0, identityHashMap0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("Jj");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) tree0, (-2717.4243));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningZero()  throws Throwable  {
      Options options0 = new Options();
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(",fyka|\"Uo2V `b");
      Constituent constituent0 = simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(constituent0);
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      options0.tlpParams = (TreebankLangParserParams) hungarianTreebankParserParams0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
      treeGraphNode0.indexSpans();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>(1673);
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = (double) 1673;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 1673;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = (double) 100;
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
      twoDimensionalMap0.remove("dy!Q_\"`Gs*o'tc");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      assertNotSame(threeDimensionalMap1, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerException()  throws Throwable  {
      TaggedWord taggedWord0 = new TaggedWord("ESS1=y.sG0G85ul$", "ESS1=y.sG0G85ul$");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      treeGraphNode0.subTreeList();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      treeGraphNode0.insertDtr(treeGraphNode0, (-2));
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNegative()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling.shouldAllThrowIOExceptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor1.getStateSplitCount("");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(" in ", "ItrationD!", "");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      IndexedWord indexedWord0 = new IndexedWord();
      splittingGrammarExtractor1.state("ItrationD!", (-1186));
      splittingGrammarExtractor1.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor1.mergeStates();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor1.recalculateMergedBetas(hashMap0);
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Tree tree0 = negraPennTreebankParserParams0.transformTree(treeGraphNode0, treeGraphNode0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      splittingGrammarExtractor0.saveTrees(treeGraphNode0, (-2476.0), tree0, 0.0);
      assertEquals(Double.NaN, treeGraphNode0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testRecountWeights()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.keySet();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap3, identityHashMap3, identityHashMap1, identityHashMap0);
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      PriorityQueue<LabeledScoredTreeNode> priorityQueue0 = new PriorityQueue<LabeledScoredTreeNode>();
      PriorityQueue<Tree> priorityQueue1 = new PriorityQueue<Tree>(priorityQueue0);
      splittingGrammarExtractor0.extract((Collection<Tree>) priorityQueue1, (double) 100, (Collection<Tree>) priorityQueue1, 0.0);
      assertEquals(0, priorityQueue1.size());
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndBuildGrammarsThrowsNullPointerException()  throws Throwable  {
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningNegative()  throws Throwable  {
      Options options0 = new Options();
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("&3&oo]hJ.%*");
      simpleConstituentFactory0.newConstituent(85, (-673), (Label) coreLabel0, 2257.7921769539);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, identityHashMap1, identityHashMap1);
      treeGraphNode0.indexSpans();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>(2226);
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 2226;
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, (-1), (IdentityHashMap<Tree, double[][]>) null, identityHashMap2, (Map<String, double[]>) identityHashMap3, twoDimensionalMap0, threeDimensionalMap0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) identityHashMap3);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSaveTrees()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Double double0 = Double.valueOf((-1.231739572450155));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 100, double0);
      linkedList0.offerFirst(triple0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.testMemoryTreebank();
      MapFactory<String, List<Object>> mapFactory0 = MapFactory.weakHashMapFactory();
      HashMap<Tree, Integer> hashMap0 = new HashMap<Tree, Integer>();
      mapFactory0.setMap(hashMap0);
      HashIndex<Tree> hashIndex0 = new HashIndex<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) hashIndex0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.saveTrees(hashIndex0, 100, memoryTreebank0, 0.0);
      assertEquals(0, hashIndex0.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Double double0 = new Double(0.0);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple(",fyka|\"Uo2V `b", 100, double0);
      linkedList0.offerFirst(triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.getTwoDimensionalMap("->");
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      IndexedWord indexedWord0 = new IndexedWord();
      splittingGrammarExtractor0.state("KILL", 0);
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndDEBUG1()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      WordTag wordTag0 = new WordTag((String) null);
      treeGraphNodeFactory0.newLeaf((Label) wordTag0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.getTwoDimensionalMap("O!YJE^");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[2][0];
      double[] doubleArray1 = new double[9];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 5.0;
      doubleArray1[2] = Double.NaN;
      doubleArray1[3] = (double) 100;
      twoDimensionalMap0.put((String) null, "O!YJE^", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap1.getTwoDimensionalMap("O!YJE^");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap1);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(",fyka|\"Uo2V `b");
      Constituent constituent0 = simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(constituent0);
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      options0.tlpParams = (TreebankLangParserParams) hungarianTreebankParserParams0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
      treeGraphNode0.indexSpans();
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>(1673);
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) identityHashMap2, (Map<String, double[]>) hashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWord taggedWord0 = new TaggedWord("ESS1=y.sG0G85ul$", "ESS1=y.sG0G85ul$");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      treeGraphNode0.subTreeList();
      Options options1 = new Options();
      taggedWord0.setBeginPosition(100);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      treeGraphNode0.toPrettyString(100);
      treeGraphNode0.insertDtr(treeGraphNode0, (-2));
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = 526;
      splittingGrammarExtractor1.recountInside(treeGraphNode0, options0.coarseDistance, int0, identityHashMap0);
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor1.recalculateMergedBetas(identityHashMap1);
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas2()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][0];
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexAndBuildStateIndex()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 0, (Double) 5.0);
      linkedList0.offerFirst(triple0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      IndexedWord indexedWord0 = new IndexedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      CategoryWordTagFactory categoryWordTagFactory0 = new CategoryWordTagFactory();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 3;
      doubleArray0[1] = 24.01409824083091;
      doubleArray0[2] = 1.0;
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideWithNull()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options(options0.tlpParams);
      Options options2 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.state(">", 100);
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.mergeStates();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      CoreLabel coreLabel0 = new CoreLabel(0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      treeGraphNode0.lastChild();
      hungarianTreebankParserParams0.transformTree((Tree) null, (Tree) null);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside((Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments1()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      SystemInUtil.addInputLine((String) null);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      Word word0 = new Word((String) null, 142, 0);
      TaggedWord taggedWord0 = new TaggedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(word0, list0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      HeadFinder headFinder0 = englishTreebankParserParams0.headFinder();
      Tree tree0 = treeGraphNode1.headPreTerminal(headFinder0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap2, (Map<String, double[]>) identityHashMap2, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(",fyka|\"Uo2V `b");
      Constituent constituent0 = simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(constituent0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>(1673);
      IndexedWord indexedWord0 = new IndexedWord();
      splittingGrammarExtractor0.state("@ADVP|PP < ((IN|RB=node1 < /^(?i)of$/) $+ (NN|RB=node2 < /^(?i)course$/))", (-1936109745));
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 2146, identityHashMap3, identityHashMap1);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) treeGraphNode0, false, identityHashMap4, identityHashMap0, identityHashMap3, identityHashMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5Arguments()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) identityHashMap3, (Map<String, double[]>) identityHashMap3, identityHashMap2, identityHashMap2);
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3Arguments()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 0, (Double) 5.0);
      linkedList0.offerFirst(triple0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      IndexedWord indexedWord0 = new IndexedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      CategoryWordTagFactory categoryWordTagFactory0 = new CategoryWordTagFactory();
      TreeFactory treeFactory0 = LabeledScoredTreeNode.factory((LabelFactory) categoryWordTagFactory0);
      Tree tree0 = treeGraphNode0.deepCopy(treeFactory0, (LabelFactory) categoryWordTagFactory0);
      Tree tree1 = treeGraphNode0.upperMostUnary(tree0);
      hebrewTreebankParserParams0.transformTree(tree1, treeGraphNode0);
      byte[] byteArray0 = new byte[2];
      byteArray0[0] = (byte)95;
      byteArray0[1] = (byte)1;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.outputTransitions((Tree) treeGraphNode0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
      splittingGrammarExtractor1.recalculateBetas(false);
      MapFactory<Object, String> mapFactory0 = MapFactory.weakHashMapFactory();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel, Object> mapFactory1 = MapFactory.treeMapFactory(comparator0);
      Map<String, double[]> map0 = mapFactory1.setMap(null);
      Map<String, double[]> map1 = mapFactory0.setMap(map0, 0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects(tree0, map1, map0, identityHashMap1, identityHashMap1);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NN cat))");
      Label label0 = tree0.label();
      label0.setValue("S");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, 100, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testStateThrowsNullPointerException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 0, (Double) 5.0);
      linkedList0.offerFirst(triple0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.getTwoDimensionalMap((String) null);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      IndexedWord indexedWord0 = new IndexedWord();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.state((String) null, (-1936109745));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get("xA}~]('{Ub");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      byte[] byteArray0 = new byte[5];
      byteArray0[0] = (byte)2;
      byteArray0[1] = (byte)2;
      byteArray0[2] = (byte)95;
      byteArray0[3] = (byte) (-10);
      byteArray0[4] = (byte)100;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor1.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = new Word("    ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      treeGraphNode0.postOrderNodeList();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>(100);
      double[] doubleArray0 = new double[1];
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options(options0.tlpParams);
      Options options2 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.state(">", 100);
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.mergeStates();
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.put("strut", ">", (double[][]) null);
      twoDimensionalMap0.values();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringWithNull()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte) (-103);
      byteArray0[1] = (byte)28;
      byteArray0[2] = (byte)19;
      byteArray0[3] = (byte) (-10);
      byteArray0[4] = (byte)100;
      byteArray0[5] = (byte)2;
      byteArray0[6] = (byte) (-79);
      byteArray0[7] = (byte)95;
      byteArray0[8] = (byte)1;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.getStateSplitCount((String) null);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(" in ", (String) null, " | ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      CompositeTreeTransformer compositeTreeTransformer0 = new CompositeTreeTransformer();
      Tree tree0 = treeGraphNode0.transform((TreeTransformer) compositeTreeTransformer0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = new CoreLabel();
      simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.get("0E%", "chug");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.getStateSplitCount("");
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag((String) null, (String) null, "Converged for cycle ");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      CompositeTreeTransformer compositeTreeTransformer0 = new CompositeTreeTransformer();
      treeGraphNode0.lastChild();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) treeGraphNode0, identityHashMap1, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecalculateBetas()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte) (-103);
      byteArray0[1] = (byte)28;
      byteArray0[2] = (byte) (-14);
      byteArray0[3] = (byte) (-10);
      byteArray0[4] = (byte)100;
      byteArray0[5] = (byte)2;
      byteArray0[6] = (byte) (-79);
      byteArray0[7] = (byte)95;
      byteArray0[8] = (byte)1;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(",f`yka|\"Uo2V `b");
      Constituent constituent0 = simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(constituent0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(constituent0, list0);
      splittingGrammarExtractor1.mergeTransitions(treeGraphNode1, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, (double[]) null, identityHashMap2);
      assertNotSame(treeGraphNode1, treeGraphNode0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndUseNewBetas()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 0, (Double) 5.0);
      linkedList0.offerFirst(triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      IndexedWord indexedWord0 = new IndexedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      CategoryWordTagFactory categoryWordTagFactory0 = new CategoryWordTagFactory();
      TreeFactory treeFactory0 = LabeledScoredTreeNode.factory((LabelFactory) categoryWordTagFactory0);
      Tree tree0 = treeGraphNode0.deepCopy(treeFactory0, (LabelFactory) categoryWordTagFactory0);
      Tree tree1 = treeGraphNode0.upperMostUnary(tree0);
      Tree tree2 = hebrewTreebankParserParams0.transformTree(tree1, treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 3;
      doubleArray0[1] = 24.01409824083091;
      doubleArray0[2] = 1.0;
      splittingGrammarExtractor0.mergeTransitions(tree2, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, map0);
      assertEquals(Double.NaN, tree2.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testMergeTransitions()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      WordTag wordTag0 = new WordTag((String) null);
      Tree tree0 = treeGraphNodeFactory0.newLeaf((Label) wordTag0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, (double[]) null, identityHashMap2);
      assertEquals(0, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(",fyka|\"Uo2V `b");
      Constituent constituent0 = simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(constituent0);
      HungarianTreebankParserParams hungarianTreebankParserParams0 = new HungarianTreebankParserParams();
      options0.tlpParams = (TreebankLangParserParams) hungarianTreebankParserParams0;
      Tree tree0 = treeGraphNode0.treeSkeletonCopy();
      splittingGrammarExtractor0.state(",fyka|\"Uo2V `b", 2476);
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, (Tree) treeGraphNode0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Random.setNextRandom(100);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTree()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Double double0 = Double.valueOf((-1.231739572450155));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 100, double0);
      linkedList0.offerFirst(triple0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.testMemoryTreebank();
      Supplier<List<Tree>> supplier0 = (Supplier<List<Tree>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn(memoryTreebank0).when(supplier0).get();
      MapFactory<String, List<Object>> mapFactory0 = MapFactory.weakHashMapFactory();
      HashMap<Tree, Integer> hashMap0 = new HashMap<Tree, Integer>();
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(100);
      englishTreebankParserParams0.pw((OutputStream) byteArrayOutputStream0);
      Map<Tree, Integer> map0 = mapFactory0.setMap(hashMap0);
      Supplier<Map<Tree, Integer>> supplier1 = (Supplier<Map<Tree, Integer>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn(map0).when(supplier1).get();
      HashIndex<Tree> hashIndex0 = new HashIndex<Tree>(supplier0, supplier1);
      splittingGrammarExtractor0.extract((Collection<Tree>) hashIndex0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      String[] stringArray0 = new String[6];
      stringArray0[0] = null;
      CoreLabel coreLabel0 = new CoreLabel(stringArray0, stringArray0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer(pennTreebankLanguagePack0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      LabelFactory labelFactory0 = coreLabel0.labelFactory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      Tree tree0 = treeGraphNodeFactory0.newLeaf((Label) coreLabel0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount(tree0);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasReturningFalse()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      Double.valueOf(0.0);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("n)s.!s)}!q~0", (Integer) 100, (Double) 0.0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      linkedList0.offerFirst(triple0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      String string0 = null;
      List.copyOf(linkedList0);
      double double0 = (-1.231739572450155);
      Double.valueOf((-1.231739572450155));
      Tree tree0 = null;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      splittingGrammarExtractor0.recountOutside((Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testTestConvergenceWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(",fyka|\"Uo2V `b");
      Constituent constituent0 = simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      FileSystemHandling.shouldAllThrowIOExceptions();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(constituent0);
      Double.valueOf(Double.NEGATIVE_INFINITY);
      Double double0 = new Double(Double.NEGATIVE_INFINITY);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) null, double0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      linkedList0.offerFirst(triple0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MapFactory<String, List<Object>> mapFactory0 = MapFactory.weakHashMapFactory();
      HashMap<Tree, Integer> hashMap0 = new HashMap<Tree, Integer>();
      mapFactory0.setMap(hashMap0);
      HashIndex<Tree> hashIndex0 = new HashIndex<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollection0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      Label label0 = tree0.label();
      label0.setValue("ROOT");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexAndBuildGrammars()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.buildGrammars();
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasWithTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndBuildMergeCorrespondenceAndExtractTakingCollection()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Double double0 = Double.valueOf((-1.231739572450155));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 100, double0);
      linkedList0.offerFirst(triple0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.testMemoryTreebank();
      Supplier<List<Tree>> supplier0 = (Supplier<List<Tree>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn(memoryTreebank0).when(supplier0).get();
      MapFactory<String, List<Object>> mapFactory0 = MapFactory.weakHashMapFactory();
      HashMap<Tree, Integer> hashMap0 = new HashMap<Tree, Integer>();
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(100);
      englishTreebankParserParams0.pw((OutputStream) byteArrayOutputStream0);
      Map<Tree, Integer> map0 = mapFactory0.setMap(hashMap0);
      Supplier<Map<Tree, Integer>> supplier1 = (Supplier<Map<Tree, Integer>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn(map0).when(supplier1).get();
      HashIndex<Tree> hashIndex0 = new HashIndex<Tree>(supplier0, supplier1);
      splittingGrammarExtractor0.extract((Collection<Tree>) hashIndex0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      String[] stringArray0 = new String[6];
      stringArray0[0] = null;
      CoreLabel coreLabel0 = new CoreLabel(stringArray0, stringArray0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer(pennTreebankLanguagePack0);
      // Undeclared exception!
      try { 
        basicCategoryTreeTransformer0.transformHelper((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.trees.RecursiveTreeTransformer", e);
      }
  }

  @Test(timeout = 4000)
  public void testStateWithEmptyString()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("", 1461);
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
  }

  @Test(timeout = 4000)
  public void testState2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = splittingGrammarExtractor0.state(">Yab<`F0]v", 100);
      assertEquals(">Yab<`F0]v^100", string0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      Double double0 = Double.valueOf((-20.190719206142877));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 100, double0);
      linkedList0.offerFirst(triple0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      String[] stringArray0 = new String[6];
      stringArray0[0] = null;
      stringArray0[1] = null;
      stringArray0[3] = null;
      stringArray0[3] = null;
      stringArray0[4] = null;
      stringArray0[5] = null;
      String[] stringArray1 = new String[7];
      stringArray1[0] = null;
      stringArray1[1] = null;
      stringArray1[2] = "A{oflFe%@c`YcJ`f~6";
      stringArray1[3] = null;
      stringArray1[4] = null;
      stringArray1[5] = null;
      stringArray1[6] = null;
      CoreLabel coreLabel0 = null;
      try {
        coreLabel0 = new CoreLabel(stringArray0, stringArray1);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Argument array lengths differ: [null, null, null, null, null, null] vs. [null, null, A{oflFe%@c`YcJ`f~6, null, null, null, null]
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      assertTrue(hashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testUseNewBetasReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Double double0 = Double.valueOf((-1.231739572450155));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 100, double0);
      linkedList0.offerFirst(triple0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      String[] stringArray0 = new String[6];
      stringArray0[0] = null;
      stringArray0[1] = null;
      stringArray0[3] = null;
      stringArray0[3] = null;
      stringArray0[4] = null;
      stringArray0[5] = null;
      String[] stringArray1 = new String[7];
      stringArray1[0] = null;
      stringArray1[1] = null;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesReturningNonEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor1.neginfDoubles(1186);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      MapFactory<Object, CoreLabel> mapFactory0 = MapFactory.treeMapFactory();
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        mapFactory0.setMap(identityHashMap0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.util.MapFactory$TreeMapFactory", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollection1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashIndex<Tree> hashIndex0 = new HashIndex<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) hashIndex0);
      Random.setNextRandom(100);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      String string0 = null;
      Double double0 = Double.valueOf((-1.231739572450155));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 100, double0);
      linkedList0.offerFirst(triple0);
      Supplier<List<Tree>> supplier0 = (Supplier<List<Tree>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      Supplier<Map<Tree, Integer>> supplier1 = (Supplier<Map<Tree, Integer>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier1).get();
      HashIndex<Tree> hashIndex0 = new HashIndex<Tree>(supplier0, supplier1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) hashIndex0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.util.HashIndex", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleConstituentFactory simpleConstituentFactory0 = new SimpleConstituentFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(",fyka|\"Uo2V `b");
      Constituent constituent0 = simpleConstituentFactory0.newConstituent((-769), (-769), (Label) coreLabel0, (double) (-769));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(constituent0);
      Tree tree0 = treeGraphNode0.treeSkeletonCopy();
      MapFactory<Object, CoreLabel> mapFactory0 = MapFactory.weakHashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(null);
      Map<String, double[]> map1 = mapFactory0.setMap(map0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, false, map1, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStatesThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("Jj");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) tree0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringAndGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 100, (Double) 0.0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      String[] stringArray0 = new String[6];
      stringArray0[0] = null;
      stringArray0[1] = null;
      stringArray0[2] = null;
      stringArray0[3] = null;
      stringArray0[4] = null;
      stringArray0[5] = null;
      int int0 = splittingGrammarExtractor0.getStateSplitCount("");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.useNewBetas(false, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testDEBUG()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("Pre-split betas", "Pre-split betas", (String) null);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.testMemoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, memoryTreebank0);
      Tree tree0 = treeGraphNode0.treeSkeletonCopy();
      tree0.toString();
      // Undeclared exception!
      try { 
        CoordinationTransformer.CCtransform(tree0);
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>(":", (Integer) 100, (Double) 0.0);
      stack0.add(triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testOutputBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Double double0 = Double.valueOf(0.0);
      Integer integer0 = new Integer((-570));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("NJ+", integer0, double0);
      linkedList0.offerFirst(triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      stack0.add((Triple<String, Integer, Double>) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideWithNull()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      twoDimensionalMap0.get("HyWm@\">6DP;S`", "\"qjIKBJ");
      threeDimensionalMap0.getTwoDimensionalMap("->");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>(855);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside((Tree) null, false, 100, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceWithEmptyList()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringAndGetStateSplitCountTakingStringWithNonEmptyString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount("row");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testOutputBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesAndMergeStates()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      double double0 = (-1.231739572450155);
      Double double1 = Double.valueOf((-1.231739572450155));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>((String) null, (Integer) 100, double1);
      linkedList0.offerFirst(triple0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
      String[] stringArray0 = new String[6];
      stringArray0[0] = null;
      stringArray0[1] = null;
      stringArray0[2] = null;
      stringArray0[3] = null;
      stringArray0[4] = null;
      stringArray0[5] = null;
      String[] stringArray1 = new String[7];
      stringArray1[0] = null;
      stringArray1[1] = null;
      stringArray1[2] = "A{oflFe%@c`YcJ`f~6";
      stringArray1[3] = null;
      stringArray1[4] = null;
      stringArray1[5] = null;
      stringArray1[6] = null;
      CoreLabel coreLabel0 = null;
      try {
        coreLabel0 = new CoreLabel(stringArray0, stringArray1);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Argument array lengths differ: [null, null, null, null, null, null] vs. [null, null, A{oflFe%@c`YcJ`f~6, null, null, null, null]
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(100);
      assertEquals(100, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesReturningEmptyArray()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(0);
      assertEquals(0, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor()  throws Throwable  {
      Options options0 = new Options();
      options0.doDep = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateSplittingGrammarExtractorThrowsNullPointerException()  throws Throwable  {
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Options options0 = spanishUnknownWordModelTrainer0.op;
      SplittingGrammarExtractor splittingGrammarExtractor0 = null;
      try {
        splittingGrammarExtractor0 = new SplittingGrammarExtractor((Options) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }
}
