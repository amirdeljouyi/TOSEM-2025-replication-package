/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Jun 11 21:15:33 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.NERClassifierCombiner;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.StringLabel;
import edu.stanford.nlp.ling.Tag;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.TaggedWordFactory;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.ling.WordTagFactory;
import edu.stanford.nlp.objectbank.IdentityFunction;
import edu.stanford.nlp.objectbank.ObjectBank;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.FrenchTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HebrewTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ItalianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Lexicon;
import edu.stanford.nlp.parser.lexparser.NegraPennTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.SpanishUnknownWordModelTrainer;
import edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor;
import edu.stanford.nlp.parser.lexparser.TreebankLangParserParams;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.sequences.SeqClassifierFlags;
import edu.stanford.nlp.trees.Dependency;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.NPTmpRetainingTreeNormalizer;
import edu.stanford.nlp.trees.PennTreebankLanguagePack;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeGraphNodeFactory;
import edu.stanford.nlp.trees.TreeReaderFactory;
import edu.stanford.nlp.trees.TreeTransformer;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.ThreeDimensionalMap;
import edu.stanford.nlp.util.Triple;
import edu.stanford.nlp.util.TwoDimensionalMap;
import java.io.BufferedOutputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.net.URISyntaxException;
import java.nio.file.LinkOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Predicate;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.net.MockURI;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class SplittingGrammarExtractor_3_ESTest extends SplittingGrammarExtractor_3_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitions0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 0;
      intArray0[1] = 3;
      hashMap0.put("X", intArray0);
      int[] intArray1 = new int[2];
      intArray1[0] = 0;
      intArray1[1] = 0;
      hashMap0.put("Y", intArray1);
      double[] doubleArray1 = new double[2];
      Math.log(0.6);
      doubleArray1[0] = (-0.5108256237659907);
      Math.log(0.4);
      doubleArray1[1] = (-0.916290731874155);
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3, doubleArray1, hashMap0);
      identityHashMap2.containsKey(tree0);
      MapFactory<CoreLabel.GenericAnnotation<CoreLabel>, String> mapFactory0 = MapFactory.arrayMapFactory();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      mapFactory0.setMap(hashMap1, 0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = null;
      try {
        twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>((TwoDimensionalMap<String, String, double[][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.util.TwoDimensionalMap", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitions0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      tree0.label();
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 0;
      intArray0[1] = 3;
      hashMap0.put("X", intArray0);
      int[] intArray1 = new int[2];
      intArray1[0] = 0;
      intArray1[1] = 0;
      hashMap0.put("Y", intArray1);
      double[] doubleArray1 = new double[2];
      Math.log(0);
      doubleArray1[0] = Double.NEGATIVE_INFINITY;
      Math.log(0.4);
      doubleArray1[1] = (-0.916290731874155);
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3, doubleArray1, hashMap0);
      identityHashMap2.containsKey(tree0);
      MapFactory<CoreLabel.GenericAnnotation<CoreLabel>, String> mapFactory0 = MapFactory.arrayMapFactory();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      mapFactory0.setMap(hashMap1, 0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = null;
      try {
        twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>((TwoDimensionalMap<String, String, double[][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.util.TwoDimensionalMap", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithPositive0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tag tag0 = new Tag("-");
      LabeledWord labeledWord0 = new LabeledWord(".$$.");
      Collections.singletonList(splittingGrammarExtractor0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0, arrayList0);
      List<Tree> list0 = treeGraphNode0.getLeaves(arrayList0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) labeledWord0, list0);
      Collections.singletonList("ROOT");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0, 0.001, (Collection<Tree>) tree0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("(X (Y y))");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = (double) 100;
      doubleArray1[4] = 0.0;
      doubleArray1[5] = 0.0;
      identityHashMap2.put(tree0, doubleArray1);
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      hashMap1.put("(X (Y y))", doubleArray1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap1, (Map<String, double[]>) hashMap1, identityHashMap2, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SFAR < (WHNP=targt n WRB)");
      tree0.setValue("SFAR < (WHNP=targt n WRB)");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      identityHashMap2.put(tree0, doubleArray0);
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "NP.*-TMP.*");
      hashMap1.put("SFAR < (WHNP=targt n WRB)", doubleArray0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      identityHashMap3.put(tree0, (double[]) null);
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap1, (Map<String, double[]>) hashMap1, identityHashMap2, identityHashMap3);
      assertEquals(1, identityHashMap2.size());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndUseNewBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[1][3][1];
      double[][] doubleArray1 = new double[4][0];
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = (double) 100;
      doubleArray1[1] = doubleArray1[2];
      double[] doubleArray3 = new double[0];
      doubleArray1[2] = doubleArray3;
      doubleArray1[3] = doubleArray3;
      doubleArray0[0] = doubleArray1;
      identityHashMap1.put(tree0, doubleArray0);
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      twoDimensionalMap0.forEach(consumer0);
      twoDimensionalMap0.isEmpty();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray4 = new double[8];
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray4, 100, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap2, identityHashMap1);
      double[] doubleArray5 = splittingGrammarExtractor1.neginfDoubles(100);
      assertEquals(100, doubleArray5.length);
      
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      int int0 = splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, doubleArray4, 100, identityHashMap3, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(100, int0);
      assertArrayEquals(new double[] {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, doubleArray4, 0.01);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNonEmptyMapAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SFAR < (WHNP=targt n WRB)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[5][1][1];
      double[] doubleArray1 = new double[0];
      identityHashMap0.put(tree0, doubleArray1);
      double[][] doubleArray2 = new double[16][0];
      doubleArray0[0] = doubleArray2;
      identityHashMap1.put(tree0, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray2[1], 100, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap2, identityHashMap1);
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 100, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(hashMap0.isEmpty());
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[1][3][1];
      double[][] doubleArray1 = new double[4][0];
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = (double) 100;
      doubleArray1[2] = doubleArray2;
      doubleArray1[1] = doubleArray2;
      double[] doubleArray3 = new double[0];
      FileSystemHandling.shouldAllThrowIOExceptions();
      doubleArray1[2] = doubleArray3;
      double[] doubleArray4 = new double[0];
      doubleArray1[3] = doubleArray4;
      doubleArray0[0] = doubleArray1;
      identityHashMap1.put(tree0, doubleArray0);
      splittingGrammarExtractor0.buildStateIndex();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.isEmpty();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray5 = new double[8];
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray5, 100, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap2, identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NN cat))");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      String string0 = "<E0pdD,3kXKdGY";
      StringLabel stringLabel0 = new StringLabel("<E0pdD,3kXKdGY");
      Object object0 = new Object();
      Collections.singletonList(object0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      List<Tree> list0 = List.of(tree0, tree0, tree0, tree0, tree0, tree0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((Label) tree0, list0);
      Collections.singletonList(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree1, 0.0, (Collection<Tree>) list0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Trees should have been binarized, expected 1 or 2 children
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithPositive1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = Tree.valueOf("VP < (VV=target $+ VP !< /^(\u53EF(\u4EE5|\u80FD)?)|\u80FD\u591F?|\u5E94\u8BE5?|\u5C06\u8981?|\u5FC5\u987B|\u4F1A$/)");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.4492102082386951, (Collection<Tree>) tree0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Trees should have been binarized, expected 1 or 2 children
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (W{ cat))");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[9][6];
      double[] doubleArray1 = new double[17];
      doubleArray1[0] = (double) 100;
      doubleArray0[6] = doubleArray1;
      identityHashMap0.put(tree0, doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 11, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (W{ cat))");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[9][6];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      doubleArray0[0] = doubleArray1;
      identityHashMap0.put(tree0, doubleArray0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 11, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[][][] doubleArray0 = new double[1][2][1];
      identityHashMap0.put(tree0, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.isEmpty();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray1 = new double[9];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 0.0;
      doubleArray1[4] = 641.0356;
      doubleArray1[5] = (double) 4428;
      doubleArray1[6] = 0.0;
      doubleArray1[7] = 0.0;
      doubleArray1[8] = (double) 4428;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 4428, identityHashMap1, identityHashMap0, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap2, identityHashMap2, identityHashMap1, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsThrowsRuntimeExceptionAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[1][3][1];
      double[][] doubleArray1 = new double[4][0];
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = (double) 100;
      doubleArray1[2] = doubleArray2;
      double[] doubleArray3 = new double[0];
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[0];
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[0];
      doubleArray1[3] = doubleArray5;
      doubleArray0[0] = doubleArray1;
      identityHashMap1.put(tree0, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.isEmpty();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray6 = new double[8];
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray6, 4428, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor1.neginfDoubles(351);
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap2, identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[2][4][0];
      double[][] doubleArray1 = new double[4][9];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = 0.0;
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[7];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = (double) 100;
      doubleArray4[2] = (double) 100;
      doubleArray4[3] = 0.0;
      doubleArray4[4] = 0.0;
      doubleArray4[5] = (double) 100;
      doubleArray4[6] = (double) 100;
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[2];
      doubleArray5[0] = 0.0;
      doubleArray5[1] = 0.0;
      doubleArray1[3] = doubleArray5;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray6 = new double[1][6];
      doubleArray6[0] = doubleArray5;
      doubleArray0[1] = doubleArray6;
      threeDimensionalMap0.put((String) null, "Vm&S[ZE8^AW'8", "_${}Z|q?)", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[1][18][5];
      double[][] doubleArray1 = new double[5][1];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put(">OR0L/3%M$^A^ |?", ">OR0L/3%M$^A^ |?", ">OR0L/3%M$^A^ |?", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("(S (NN cat))");
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(tree0, (List<Tree>) null);
      labeledScoredTreeNode0.treeSkeletonConstituentCopy();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[1][0];
      double[] doubleArray1 = new double[9];
      doubleArray1[0] = 0.6;
      doubleArray1[1] = 0.6;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 0.6;
      doubleArray1[4] = 0.6;
      doubleArray1[5] = 0.0;
      doubleArray1[6] = 0.0;
      doubleArray1[7] = (double) 100;
      doubleArray1[8] = (double) 100;
      doubleArray0[0] = doubleArray1;
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray2 = new double[4][7][8];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      double[][] doubleArray3 = new double[7][4];
      doubleArray3[0] = doubleArray1;
      double[] doubleArray4 = new double[5];
      doubleArray4[0] = 0.6;
      doubleArray4[1] = 0.6;
      doubleArray4[2] = 2597.0666420200323;
      doubleArray4[3] = (double) 100;
      doubleArray4[4] = (double) 100;
      doubleArray3[1] = doubleArray4;
      doubleArray3[2] = doubleArray1;
      doubleArray3[3] = doubleArray1;
      doubleArray3[4] = doubleArray1;
      double[] doubleArray5 = new double[3];
      doubleArray5[0] = (double) 100;
      doubleArray5[1] = (double) 100;
      doubleArray5[2] = 0.6;
      doubleArray3[5] = doubleArray5;
      doubleArray3[6] = doubleArray1;
      doubleArray2[2] = doubleArray3;
      double[][] doubleArray6 = new double[1][1];
      doubleArray6[0] = doubleArray5;
      doubleArray2[3] = doubleArray6;
      identityHashMap1.put(tree0, doubleArray2);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
      assertEquals(1, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NN cat))");
      Tree tree1 = tree0.treeSkeletonConstituentCopy();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.0;
      double[] doubleArray1 = new double[9];
      doubleArray1[0] = (double) 100;
      doubleArray1[1] = (double) 100;
      doubleArray1[2] = (double) 100;
      doubleArray1[3] = 0.0;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree1);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      treeGraphNode2.subTreeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.outputTransitions(tree1, 91, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NN cat))");
      Tree tree1 = tree0.treeSkeletonConstituentCopy();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[8][9];
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = 0.0;
      double[] doubleArray2 = new double[9];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      doubleArray2[4] = 0.6;
      doubleArray2[5] = (double) 100;
      tree1.dependencies((Predicate<Dependency<Label, Label, Object>>) null);
      doubleArray2[6] = 0.0;
      doubleArray2[7] = (double) 100;
      doubleArray2[8] = (double) 100;
      tree0.toArray();
      doubleArray0[2] = doubleArray2;
      double[] doubleArray3 = new double[9];
      doubleArray3[0] = 0.6;
      doubleArray3[1] = 0.6;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = 0.0;
      doubleArray3[4] = 0.6;
      doubleArray3[5] = 100.0;
      doubleArray3[6] = (double) 100;
      doubleArray3[7] = (double) 100;
      doubleArray3[8] = 0.6;
      doubleArray0[4] = doubleArray3;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) tree1, 4494.31173, (Collection<Tree>) tree1, 100.0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndExtractTaking4ArgumentsWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NN cat))");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (-1074.46648), (Collection<Tree>) tree0, 0.0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][6];
      twoDimensionalMap0.put("5/:X", "5/:X", doubleArray0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("5/:X");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      identityHashMap0.put(treeGraphNode0, doubleArray1);
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, (Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap2);
      assertEquals(0, identityHashMap2.size());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][6];
      twoDimensionalMap0.put("5/:X", "5/:X", doubleArray0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("5/:X");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = (double) 100;
      identityHashMap0.put(treeGraphNode0, doubleArray1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, (Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsWithTreeWhereScoreIsPositiveAndTreeWhereScoreIsPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][6];
      twoDimensionalMap0.put("5/:X", "5/:X", doubleArray0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("5/:X");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, (Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(P (C x))");
      Options options1 = new Options();
      Tree.valueOf("(P (C x))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.neginfDoubles(98);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[4][6];
      twoDimensionalMap0.put("T5/:", "T5/:", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountOutside((Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, (Tree) labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[1][1][1];
      double[][] doubleArray1 = new double[18][0];
      doubleArray1[1] = doubleArray1[2];
      identityHashMap1.put(tree0, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray2 = new double[3];
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray2, 100, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SFAR < (WHNP=targt n WRB)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[1][1][1];
      double[][] doubleArray1 = new double[22][0];
      doubleArray0[0] = doubleArray1;
      identityHashMap1.put(tree0, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1[1], 100, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap2, identityHashMap1);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithEmptyMap0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("7$> ", list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      hashMap1.put("7$> ", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap1, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      Integer integer0 = new Integer(100);
      WordTag wordTag0 = Morphology.stemStatic(".OLEXICON", ".OLEXICON");
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(wordTag0, 100);
      StringLabel stringLabel0 = new StringLabel(labeledScoredTreeNode0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("After feature grouping, total of ", list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      treeGraphNode0.treeSkeletonCopy((TreeFactory) treeGraphNodeFactory0);
      int int0 = splittingGrammarExtractor0.recountInside(tree0, false, (-1), identityHashMap1);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[1][7][8];
      double[][] doubleArray1 = new double[0][5];
      doubleArray0[0] = doubleArray1;
      identityHashMap1.put(tree0, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray2 = new double[9];
      doubleArray2[0] = (double) 100;
      doubleArray2[2] = (double) 75296902;
      doubleArray2[3] = (double) 75296902;
      doubleArray2[4] = 0.0;
      doubleArray2[5] = (double) 100;
      doubleArray2[6] = (double) 100;
      doubleArray2[7] = (double) 100;
      doubleArray2[8] = (double) 100;
      IdentityFunction<double[][]> identityFunction0 = new IdentityFunction<double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(identityFunction0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray2, 75296902, identityHashMap0, identityHashMap1, (Map<String, double[]>) null, twoDimensionalMap1, threeDimensionalMap1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsAndRecountOutsideTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testState0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String[] stringArray0 = new String[2];
      stringArray0[0] = "ROOT";
      stringArray0[1] = "S";
      Arrays.asList(stringArray0);
      String string0 = splittingGrammarExtractor0.state("ROOT", 2);
      assertEquals("ROOT", string0);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNonEmptyMapAndRecountWeightsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(A (B b))");
      Label label0 = tree0.label();
      label0.setValue("A");
      double[][] doubleArray0 = new double[1][1];
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[1];
      doubleArray1[0] = 0.0;
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      identityHashMap1.put(tree0, doubleArray2);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(P (C x))");
      Label label0 = tree0.label();
      label0.setValue("P");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray1 = new double[2];
      Math.log(0.5);
      doubleArray1[0] = (-0.6931471805599453);
      Math.log(0.5);
      doubleArray1[1] = (-0.6931471805599453);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(tree0, false, 0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NN cat))");
      Label label0 = tree0.label();
      label0.setValue("S");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitions1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("(X (Y y))");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      identityHashMap0.put(tree0, doubleArray0);
      int[] intArray0 = new int[2];
      hashMap0.put("(X (Y y))", intArray0);
      hashMap0.put("Y", intArray0);
      double[] doubleArray1 = new double[2];
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray1, hashMap0);
      assertEquals(0, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("(X (Y y))");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      hashMap0.put("(X (Y y))", intArray0);
      hashMap0.put("Y", intArray0);
      double[] doubleArray0 = new double[2];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNullAndTreeWhereScoreIsPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (W{ cat))");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, (double[]) null, hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitions1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(X (Y y))");
      Label label0 = tree0.label();
      label0.setValue("X");
      double[][] doubleArray0 = new double[2][2];
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      Map<String, int[]> map0 = new HashMap<String, int[]>();
      int[] intArray0 = new int[2];
      intArray0[0] = 0;
      intArray0[1] = 0;
      map0.put("X", intArray0);
      int[] intArray1 = new int[2];
      intArray1[0] = 0;
      intArray1[1] = 0;
      map0.put("Y", intArray1);
      double[] doubleArray1 = new double[2];
      Math.log(0.6);
      doubleArray1[0] = (-0.5108256237659907);
      Math.log(0.4);
      doubleArray1[1] = (-0.916290731874155);
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3, doubleArray1, map0);
      boolean boolean0 = identityHashMap2.containsKey(tree0);
      assertEquals(1, identityHashMap2.size());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (Wq cat))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testState1()  throws Throwable  {
      Options options0 = new Options();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      List<String> list0 = new ArrayList<String>();
      list0.add("ROOT");
      String string0 = splittingGrammarExtractor0.state("ROOT", 3);
      assertEquals("ROOT", string0);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideAndRecurseOutsideThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      double[][][] doubleArray0 = new double[1][3][1];
      double[][] doubleArray1 = new double[4][0];
      double[] doubleArray2 = new double[19];
      doubleArray2[10] = (double) 100;
      doubleArray1[1] = doubleArray1[0];
      BiFunction<Object, Object, double[]> biFunction0 = (BiFunction<Object, Object, double[]>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      identityHashMap0.computeIfPresent(tree0, biFunction0);
      doubleArray1[2] = doubleArray1[0];
      doubleArray1[3] = doubleArray1[2];
      identityHashMap1.put(tree0, doubleArray0);
      TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      MapFactory<Object, String> mapFactory0 = MapFactory.arrayMapFactory();
      IdentityHashMap<String, int[]> identityHashMap4 = new IdentityHashMap<String, int[]>();
      Map<String, int[]> map0 = mapFactory0.setMap(identityHashMap4);
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      Options options0 = new Options();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (NP (DT the)) (VP (VBZ sings)))");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][6];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("LEXICON", "LEXICON", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testStateAndStateWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      treeGraphNodeFactory0.newTreeNode("(H' a`d^QuJ3.#\"]EvS", list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.state(".$$.", (-1401));
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      assertEquals(0, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      double[][] doubleArray0 = new double[1][6];
      twoDimensionalMap0.put("5/:X", "5/:X", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray1 = new double[5][3][1];
      doubleArray1[0] = null;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = null;
      doubleArray1[3] = null;
      doubleArray1[4] = null;
      threeDimensionalMap0.put(":", "5/:X", "5/:X", doubleArray1);
      splittingGrammarExtractor0.splitBetas();
      assertFalse(splittingGrammarExtractor0.equals((Object)splittingGrammarExtractor1));
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel(" in ");
      Tag tag0 = new Tag(label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(label0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, false, (-1670), identityHashMap3);
      assertEquals((-1669), int0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsThrowsRuntimeExceptionAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[1][3][1];
      double[][] doubleArray1 = new double[4][0];
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = (double) 100;
      doubleArray1[2] = doubleArray2;
      double[] doubleArray3 = new double[0];
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[0];
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[0];
      doubleArray1[3] = doubleArray5;
      doubleArray0[0] = doubleArray1;
      identityHashMap1.put(tree0, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray6 = new double[8];
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray6, 4428, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor1.neginfDoubles(351);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel(" in ");
      Tag tag0 = new Tag(label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(label0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      wordTagFactory0.newLabel(" in ", 1099);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray0 = new double[1];
      splittingGrammarExtractor0.buildGrammars();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap1);
      double[] doubleArray1 = splittingGrammarExtractor0.neginfDoubles(100);
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1, 101, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndOutputTransitionsTaking4Arguments0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[1][3][1];
      double[][] doubleArray1 = new double[4][0];
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = (double) 100;
      doubleArray1[0] = doubleArray2;
      identityHashMap1.put(tree0, doubleArray0);
      IdentityHashMap<String, double[]> identityHashMap4 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap2, identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) tree0, 100.0, (Collection<Tree>) tree0, 100.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndOutputTransitionsTaking4Arguments1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[][][] doubleArray0 = new double[1][3][1];
      double[][] doubleArray1 = new double[15][0];
      doubleArray1[3] = doubleArray1[2];
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap1, identityHashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) tree0, 3178.7);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndRecalculateTemporaryBetasTaking8ArgumentsWithEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SFAR < (WHNP=targt n WRB)");
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[5][1][1];
      double[][] doubleArray1 = new double[16][0];
      doubleArray0[0] = doubleArray1;
      identityHashMap0.put(tree0, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1[1], 100, identityHashMap1, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(1, hashMap0.size());
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[1][3][1];
      double[][] doubleArray1 = new double[4][0];
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = (double) 100;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[0];
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[0];
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[0];
      doubleArray1[3] = doubleArray5;
      doubleArray0[0] = doubleArray1;
      identityHashMap1.put(tree0, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray6 = new double[4];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray6, 4428, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      double[][][] doubleArray0 = new double[1][3][1];
      double[][] doubleArray1 = new double[24][0];
      identityHashMap0.put(tree0, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1[3], 100, identityHashMap1, identityHashMap0, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsArrayIndexOutOfBoundsException2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SFAR < (WHNP=targt n WRB)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][][] doubleArray0 = new double[6][1][1];
      double[][] doubleArray1 = new double[4][0];
      doubleArray0[0] = doubleArray1;
      identityHashMap1.put(tree0, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray1[1], 100, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray2, 100, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      options0.useSmoothTagProjection = true;
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.outputTransitions(tree0, 100, identityHashMap4, identityHashMap5);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (W{ cat))");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsAndOutputTransitionsTaking3ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (W{ cat))");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[9][6];
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
      assertFalse(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.op = options0;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      twoDimensionalMap0.size();
      double[][] doubleArray0 = new double[1][6];
      twoDimensionalMap0.put("LEXICON", "LEXICON", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("(H' $`d^QuJ3.#\"]EvS", list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 0, identityHashMap0, identityHashMap1);
      System.setCurrentTimeMillis(2137L);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningZero()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      WordTagFactory wordTagFactory1 = new WordTagFactory('&');
      Label label0 = wordTagFactory1.newLabel("");
      Tag tag0 = new Tag(label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) '&';
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.neginfDoubles(35);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap2);
      assertFalse(hashMap0.isEmpty());
      assertEquals(1, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      splittingGrammarExtractor0.state("SBAR < (WHNP=target < WRB)", 75296902);
      splittingGrammarExtractor0.countOriginalStates();
      FileSystemHandling.shouldAllThrowIOExceptions();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) tree0, (-3378.1), (Collection<Tree>) tree0, (double) 75296902);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Stack<Tree> stack0 = new Stack<Tree>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      MapFactory<String, String> mapFactory0 = MapFactory.linkedHashMapFactory();
      mapFactory0.setMap(identityHashMap1, 100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = (double) 100;
      doubleArray0[3] = 1431.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.0;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) identityHashMap1, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap1);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<CoreLabel, Object> mapFactory1 = MapFactory.weakHashMapFactory();
      Map<String, int[]> map0 = mapFactory1.setMap(null);
      Map<String, int[]> map1 = mapFactory1.setMap(map0);
      Map<String, int[]> map2 = mapFactory1.setMap(map1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap2, identityHashMap3, identityHashMap2, identityHashMap3, doubleArray0, map2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNullAndTreeWhereScoreIsPositive()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap0, identityHashMap0, (IdentityHashMap<Tree, double[][]>) null, (IdentityHashMap<Tree, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6Arguments()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      WordTag wordTag0 = Morphology.stemStatic("4ef$j[417|", "x;Bru;,D");
      Label label0 = wordTagFactory0.newLabel("4ef$j[417|");
      Tag tag0 = new Tag(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(label0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(tree0, true, 947, identityHashMap2);
      splittingGrammarExtractor0.recountTree(tree0, false, identityHashMap2, identityHashMap2, identityHashMap0, identityHashMap1);
      assertTrue(identityHashMap1.isEmpty());
      assertEquals(0, identityHashMap0.size());
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithPositive2()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Stack<Tree> stack0 = new Stack<Tree>();
      TaggedWord taggedWord0 = new TaggedWord();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) stack0, 8.0, (Collection<Tree>) tree0, 1431.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStatesThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Stack<Tree> stack0 = new Stack<Tree>();
      List.of(splittingGrammarExtractor0, splittingGrammarExtractor0, splittingGrammarExtractor0, splittingGrammarExtractor0, splittingGrammarExtractor0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TaggedWord taggedWord0 = new TaggedWord();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.outputTransitions(tree0, identityHashMap2, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("RcT");
      Tag tag0 = new Tag(label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) tag0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(tree0, identityHashMap1, identityHashMap1, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null);
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (double) 100;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = 1.000000000190015;
      doubleArray0[6] = (double) 100;
      doubleArray0[7] = 0.0;
      doubleArray0[8] = 0.0;
      identityHashMap2.replace("RcT", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      TwoDimensionalMap.treeMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, (double[]) null, 2755, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexAndRecountInside()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      WordTag wordTag0 = Morphology.stemStatic("4ef$j[417|", "x;Bru;,D");
      Label label0 = wordTagFactory0.newLabel("f");
      Tag tag0 = new Tag(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(label0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, true, 947, identityHashMap2);
      assertEquals(948, int0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeExceptionAndRecurseOutsideAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Stack<Tree> stack0 = new Stack<Tree>();
      IndexedWord indexedWord0 = new IndexedWord("  2| ", 660, (-2062));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      stack0.add((Tree) treeGraphNode0);
      Tag tag0 = new Tag("}=O,}BCb");
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(tag0, stack0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode1, stack0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      splittingGrammarExtractor0.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(treeGraphNode0, false, 660, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndBuildStateIndexAndRecountInside()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      wordTagFactory0.newLabelFromString("P%e");
      Label label0 = wordTagFactory0.newLabel("RcT");
      Tag tag0 = new Tag(label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountInside(tree0, false, 666460443, identityHashMap2);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Stack<Tree> stack0 = new Stack<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      List.of(splittingGrammarExtractor0, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      TaggedWord taggedWord0 = new TaggedWord();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = (-1019.5545127689);
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = 0.0;
      doubleArray0[7] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      MapFactory<String, String> mapFactory0 = MapFactory.arrayMapFactory();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap3, 2);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recalculateTemporaryBetas(tree0, doubleArray0, 75, identityHashMap1, identityHashMap2, map0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SFAR < (WHNP=ta2Yt n WRQ)");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][] doubleArray0 = new double[17][0];
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0[1], 100, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNullAndNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (Wq cat))");
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) null, (Map<String, double[]>) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNegativeArraySizeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      WordTagFactory wordTagFactory0 = new WordTagFactory('G');
      Label label0 = wordTagFactory0.newLabel("9wRQ=l*@h=XFgUj{Pg^");
      Tag tag0 = new Tag(label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordTagFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor1.binaryBetas;
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap2, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap2);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.neginfDoubles((-324));
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // -324
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      splittingGrammarExtractor0.state(".$$.", (-1401));
      Random.setNextRandom(2);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeExceptionAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Stack<Tree> stack0 = new Stack<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      List.of(splittingGrammarExtractor0, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      TaggedWord taggedWord0 = new TaggedWord();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recountInside(tree0, false, 68, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3Arguments()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      WordTag wordTag0 = Morphology.stemStatic("RcT", "RcT");
      Tag tag0 = new Tag(wordTag0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(tag0, list0);
      TaggedWord taggedWord0 = new TaggedWord("Iteration ");
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      String string0 = "_J \\uBHBJs$We";
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 0.0;
      doubleArray0[5] = (double) 100;
      doubleArray0[6] = 0.0;
      doubleArray0[7] = 0.0;
      doubleArray0[8] = (double) 100;
      hashMap1.put(string0, doubleArray0);
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap1, (Map<String, double[]>) hashMap0);
      splittingGrammarExtractor0.neginfDoubles(100);
      System.setCurrentTimeMillis((-1L));
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("Determined head (case 1) for ");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.recountTree(tree0, false, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(hashMap0);
      splittingGrammarExtractor1.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) tree0, 5018.82);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException3()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("");
      Tag tag0 = new Tag(label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(wordTagFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(label0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.remove("");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInsideWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((String) null, list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, false, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("ri]_");
      Tag tag0 = new Tag(label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, (double[]) null, 100, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountTree((Tree) treeGraphNode0, false, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsWithNullAndNull()  throws Throwable  {
      Options options0 = new Options();
      boolean boolean0 = false;
      options0.directional = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor1.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("ri]_");
      Tag tag0 = new Tag(label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(label0, list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, (double[]) null, 100, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsWithNullAndRecountOutsideTaking4ArgumentsWithNullAndOutputBetas()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      double[][] doubleArray0 = new double[1][6];
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = (-871.225);
      doubleArray1[3] = (double) 100;
      doubleArray1[4] = (double) 100;
      doubleArray1[5] = 0.0;
      twoDimensionalMap0.put("5/:SXQ", "5/:SXQ", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor1.state("pctSegmenterScaleByCRF", (-1606));
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      MapFactory.linkedHashMapFactory();
      splittingGrammarExtractor0.outputBetas();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("pctSegmenterScaleByCRF", "useDisjunctive", "retransmit");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeFactory treeFactory0 = TreeGraphNode.factory();
      Tree tree0 = treeGraphNode0.treeSkeletonCopy(treeFactory0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor2.recountOutside(tree0, tree0, (IdentityHashMap<Tree, double[]>) null, (IdentityHashMap<Tree, double[]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningNegative()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      Tag tag0 = new Tag(",\"Q&\"@9M8nJiHtEv");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0, arrayList0);
      englishTreebankParserParams0.subcategoryStripper();
      TaggedWord taggedWord0 = new TaggedWord(",\"Q&\"@9M8nJiHtEv", ",\"Q&\"@9M8nJiHtEv");
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = 0.6;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 100;
      doubleArray0[5] = Double.NEGATIVE_INFINITY;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, (-3380), identityHashMap0, identityHashMap2, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.neginfDoubles((-3380));
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // -3380
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndOutputBetasAndUseNewBetas0()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      threeDimensionalMap0.thirdKeySet();
      twoDimensionalMap0.get(" P%e");
      Morphology morphology0 = new Morphology();
      double[][][] doubleArray0 = new double[1][8][9];
      threeDimensionalMap0.put("  removing: ", "  removing: ", " P%e", doubleArray0);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor1.splitBetas();
      assertFalse(splittingGrammarExtractor1.equals((Object)splittingGrammarExtractor0));
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceThrowsNullPointerException()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      String[] stringArray0 = new String[3];
      stringArray0[0] = "Akffb~'87O2>4ES0";
      stringArray0[1] = "Akffb~'87O2>4ES0";
      stringArray0[2] = ")>5vo932nD%";
      options0.setOptionFlag(stringArray0, 1);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.mergeStates();
      splittingGrammarExtractor1.buildStateIndex();
      Double double0 = new Double(1);
      Integer integer0 = new Integer(1);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple(")]+%ff+DT>uI,7WrhDg", integer0, double0);
      Integer integer1 = new Integer(3597);
      Double double1 = new Double(3597);
      Integer integer2 = new Integer((-925));
      Double double2 = new Double(0.0);
      Triple<String, Integer, Double> triple1 = new Triple<String, Integer, Double>("W}v\"cP @=^1122", integer2, double2);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple1, triple1, triple1, triple1, triple0, triple1, triple1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerExceptionAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][6];
      NegraPennTreebankParserParams negraPennTreebankParserParams0 = new NegraPennTreebankParserParams();
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      HashIndex<String> hashIndex0 = new HashIndex<String>(set0);
      Lexicon lexicon0 = negraPennTreebankParserParams0.lex(options0, hashIndex0, hashIndex0);
      splittingGrammarExtractor0.lex = lexicon0;
      twoDimensionalMap0.put("5/:X", "5/:X", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Integer integer0 = new Integer(Integer.MAX_VALUE);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("5/:X", integer0, 0.0);
      stack0.add(triple0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsNullPointerExceptionAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      String string0 = "5/:SXQ";
      double[][] doubleArray0 = new double[1][6];
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = (-871.225);
      doubleArray1[3] = (double) 100;
      doubleArray1[4] = (double) 100;
      doubleArray1[5] = 0.0;
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("5/:SXQ", "5/:SXQ", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor1.mergeStates();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.buildStateIndex();
      splittingGrammarExtractor0.DEBUG();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeException()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor2.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      twoDimensionalMap1.get(" P%e");
      Morphology morphology0 = new Morphology();
      twoDimensionalMap1.transform(morphology0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor2.mergeStates();
      splittingGrammarExtractor1.buildStateIndex();
      splittingGrammarExtractor1.DEBUG();
      splittingGrammarExtractor1.buildGrammars();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString(" P%e");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      treeGraphNode0.subTreeList();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap3 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor1.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap1, twoDimensionalMap3, threeDimensionalMap1);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountInside(treeGraphNode0, false, 100, identityHashMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndOutputBetasAndUseNewBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      twoDimensionalMap0.get(" P%e");
      Morphology morphology0 = new Morphology();
      double[][][] doubleArray0 = new double[1][8][9];
      threeDimensionalMap0.put(" P%e", " P%e", " P%e", doubleArray0);
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor1.splitBetas();
      assertFalse(splittingGrammarExtractor1.equals((Object)splittingGrammarExtractor0));
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      twoDimensionalMap0.get(" P%e");
      Morphology morphology0 = new Morphology();
      double[][][] doubleArray0 = new double[1][8][9];
      double[][] doubleArray1 = new double[1][1];
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("  removing: ", "  removing: ", " P%e", doubleArray0);
      splittingGrammarExtractor0.outputBetas();
      assertFalse(splittingGrammarExtractor0.equals((Object)splittingGrammarExtractor1));
  }

  @Test(timeout = 4000)
  public void testOutputBetasThrowsNullPointerExceptionAndRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
      Properties properties0 = options0.testOptions.evals;
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      threeDimensionalMap0.put("bX 'vy?)S", "bX 'vy?)S", "bX 'vy?)S", (double[][][]) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountInside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledScoredTreeNode0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode(".$$.", list0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, true, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Integer integer0 = new Integer(86);
      Double double0 = new Double((-100.0));
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("  Log Split -> ", integer0, double0);
      arrayList0.add(triple0);
      splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      Options.LexOptions options_LexOptions0 = new Options.LexOptions();
      options0.lexOptions = options_LexOptions0;
      options0.useUnigramWordSmoothing = true;
      splittingGrammarExtractor0.neginfDoubles(2391);
      splittingGrammarExtractor0.recalculateBetas(false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("  Log Split -> ");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.9999000099990001, (Collection<Tree>) tree0, (-100.0));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      arrayList0.add((Triple<String, Integer, Double>) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Double double0 = new Double(100);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("Trees should have been binarized, expected 1 or 2 children", 100, double0);
      linkedList0.push(triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndDEBUGAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree.valueOf("(S (W{ cat))");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      double[][] doubleArray0 = new double[1][6];
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray1 = new double[4][6][5];
      doubleArray1[0] = doubleArray0;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[3] = doubleArray0;
      threeDimensionalMap0.put("(S (W{ cat))", "XnGRk~(AeY1Aj*Ge", ".$$.", doubleArray1);
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsWithTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>(1027);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) null, true, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasThrowsNullPointerExceptionAndOutputBetas()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor1.unaryBetas;
      twoDimensionalMap0.get("IZxYIC");
      Morphology morphology0 = new Morphology();
      twoDimensionalMap0.transform(morphology0);
      String string0 = " has been declared twice, which makes no sense";
      twoDimensionalMap0.put("5/:SXQ", "", (double[][]) null);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor1.DEBUG();
      splittingGrammarExtractor0.buildGrammars();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(" has been declared twice, which makes no sense");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Stack<Tree> stack0 = new Stack<Tree>();
      MapFactory.linkedHashMapFactory();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.outputBetas();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel(" in ");
      Tag tag0 = new Tag(label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(label0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      wordTagFactory0.newLabel(">", 1099);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray0 = new double[1];
      splittingGrammarExtractor0.buildGrammars();
      doubleArray0[0] = 0.0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.neginfDoubles(100);
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap1);
      assertEquals(1, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithPositive3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("Determined ead (case 1) for");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (double) 100, (Collection<Tree>) tree0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithZero0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("Determined ead (case 1) for");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) tree0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndBuildGrammars()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      twoDimensionalMap0.get(" P%e");
      Morphology morphology0 = new Morphology();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = twoDimensionalMap1.transform(morphology0);
      twoDimensionalMap2.put(" has been declared twice, which makes no sense", " has been declared twice, which makes no sense", (double[][]) null);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap2, threeDimensionalMap1);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor1.buildStateIndex();
      splittingGrammarExtractor0.DEBUG();
      splittingGrammarExtractor1.buildGrammars();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor1.recalculateMergedBetas(hashMap0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(" P%e");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = new Stack<Tree>();
      MapFactory.linkedHashMapFactory();
      splittingGrammarExtractor0.outputBetas();
      assertFalse(splittingGrammarExtractor0.equals((Object)splittingGrammarExtractor1));
  }

  @Test(timeout = 4000)
  public void testOutputBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      int int0 = SplittingGrammarExtractor.MIN_DEBUG_ITERATION;
      double[][] doubleArray0 = new double[1][6];
      twoDimensionalMap0.put("5/:SXQ", "5/:SXQ", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.outputBetas();
      assertFalse(splittingGrammarExtractor0.equals((Object)splittingGrammarExtractor1));
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesThrowsNullPointerException()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      TreeFactory treeFactory0 = LabeledScoredTreeNode.factory();
      Tag tag0 = new Tag("ryTsn7K)_*Ky");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0, arrayList0);
      TreeTransformer treeTransformer0 = englishTreebankParserParams0.subcategoryStripper();
      Tree tree0 = treeGraphNode0.transform(treeTransformer0, treeFactory0);
      TaggedWord taggedWord0 = new TaggedWord();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      englishTreebankParserParams0.defaultTestSentence();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap1, (Map<String, double[]>) hashMap1, identityHashMap0, identityHashMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      int int0 = (-3761);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountOutside((Tree) treeGraphNode0, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeException0()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      twoDimensionalMap0.get(" P%e");
      Morphology morphology0 = new Morphology();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = twoDimensionalMap1.transform(morphology0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap2, threeDimensionalMap1);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor1.buildStateIndex();
      splittingGrammarExtractor0.DEBUG();
      splittingGrammarExtractor1.buildGrammars();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor1.recalculateMergedBetas(hashMap0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(" P%e");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode(" P%e", list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) list0, 76.18009172947146, (Collection<Tree>) tree0, 0.45);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithZero1()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) tree0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory('R');
      Label label0 = taggedWordFactory0.newLabelFromString("$_FW{<TFi=a,#\" l");
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.get("$_FW{<TFi=a,#\" l");
      Morphology morphology0 = new Morphology();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(morphology0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap1);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.DEBUG();
      splittingGrammarExtractor0.buildGrammars();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.recalculateMergedBetas(hashMap0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      CoreLabel.wordFromString("3h%GYg6Qk");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      treeGraphNodeFactory0.newTreeNode("$_FW{<TFi=a,#\" l", list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>(identityHashMap0);
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      splittingGrammarExtractor2.mergeTransitions(treeGraphNode0, identityHashMap2, identityHashMap1, identityHashMap2, identityHashMap1, doubleArray0, hashMap0);
      assertEquals(0, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitionsWithEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      double[] doubleArray0 = new double[0];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap1, identityHashMap0, identityHashMap1, identityHashMap0, doubleArray0, hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitionsWithEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      double[] doubleArray0 = new double[0];
      splittingGrammarExtractor0.mergeTransitions(labeledScoredTreeNode0, identityHashMap1, identityHashMap0, identityHashMap1, identityHashMap0, doubleArray0, hashMap0);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitionsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("SBAR\"< (HNP=target  WRB)");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[8];
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, identityHashMap2);
      assertArrayEquals(new double[] {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, doubleArray0, 0.01);
  }

  @Test(timeout = 4000)
  public void testTestConvergence0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      Integer integer0 = new Integer(100);
      double[][] doubleArray0 = new double[8][6];
      twoDimensionalMap0.put(".OLEXICON", ".OLEXICON", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Stack<Tree> stack0 = new Stack<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      List.of(splittingGrammarExtractor0, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.extract((Collection<Tree>) stack0, (-131.0), (Collection<Tree>) stack0, (-131.0));
      splittingGrammarExtractor1.getStateSplitCount("\"4LOm~2NQDsj8");
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode((Label) null, stack0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel$CoreLabelFactory", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeStatesAndMergeStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      splittingGrammarExtractor0.state("    ", 100);
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      MapFactory.linkedHashMapFactory();
      MapFactory<CoreLabel, Object> mapFactory0 = MapFactory.hashMapFactory();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      mapFactory0.setMap(identityHashMap0, 100);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.outputBetas();
      splittingGrammarExtractor1.countOriginalStates();
      splittingGrammarExtractor1.mergeStates();
      assertFalse(splittingGrammarExtractor1.equals((Object)splittingGrammarExtractor0));
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesReturningEmptyArray()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      WordTag wordTag0 = new WordTag("lq:+TRl@w@w}:[w", "lq:+TRl@w@w}:[w");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0, arrayList0);
      TreeTransformer treeTransformer0 = englishTreebankParserParams0.subcategoryStripper();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      TreeFactory treeFactory0 = TreeGraphNode.factory((LabelFactory) wordTagFactory0);
      Tree tree0 = treeGraphNode0.transform(treeTransformer0, treeFactory0);
      TaggedWord taggedWord0 = new TaggedWord();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap1, (Map<String, double[]>) hashMap1, identityHashMap0, identityHashMap0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(0);
      assertEquals(0, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Stack<Tree> stack0 = new Stack<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      List.of(splittingGrammarExtractor0, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode((Label) null, stack0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(labeledScoredTreeNode0, identityHashMap0, identityHashMap0);
      threeDimensionalMap0.put("-format", "-format", "\"4LOm~2NQDsj8", (double[][][]) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas((TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNullAndPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.buildStateIndex();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      splittingGrammarExtractor1.saveTrees(arrayList0, 3472.38974582506, (Collection<Tree>) null, 3472.38974582506);
      assertEquals(0, arrayList0.size());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsWithNull()  throws Throwable  {
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) null, 66, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWord taggedWord0 = new TaggedWord("' m#-QJoM", "3h%GYg6Qk");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0, (List<Tree>) null);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode1.flatten();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][] doubleArray1 = new double[5][9];
      double[] doubleArray2 = new double[2];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray1[0] = doubleArray2;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[3] = doubleArray0;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = (double) 100;
      doubleArray1[4] = doubleArray3;
      identityHashMap0.put(treeGraphNode0, doubleArray1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.getTwoDimensionalMap("' m#-QJoM");
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWord taggedWord0 = new TaggedWord("' m#-QJoM", "3h%GYg6Qk");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0, (List<Tree>) null);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode1.flatten();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][] doubleArray1 = new double[5][9];
      double[] doubleArray2 = new double[2];
      doubleArray2[1] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray1[0] = doubleArray2;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[4] = doubleArray0;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = (double) 100;
      doubleArray1[4] = doubleArray3;
      identityHashMap0.put(treeGraphNode0, doubleArray1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.getTwoDimensionalMap("' m#-QJoM");
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap0, identityHashMap1);
      assertEquals(0, identityHashMap1.size());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsAndOutputTransitionsTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (W{ cat))");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      double[][] doubleArray0 = new double[3][6];
      identityHashMap0.put(tree0, doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, identityHashMap1);
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap0, identityHashMap1);
      assertTrue(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      splittingGrammarExtractor0.tagIndex = null;
      options0.doPCFG = true;
      splittingGrammarExtractor0.binaryBetas = null;
      splittingGrammarExtractor0.tagIndex = null;
      splittingGrammarExtractor0.state(" P%e", 100);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      splittingGrammarExtractor0.state("    ", 384);
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      MapFactory.linkedHashMapFactory();
      MapFactory<CoreLabel, Object> mapFactory0 = MapFactory.hashMapFactory();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      Map<String, int[]> map0 = mapFactory0.setMap(identityHashMap0, 100);
      splittingGrammarExtractor1.recalculateMergedBetas(map0);
      splittingGrammarExtractor1.outputBetas();
      splittingGrammarExtractor2.countOriginalStates();
      assertFalse(splittingGrammarExtractor2.equals((Object)splittingGrammarExtractor1));
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TaggedWord taggedWord0 = new TaggedWord("' m#-QJoM", "3h%GYg6Qk");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0, (List<Tree>) null);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Tree tree0 = treeGraphNode1.flatten();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (double) 100;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      double[][] doubleArray1 = new double[5][9];
      double[] doubleArray2 = new double[2];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray1[0] = doubleArray2;
      doubleArray1[1] = doubleArray0;
      doubleArray1[2] = doubleArray0;
      doubleArray1[3] = doubleArray0;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = (double) 100;
      doubleArray1[4] = doubleArray3;
      identityHashMap0.put(treeGraphNode0, doubleArray1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      threeDimensionalMap0.getTwoDimensionalMap("' m#-QJoM");
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsWithFalse()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordTagFactory wordTagFactory0 = new WordTagFactory();
      Label label0 = wordTagFactory0.newLabel("RcT");
      Tag tag0 = new Tag(label0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tag0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.0;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.neginfDoubles(100);
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, false, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(1, hashMap0.size());
      assertFalse(hashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsAndUseNewBetas1()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      int int0 = splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) labeledScoredTreeNode0, doubleArray0, 100, identityHashMap0, identityHashMap1, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      assertEquals(100, int0);
      
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      twoDimensionalMap0.secondKeySet();
      threeDimensionalMap0.thirdKeySet();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateMergedBetas((Map<String, int[]>) null);
      FrenchTreebankParserParams frenchTreebankParserParams0 = null;
      try {
        frenchTreebankParserParams0 = new FrenchTreebankParserParams();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.trees.tregex.TregexParser
         //
         verifyException("edu.stanford.nlp.trees.tregex.TregexPatternCompiler", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammars()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      splittingGrammarExtractor0.tagIndex = null;
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.state(" P%e", 100);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndBuildStateIndex()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      splittingGrammarExtractor0.buildGrammars();
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollection0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedHashSet<Tree> linkedHashSet0 = new LinkedHashSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) linkedHashSet0);
      assertEquals(0, linkedHashSet0.size());
  }

  @Test(timeout = 4000)
  public void testMergeStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndExtractTakingCollectionAndGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Stack<Tree> stack0 = new Stack<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      List.of(splittingGrammarExtractor0, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1);
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, true, Integer.MAX_VALUE, true);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      options0.distance = true;
      splittingGrammarExtractor0.getStateSplitCount("$_FW{<TFi=a,#\" l");
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>(0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.extract((Collection<Tree>) stack0);
      assertEquals(0, stack0.size());
  }

  @Test(timeout = 4000)
  public void testCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      options0.useUnigramWordSmoothing = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.neginfDoubles(100);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap1);
      Properties properties0 = options0.testOptions.evals;
      SeqClassifierFlags seqClassifierFlags0 = new SeqClassifierFlags(properties0, false);
      CoreLabel coreLabel0 = seqClassifierFlags0.pad;
      TreeSet<LinkOption> treeSet0 = new TreeSet<LinkOption>();
      Morphology morphology0 = new Morphology((Reader) null, 1537);
      ObjectBank<LabeledScoredTreeNode> objectBank0 = ObjectBank.getLineIterator(treeSet0, morphology0, "bU0F0rRKunl@b[AN");
      List<Tree> list0 = List.copyOf(objectBank0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0, list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0, (-1726.7833919128), (Collection<Tree>) treeGraphNode0, (double) (-1));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRescaleTemporaryBetas1()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      Integer integer0 = new Integer(100);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][6];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      twoDimensionalMap0.put("LEXICON", "LEXICON", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray0 = new double[0][6];
      twoDimensionalMap0.put("LEXICON", "LEXICON", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][6];
      twoDimensionalMap0.put("LEXICON", "LEXICON", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5ArgumentsWithEmptyMap1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Stack<Tree> stack0 = new Stack<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      List.of(splittingGrammarExtractor0, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      TaggedWord taggedWord0 = new TaggedWord();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsAndNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      splittingGrammarExtractor0.tagIndex = null;
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.state(" P%e", 100);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor2.recalculateMergedBetas(identityHashMap0);
      String string0 = splittingGrammarExtractor1.state(" P%e^100", 717);
      assertEquals(" P%e^100^717", string0);
      
      splittingGrammarExtractor2.DEBUG();
      WordTagFactory wordTagFactory0 = new WordTagFactory('@');
      WordTagFactory wordTagFactory1 = new WordTagFactory('W');
      Label label0 = wordTagFactory1.newLabel("Pre-split betas");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(120, false, 120, true, true);
      wordTagFactory1.newLabel((String) null);
      TreeFactory treeFactory0 = LabeledScoredTreeNode.factory();
      treeGraphNode0.transform((TreeTransformer) nPTmpRetainingTreeNormalizer0, treeFactory0);
      wordTagFactory1.newLabel((Label) treeGraphNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor2.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap1, identityHashMap1);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(1557);
      assertEquals(1557, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideWithNonEmptyMapAndNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      identityHashMap0.put((Tree) null, doubleArray0);
      BiConsumer<Object, double[]> biConsumer0 = (BiConsumer<Object, double[]>) mock(BiConsumer.class, new ViolatedAssumptionAnswer());
      identityHashMap0.forEach(biConsumer0);
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside((Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeException1()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      twoDimensionalMap0.get(" P%e");
      Morphology morphology0 = new Morphology();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = twoDimensionalMap1.transform(morphology0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap2, threeDimensionalMap1);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor1.buildStateIndex();
      splittingGrammarExtractor0.DEBUG();
      splittingGrammarExtractor1.buildGrammars();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor1.recalculateMergedBetas(hashMap0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(" P%e");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("xrWo\\#>GqS", list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) tree0, 1.0, (Collection<Tree>) treeGraphNode0, 1.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      splittingGrammarExtractor0.tagIndex = null;
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.state(" P%e", 100);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor2.recalculateMergedBetas(identityHashMap0);
      splittingGrammarExtractor1.state(" P%e^100", 717);
      splittingGrammarExtractor2.DEBUG();
      WordTagFactory wordTagFactory0 = new WordTagFactory('@');
      WordTagFactory wordTagFactory1 = new WordTagFactory('W');
      Label label0 = wordTagFactory1.newLabel("Pre-split betas");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(120, false, 120, true, true);
      TreeFactory treeFactory0 = LabeledScoredTreeNode.factory();
      Tree tree0 = treeGraphNode0.transform((TreeTransformer) nPTmpRetainingTreeNormalizer0, treeFactory0);
      int[] intArray0 = new int[1];
      intArray0[0] = 62;
      identityHashMap0.put("UCP", intArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.outputTransitions(tree0, identityHashMap1, identityHashMap3);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap5 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.recountWeights(treeGraphNode0, identityHashMap4, identityHashMap5, identityHashMap1, identityHashMap2);
      splittingGrammarExtractor1.splitBetas();
      splittingGrammarExtractor2.recountOutside(tree0, identityHashMap4, identityHashMap5);
      assertEquals(1, identityHashMap5.size());
      assertEquals(0, identityHashMap4.size());
  }

  @Test(timeout = 4000)
  public void testRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(labeledScoredTreeNode0, identityHashMap1, identityHashMap1);
      assertEquals(Double.NaN, labeledScoredTreeNode0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(S (Wq cat))");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 1 out of bounds for length 1
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsAndRecalculateTemporaryBetasTaking5ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "$j-9nHJ&31");
      options0.dcTags = false;
      options0.coarseDistance = false;
      splittingGrammarExtractor0.neginfDoubles(100);
      splittingGrammarExtractor0.recalculateBetas(false);
      IndexedWord indexedWord0 = new IndexedWord("$j-9nHJ&31", 96, 96);
      TaggedWord taggedWord0 = new TaggedWord(indexedWord0, indexedWord0);
      LabelFactory labelFactory0 = taggedWord0.labelFactory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      Tree tree0 = treeGraphNodeFactory0.newLeaf("ATZ}^zt&odCq$%$");
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, false, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = "SBAR < (WHNP=target < WRB)";
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      MapFactory<String, String> mapFactory0 = MapFactory.linkedHashMapFactory();
      mapFactory0.setMap(identityHashMap1, 100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[] doubleArray0 = new double[8];
      doubleArray0[0] = (double) 100;
      doubleArray0[3] = (double) 100;
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = null;
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap3, identityHashMap3, identityHashMap4, (IdentityHashMap<Tree, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      String string0 = splittingGrammarExtractor0.state("$j-9nHJ&31", 100);
      assertEquals("$j-9nHJ&31^100", string0);
      
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      HebrewTreebankParserParams hebrewTreebankParserParams1 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      hebrewTreebankParserParams1.memoryTreebank();
      hebrewTreebankParserParams0.treeReaderFactory();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recalculateMergedBetas(hashMap0);
      splittingGrammarExtractor0.recalculateBetas(false);
      splittingGrammarExtractor0.DEBUG();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap3, identityHashMap3, identityHashMap2, (IdentityHashMap<Tree, double[][][]>) null);
      splittingGrammarExtractor0.splitBetas();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor1.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recountWeights(labeledScoredTreeNode0, identityHashMap0, identityHashMap0, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null);
      assertTrue(identityHashMap1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerExceptionAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][5];
      twoDimensionalMap0.put("7$>*", ".$$.", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3Arguments()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      splittingGrammarExtractor1.state(" P%e", 100);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      splittingGrammarExtractor1.state(" P%e^100", 100);
      splittingGrammarExtractor1.DEBUG();
      WordTagFactory wordTagFactory0 = new WordTagFactory('W');
      Label label0 = wordTagFactory0.newLabel(" predictSplits=");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, true, 100, true, false);
      TreeFactory treeFactory0 = LabeledScoredTreeNode.factory();
      Tree tree0 = treeGraphNode0.transform((TreeTransformer) nPTmpRetainingTreeNormalizer0, treeFactory0);
      int[] intArray0 = new int[2];
      intArray0[0] = 100;
      intArray0[1] = 1500;
      identityHashMap0.put("thorn", intArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap1, identityHashMap2);
      assertEquals(0, identityHashMap2.size());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      Tree tree0 = Tree.valueOf("SBAR < (WHNP=target < WRB)");
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, identityHashMap0, (IdentityHashMap<Tree, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) labeledScoredTreeNode0, identityHashMap1, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasReturningFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      twoDimensionalMap0.secondKeySet();
      threeDimensionalMap0.thirdKeySet();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateMergedBetas((Map<String, int[]>) null);
      FrenchTreebankParserParams frenchTreebankParserParams0 = null;
      try {
        frenchTreebankParserParams0 = new FrenchTreebankParserParams();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.trees.tregex.TregexParser
         //
         verifyException("edu.stanford.nlp.trees.tregex.TregexPatternCompiler", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceWithEmptyList()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence((List<Triple<String, Integer, Double>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTree()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      splittingGrammarExtractor1.state(" P%e", 100);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
      
      String string0 = splittingGrammarExtractor1.state(" P%e^100", 100);
      assertEquals(" P%e^100^100", string0);
      
      boolean boolean1 = splittingGrammarExtractor1.DEBUG();
      assertFalse(boolean1);
      
      WordTagFactory wordTagFactory0 = new WordTagFactory('W');
      Label label0 = wordTagFactory0.newLabel(" predictSplits=");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, false, 100, true, false);
      TreeFactory treeFactory0 = LabeledScoredTreeNode.factory();
      Tree tree0 = treeGraphNode0.transform((TreeTransformer) nPTmpRetainingTreeNormalizer0, treeFactory0);
      splittingGrammarExtractor1.getStateSplitCount(tree0);
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor1.buildMergeCorrespondence(arrayList0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>(1027);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) null, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsWithNullAndNull()  throws Throwable  {
      Options options0 = new Options();
      options0.display();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      splittingGrammarExtractor0.tagIndex = null;
      options0.doPCFG = true;
      splittingGrammarExtractor0.binaryBetas = null;
      splittingGrammarExtractor0.tagIndex = null;
      splittingGrammarExtractor0.state(" P%e", 100);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.state(" P%e^100", 100);
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      splittingGrammarExtractor0.recalculateBetas(false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      boolean boolean0 = splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, splittingGrammarExtractor0.binaryBetas);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNullAndDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      splittingGrammarExtractor0.tagIndex = null;
      options0.doPCFG = true;
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "P%e");
      splittingGrammarExtractor0.binaryBetas = null;
      splittingGrammarExtractor0.tagIndex = null;
      splittingGrammarExtractor0.state("P%e", 100);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      hebrewTreebankParserParams0.memoryTreebank();
      TreeReaderFactory treeReaderFactory0 = hebrewTreebankParserParams0.treeReaderFactory();
      Tree.valueOf("P%e^100", treeReaderFactory0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      splittingGrammarExtractor1.recalculateBetas(false);
      splittingGrammarExtractor0.DEBUG();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountWeights((Tree) null, identityHashMap3, identityHashMap3, identityHashMap2, (IdentityHashMap<Tree, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedHashSet<Tree> linkedHashSet0 = new LinkedHashSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) linkedHashSet0, (-433.3477473), (Collection<Tree>) linkedHashSet0, (-433.3477473));
      assertTrue(linkedHashSet0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithZero()  throws Throwable  {
      Options options0 = new Options();
      options0.display();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      splittingGrammarExtractor0.tagIndex = null;
      options0.doPCFG = true;
      splittingGrammarExtractor0.binaryBetas = null;
      splittingGrammarExtractor1.buildStateIndex();
      splittingGrammarExtractor0.tagIndex = null;
      splittingGrammarExtractor0.state(" P%e", 100);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      splittingGrammarExtractor0.recalculateBetas(false);
      IndexedWord indexedWord0 = new IndexedWord((String) null, 67, 0);
      LabelFactory labelFactory0 = indexedWord0.labelFactory();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory(labelFactory0);
      Vector<Tree> vector0 = new Vector<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0, vector0);
      List<Tree> list0 = treeGraphNode0.getLeaves();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode((Label) indexedWord0, list0);
      splittingGrammarExtractor1.saveTrees(tree0, 0.0, tree0, 0.0);
      assertFalse(splittingGrammarExtractor1.equals((Object)splittingGrammarExtractor0));
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithPositive4()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) labeledScoredTreeNode0, (double) 100, (Collection<Tree>) labeledScoredTreeNode0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideWithNull()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      OutputStream outputStream0 = OutputStream.nullOutputStream();
      BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(outputStream0, 70);
      italianTreebankParserParams0.pw((OutputStream) bufferedOutputStream0);
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = 1399;
      Word word0 = new Word("f*79HR<4", 70, 1399);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(word0, word0);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, linkedList0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      treeGraphNode1.lastChild();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside((Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndRecalculateBetasAndState()  throws Throwable  {
      Options options0 = new Options();
      options0.display();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      splittingGrammarExtractor0.tagIndex = null;
      options0.doPCFG = true;
      splittingGrammarExtractor0.binaryBetas = null;
      splittingGrammarExtractor1.buildStateIndex();
      splittingGrammarExtractor0.tagIndex = null;
      splittingGrammarExtractor0.state(" P%e", 100);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      splittingGrammarExtractor0.recalculateBetas(false);
      splittingGrammarExtractor0.outputBetas();
      assertFalse(splittingGrammarExtractor0.equals((Object)splittingGrammarExtractor1));
  }

  @Test(timeout = 4000)
  public void testOutputBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndTestConvergenceReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Stack<Tree> stack0 = new Stack<Tree>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][0][1];
      double[][] doubleArray1 = new double[1][3];
      double[] doubleArray2 = new double[9];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = 3472.38974582506;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = 0.0;
      doubleArray2[4] = (-2980.597155344998);
      doubleArray2[5] = 0.0;
      doubleArray2[6] = 0.0;
      doubleArray2[7] = 1.0E-4;
      doubleArray2[8] = (-2980.597155344998);
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      threeDimensionalMap0.put("Converged for cycle ", "Converged for cycle ", "Converged for cycle ", doubleArray0);
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.arrayMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.treeMapFactory(null);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergence1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][3][2];
      threeDimensionalMap0.put("U%N(;3c;8SlV%&S", "U%N(;3c;8SlV%&S", "RcT", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[1][3][2];
      threeDimensionalMap0.put("U%N(;3c;8SlV%&S", "U%N(;3c;8SlV%&S", "RcT", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, threeDimensionalMap1);
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      options0.directional = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      twoDimensionalMap0.get(" P%e");
      Morphology morphology0 = new Morphology();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap2 = twoDimensionalMap1.transform(morphology0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap2, threeDimensionalMap1);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor1.buildStateIndex();
      splittingGrammarExtractor0.DEBUG();
      splittingGrammarExtractor1.buildGrammars();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      splittingGrammarExtractor1.recalculateMergedBetas(hashMap0);
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(" P%e");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode(" P%e", list0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[0];
      splittingGrammarExtractor1.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, hashMap0);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndSplitBetasAndTestConvergence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      options0.tlpParams = (TreebankLangParserParams) chineseTreebankParserParams0;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      Integer integer0 = new Integer(100);
      double[][] doubleArray0 = new double[8][6];
      twoDimensionalMap0.put("tuGB[a!o3jff.OV", "tuGB[a!o3jff.OV", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      Morphology morphology0 = new Morphology();
      double[][][] doubleArray0 = new double[4][8][9];
      threeDimensionalMap0.put(" %e", " %e", " %e", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithNegative()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      splittingGrammarExtractor0.saveTrees(arrayList0, 0.0, arrayList0, (-7021.6));
      assertTrue(arrayList0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithPositive()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      splittingGrammarExtractor0.saveTrees(arrayList0, 77459, arrayList0, 0.0);
      assertTrue(arrayList0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4ArgumentsWithPositiveAndExtractTaking4ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedHashSet<Tree> linkedHashSet0 = new LinkedHashSet<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) linkedHashSet0, (double) 100, (Collection<Tree>) linkedHashSet0, (double) 100);
      assertTrue(linkedHashSet0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>(1027);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) null, false, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNullAndRecalculateMergedBetasAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      splittingGrammarExtractor0.tagIndex = null;
      options0.doPCFG = true;
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, " P%e");
      splittingGrammarExtractor0.binaryBetas = null;
      splittingGrammarExtractor0.tagIndex = null;
      splittingGrammarExtractor0.state(" P%e", 100);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      TreeReaderFactory treeReaderFactory0 = hebrewTreebankParserParams0.treeReaderFactory();
      Tree.valueOf(" P%e^100", treeReaderFactory0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions((Tree) null, identityHashMap1, identityHashMap2, identityHashMap1, identityHashMap2, doubleArray0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testDEBUGAndDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.iteration = (-863);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[][][] doubleArray0 = new double[29][1][5];
      double[][] doubleArray1 = new double[7][1];
      double[] doubleArray2 = new double[0];
      doubleArray1[0] = doubleArray2;
      doubleArray0[7] = doubleArray1;
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndBuildStateIndex()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[3][3][9];
      double[][] doubleArray1 = new double[1][1];
      double[] doubleArray2 = new double[1];
      doubleArray2[0] = 0.0;
      doubleArray1[0] = doubleArray2;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray3 = new double[8][3];
      doubleArray3[0] = doubleArray2;
      doubleArray3[1] = doubleArray2;
      doubleArray3[2] = doubleArray2;
      doubleArray3[3] = doubleArray2;
      doubleArray3[4] = doubleArray2;
      doubleArray3[5] = doubleArray2;
      doubleArray3[6] = doubleArray2;
      doubleArray3[7] = doubleArray2;
      doubleArray0[1] = doubleArray3;
      double[][] doubleArray4 = new double[2][4];
      doubleArray4[0] = doubleArray2;
      doubleArray4[1] = doubleArray2;
      doubleArray0[2] = doubleArray4;
      threeDimensionalMap0.put("    ^1737", "    ^1737", (String) null, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      double[][] doubleArray0 = new double[1][6];
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = 0.0;
      doubleArray1[3] = (double) 100;
      doubleArray1[3] = (double) 100;
      doubleArray1[5] = 0.0;
      twoDimensionalMap0.put("5/:SXQ", "5/:SXQ", doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap0);
      splittingGrammarExtractor1.mergeStates();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor3 = new SplittingGrammarExtractor(options0);
      threeDimensionalMap0.put("5/:SXQ", "rvI`5HeCVwO$", "5/:SXQ", (double[][][]) null);
      splittingGrammarExtractor3.outputBetas();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      twoDimensionalMap0.get("Qu<L^ mjJnm:i");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      twoDimensionalMap0.secondKeySet();
      threeDimensionalMap0.getTwoDimensionalMap("th");
      threeDimensionalMap0.thirdKeySet();
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateMergedBetas((Map<String, int[]>) null);
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode((Label) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel$CoreLabelFactory", e);
      }
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas3()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[6][6][8];
      threeDimensionalMap0.put((String) null, (String) null, (String) null, doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRescaleTemporaryBetas2()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      hebrewTreebankParserParams0.dependencyGrammarExtractor(options0, (Index<String>) null, (Index<String>) null);
      Options options1 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.hashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.treeMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testBuildStateIndex()  throws Throwable  {
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      Options options0 = new Options(englishTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      String string0 = "";
      String string1 = " iterations";
      String string2 = "w1";
      try { 
        MockURI.URI("", "?z8ms--/H~CP-cc|:", "uY`tvx91{GwtO$*", 77459, "uY`tvx91{GwtO$*", " iterations", "w1");
        fail("Expecting exception: URISyntaxException");
      
      } catch(URISyntaxException e) {
         //
         // Relative path in absolute URI: ://%3Fz8ms--%2FH~CP-cc%7C:@uY`tvx91{GwtO$*:77459uY%60tvx91%7BGwtO$*?%20iterations#w1
         //
         verifyException("java.net.URI", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsWithNullAndRecountOutsideTaking4ArgumentsWithNullAndRecountOutsideTaking4ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = null;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      identityHashMap0.put((Tree) null, doubleArray0);
      BiConsumer<Object, double[]> biConsumer0 = (BiConsumer<Object, double[]>) mock(BiConsumer.class, new ViolatedAssumptionAnswer());
      identityHashMap0.forEach(biConsumer0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) null, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      int int0 = splittingGrammarExtractor0.getStateSplitCount("gZBDdY Mq[V");
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(100);
      assertEquals(100, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringAndNeginfDoubles()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      hebrewTreebankParserParams0.treeReaderFactory();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount((String) null);
      splittingGrammarExtractor0.neginfDoubles(100);
      StringLabel stringLabel0 = new StringLabel("utf-8");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(stringLabel0);
      Tree.valueOf("ADJP");
      // Undeclared exception!
      try { 
        treeGraphNode0.ancestor((-3150), (Tree) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ancestor: height cannot be negative
         //
         verifyException("edu.stanford.nlp.trees.Tree", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory('R');
      String string0 = "$_FW{<TFi=a,#\" l";
      Label label0 = taggedWordFactory0.newLabelFromString("$_FW{<TFi=a,#\" l");
      Stack<Tree> stack0 = new Stack<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      List.of(splittingGrammarExtractor0, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1, splittingGrammarExtractor1);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode(label0, (List<Tree>) stack0);
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, true, Integer.MAX_VALUE, true);
      Tree tree1 = nPTmpRetainingTreeNormalizer0.apply(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree1, tree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollection1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = Tree.valueOf("(ROOT (NP (NN dog)))");
      Label label0 = tree0.label();
      label0.setValue("ROOT");
      List<Tree> list0 = (List<Tree>)Collections.singletonList(tree0);
      splittingGrammarExtractor0.extract((Collection<Tree>) list0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndSplitBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][6];
      twoDimensionalMap0.put("5/:X", "5/:X", doubleArray0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("5/:X");
      coreLabel0.toString();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      splittingGrammarExtractor0.splitBetas();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateMergedBetas((Map<String, int[]>) null);
  }

  @Test(timeout = 4000)
  public void testDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecalculateBetasWithTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRecalculateMergedBetasAndState()  throws Throwable  {
      Options options0 = new Options();
      options0.display();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Index<String> index0 = splittingGrammarExtractor1.wordIndex;
      splittingGrammarExtractor0.tagIndex = null;
      options0.doPCFG = true;
      splittingGrammarExtractor0.binaryBetas = null;
      splittingGrammarExtractor0.tagIndex = null;
      String string0 = splittingGrammarExtractor0.state(" P%e", 100);
      assertEquals(" P%e^100", string0);
      
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testState2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = splittingGrammarExtractor0.state("vT/9\"f?/OnROzk0^", 100);
      assertEquals("vT/9\"f?/OnROzk0^^100", string0);
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = null;
      try {
        coreLabel0 = new CoreLabel((CoreLabel) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateSplittingGrammarExtractorThrowsNullPointerException()  throws Throwable  {
      SpanishUnknownWordModelTrainer spanishUnknownWordModelTrainer0 = new SpanishUnknownWordModelTrainer();
      Options options0 = spanishUnknownWordModelTrainer0.op;
      SplittingGrammarExtractor splittingGrammarExtractor0 = null;
      try {
        splittingGrammarExtractor0 = new SplittingGrammarExtractor((Options) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }
}
