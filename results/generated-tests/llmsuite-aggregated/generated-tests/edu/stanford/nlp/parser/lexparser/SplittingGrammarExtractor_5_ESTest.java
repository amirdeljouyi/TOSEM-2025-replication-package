/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Jun 11 21:16:34 GMT 2025
 */

package edu.stanford.nlp.parser.lexparser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.PresetSequenceClassifier;
import edu.stanford.nlp.international.morph.MorphoFeatureSpecification;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.StringLabelFactory;
import edu.stanford.nlp.ling.Tag;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.TaggedWordFactory;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordFactory;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.parser.lexparser.ArabicTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.FrenchTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.HebrewTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.ItalianTreebankParserParams;
import edu.stanford.nlp.parser.lexparser.Options;
import edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.trees.BasicCategoryTreeTransformer;
import edu.stanford.nlp.trees.BobChrisTreeNormalizer;
import edu.stanford.nlp.trees.CoordinationTransformer;
import edu.stanford.nlp.trees.DiskTreebank;
import edu.stanford.nlp.trees.HeadFinder;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.LabeledScoredTreeNode;
import edu.stanford.nlp.trees.LeftHeadFinder;
import edu.stanford.nlp.trees.MemoryTreebank;
import edu.stanford.nlp.trees.NPTmpRetainingTreeNormalizer;
import edu.stanford.nlp.trees.PennTreebankLanguagePack;
import edu.stanford.nlp.trees.QPTreeTransformer;
import edu.stanford.nlp.trees.RightHeadFinder;
import edu.stanford.nlp.trees.SimpleTree;
import edu.stanford.nlp.trees.SimpleTreeFactory;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeFactory;
import edu.stanford.nlp.trees.TreeFilters;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreeGraphNodeFactory;
import edu.stanford.nlp.trees.TreeReaderFactory;
import edu.stanford.nlp.trees.TreeTransformer;
import edu.stanford.nlp.trees.TreebankLanguagePack;
import edu.stanford.nlp.util.ArrayCoreMap;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.Filters;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.ThreeDimensionalMap;
import edu.stanford.nlp.util.Triple;
import edu.stanford.nlp.util.TwoDimensionalMap;
import java.io.BufferedReader;
import java.io.StringReader;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.Supplier;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.EvoSuiteURL;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.testdata.NetworkHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class SplittingGrammarExtractor_5_ESTest extends SplittingGrammarExtractor_5_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      LinkedHashSet<double[][][]> linkedHashSet0 = new LinkedHashSet<double[][][]>();
      double[][][] doubleArray0 = new double[6][4][7];
      threeDimensionalMap0.put("-", "-", "-", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Vector<Tree> vector0 = new Vector<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("-", (List<Tree>) vector0);
      Tree tree1 = labeledScoredTreeFactory0.newTreeNode((Label) tree0, (List<Tree>) vector0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, tree1, tree1, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[5][4];
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, true);
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      doubleArray0[1] = doubleArray1;
      double[] doubleArray2 = new double[8];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      doubleArray0[2] = doubleArray2;
      double[] doubleArray3 = new double[3];
      doubleArray3[0] = 0.0;
      doubleArray3[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray0[3] = doubleArray3;
      double[] doubleArray4 = new double[6];
      doubleArray4[0] = 5.5;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = (double) 100;
      doubleArray4[3] = (double) 100;
      doubleArray4[4] = 3427.392;
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      IndexedWord indexedWord0 = new IndexedWord();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0, arrayList0);
      Tree tree0 = treeGraphNode0.localTree();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap0, identityHashMap0);
      assertFalse(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[5][4];
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, true);
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      doubleArray0[1] = doubleArray1;
      double[] doubleArray2 = new double[8];
      doubleArray2[7] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      doubleArray0[2] = doubleArray2;
      double[] doubleArray3 = new double[3];
      doubleArray3[0] = 0.0;
      doubleArray3[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray0[3] = doubleArray2;
      double[] doubleArray4 = new double[6];
      doubleArray4[0] = 5.5;
      doubleArray4[2] = (double) 100;
      doubleArray4[3] = (double) 100;
      doubleArray4[4] = 3427.392;
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      IndexedWord indexedWord0 = new IndexedWord();
      ArrayList<Tree> arrayList0 = new ArrayList<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0, arrayList0);
      Tree tree0 = treeGraphNode0.localTree();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, tree0, identityHashMap0, identityHashMap0);
      assertEquals(Double.NaN, tree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasWithFalse0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[5][4];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      doubleArray0[1] = doubleArray1;
      double[] doubleArray2 = new double[4];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      doubleArray0[2] = doubleArray2;
      double[] doubleArray3 = new double[3];
      doubleArray3[0] = 0.0;
      doubleArray3[1] = (double) 100;
      doubleArray2[2] = 0.0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray4 = new double[2][1][7];
      doubleArray4[0] = doubleArray0;
      doubleArray4[1] = doubleArray0;
      threeDimensionalMap1.put("x7\"hoPeCFqPjJmK", (String) null, "x7\"hoPeCFqPjJmK", doubleArray4);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap1, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][] doubleArray0 = new double[2][4];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      doubleArray0[1] = doubleArray1;
      LinkedHashSet<double[][][]> linkedHashSet0 = new LinkedHashSet<double[][][]>();
      double[][][] doubleArray2 = new double[2][8][0];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      threeDimensionalMap0.put("-", "-", "-", doubleArray2);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasWithFalse1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[5][4];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[2];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = 0.0;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[4];
      doubleArray3[0] = (double) 100;
      doubleArray3[1] = (double) 100;
      doubleArray3[2] = (double) 100;
      doubleArray3[3] = 0.0;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[3];
      doubleArray4[0] = 0.0;
      doubleArray4[1] = (double) 100;
      doubleArray3[2] = 0.0;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[6];
      doubleArray5[0] = 5.5;
      doubleArray5[1] = 0.0;
      doubleArray5[2] = (double) 100;
      doubleArray5[3] = (double) 100;
      doubleArray5[4] = 3427.392;
      doubleArray5[5] = 0.0;
      doubleArray0[4] = doubleArray5;
      twoDimensionalMap0.put("tjQ", (String) null, doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasWithFalse2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[5][4];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      doubleArray0[1] = doubleArray1;
      double[] doubleArray2 = new double[4];
      doubleArray2[0] = (double) 100;
      doubleArray2[1] = (double) 100;
      doubleArray2[2] = (double) 100;
      doubleArray2[3] = 0.0;
      doubleArray0[2] = doubleArray2;
      double[] doubleArray3 = new double[3];
      doubleArray3[0] = 0.0;
      doubleArray3[1] = (double) 100;
      doubleArray2[2] = 0.0;
      doubleArray0[3] = doubleArray3;
      double[] doubleArray4 = new double[6];
      doubleArray4[0] = 5.5;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = (double) 100;
      doubleArray4[3] = (double) 100;
      doubleArray4[4] = 3427.392;
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsWithNonEmptyMapAndNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = Word.EMPTY;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode2 = new TreeGraphNode(word0, list0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(74, false);
      Tree tree0 = treeGraphNode2.transform((TreeTransformer) nPTmpRetainingTreeNormalizer0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor2.recountInside(treeGraphNode2, false, 100, identityHashMap0);
      Tree tree1 = treeGraphNode2.lastChild();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside(tree0, (Tree) treeGraphNode1, tree1, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideWithNonEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      simpleTree0.addChild((Tree) treeGraphNode0);
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(simpleTree0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree(simpleTree0, list1);
      simpleTree1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, 100, identityHashMap0, identityHashMap1);
      assertNotSame(treeGraphNode1, treeGraphNode0);
      
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(simpleTree1, false, 1081, identityHashMap2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndSplitBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][7];
      twoDimensionalMap0.put("t@:", "Thib", doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      ArabicTreebankParserParams arabicTreebankParserParams0 = null;
      try {
        arabicTreebankParserParams0 = new ArabicTreebankParserParams();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.trees.tregex.TregexParser
         //
         verifyException("edu.stanford.nlp.trees.tregex.TregexPatternCompiler", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("<sente'ce id=");
      CoreLabel coreLabel1 = new CoreLabel(coreLabel0);
      CoreLabel coreLabel2 = new CoreLabel((CoreMap) coreLabel1);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(coreLabel2, list0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer(pennTreebankLanguagePack0);
      Tree tree0 = treeGraphNode1.transform((TreeTransformer) bobChrisTreeNormalizer0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, true, 100, identityHashMap0);
      assertEquals(101, int0);
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndOutputTransitionsTaking4ArgumentsAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("<sente'ce id=");
      CoreLabel coreLabel1 = new CoreLabel(coreLabel0);
      CoreLabel coreLabel2 = new CoreLabel((CoreMap) coreLabel1);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) coreLabel2, list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, (-1), identityHashMap1, identityHashMap2);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray0 = new double[0];
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 329, identityHashMap3, identityHashMap2, (Map<String, double[]>) hashMap0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("g%o");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      treeGraphNode1.highestNodeWithSameHead();
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndSplitBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][7];
      twoDimensionalMap0.put("Thib", "Thib", doubleArray0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      LeftHeadFinder leftHeadFinder0 = new LeftHeadFinder();
      splittingGrammarExtractor0.splitBetas();
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideReturningNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("<sente'ce id=");
      CoreLabel coreLabel1 = new CoreLabel(coreLabel0);
      CoreLabel coreLabel2 = new CoreLabel((CoreMap) coreLabel1);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(coreLabel2, list0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer(pennTreebankLanguagePack0);
      Tree tree0 = treeGraphNode1.transform((TreeTransformer) bobChrisTreeNormalizer0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(tree0, true, (-990), identityHashMap0);
      assertEquals((-989), int0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("<sentence id=");
      CoreLabel coreLabel1 = new CoreLabel(coreLabel0);
      CoreLabel coreLabel2 = new CoreLabel((CoreMap) coreLabel1);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(coreLabel2, list0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer(pennTreebankLanguagePack0);
      Tree tree0 = treeGraphNode1.transform((TreeTransformer) bobChrisTreeNormalizer0);
      tree0.treeFactory();
      pennTreebankLanguagePack0.getCategoryAndFunctionFunction();
      treeGraphNode1.pennPrint();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      coreLabel2.keySet();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      DiskTreebank diskTreebank0 = hebrewTreebankParserParams0.diskTreebank();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1, 0.0, (Collection<Tree>) diskTreebank0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitions()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      CoreLabel coreLabel0 = new CoreLabel();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0, (List<Tree>) null);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(treeGraphNode1, list0);
      simpleTree0.addChild((Tree) treeGraphNode1);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      simpleTree0.indexSpans();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = (double) 86;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 86;
      doubleArray0[5] = (double) 86;
      int int0 = SplittingGrammarExtractor.MAX_DEBUG_ITERATION;
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap1);
      splittingGrammarExtractor0.neginfDoubles(2);
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(simpleTree0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, (IdentityHashMap<Tree, double[][]>) null, identityHashMap3, doubleArray0, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor1.binaryBetas;
      CoreLabel coreLabel0 = new CoreLabel();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0, (List<Tree>) null);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.subTreeList();
      SimpleTree simpleTree0 = new SimpleTree(treeGraphNode1, list0);
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      int int0 = SplittingGrammarExtractor.MAX_DEBUG_ITERATION;
      options0.baseParserWeight = (double) 0;
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      splittingGrammarExtractor1.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      double[] doubleArray0 = splittingGrammarExtractor1.neginfDoubles(5528);
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(simpleTree0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, doubleArray0, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsWithNullAndStateWithEmptyString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("<sentence id=");
      ArrayCoreMap arrayCoreMap0 = new ArrayCoreMap((ArrayCoreMap) coreLabel0);
      CoreLabel coreLabel1 = new CoreLabel(arrayCoreMap0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(coreLabel1, list0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      BobChrisTreeNormalizer bobChrisTreeNormalizer0 = new BobChrisTreeNormalizer(pennTreebankLanguagePack0);
      Tree tree0 = treeGraphNode1.transform((TreeTransformer) bobChrisTreeNormalizer0);
      Map<String, double[]> map0 = null;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, true, (Map<String, double[]>) null, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      splittingGrammarExtractor0.state("", 100);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      String string0 = "i$x\"8`ueu7n";
      String[] stringArray0 = new String[5];
      stringArray0[0] = ".$$.";
      stringArray0[1] = "^100";
      stringArray0[2] = "<sentence id=";
      stringArray0[3] = "^100";
      stringArray0[4] = "<sentence id=";
      // Undeclared exception!
      try { 
        options0.setOptionFlag(stringArray0, (-5458));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index -5458 out of bounds for length 5
         //
         verifyException("edu.stanford.nlp.parser.lexparser.Options", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideWithNegative()  throws Throwable  {
      Options options0 = new Options();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("g%o");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      int int0 = splittingGrammarExtractor0.recountInside(treeGraphNode2, true, (-2554), identityHashMap0);
      assertEquals((-2553), int0);
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceReturningMapWhereIsEmptyIsFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      Properties properties0 = options0.testOptions.evals;
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      Set<String> set0 = presetSequenceClassifier0.labels();
      splittingGrammarExtractor0.originalStates = set0;
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      double[][][] doubleArray0 = new double[6][7][7];
      threeDimensionalMap0.put("-", "-", "-", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      twoDimensionalMap0.size();
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<Object, String> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      Map<String, int[]> map1 = mapFactory0.setMap(map0, 100);
      splittingGrammarExtractor0.recalculateMergedBetas(map1);
      assertFalse(map1.equals((Object)map0));
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondence0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Properties properties0 = options0.testOptions.evals;
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      Set<String> set0 = presetSequenceClassifier0.labels();
      splittingGrammarExtractor0.originalStates = set0;
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      assertEquals(1, map0.size());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerExceptionAndDEBUGAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      options0.useUnigramWordSmoothing = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      double[][][] doubleArray0 = new double[6][7][7];
      threeDimensionalMap0.put("-", "-", "-", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      int int0 = splittingGrammarExtractor0.iteration;
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.DEBUG();
      TreeGraphNodeFactory treeGraphNodeFactory0 = new TreeGraphNodeFactory();
      IndexedWord indexedWord0 = IndexedWord.NO_WORD;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      Tree tree0 = treeGraphNodeFactory0.newTreeNode("-", list0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (-1448.5298784307224), (Collection<Tree>) list0, (-1448.5298784307224));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.IntTaggedWord", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      treeGraphNode0.subTrees(list0);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions(tree0, 64, identityHashMap3, identityHashMap5);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsWithFalse()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag("YzxaAoQ8Dm}n*;");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) wordLemmaTag0, list0);
      labeledScoredTreeFactory0.newLeaf("j<I=P\"");
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Comparator<Tag> comparator0 = (Comparator<Tag>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap4 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = new HashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, false, map0, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.DEBUG();
      IdentityHashMap<Tree, double[]> identityHashMap5 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(treeGraphNode0, identityHashMap5, identityHashMap5);
      assertNotSame(splittingGrammarExtractor0, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3Arguments0()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) simpleTree0, list0);
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap3, identityHashMap4);
      splittingGrammarExtractor0.recalculateBetas(true);
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
      assertEquals(0, hashMap0.size());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments0()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      treeGraphNode0.subTrees(list0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("-N2W");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, (-1), identityHashMap1, identityHashMap5);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0, (double) 100, (Collection<Tree>) tree0, (double) 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      treeGraphNode0.subTrees(list0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0, (double) 100, (Collection<Tree>) tree0, (double) 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException0()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      treeGraphNode0.subTreeList();
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      LabeledWord labeledWord0 = new LabeledWord();
      LinkedList<Tree> linkedList1 = new LinkedList<Tree>(simpleTree0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) labeledWord0, (List<Tree>) linkedList1);
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      Object object0 = new Object();
      Object object1 = new Object();
      identityHashMap4.remove(object0, object1);
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, (-1223), identityHashMap1, identityHashMap4);
      splittingGrammarExtractor0.recalculateBetas(true);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[] doubleArray0 = new double[0];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 73, identityHashMap3, identityHashMap4, (Map<String, double[]>) hashMap0, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new LinkedHashSet<double[][][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      double[][][] doubleArray0 = new double[6][7][7];
      threeDimensionalMap0.put("-N2W", "-N2W", "-N2W", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray1 = new double[3][7];
      twoDimensionalMap0.put("tjQ", "This", doubleArray1);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateBetas(false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("<sentence id=");
      CoreLabel coreLabel1 = new CoreLabel((CoreMap) coreLabel0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel1);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(coreLabel1, list0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, false);
      Tree tree0 = treeGraphNode1.transform((TreeTransformer) nPTmpRetainingTreeNormalizer0);
      pennTreebankLanguagePack0.getCategoryAndFunctionFunction();
      treeGraphNode0.pennPrint();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      hebrewTreebankParserParams0.diskTreebank();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.extract((Collection<Tree>) treeGraphNode1, 525.841241135, (Collection<Tree>) tree0, 1231.67539366153);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException1()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) simpleTree0, list0);
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap3, identityHashMap4);
      splittingGrammarExtractor0.recalculateBetas(true);
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(tree0, doubleArray0, 247, identityHashMap1, identityHashMap4, (Map<String, double[]>) hashMap0, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsWithTrueAndNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = Word.EMPTY;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.buildMergeCorrespondence(linkedList0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) treeGraphNode1, true, (Map<String, double[]>) identityHashMap0, (TwoDimensionalMap<String, String, double[][]>) null, threeDimensionalMap0);
      assertNotSame(treeGraphNode1, treeGraphNode0);
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking6ArgumentsThrowsRuntimeException()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashIndex<String> hashIndex0 = new HashIndex<String>();
      splittingGrammarExtractor0.wordIndex = (Index<String>) hashIndex0;
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.recalculateBetas(false);
      LabelFactory labelFactory0 = TaggedWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      IndexedWord indexedWord0 = new IndexedWord();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      MemoryTreebank memoryTreebank0 = hebrewTreebankParserParams0.memoryTreebank();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) indexedWord0, (List<Tree>) memoryTreebank0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree(tree0, false, identityHashMap0, identityHashMap1, identityHashMap2, identityHashMap3);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      double[][][] doubleArray0 = new double[6][7][7];
      threeDimensionalMap0.put("-N2W", "-N2W", "-N2W", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray1 = new double[1][7];
      double[] doubleArray2 = new double[2];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = (-50.0);
      doubleArray1[0] = doubleArray2;
      twoDimensionalMap0.put("tjQ", "This", doubleArray1);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>(100, 149);
      Filters.RandomFilter<Object> filters_RandomFilter0 = new Filters.RandomFilter<Object>();
      Predicate<Object> predicate0 = Predicate.not(filters_RandomFilter0);
      Double double0 = new Double((-1345.20519));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("tjQ", (Integer) 100, double0);
      Object object0 = new Object();
      triple0.equals(object0);
      vector0.add(triple0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      vector0.removeIf(predicate0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      NPTmpRetainingTreeNormalizer.NPTmpRetainingTreeReaderFactory nPTmpRetainingTreeNormalizer_NPTmpRetainingTreeReaderFactory0 = new NPTmpRetainingTreeNormalizer.NPTmpRetainingTreeReaderFactory();
      Tree.valueOf("-N2W", (TreeReaderFactory) nPTmpRetainingTreeNormalizer_NPTmpRetainingTreeReaderFactory0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.testMemoryTreebank();
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode((Label) null, memoryTreebank0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel$CoreLabelFactory", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments1()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      List<Tree> list0 = treeGraphNode1.subTreeList();
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("-N2W");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode1, list0);
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode1, (-1), identityHashMap1, identityHashMap5);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0, (double) 100, (Collection<Tree>) tree0, (double) 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      double[][][] doubleArray0 = new double[6][7][7];
      threeDimensionalMap0.put("-N2W", "-N2W", "-N2W", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray1 = new double[1][7];
      double[] doubleArray2 = new double[2];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = (-50.0);
      doubleArray1[0] = doubleArray2;
      twoDimensionalMap0.put("tjQ", "This", doubleArray1);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>(100, 149);
      Filters.RandomFilter<Object> filters_RandomFilter0 = new Filters.RandomFilter<Object>();
      Predicate<Object> predicate0 = Predicate.not(filters_RandomFilter0);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      vector0.removeIf(predicate0);
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      QPTreeTransformer qPTreeTransformer0 = null;
      try {
        qPTreeTransformer0 = new QPTreeTransformer();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateSplittingGrammarExtractorThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = Word.EMPTY;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, false);
      treeGraphNode0.parent();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode1, (double) 100, (Collection<Tree>) treeGraphNode0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag("YzxaAoQ8Dm}n*;");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) wordLemmaTag0, list0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      Comparator<Tag> comparator0 = (Comparator<Tag>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<Tag, Tag> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap4 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(identityHashMap4);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateTemporaryBetas(tree0, false, map0, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.TreeMap", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][7];
      twoDimensionalMap0.put("t@:", "This", doubleArray0);
      boolean boolean0 = NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "t@:");
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.splitBetas();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean1 = splittingGrammarExtractor0.DEBUG();
      assertTrue(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergence0()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.remove(">]M0NN18CLb5", "V9DEV*Wxb-t#p");
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      twoDimensionalMap0.remove("V9DEV*Wxb-t#p");
      twoDimensionalMap0.forEach(consumer0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      Stack<String> stack0 = new Stack<String>();
      assertTrue(stack0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) treeGraphNode0, list0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0, (double) 100, (Collection<Tree>) tree0, (double) 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments2()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag("YzxaAoQ8Dm}n*;");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) simpleTree0, list0);
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, (-3), identityHashMap3, identityHashMap5);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, (double) 100, (Collection<Tree>) simpleTree0, 497.26510563);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetas0()  throws Throwable  {
      Options options0 = new Options();
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.remove("frc", "frc");
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testTestConvergence1()  throws Throwable  {
      Options options0 = new Options();
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.remove("frc", "frc");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRescaleTemporaryBetas0()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.remove(">]M0NN18CLb5", "V9DEV*Wxb-t#p");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[1][7];
      twoDimensionalMap0.put("t@:", "t@:", doubleArray0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsThrowsNoClassDefFoundError()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      double[][][] doubleArray0 = new double[6][7][7];
      threeDimensionalMap0.put("-N2W", "-N2W", "-N2W", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray1 = new double[1][7];
      double[] doubleArray2 = new double[2];
      doubleArray2[0] = 0.0;
      doubleArray2[1] = (-50.0);
      doubleArray1[0] = doubleArray2;
      twoDimensionalMap0.put("tjQ", "This", doubleArray1);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>(100, 149);
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      QPTreeTransformer qPTreeTransformer0 = null;
      try {
        qPTreeTransformer0 = new QPTreeTransformer();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasWithTrue0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      double[][] doubleArray0 = new double[3][7];
      twoDimensionalMap0.put("tjQ", "This", doubleArray0);
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetas()  throws Throwable  {
      Options options0 = new Options();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.iteration = (-1752);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerExceptionAndRescaleTemporaryBetas()  throws Throwable  {
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      twoDimensionalMap0.remove("8k", "8k");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, (Tree) simpleTree0, (Tree) treeGraphNode0, identityHashMap1, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      double[][] doubleArray0 = new double[0][2];
      twoDimensionalMap0.put((String) null, (String) null, doubleArray0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 0 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRescaleTemporaryBetas1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      twoDimensionalMap0.remove("V9DEV*Wxb-t#p", "V9DEV*Wxb-t#p");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideAndRecountOutsideTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      Tree tree0 = hebrewTreebankParserParams0.transformTree(simpleTree0, simpleTree0);
      simpleTree0.addChild(tree0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Integer integer0 = new Integer(100);
      Double double0 = new Double(100);
      Triple<String, Integer, Double> triple0 = Triple.makeTriple("eab6BY`0", integer0, double0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple0, triple0, triple0, triple0, triple0, triple0, triple0, triple0);
      splittingGrammarExtractor0.buildMergeCorrespondence(list0);
      boolean boolean0 = false;
      splittingGrammarExtractor0.recountInside(tree0, boolean0, options0.rerankerKBest, identityHashMap3);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside(tree0, (Tree) simpleTree0, identityHashMap3, identityHashMap4);
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      double[][][] doubleArray0 = new double[6][7][7];
      threeDimensionalMap0.put("-N2W", "-N2W", "-N2W", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray1 = new double[1][7];
      twoDimensionalMap0.put("tjQ", "This", doubleArray1);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>(100, 149);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      splittingGrammarExtractor0.countOriginalStates();
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetas1()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[6][7][7];
      double[] doubleArray1 = new double[8];
      doubleArray1[0] = 0.0;
      doubleArray1[2] = 0.0;
      doubleArray1[4] = (double) 100;
      doubleArray1[5] = 6.283185307179586;
      doubleArray1[6] = (double) 100;
      doubleArray1[7] = (double) 100;
      threeDimensionalMap1.put("Iteration ", "Iteration ", "-N2W", doubleArray0);
      threeDimensionalMap1.get("{ti", "{ti");
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.hashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.identityHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap1);
      assertSame(threeDimensionalMap1, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitionsWithEmptyMap()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashSet<double[][][]> hashSet0 = new LinkedHashSet<double[][][]>();
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      Tree tree0 = hebrewTreebankParserParams0.transformTree(simpleTree0, simpleTree0);
      simpleTree0.addChild(tree0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = 0.01;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap1, identityHashMap2, identityHashMap3, identityHashMap2, doubleArray0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndMergeTransitionsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Tree tree0 = chineseTreebankParserParams0.transformTree(simpleTree0, simpleTree0);
      simpleTree0.addChild(tree0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.mergeTransitions(tree0, (IdentityHashMap<Tree, double[][]>) null, identityHashMap4, (IdentityHashMap<Tree, double[][]>) null, identityHashMap5, (double[]) null, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsThrowsNullPointerExceptionAndBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      Tree tree0 = hebrewTreebankParserParams0.transformTree(simpleTree0, simpleTree0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      tree0.addChild((Tree) simpleTree0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>(100);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, (double[]) null, map0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap1.get("LEXICON", "UPPR");
      splittingGrammarExtractor0.neginfDoubles(100);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree(simpleTree0, list0);
      simpleTree1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, (Map<String, double[]>) identityHashMap3, (Map<String, double[]>) identityHashMap3, identityHashMap4, identityHashMap4);
      IdentityHashMap<Tree, double[]> identityHashMap5 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(simpleTree1, identityHashMap4, identityHashMap5);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerException0()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.addChild((Tree) simpleTree0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      LeftHeadFinder leftHeadFinder0 = new LeftHeadFinder();
      Tree tree0 = leftHeadFinder0.determineHead((Tree) simpleTree0, (Tree) simpleTree0);
      simpleTree0.addChild(tree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(simpleTree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetas1()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[6][7][7];
      threeDimensionalMap0.put("2W", "2W", "2W", doubleArray0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Tree tree0 = chineseTreebankParserParams0.transformTree(simpleTree0, simpleTree0);
      simpleTree0.addChild(tree0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 2400;
      doubleArray0[1] = 6.536;
      doubleArray0[2] = 5.0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 68, (IdentityHashMap<Tree, double[][]>) null, identityHashMap3, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndNeginfDoubles()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree(wordLemmaTag0, list0);
      simpleTree1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.neginfDoubles(100);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      italianTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(wordLemmaTag0, list0);
      List<Tree> list1 = treeGraphNode1.subTreeList();
      TaggedWordFactory taggedWordFactory0 = new TaggedWordFactory();
      Label label0 = taggedWordFactory0.newLabel("AJ|@ ;E9H r7oA9cV", 100);
      SimpleTree simpleTree2 = new SimpleTree(label0, list0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(taggedWordFactory0);
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("AJ|@ ;E9H r7oA9cV", list1);
      simpleTree1.addChild(tree0);
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap5 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap6 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap7 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(tree0, identityHashMap6, identityHashMap5, identityHashMap1, identityHashMap7);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException3()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree(wordLemmaTag0, list0);
      simpleTree1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree1, doubleArray0, 86, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException4()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree(wordLemmaTag0, list0);
      simpleTree1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree1, doubleArray0, 2400, (IdentityHashMap<Tree, double[][]>) null, identityHashMap2, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException5()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.addChild((Tree) simpleTree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      Map<String, double[]> map0 = null;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 19000, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecountWeightsAndNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap1.get("LEXICON", "UPPER");
      splittingGrammarExtractor0.neginfDoubles(100);
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      MemoryTreebank memoryTreebank0 = italianTreebankParserParams0.memoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, memoryTreebank0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree(simpleTree0, list0);
      simpleTree1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(simpleTree1, identityHashMap3, identityHashMap3, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildStateIndexThrowsNullPointerException()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree(wordLemmaTag0, list0);
      simpleTree1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(simpleTree1, identityHashMap2, identityHashMap2, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitionsWithNullAndMergeTransitions()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      treeGraphNode0.subTreeList();
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 100;
      splittingGrammarExtractor1.mergeTransitions(simpleTree0, identityHashMap1, identityHashMap2, identityHashMap1, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, identityHashMap0);
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      assertTrue(identityHashMap4.equals((Object)identityHashMap3));
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasThrowsRuntimeExceptionAndSaveTreesWithPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Word word0 = Word.EMPTY;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      List<Tree> list0 = treeGraphNode0.preOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(treeGraphNode0, list0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      splittingGrammarExtractor0.saveTrees(treeGraphNode1, 8.0, treeGraphNode0, (-255.074263497));
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3Arguments1()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      TreebankLanguagePack treebankLanguagePack0 = englishTreebankParserParams0.treebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      Tree tree0 = hebrewTreebankParserParams0.transformTree(simpleTree0, simpleTree0);
      simpleTree0.addChild(tree0);
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      HashMap<String, double[]> hashMap1 = new HashMap<String, double[]>(544);
      splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) hashMap1, (Map<String, double[]>) hashMap1);
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerExceptionAndRecurseOutside()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      TreebankLanguagePack treebankLanguagePack0 = englishTreebankParserParams0.treebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      Tree tree0 = hebrewTreebankParserParams0.transformTree(simpleTree0, simpleTree0);
      simpleTree0.addChild(tree0);
      IdentityHashMap<String, int[]> identityHashMap1 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap5 = new IdentityHashMap<Tree, double[]>();
      Options options1 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recurseOutside(simpleTree0, identityHashMap5, identityHashMap5);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsThrowsNullPointerExceptionAndRecountWeights()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "Post-split betas");
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      TreebankLanguagePack treebankLanguagePack0 = englishTreebankParserParams0.treebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(treebankLanguagePack0);
      Tree tree0 = hebrewTreebankParserParams0.transformTree(simpleTree0, simpleTree0);
      simpleTree0.addChild(tree0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap1, identityHashMap1, identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4Arguments()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree();
      simpleTree1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag("$[=t_\"X8;ia#h'");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) simpleTree1, list0);
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap6 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap6, identityHashMap2, identityHashMap1, identityHashMap5);
      splittingGrammarExtractor0.outputTransitions(tree0, 100, identityHashMap4, identityHashMap5);
      assertTrue(identityHashMap4.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeExceptionAndRecountInside()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree(wordLemmaTag0, list0);
      simpleTree1.addChild((Tree) treeGraphNode0);
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)38;
      byte byte0 = (byte) (-97);
      byteArray0[1] = (byte) (-97);
      byteArray0[2] = (byte)10;
      byteArray0[3] = (byte) (-61);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(simpleTree1, true, 100, identityHashMap3);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsRuntimeException()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree(wordLemmaTag0, list0);
      simpleTree1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree1, (Map<String, double[]>) identityHashMap1, (Map<String, double[]>) identityHashMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      simpleTree0.addChild((Tree) simpleTree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recurseOutside(simpleTree0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutside0()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      simpleTree0.addChild((Tree) treeGraphNode0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(simpleTree0, identityHashMap0, identityHashMap0);
      assertEquals(Double.NaN, simpleTree0.score(), 0.01);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNull()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree();
      simpleTree1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      WordLemmaTag wordLemmaTag1 = new WordLemmaTag("$[=t_\"X8;ia#h'");
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode((Label) simpleTree1, list0);
      MapFactory<LinkedList<Object>, CoreLabel> mapFactory0 = MapFactory.weakHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory0.setMap(hashMap0, 2246);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, map0, (Map<String, double[]>) null, identityHashMap2, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.addChild((Tree) simpleTree0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsWithNullAndSaveTreesWithNull()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      SimpleTree simpleTree0 = new SimpleTree();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      EnglishTreebankParserParams englishTreebankParserParams0 = new EnglishTreebankParserParams();
      MemoryTreebank memoryTreebank0 = englishTreebankParserParams0.testMemoryTreebank();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, memoryTreebank0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      TreeFilters.HasMatchingChild treeFilters_HasMatchingChild0 = new TreeFilters.HasMatchingChild(pennTreebankLanguagePack0, "W$J_F#R&lo~=P}");
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode();
      TreeFactory treeFactory0 = labeledScoredTreeNode0.treeFactory();
      treeGraphNode0.spliceOut((Predicate<Tree>) treeFilters_HasMatchingChild0, treeFactory0);
      splittingGrammarExtractor0.saveTrees(simpleTree0, 100, (Collection<Tree>) null, 899.69607377169);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>(80);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) null, (Map<String, double[]>) null, (Map<String, double[]>) null, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerExceptionAndRecountInsideWithTreeWhereScoreIsPositive()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(simpleTree0, true, 100, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException1()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree(simpleTree0, list0);
      simpleTree1.addChild((Tree) simpleTree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree1, 100, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndRecalculateTemporaryBetasTaking4ArgumentsAndRescaleTemporaryBetas()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.get(" | ", "{MoJHiMUu,Z{]H%");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      StringReader stringReader0 = new StringReader("{MoJHiMUu,Z{]H%");
      BufferedReader bufferedReader0 = new BufferedReader(stringReader0, 93);
      BufferedReader bufferedReader1 = new BufferedReader(bufferedReader0);
      Morphology morphology0 = new Morphology(bufferedReader1, 2107);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap2 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.treeMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.weakHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap3 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) hashMap0, twoDimensionalMap1, threeDimensionalMap3);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options1);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap4 = splittingGrammarExtractor1.binaryBetas;
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap2);
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap1, threeDimensionalMap4);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      Object object0 = new Object();
      identityHashMap4.remove((Object) treeGraphNode0, object0);
      identityHashMap4.putAll(identityHashMap1);
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap4, identityHashMap4, identityHashMap2, identityHashMap3);
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 100, identityHashMap2, identityHashMap5);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeightsWithNullAndNull()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.addChild((Tree) simpleTree0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountWeights(simpleTree0, (IdentityHashMap<Tree, double[]>) null, (IdentityHashMap<Tree, double[]>) null, identityHashMap1, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3Arguments2()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode0, list0);
      splittingGrammarExtractor0.countMergeEffects((Tree) labeledScoredTreeNode0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
      assertTrue(hashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsWithTreeWhereScoreIsPositive()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.addChild((Tree) simpleTree0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 100, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeException1()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[6][7][7];
      threeDimensionalMap0.put("@", "@", "@", doubleArray0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0, 0.0, (Collection<Tree>) simpleTree0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesReturningEmptyArray()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.transform(null);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.thirdKeySet();
      threeDimensionalMap0.get("  Log Split -> ", ":qRyw/~!4$cN{v{E", "  Log Split -> ");
      threeDimensionalMap0.values();
      threeDimensionalMap0.get("%__0", "%__0");
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateBetas(true);
      Options options1 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor1.neginfDoubles(0);
      splittingGrammarExtractor1.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.splitBetas();
      System.setCurrentTimeMillis(1995L);
      splittingGrammarExtractor1.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Options options2 = new Options(options0.tlpParams);
      Options options3 = new Options(options1.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options3);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Tree tree0 = simpleTreeFactory0.newLeaf((Label) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recountInside(tree0, false, 100, identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeAndDEBUGAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      HashSet<Tree> hashSet0 = new HashSet<Tree>();
      splittingGrammarExtractor0.outputTransitions((Tree) treeGraphNode0, 100, identityHashMap1, identityHashMap2);
      int int0 = splittingGrammarExtractor0.getStateSplitCount((Tree) treeGraphNode0);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesThrowsNegativeArraySizeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.transform(null);
      options0.genStop = false;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap0.thirdKeySet();
      threeDimensionalMap0.get("l@]R~P?zS  O-%", "  Log Split -> ", "l@]R~P?zS  O-%");
      threeDimensionalMap0.values();
      threeDimensionalMap0.get("l@]R~P?zS  O-%", ": ");
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.recalculateBetas(false);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.neginfDoubles((-2461));
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // -2461
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndUseNewBetas()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[6][7][7];
      double[] doubleArray1 = new double[8];
      doubleArray1[0] = 0.0;
      doubleArray1[2] = 0.0;
      doubleArray1[4] = (double) 100;
      doubleArray1[5] = 6.283185307179586;
      doubleArray1[6] = (double) 100;
      doubleArray1[7] = (double) 100;
      threeDimensionalMap1.put("Iteration ", "Iteration ", "-N2W", doubleArray0);
      threeDimensionalMap1.get("{ti", "{ti");
      splittingGrammarExtractor0.recalculateBetas(true);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testUseNewBetasAndUseNewBetasWithTrue1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[6][4][7];
      threeDimensionalMap0.put("-", "-", "-", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      boolean boolean0 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException6()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.saveTrees(simpleTree0, (-809.216604546), simpleTree0, (-809.216604546));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (-809.216604546);
      doubleArray0[1] = (-809.216604546);
      doubleArray0[2] = (-809.216604546);
      doubleArray0[3] = (-4057.293942);
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap1, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException7()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.addChild((Tree) simpleTree0);
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.identityHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, (double[]) null, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerException2()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      double double0 = (-809.216604546);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeGraphNode0, 1.0E-4, (Collection<Tree>) simpleTree0, 5.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerExceptionAndExtractTaking4ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      simpleTree0.addChild((Tree) treeGraphNode0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0, (double) 100, (Collection<Tree>) simpleTree0, 0.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.saveTrees(simpleTree0, (-809.216604546), simpleTree0, (-809.216604546));
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateMergedBetas(identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3Arguments3()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.addChild((Tree) simpleTree0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      simpleTree0.addChild((Tree) treeGraphNode0);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsThrowsNullPointerExceptionAndDEBUG()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap.hashMap();
      IdentityHashMap<String, double[]> identityHashMap3 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, (Tree) treeGraphNode0, (Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      SimpleTree simpleTree0 = new SimpleTree();
      splittingGrammarExtractor0.saveTrees(treeSet0, 1554.776980983637, simpleTree0, 0.0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>(100);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) null, twoDimensionalMap1, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceAndBuildMergeCorrespondenceThrowsNullPointerException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.pennPrint();
      Integer integer0 = new Integer((-1133));
      Double double0 = new Double((-468.048505214429));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>(" iterations", integer0, double0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      linkedList0.push(triple0);
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.buildMergeCorrespondence(linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      double[][][] doubleArray0 = new double[10][3][7];
      threeDimensionalMap0.put("-N2W", "-N2W", "-N2W", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      Integer integer0 = new Integer((-302));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("-N2W", integer0, (Double) 0.0);
      Integer integer1 = new Integer((-729));
      Triple<String, Integer, Double> triple1 = Triple.makeTriple("t@q", integer1, 0.0);
      List<Triple<String, Integer, Double>> list0 = List.of(triple0, triple0, triple0, triple1, triple1, triple0, triple1, triple1, triple1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.buildMergeCorrespondence(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasThrowsRuntimeExceptionAndSaveTreesWithNegative()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      SimpleTree simpleTree0 = new SimpleTree();
      double double0 = 1536.5364591813825;
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      double double1 = (-793.82);
      splittingGrammarExtractor0.saveTrees(simpleTree0, (-793.82), treeSet0, (-447.929168122));
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking5ArgumentsThrowsRuntimeException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag((String) null);
      Options options0 = new Options();
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabelFromString("0B^y<t`X=");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      Map<String, double[]> map0 = null;
      chineseTreebankParserParams0.useCharBasedUnknownWordModel = false;
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) treeGraphNode0, false, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningZero()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.pennPrint();
      splittingGrammarExtractor0.recalculateBetas(false);
      Options options1 = new Options(chineseTreebankParserParams0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, (double[]) null, 0, identityHashMap0, identityHashMap1, (Map<String, double[]>) identityHashMap2, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      boolean boolean0 = splittingGrammarExtractor0.testConvergence((TwoDimensionalMap<String, String, double[][]>) null, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      wordLemmaTag0.setWord("excise sq sq");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      MapFactory<CoreLabel.GenericAnnotation<String>, CoreLabel.GenericAnnotation<Object>> mapFactory0 = MapFactory.identityHashMapFactory();
      mapFactory0.setMap(null, 0);
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) treeGraphNode0, (Tree) treeGraphNode0, identityHashMap0, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking3Arguments()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountOutside((Tree) simpleTree0, identityHashMap0, identityHashMap0);
      splittingGrammarExtractor0.mergeStates();
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningNegative()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<CoreLabel>, String> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      MapFactory<WordTag, List<String>> mapFactory1 = MapFactory.arrayMapFactory();
      Map<String, double[]> map0 = mapFactory1.setMap(null, 100);
      mapFactory0.setMap(map0, 2524);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>(2);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) null, (Map<String, double[]>) null, identityHashMap1, identityHashMap2);
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      IdentityHashMap<Tree, double[][]> identityHashMap5 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor1.recalculateTemporaryBetas((Tree) simpleTree0, (double[]) null, (-1895), identityHashMap5, identityHashMap4, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0, 889.4602, (Collection<Tree>) simpleTree0, (-1207.4));
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesAndSaveTrees()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      SimpleTree simpleTree0 = new SimpleTree();
      options0.baseParserWeight = 1536.5364591813825;
      splittingGrammarExtractor0.saveTrees(treeSet0, 1536.5364591813825, simpleTree0, 0.0);
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = false;
      options0.distance = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      Stack<Tree> stack0 = new Stack<Tree>();
      splittingGrammarExtractor0.saveTrees(stack0, 100, stack0, 0.45);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      splittingGrammarExtractor0.recalculateBetas(false);
      splittingGrammarExtractor0.extract((Collection<Tree>) stack0, (-157.24), (Collection<Tree>) stack0, (-157.24));
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildGrammars();
      Word word0 = Word.EMPTY;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0, stack0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor1.outputTransitions((Tree) treeGraphNode0, identityHashMap0, identityHashMap1);
      splittingGrammarExtractor0.state("is", (-644));
      splittingGrammarExtractor1.DEBUG();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.splitBetas();
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer(treebankLanguagePack0);
      TaggedWord taggedWord0 = new TaggedWord("XOBU=.iU8t2LiF ", "_MXCPmbD4yKKEy");
      LabeledWord labeledWord0 = new LabeledWord(taggedWord0, taggedWord0);
      SimpleTree simpleTree0 = new SimpleTree(labeledWord0, stack0);
      Tree tree0 = basicCategoryTreeTransformer0.transformHelper(simpleTree0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      Tree.valueOf("is^-644");
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor2.recountWeights(tree0, identityHashMap2, identityHashMap2, identityHashMap3, identityHashMap4);
      assertEquals(0, identityHashMap3.size());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsAndOutputTransitionsTaking3ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<CoreLabel>, String> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      mapFactory0.setMap(null, 100);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(100);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) null, identityHashMap2, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking3ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) null, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      splittingGrammarExtractor1.recalculateTemporaryBetas(false, (Map<String, double[]>) identityHashMap0, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      MapFactory<MorphoFeatureSpecification.MorphoFeatureType, Triple<String, String, Object>> mapFactory0 = MapFactory.hashMapFactory();
      mapFactory0.setMap(null, 61);
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 1554.776980983637;
      splittingGrammarExtractor0.mergeTransitions(simpleTree0, identityHashMap1, identityHashMap2, identityHashMap3, identityHashMap2, doubleArray0, (Map<String, int[]>) null);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(simpleTree0, identityHashMap4, identityHashMap4);
      assertTrue(identityHashMap4.isEmpty());
      
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 100, identityHashMap3, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap4, identityHashMap4, identityHashMap1, identityHashMap5);
      splittingGrammarExtractor0.extract((Collection<Tree>) treeSet0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsRuntimeExceptionAndMergeStatesAndMergeTransitions()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      Tree tree0 = treeGraphNode0.treeSkeletonCopy();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = (double) 100;
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap3, identityHashMap1, identityHashMap4, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, identityHashMap2);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>(1);
      IdentityHashMap<Tree, double[]> identityHashMap5 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside(treeGraphNode0, false, 1, identityHashMap5);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsThrowsNullPointerException8()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = new ArrayList<Tree>();
      SimpleTree simpleTree1 = new SimpleTree(wordLemmaTag0, list0);
      simpleTree1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = 0.0;
      Map<String, double[]> map0 = null;
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree1, doubleArray0, 2400, (IdentityHashMap<Tree, double[][]>) null, identityHashMap2, (Map<String, double[]>) null, twoDimensionalMap0, threeDimensionalMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking8ArgumentsReturningPositive()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      splittingGrammarExtractor1.recalculateTemporaryBetas(false, (Map<String, double[]>) identityHashMap0, twoDimensionalMap1, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      MapFactory<MorphoFeatureSpecification.MorphoFeatureType, Triple<String, String, Object>> mapFactory0 = MapFactory.hashMapFactory();
      mapFactory0.setMap(null, 61);
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (double) 100;
      doubleArray0[3] = 1554.776980983637;
      splittingGrammarExtractor0.mergeTransitions(simpleTree0, identityHashMap1, identityHashMap2, identityHashMap3, identityHashMap2, doubleArray0, (Map<String, int[]>) null);
      IdentityHashMap<Tree, double[]> identityHashMap4 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(simpleTree0, identityHashMap4, identityHashMap4);
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, doubleArray0, 100, identityHashMap3, identityHashMap2, (Map<String, double[]>) identityHashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap4, identityHashMap4, identityHashMap1, identityHashMap5);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 100, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndRecalculateTemporaryBetasTaking8Arguments()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory.identityHashMapFactory();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas((Tree) simpleTree0, (double[]) null, 100, (IdentityHashMap<Tree, double[][]>) null, identityHashMap0, (Map<String, double[]>) hashMap0, twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      Options options0 = new Options(hebrewTreebankParserParams0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Double double0 = new Double((-2.0));
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("p", (Integer) 100, (Double) 0.0);
      linkedList0.push(triple0);
      Options options1 = new Options();
      Options options2 = new Options(hebrewTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options2);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      LabelFactory labelFactory0 = LabeledWord.factory();
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory(labelFactory0);
      MemoryTreebank memoryTreebank0 = hebrewTreebankParserParams0.memoryTreebank();
      Tree tree0 = labeledScoredTreeFactory0.newTreeNode("so", (List<Tree>) memoryTreebank0);
      SimpleTree simpleTree0 = new SimpleTree(tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.outputTransitions(tree0, 75, identityHashMap0, identityHashMap1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree(tree0, false, identityHashMap0, identityHashMap1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testSaveTreesWithZero()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.saveTrees(simpleTree0, 0.0, simpleTree0, 0.0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecurseOutsideAndRecurseOutside()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      simpleTree0.addChild((Tree) treeGraphNode0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor1.recurseOutside(simpleTree0, identityHashMap0, identityHashMap0);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testRecurseOutside1()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recurseOutside(simpleTree0, identityHashMap0, identityHashMap0);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndOutputTransitionsTaking4Arguments()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap.hashMap();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SimpleTree simpleTree0 = new SimpleTree();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0, (List<Tree>) null);
      List<Tree> list0 = treeGraphNode0.subTreeList();
      SimpleTree simpleTree1 = new SimpleTree(wordLemmaTag0, list0);
      simpleTree1.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap3, identityHashMap3, identityHashMap1, identityHashMap2);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree1, 100, identityHashMap1, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerExceptionAndBuildMergeCorrespondence()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.pennPrint();
      splittingGrammarExtractor0.recalculateBetas(false);
      Double double0 = new Double(100);
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("Fks`'/kY", (Integer) 3, double0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      linkedList0.push(triple0);
      Options options1 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 100, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testOutputTransitionsTaking4ArgumentsThrowsNullPointerException3()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.outputTransitions((Tree) simpleTree0, 100, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsThrowsNullPointerExceptionAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("<sentence id=");
      CoreLabel coreLabel1 = new CoreLabel((CoreMap) coreLabel0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<Tree> list0 = treeGraphNode0.postOrderNodeList();
      TreeGraphNode treeGraphNode1 = new TreeGraphNode(coreLabel1, list0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      NPTmpRetainingTreeNormalizer nPTmpRetainingTreeNormalizer0 = new NPTmpRetainingTreeNormalizer(100, true);
      treeGraphNode1.transform((TreeTransformer) nPTmpRetainingTreeNormalizer0);
      pennTreebankLanguagePack0.getCategoryAndFunctionFunction();
      treeGraphNode1.pennPrint();
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<String, double[]> identityHashMap2 = new IdentityHashMap<String, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode1, (Map<String, double[]>) identityHashMap2, (Map<String, double[]>) identityHashMap2, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5ArgumentsAndCountMergeEffectsTaking5Arguments()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      wordLemmaTag0.setWord("excise sq sq");
      Options options0 = new Options();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<CoreLabel.GenericAnnotation<CoreLabel>, String> mapFactory0 = MapFactory.treeMapFactory(comparator0);
      Map<String, double[]> map0 = mapFactory0.setMap(null, 100);
      IdentityHashMap<String, double[]> identityHashMap1 = new IdentityHashMap<String, double[]>(100);
      splittingGrammarExtractor0.countMergeEffects((Tree) treeGraphNode0, map0, (Map<String, double[]>) identityHashMap1, identityHashMap0, identityHashMap0);
      assertTrue(identityHashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking5Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      splittingGrammarExtractor0.countMergeEffects((Tree) simpleTree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0, identityHashMap0, identityHashMap0);
      assertEquals(0, identityHashMap0.size());
  }

  @Test(timeout = 4000)
  public void testCountMergeEffectsTaking3ArgumentsThrowsRuntimeExceptionAndMergeStates()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      Options options1 = new Options(options0.tlpParams);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options1);
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      Tree tree0 = treeGraphNode0.treeSkeletonCopy();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = (double) 100;
      splittingGrammarExtractor0.mergeTransitions(tree0, identityHashMap3, identityHashMap1, identityHashMap4, (IdentityHashMap<Tree, double[][][]>) null, doubleArray0, identityHashMap2);
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>(1);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.countMergeEffects(tree0, (Map<String, double[]>) hashMap0, (Map<String, double[]>) hashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountOutsideTaking5ArgumentsWithNull()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      TwoDimensionalMap.hashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = null;
      Tree.valueOf("");
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountOutside((Tree) null, (Tree) null, (Tree) null, identityHashMap1, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasReturningFalse()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
      
      Options options1 = new Options(chineseTreebankParserParams0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      boolean boolean1 = splittingGrammarExtractor0.useNewBetas(false, twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean1);
  }

  @Test(timeout = 4000)
  public void testNeginfDoubles()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(100);
      assertEquals(100, doubleArray0.length);
  }

  @Test(timeout = 4000)
  public void testNeginfDoublesAndStateThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      options0.distance = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      splittingGrammarExtractor0.neginfDoubles(1912);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.state((String) null, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testUseNewBetasReturningTrue()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      SimpleTree simpleTree0 = new SimpleTree();
      Stack<Tree> stack0 = new Stack<Tree>();
      splittingGrammarExtractor0.saveTrees(treeSet0, 1554.776980983637, simpleTree0, 0.0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor2.recalculateBetas(true);
      assertFalse(boolean0);
      
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      boolean boolean1 = splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingStringAndExtractTakingCollectionThrowsRuntimeException()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      splittingGrammarExtractor0.getStateSplitCount("\"(#$z");
      ArrayList<Triple<String, Integer, Double>> arrayList0 = new ArrayList<Triple<String, Integer, Double>>();
      splittingGrammarExtractor0.buildMergeCorrespondence(arrayList0);
      Set<Tree> set0 = treeGraphNode0.subTrees();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) set0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasThrowsRuntimeException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      options0.forceCNF = false;
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      SimpleTree simpleTree0 = new SimpleTree();
      Stack<Tree> stack0 = new Stack<Tree>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.saveTrees(simpleTree0, 1554.776980983637, simpleTree0, 0.45);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.recalculateBetas(false);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndSaveTrees()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      SimpleTree simpleTree0 = new SimpleTree();
      Stack<Tree> stack0 = new Stack<Tree>();
      splittingGrammarExtractor0.saveTrees(treeSet0, 1554.776980983637, simpleTree0, 0.0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor2.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.addChild((Tree) simpleTree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount((Tree) simpleTree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingTreeAndGetStateSplitCountTakingTreeThrowsNullPointerException()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer(pennTreebankLanguagePack0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      LabeledScoredTreeNode labeledScoredTreeNode0 = new LabeledScoredTreeNode(treeGraphNode1);
      List<Tree> list0 = treeGraphNode1.pathNodeToNode(labeledScoredTreeNode0, labeledScoredTreeNode0);
      SimpleTree simpleTree0 = new SimpleTree(wordLemmaTag0, list0);
      Tree tree0 = basicCategoryTreeTransformer0.transformTree(simpleTree0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.getStateSplitCount(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndNeginfDoubles()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      MemoryTreebank memoryTreebank0 = hebrewTreebankParserParams0.memoryTreebank();
      splittingGrammarExtractor0.extract((Collection<Tree>) memoryTreebank0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      double[] doubleArray0 = splittingGrammarExtractor0.neginfDoubles(3);
      assertArrayEquals(new double[] {Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY}, doubleArray0, 0.01);
  }

  @Test(timeout = 4000)
  public void testExtractTakingCollectionAndExtractTakingCollectionThrowsRuntimeException()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.DEBUG();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(treeGraphNode0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      Set<Tree> set0 = treeGraphNode0.subTrees();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) set0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(".$$.", 666460448);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.outputBetas();
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor1.buildStateIndex();
      splittingGrammarExtractor1.mergeStates();
      Tree tree0 = null;
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap5 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 100;
      doubleArray0[2] = (double) 666460448;
      doubleArray0[3] = (double) 666460448;
      doubleArray0[4] = (double) 666460448;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.mergeTransitions((Tree) null, identityHashMap3, identityHashMap5, identityHashMap3, identityHashMap1, doubleArray0, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testState0()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      options0.distance = true;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state(".$$.", 100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      assertNotNull(twoDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsNullPointerExceptionAndRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(simpleTree0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      simpleTree0.addChild((Tree) treeGraphNode0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap2 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap1, identityHashMap1, identityHashMap2, identityHashMap3);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0, (-809.216604546), (Collection<Tree>) simpleTree0, Double.POSITIVE_INFINITY);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountWeights()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      IdentityHashMap<Tree, double[][][]> identityHashMap0 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[]> identityHashMap1 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      splittingGrammarExtractor0.recountWeights(simpleTree0, identityHashMap1, identityHashMap2, identityHashMap3, identityHashMap0);
      assertNotSame(identityHashMap1, identityHashMap2);
  }

  @Test(timeout = 4000)
  public void testBuildGrammars()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = false;
      options0.distance = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      Stack<Tree> stack0 = new Stack<Tree>();
      splittingGrammarExtractor0.saveTrees(stack0, 100, stack0, 0.45);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      splittingGrammarExtractor0.recalculateBetas(false);
      splittingGrammarExtractor0.extract((Collection<Tree>) stack0, (-157.24), (Collection<Tree>) stack0, (-157.24));
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildGrammars();
      splittingGrammarExtractor0.state("is", (-644));
      splittingGrammarExtractor1.DEBUG();
      SplittingGrammarExtractor splittingGrammarExtractor2 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor2.splitBetas();
      TreebankLanguagePack treebankLanguagePack0 = options0.langpack();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer(treebankLanguagePack0);
      TaggedWord taggedWord0 = new TaggedWord("XOBU=.iU8t2LiF ", "_MXCPmbD4yKKEy");
      LabeledWord labeledWord0 = new LabeledWord(taggedWord0, taggedWord0);
      SimpleTree simpleTree0 = new SimpleTree(labeledWord0, stack0);
      Tree tree0 = basicCategoryTreeTransformer0.transformHelper(simpleTree0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      Tree.valueOf("is^-644");
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor2.recountWeights(tree0, identityHashMap0, identityHashMap0, identityHashMap1, identityHashMap2);
      assertNotSame(splittingGrammarExtractor2, splittingGrammarExtractor1);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasAndRecalculateTemporaryBetasTaking4ArgumentsAndRescaleTemporaryBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      MapFactory<String, Map<String, double[][]>> mapFactory0 = MapFactory.linkedHashMapFactory();
      MapFactory<String, double[][]> mapFactory1 = MapFactory.weakHashMapFactory();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory0, mapFactory1);
      StringReader stringReader0 = new StringReader("G]Ala6`Z7h~%Ky` aW");
      Morphology morphology0 = new Morphology(stringReader0, 100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = twoDimensionalMap0.transform(morphology0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(false, (Map<String, double[]>) identityHashMap0, twoDimensionalMap1, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap1, threeDimensionalMap0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndBuildMergeCorrespondence()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("|ev8", (Integer) 100, (Double) 0.0);
      linkedList0.push(triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      WordFactory wordFactory0 = new WordFactory();
      Label label0 = wordFactory0.newLabel("|ev8");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      HeadFinder headFinder0 = chineseTreebankParserParams0.headFinder();
      Tree tree0 = treeGraphNode0.treeSkeletonConstituentCopy();
      Tree tree1 = treeGraphNode0.headTerminal(headFinder0, tree0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 100;
      doubleArray0[1] = (double) 3;
      doubleArray0[2] = (double) 0;
      splittingGrammarExtractor0.mergeTransitions(tree1, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, doubleArray0, map0);
      assertSame(tree1, treeGraphNode0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsAndMergeTransitionsWithNullAndMergeTransitionsWithEmptyMap()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      SimpleTree simpleTree0 = new SimpleTree();
      HashMap<String, int[]> hashMap0 = new HashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.mergeTransitions(simpleTree0, identityHashMap0, identityHashMap1, identityHashMap0, identityHashMap1, (double[]) null, hashMap0);
      IdentityHashMap<Tree, double[]> identityHashMap2 = new IdentityHashMap<Tree, double[]>();
      IdentityHashMap<Tree, double[]> identityHashMap3 = new IdentityHashMap<Tree, double[]>();
      assertTrue(identityHashMap3.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetStateSplitCountTakingString()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.getStateSplitCount("-");
      HashMap<String, double[]> hashMap0 = new HashMap<String, double[]>();
      assertTrue(hashMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testOutputBetasAndRecalculateMergedBetas()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = splittingGrammarExtractor0.binaryBetas;
      threeDimensionalMap1.get("LEXICON", "UPPER");
      splittingGrammarExtractor0.outputBetas();
      splittingGrammarExtractor0.recalculateMergedBetas((Map<String, int[]>) null);
  }

  @Test(timeout = 4000)
  public void testRescaleTemporaryBetasThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.state("", 666460443);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor1.outputBetas();
      splittingGrammarExtractor1.buildStateIndex();
      splittingGrammarExtractor0.mergeStates();
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap2 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap3 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][]> identityHashMap4 = new IdentityHashMap<Tree, double[][]>();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 100;
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.mergeTransitions((Tree) null, identityHashMap4, identityHashMap1, identityHashMap4, identityHashMap1, doubleArray0, identityHashMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testOutputBetas2()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.outputBetas();
  }

  @Test(timeout = 4000)
  public void testCountOriginalStatesAndCountOriginalStates()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testSplitBetasAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      double[][][] doubleArray0 = new double[6][7][7];
      threeDimensionalMap0.put("-N2W", "-N2W", "-N2W", doubleArray0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      double[][] doubleArray1 = new double[1][7];
      twoDimensionalMap0.put("tjQ", "This", doubleArray1);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      Vector<Triple<String, Integer, Double>> vector0 = new Vector<Triple<String, Integer, Double>>(100, 149);
      splittingGrammarExtractor0.useNewBetas(true, twoDimensionalMap0, threeDimensionalMap0);
      splittingGrammarExtractor0.buildMergeCorrespondence(vector0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      splittingGrammarExtractor0.splitBetas();
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4ArgumentsWithZeroAndExtractTaking4ArgumentsWithNegative()  throws Throwable  {
      ItalianTreebankParserParams italianTreebankParserParams0 = new ItalianTreebankParserParams();
      Options options0 = new Options(italianTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashSet<Tree> hashSet0 = new HashSet<Tree>(100, 100);
      splittingGrammarExtractor0.extract((Collection<Tree>) hashSet0, 0.0, (Collection<Tree>) hashSet0, (-100.0));
      assertTrue(hashSet0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedList<Tree> linkedList0 = new LinkedList<Tree>();
      splittingGrammarExtractor0.extract((Collection<Tree>) linkedList0, (double) 100, (Collection<Tree>) linkedList0, 0.0);
      assertEquals(0, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testMergeStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.mergeStates();
  }

  @Test(timeout = 4000)
  public void testRecountTreeTaking4ArgumentsThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      Tree.valueOf("");
      MapFactory<LinkedList<Object>, ChronoUnit> mapFactory0 = MapFactory.weakHashMapFactory();
      Map<String, double[]> map0 = mapFactory0.setMap(null);
      MapFactory<String, Map<String, double[][]>> mapFactory1 = MapFactory.treeMapFactory();
      MapFactory<String, double[][]> mapFactory2 = MapFactory.identityHashMapFactory();
      Supplier<List<String>> supplier0 = (Supplier<List<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      Supplier<Map<String, Integer>> supplier1 = (Supplier<Map<String, Integer>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier1).get();
      HashIndex<String> hashIndex0 = new HashIndex<String>(supplier0, supplier1);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>(mapFactory1, mapFactory2);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap1 = new TwoDimensionalMap<String, String, double[][]>(twoDimensionalMap0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      mapFactory0.newMap();
      FileSystemHandling.shouldAllThrowIOExceptions();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map0, twoDimensionalMap1, threeDimensionalMap0);
      IdentityHashMap<Tree, double[][]> identityHashMap0 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap1 = new IdentityHashMap<Tree, double[][][]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountTree((Tree) null, false, identityHashMap0, identityHashMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerException0()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      options0.freeDependencies = false;
      options0.useSmoothTagProjection = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside((Tree) null, false, 1558, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildGrammarsAndSaveTrees()  throws Throwable  {
      Options options0 = new Options();
      options0.freeDependencies = false;
      options0.distance = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
      Stack<Tree> stack0 = new Stack<Tree>();
      splittingGrammarExtractor0.saveTrees(stack0, 100, stack0, 0.45);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, (ThreeDimensionalMap<String, String, String, double[][][]>) null);
      splittingGrammarExtractor0.recalculateBetas(false);
      splittingGrammarExtractor0.extract((Collection<Tree>) stack0, (-157.24), (Collection<Tree>) stack0, (-1207.4));
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.buildGrammars();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.BinaryGrammar", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeException2()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.pennPrint();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      String string0 = "useAdaDelta";
      Tree tree0 = labeledScoredTreeFactory0.newLeaf("useAdaDelta");
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) tree0, 0.0, (Collection<Tree>) simpleTree0, (double) 100);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCountOriginalStates()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.countOriginalStates();
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsRuntimeExceptionAndExtractTaking4ArgumentsWithZero()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) simpleTree0, (double) 100, (Collection<Tree>) simpleTree0, 0.0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsAndExtractTaking4ArgumentsThrowsRuntimeException()  throws Throwable  {
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Options options0 = new Options(chineseTreebankParserParams0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      treeSet0.remove(wordLemmaTag0);
      SimpleTree simpleTree0 = new SimpleTree();
      simpleTree0.pennPrint();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) treeSet0, (double) 3, (Collection<Tree>) simpleTree0, (double) 3);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testDEBUG()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.DEBUG();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testMergeTransitionsWithEmptyArray()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<LinkedList<Object>, SplittingGrammarExtractor> mapFactory0 = MapFactory.linkedHashMapFactory();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<LinkedList<Object>, ChronoUnit> mapFactory1 = MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory1.setMap(identityHashMap0);
      Map<String, double[]> map1 = mapFactory0.setMap(map0, 100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map1, twoDimensionalMap0, threeDimensionalMap0);
      RightHeadFinder rightHeadFinder0 = new RightHeadFinder();
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer(pennTreebankLanguagePack0);
      SimpleTree simpleTree0 = new SimpleTree();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<String, int[]> identityHashMap3 = new IdentityHashMap<String, int[]>();
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<Tree, double[][][]> identityHashMap4 = new IdentityHashMap<Tree, double[][][]>();
      double[][][] doubleArray0 = new double[7][3][7];
      double[][] doubleArray1 = new double[4][0];
      double[] doubleArray2 = new double[2];
      doubleArray2[0] = (-576.540938);
      doubleArray2[1] = 0.0;
      doubleArray1[0] = doubleArray2;
      double[] doubleArray3 = new double[1];
      doubleArray3[0] = (double) 100;
      doubleArray1[1] = doubleArray3;
      double[] doubleArray4 = new double[7];
      doubleArray4[0] = (-576.540938);
      doubleArray4[1] = (-576.540938);
      doubleArray4[2] = (-576.540938);
      doubleArray4[3] = 0.0;
      doubleArray4[4] = (-576.540938);
      doubleArray4[5] = 0.0;
      doubleArray4[6] = (double) 100;
      doubleArray1[2] = doubleArray4;
      double[] doubleArray5 = new double[1];
      doubleArray5[0] = (-576.540938);
      doubleArray1[3] = doubleArray5;
      doubleArray0[0] = doubleArray1;
      double[][] doubleArray6 = new double[2][0];
      doubleArray6[0] = doubleArray4;
      doubleArray6[1] = doubleArray2;
      doubleArray0[1] = doubleArray6;
      double[][] doubleArray7 = new double[9][2];
      doubleArray7[0] = doubleArray3;
      doubleArray7[1] = doubleArray4;
      double[] doubleArray8 = new double[4];
      doubleArray8[0] = 0.9999000099990001;
      doubleArray8[1] = (-576.540938);
      doubleArray8[2] = (-576.540938);
      doubleArray8[3] = (double) 100;
      doubleArray7[2] = doubleArray8;
      doubleArray7[3] = doubleArray2;
      doubleArray7[4] = doubleArray4;
      doubleArray7[5] = doubleArray4;
      doubleArray7[6] = doubleArray3;
      doubleArray7[7] = doubleArray4;
      doubleArray7[8] = doubleArray5;
      doubleArray0[2] = doubleArray7;
      double[][] doubleArray9 = new double[6][2];
      doubleArray9[0] = doubleArray5;
      doubleArray9[1] = doubleArray8;
      doubleArray9[2] = doubleArray8;
      doubleArray9[3] = doubleArray8;
      doubleArray9[4] = doubleArray5;
      doubleArray9[5] = doubleArray5;
      doubleArray0[3] = doubleArray9;
      double[][] doubleArray10 = new double[2][4];
      doubleArray10[0] = doubleArray4;
      doubleArray10[1] = doubleArray5;
      doubleArray0[4] = doubleArray10;
      double[][] doubleArray11 = new double[2][3];
      doubleArray11[0] = doubleArray5;
      doubleArray11[1] = doubleArray5;
      doubleArray0[5] = doubleArray11;
      double[][] doubleArray12 = new double[5][2];
      doubleArray12[0] = doubleArray5;
      doubleArray12[1] = doubleArray8;
      double[] doubleArray13 = new double[0];
      doubleArray12[2] = doubleArray13;
      doubleArray12[3] = doubleArray2;
      doubleArray12[4] = doubleArray5;
      doubleArray0[6] = doubleArray12;
      identityHashMap4.put(simpleTree0, doubleArray0);
      double[] doubleArray14 = new double[0];
      // Undeclared exception!
      try { 
        splittingGrammarExtractor1.mergeTransitions((Tree) null, identityHashMap1, identityHashMap4, identityHashMap1, identityHashMap4, doubleArray14, identityHashMap3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      Tree.valueOf("");
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      options_LexOptions0.unknownSuffixSize = (-1);
      options0.directional = true;
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      options_LexOptions0.wordVectorFile = "/u/scr/nlp/deeplearning/datasets/turian/embeddings-scaled.EMBEDDING_SIZE=25.txt";
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.extract((Collection<Tree>) null, 1292.6, (Collection<Tree>) treeSet0, 1292.6);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStateAndState()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<String> stack0 = new Stack<String>();
      stack0.ensureCapacity(100);
      splittingGrammarExtractor0.startSymbols = (List<String>) stack0;
      stack0.add("N");
      String string0 = splittingGrammarExtractor0.state(":1U{q?1YJ", 100);
      assertEquals(":1U{q?1YJ^100", string0);
      
      String string1 = splittingGrammarExtractor0.state("N", (-1111));
      assertEquals("N", string1);
  }

  @Test(timeout = 4000)
  public void testStateThrowsNullPointerException()  throws Throwable  {
      Options options0 = new Options();
      options0.newTrainOptions();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.state((String) null, 100);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testState1()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      String string0 = splittingGrammarExtractor0.state(",", 100);
      assertEquals(",^100", string0);
  }

  @Test(timeout = 4000)
  public void testRecountInsideThrowsNullPointerException1()  throws Throwable  {
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams();
      Options options0 = new Options(hebrewTreebankParserParams0);
      options0.freeDependencies = false;
      options0.useSmoothTagProjection = false;
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Tree tree0 = null;
      IdentityHashMap<Tree, double[]> identityHashMap0 = new IdentityHashMap<Tree, double[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recountInside((Tree) null, false, 100, identityHashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildStateIndex()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.buildStateIndex();
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndSplitBetas()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      double[][][] doubleArray0 = new double[10][3][7];
      threeDimensionalMap0.put("-N2W", "-N2W", "-N2W", doubleArray0);
      splittingGrammarExtractor0.splitBetas();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.hashMap();
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasAndRescaleTemporaryBetasAndRecalculateBetasWithFalse()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      HebrewTreebankParserParams hebrewTreebankParserParams0 = new HebrewTreebankParserParams(pennTreebankLanguagePack0);
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = splittingGrammarExtractor0.unaryBetas;
      twoDimensionalMap0.remove(">]M0NN18CLb5", "V9DEV*Wxb-t#p");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.rescaleTemporaryBetas(twoDimensionalMap0, threeDimensionalMap0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndTestConvergence0()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.treeMap();
      twoDimensionalMap0.get("v$g6D{AIK?t|Td:{V", "5%=rE^o<");
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      FrenchTreebankParserParams frenchTreebankParserParams0 = null;
      try {
        frenchTreebankParserParams0 = new FrenchTreebankParserParams();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
         //
         // Could not initialize class edu.stanford.nlp.trees.tregex.TregexParser
         //
         verifyException("edu.stanford.nlp.trees.tregex.TregexPatternCompiler", e);
      }
  }

  @Test(timeout = 4000)
  public void testTestConvergenceAndTestConvergence1()  throws Throwable  {
      Options options0 = new Options();
      SimpleTree simpleTree0 = new SimpleTree();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      HashSet<double[][][]> hashSet0 = new HashSet<double[][][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = splittingGrammarExtractor0.binaryBetas;
      ChineseTreebankParserParams chineseTreebankParserParams0 = new ChineseTreebankParserParams();
      Tree tree0 = chineseTreebankParserParams0.transformTree(simpleTree0, simpleTree0);
      simpleTree0.addChild(tree0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      IdentityHashMap<Tree, double[][]> identityHashMap1 = new IdentityHashMap<Tree, double[][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap2 = new IdentityHashMap<Tree, double[][][]>();
      IdentityHashMap<Tree, double[][][]> identityHashMap3 = new IdentityHashMap<Tree, double[][][]>();
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = new TwoDimensionalMap<String, String, double[][]>();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap1 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 2400;
      double[][][] doubleArray1 = new double[1][2][2];
      double[][] doubleArray2 = new double[3][0];
      doubleArray2[0] = doubleArray0;
      doubleArray2[1] = doubleArray0;
      doubleArray2[2] = doubleArray0;
      doubleArray1[0] = doubleArray2;
      threeDimensionalMap0.put(": ", "|+V/}", "u", doubleArray1);
      threeDimensionalMap0.get((String) null, "<Lp@@73");
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.testConvergence(twoDimensionalMap0, threeDimensionalMap0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateTemporaryBetasTaking4Arguments()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      MapFactory<LinkedList<Object>, SplittingGrammarExtractor> mapFactory0 = MapFactory.linkedHashMapFactory();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      MapFactory<LinkedList<Object>, ChronoUnit> mapFactory1 = MapFactory.treeMapFactory(comparator0);
      IdentityHashMap<String, double[]> identityHashMap0 = new IdentityHashMap<String, double[]>();
      Map<String, double[]> map0 = mapFactory1.setMap(identityHashMap0);
      Map<String, double[]> map1 = mapFactory0.setMap(map0, 100);
      TwoDimensionalMap<String, String, double[][]> twoDimensionalMap0 = TwoDimensionalMap.identityHashMap();
      ThreeDimensionalMap<String, String, String, double[][][]> threeDimensionalMap0 = new ThreeDimensionalMap<String, String, String, double[][][]>();
      splittingGrammarExtractor0.recalculateTemporaryBetas(true, map1, twoDimensionalMap0, threeDimensionalMap0);
      RightHeadFinder rightHeadFinder0 = new RightHeadFinder();
      PennTreebankLanguagePack pennTreebankLanguagePack0 = new PennTreebankLanguagePack();
      BasicCategoryTreeTransformer basicCategoryTreeTransformer0 = new BasicCategoryTreeTransformer(pennTreebankLanguagePack0);
      SimpleTree simpleTree0 = new SimpleTree();
      Tree.valueOf(".$$.");
      // Undeclared exception!
      try { 
        simpleTree0.setChild(100, (Tree) null);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 100 out of bounds for length 0
         //
         verifyException("edu.stanford.nlp.trees.Tree", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasAndRecalculateMergedBetasThrowsRuntimeException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      SimpleTree simpleTree0 = new SimpleTree();
      double double0 = 1536.5364591813825;
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      options0.baseParserWeight = 1536.5364591813825;
      double double1 = 0.0;
      splittingGrammarExtractor0.saveTrees(treeSet0, 1536.5364591813825, simpleTree0, 0.0);
      SplittingGrammarExtractor splittingGrammarExtractor1 = new SplittingGrammarExtractor(options0);
      IdentityHashMap<String, int[]> identityHashMap0 = new IdentityHashMap<String, int[]>();
      // Undeclared exception!
      try { 
        splittingGrammarExtractor0.recalculateMergedBetas(identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.parser.lexparser.SplittingGrammarExtractor", e);
      }
  }

  @Test(timeout = 4000)
  public void testRecalculateMergedBetasAndRecalculateMergedBetasWithNull()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      splittingGrammarExtractor0.recalculateMergedBetas((Map<String, int[]>) null);
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondence1()  throws Throwable  {
      Options options0 = new Options();
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasReturningFalse()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(true);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testRecalculateBetasReturningTrue()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      boolean boolean0 = splittingGrammarExtractor0.recalculateBetas(false);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testExtractTaking4ArgumentsThrowsClassCastException()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      Stack<Triple<String, Integer, Double>> stack0 = new Stack<Triple<String, Integer, Double>>();
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(stack0);
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      Tree.valueOf("");
      double double0 = 1292.6;
      Options.LexOptions options_LexOptions0 = options0.lexOptions;
      options0.lexOptions = options_LexOptions0;
      options_LexOptions0.unknownSuffixSize = (-1);
      options0.directional = true;
      TreeSet<Tree> treeSet0 = new TreeSet<Tree>();
      options_LexOptions0.wordVectorFile = "/u/scr/nlp/deeplearning/datasets/turian/embeddings-scaled.EMBEDDING_SIZE=25.txt";
      // Undeclared exception!
      try { 
        treeSet0.remove(stack0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // class java.util.Stack cannot be cast to class java.lang.Comparable (java.util.Stack and java.lang.Comparable are in module java.base of loader 'bootstrap')
         //
         verifyException("java.util.TreeMap", e);
      }
  }

  @Test(timeout = 4000)
  public void testBuildMergeCorrespondenceReturningMapWhereIsEmptyIsTrueAndMapWhereSizeIsZero()  throws Throwable  {
      Options options0 = new Options();
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      LinkedList<Triple<String, Integer, Double>> linkedList0 = new LinkedList<Triple<String, Integer, Double>>();
      Triple<String, Integer, Double> triple0 = new Triple<String, Integer, Double>("|ev8", (Integer) 100, (Double) 0.0);
      linkedList0.push(triple0);
      Map<String, int[]> map0 = splittingGrammarExtractor0.buildMergeCorrespondence(linkedList0);
      splittingGrammarExtractor0.recalculateMergedBetas(map0);
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesSplittingGrammarExtractor()  throws Throwable  {
      Options options0 = new Options();
      String[] stringArray0 = new String[0];
      Options.LexOptions options_LexOptions0 = new Options.LexOptions();
      options0.lexOptions = options_LexOptions0;
      options0.setOptions(stringArray0, (-2617), (-2617));
      SplittingGrammarExtractor splittingGrammarExtractor0 = new SplittingGrammarExtractor(options0);
      WordTag wordTag0 = WordTag.valueOf("ner.combinationMode");
      Stack<Tree> stack0 = new Stack<Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0, stack0);
      Filters.RandomFilter<Object> filters_RandomFilter0 = new Filters.RandomFilter<Object>(0.0);
      Predicate<Tree> predicate0 = Predicate.not(filters_RandomFilter0);
      LabeledScoredTreeFactory labeledScoredTreeFactory0 = new LabeledScoredTreeFactory();
      Tree tree0 = treeGraphNode0.spliceOut(predicate0, (TreeFactory) labeledScoredTreeFactory0);
      // Undeclared exception!
      try { 
        CoordinationTransformer.removeXOverX(tree0);
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }
}
