/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Jun 11 18:30:55 GMT 2025
 */

package edu.stanford.nlp.process;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.NERClassifierCombiner;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Document;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.StringLabelFactory;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordTagFactory;
import edu.stanford.nlp.ling.tokensregex.BasicSequenceMatchResult;
import edu.stanford.nlp.ling.tokensregex.ComplexNodePattern;
import edu.stanford.nlp.ling.tokensregex.Env;
import edu.stanford.nlp.ling.tokensregex.SequenceMatchAction;
import edu.stanford.nlp.ling.tokensregex.SequencePattern;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.WordToSentenceProcessor;
import edu.stanford.nlp.trees.SimpleTreeFactory;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.util.Pair;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.nio.charset.Charset;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.regex.PatternSyntaxException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.EvoSuiteURL;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.testdata.NetworkHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class WordToSentenceProcessor_5_ESTest extends WordToSentenceProcessor_5_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testProcess0()  throws Throwable  {
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>();
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(".", ".", (Set<String>) null, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
      WordTagFactory wordTagFactory0 = new WordTagFactory('!');
      Label label0 = wordTagFactory0.newLabel("<?:inputEncoding>");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode2.yield(stack0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor1.process(stack0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndProcess()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = ".";
      stringArray0[1] = ".";
      stringArray0[2] = ".";
      stringArray0[3] = ")";
      List<?> list0 = Arrays.asList(stringArray0);
      Locale locale0 = Locale.JAPANESE;
      Set<String> set0 = locale0.getUnicodeLocaleAttributes();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>("$VALUES", ".", set0, set0, ".", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super Object>) null, set0, false, false);
      List<List<Object>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeExceptionAndCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      String[] stringArray0 = new String[19];
      stringArray0[0] = "<$>";
      List<?> list0 = Arrays.asList(stringArray0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>("<$>", "<$>", treeSet0, treeSet0, "<$>", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super Object>) null, treeSet0, false, false);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess0()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("*NL*");
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(treeSet0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor0.process(stack0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak0()  throws Throwable  {
      String[] stringArray0 = new String[5];
      stringArray0[0] = ")";
      stringArray0[1] = ".";
      stringArray0[2] = "*NL*";
      stringArray0[3] = ")";
      FileSystemHandling.shouldAllThrowIOExceptions();
      stringArray0[4] = ")";
      List<?> list0 = Arrays.asList(stringArray0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      List<List<Object>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess0()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = "*NL*";
      stringArray0[1] = "*NL*";
      stringArray0[2] = "*NL*";
      stringArray0[3] = "*NL*";
      List<?> list0 = Arrays.asList(stringArray0);
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>();
      List<List<Object>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(0, list1.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsTooManyResourcesException()  throws Throwable  {
      System.setCurrentTimeMillis(0L);
      System.setCurrentTimeMillis(0L);
      String string0 = "$VALUES";
      Locale.IsoCountryCode locale_IsoCountryCode0 = Locale.IsoCountryCode.PART1_ALPHA3;
      Set<String> set0 = Locale.getISOCountries(locale_IsoCountryCode0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("Rym*J1|dg_6Zzs<", "$VALUES", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      Vector<String> vector0 = new Vector<String>(set0);
      // Undeclared exception!
      wordToSentenceProcessor0.process(vector0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak1()  throws Throwable  {
      String[] stringArray0 = new String[2];
      stringArray0[0] = "*NL*";
      stringArray0[1] = "*NL*";
      List<?> list0 = Arrays.asList(stringArray0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      List<List<Object>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("<GT>", "<GT>");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      Charset charset0 = Charset.defaultCharset();
      Set<String> set0 = charset0.aliases();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("ALWAYS", "gQ']$K%/S", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      wordToSentenceProcessor1.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("gQ']$K%/S");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'gQ']$K%/S' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcess1()  throws Throwable  {
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("ner\u0000usePresetNERTags", "ner\u0000usePresetNERTags");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      Charset.defaultCharset();
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("ner\u0000usePresetNERTags", "ner\u0000usePresetNERTags", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor1.process(stack0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testProcess2()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("qJoin", "never");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("qJoin", "favoured", treeSet0, treeSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, treeSet0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor1.process(stack0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess()  throws Throwable  {
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("<G-", "<G-");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordLemmaTag0);
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("<G-", "<G-", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      wordToSentenceProcessor0.process(list0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess1()  throws Throwable  {
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      ArrayList<HasWord> arrayList0 = new ArrayList<HasWord>();
      Word word0 = new Word("'");
      arrayList0.add((HasWord) word0);
      Word word1 = new Word("Quoted");
      Word.factory();
      arrayList0.add((HasWord) word1);
      Word word2 = new Word("text");
      FileSystemHandling.shouldAllThrowIOExceptions();
      TaggedWord taggedWord0 = new TaggedWord("!");
      arrayList0.add((HasWord) taggedWord0);
      Word word3 = new Word("'");
      arrayList0.add((HasWord) word3);
      Word word4 = new Word("");
      arrayList0.add((HasWord) word0);
      Word word5 = new Word("uB]OW`%CcKoPa");
      arrayList0.add((HasWord) word2);
      wordToSentenceProcessor0.process(arrayList0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      Vector<List<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<List<CoreAnnotations.OriginalTextAnnotation>>();
      assertEquals(0, vector0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess2()  throws Throwable  {
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      ArrayList<HasWord> arrayList0 = new ArrayList<HasWord>();
      Word word0 = new Word("'");
      arrayList0.add((HasWord) word0);
      Word.factory();
      arrayList0.add((HasWord) word0);
      Word word1 = new Word("'");
      FileSystemHandling.shouldAllThrowIOExceptions();
      TaggedWord taggedWord0 = new TaggedWord("!");
      arrayList0.add((HasWord) taggedWord0);
      Word word2 = new Word("'");
      arrayList0.add((HasWord) word2);
      Word word3 = new Word("Quoted");
      arrayList0.add((HasWord) word3);
      Word word4 = new Word("Next");
      arrayList0.add((HasWord) word4);
      wordToSentenceProcessor0.process(arrayList0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(word0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      Vector<List<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<List<CoreAnnotations.OriginalTextAnnotation>>();
      assertEquals(10, vector0.capacity());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess3()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.setWord("TJp");
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class0 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      coreLabel0.set(class0, false);
      CoreLabel[] coreLabelArray0 = new CoreLabel[1];
      coreLabelArray0[0] = coreLabel0;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(1, list1.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerExceptionAndProcess0()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceUntilEndAnnotation> class0 = CoreAnnotations.ForcedSentenceUntilEndAnnotation.class;
      coreLabel0.set(class0, false);
      CoreLabel coreLabel1 = new CoreLabel();
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      wordToSentenceProcessor0.process(stack0);
      CoreLabel coreLabel2 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class1 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      coreLabel2.set(class1, true);
      CoreLabel coreLabel3 = new CoreLabel();
      coreLabel3.setWord("-Bh.(FHE");
      CoreLabel coreLabel4 = new CoreLabel();
      CoreLabel[] coreLabelArray0 = new CoreLabel[5];
      coreLabelArray0[0] = coreLabel0;
      coreLabelArray0[2] = coreLabel0;
      coreLabelArray0[3] = coreLabel0;
      coreLabelArray0[4] = coreLabel4;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException0()  throws Throwable  {
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceUntilEndAnnotation> class0 = CoreAnnotations.ForcedSentenceUntilEndAnnotation.class;
      coreLabel0.set(class0, false);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException1()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.setWord("'");
      Class<CoreAnnotations.TextAnnotation> class0 = CoreAnnotations.TextAnnotation.class;
      coreLabel0.set(class0, "'");
      Class<CoreAnnotations.OriginalTextAnnotation> class1 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel0.set(class1, "'");
      CoreLabel coreLabel1 = new CoreLabel();
      coreLabel1.setWord("He");
      Class<CoreAnnotations.TextAnnotation> class2 = CoreAnnotations.TextAnnotation.class;
      coreLabel1.set(class2, "He");
      Class<CoreAnnotations.OriginalTextAnnotation> class3 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel1.set(class3, "He");
      CoreLabel coreLabel2 = new CoreLabel();
      coreLabel2.setWord("said");
      Class<CoreAnnotations.TextAnnotation> class4 = CoreAnnotations.TextAnnotation.class;
      coreLabel2.set(class4, "said");
      Class<CoreAnnotations.OriginalTextAnnotation> class5 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel2.set(class5, "said");
      CoreLabel coreLabel3 = new CoreLabel();
      coreLabel3.setWord("'");
      Class<CoreAnnotations.TextAnnotation> class6 = CoreAnnotations.TextAnnotation.class;
      coreLabel3.set(class6, "'");
      Class<CoreAnnotations.OriginalTextAnnotation> class7 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel3.set(class7, "'");
      CoreLabel coreLabel4 = new CoreLabel();
      coreLabel4.setWord(".");
      Class<CoreAnnotations.TextAnnotation> class8 = CoreAnnotations.TextAnnotation.class;
      coreLabel4.set(class8, ".");
      Class<CoreAnnotations.OriginalTextAnnotation> class9 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel4.set(class9, ".");
      CoreLabel coreLabel5 = new CoreLabel();
      coreLabel5.setWord("'");
      Class<CoreAnnotations.TextAnnotation> class10 = CoreAnnotations.TextAnnotation.class;
      coreLabel5.set(class10, "'");
      Class<CoreAnnotations.OriginalTextAnnotation> class11 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel5.set(class11, "'");
      CoreLabel[] coreLabelArray0 = new CoreLabel[6];
      coreLabelArray0[0] = coreLabel0;
      coreLabelArray0[1] = coreLabel1;
      coreLabelArray0[2] = coreLabel2;
      coreLabelArray0[3] = coreLabel3;
      coreLabelArray0[4] = coreLabel4;
      coreLabelArray0[5] = coreLabel5;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess4()  throws Throwable  {
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      ArrayList<HasWord> arrayList0 = new ArrayList<HasWord>();
      Word word0 = new Word("'");
      arrayList0.add((HasWord) word0);
      Word word1 = new Word("Quoted");
      Word.factory();
      arrayList0.add((HasWord) word1);
      Word word2 = new Word("text");
      FileSystemHandling.shouldAllThrowIOExceptions();
      TaggedWord taggedWord0 = new TaggedWord("!");
      arrayList0.add((HasWord) taggedWord0);
      Word word3 = new Word("'");
      arrayList0.add((HasWord) word3);
      Word word4 = new Word(")");
      Word word5 = new Word("Next");
      arrayList0.add((HasWord) word5);
      wordToSentenceProcessor0.process(arrayList0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      Vector<List<CoreAnnotations.OriginalTextAnnotation>> vector0 = new Vector<List<CoreAnnotations.OriginalTextAnnotation>>();
      assertEquals("[]", vector0.toString());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException2()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.setWord("He");
      Class<CoreAnnotations.TextAnnotation> class0 = CoreAnnotations.TextAnnotation.class;
      coreLabel0.set(class0, "He");
      Class<CoreAnnotations.OriginalTextAnnotation> class1 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel0.set(class1, "He");
      CoreLabel coreLabel1 = new CoreLabel();
      coreLabel1.setWord("said");
      Class<CoreAnnotations.TextAnnotation> class2 = CoreAnnotations.TextAnnotation.class;
      coreLabel1.set(class2, "said");
      Class<CoreAnnotations.OriginalTextAnnotation> class3 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel1.set(class3, "said");
      CoreLabel coreLabel2 = new CoreLabel();
      coreLabel2.setWord(":");
      Class<CoreAnnotations.TextAnnotation> class4 = CoreAnnotations.TextAnnotation.class;
      coreLabel2.set(class4, ":");
      Class<CoreAnnotations.OriginalTextAnnotation> class5 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel2.set(class5, ":");
      CoreLabel coreLabel3 = new CoreLabel();
      coreLabel3.setWord("\"");
      Class<CoreAnnotations.TextAnnotation> class6 = CoreAnnotations.TextAnnotation.class;
      coreLabel3.set(class6, "\"");
      Class<CoreAnnotations.OriginalTextAnnotation> class7 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel3.set(class7, "\"");
      CoreLabel coreLabel4 = new CoreLabel();
      coreLabel4.setWord("Yes");
      Class<CoreAnnotations.TextAnnotation> class8 = CoreAnnotations.TextAnnotation.class;
      coreLabel4.set(class8, "Yes");
      Class<CoreAnnotations.OriginalTextAnnotation> class9 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel4.set(class9, "Yes");
      CoreLabel coreLabel5 = new CoreLabel();
      coreLabel5.setWord(".");
      Class<CoreAnnotations.TextAnnotation> class10 = CoreAnnotations.TextAnnotation.class;
      coreLabel5.set(class10, ".");
      Class<CoreAnnotations.OriginalTextAnnotation> class11 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel5.set(class11, ".");
      CoreLabel coreLabel6 = new CoreLabel();
      coreLabel6.setWord("\"");
      Class<CoreAnnotations.TextAnnotation> class12 = CoreAnnotations.TextAnnotation.class;
      coreLabel6.set(class12, "\"");
      Class<CoreAnnotations.OriginalTextAnnotation> class13 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel6.set(class13, "\"");
      CoreLabel[] coreLabelArray0 = new CoreLabel[7];
      coreLabelArray0[0] = coreLabel0;
      coreLabelArray0[1] = coreLabel1;
      coreLabelArray0[2] = coreLabel2;
      coreLabelArray0[3] = coreLabel3;
      coreLabelArray0[4] = coreLabel4;
      coreLabelArray0[5] = coreLabel5;
      coreLabelArray0[6] = coreLabel6;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException3()  throws Throwable  {
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.setWord("\"");
      CoreLabel coreLabel1 = new CoreLabel();
      coreLabel1.setWord("Say");
      CoreLabel coreLabel2 = new CoreLabel();
      coreLabel2.setWord(".");
      CoreLabel coreLabel3 = new CoreLabel();
      coreLabel3.setWord("\"");
      List<HasWord> list0 = new ArrayList<HasWord>();
      list0.add((HasWord) coreLabel0);
      list0.add((HasWord) coreLabel1);
      list0.add((HasWord) coreLabel2);
      list0.add((HasWord) coreLabel3);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess5()  throws Throwable  {
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>();
      Object[] objectArray0 = new Object[3];
      objectArray0[0] = (Object) ")";
      objectArray0[1] = (Object) ".";
      objectArray0[2] = (Object) ")";
      List<Object> list0 = (List<Object>)Arrays.asList(objectArray0);
      List<List<Object>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess6()  throws Throwable  {
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceUntilEndAnnotation> class0 = CoreAnnotations.ForcedSentenceUntilEndAnnotation.class;
      coreLabel0.set(class0, true);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTakingNoArgumentsThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class0 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      coreLabel0.set(class0, true);
      CoreLabel[] coreLabelArray0 = new CoreLabel[2];
      coreLabelArray0[0] = coreLabel0;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeExceptionAndCreatesWordToSentenceProcessorTaking7Arguments()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add(" prior_to");
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>(linkedHashSet0);
      TaggedWord taggedWord0 = new TaggedWord(" prior_to");
      HasWord[] hasWordArray0 = new HasWord[4];
      hasWordArray0[0] = (HasWord) taggedWord0;
      List<HasWord> list0 = (List<HasWord>)Arrays.asList(hasWordArray0);
      taggedWord0.setEndPosition(3);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor1 = new WordToSentenceProcessor<HasWord>("X-PREV-OCCURRENCE-YX", " prior_to", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super HasWord>) null, linkedHashSet0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor1.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess7()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\u2029");
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      treeGraphNode0.yield(stack0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess1()  throws Throwable  {
      CoreLabel.wordFromString("*NL*");
      String[] stringArray0 = new String[2];
      stringArray0[0] = "*NL*";
      stringArray0[1] = "Z+`87|,2-9m&;eLw";
      List<?> list0 = Arrays.asList(stringArray0);
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>(set0);
      List<List<Object>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add(" prio<_to");
      String[] stringArray0 = new String[2];
      stringArray0[0] = " prio<_to";
      stringArray0[1] = " prio<_to";
      List<?> list0 = Arrays.asList(stringArray0);
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>(linkedHashSet0);
      wordToSentenceProcessor0.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("th'b");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'th'b' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess8()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("*NL*");
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor0.process(stack0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess9()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\u2029");
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testProcessAndCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("*NL*");
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      treeGraphNode0.yield(stack0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<Object> wordToSentenceProcessor1 = new WordToSentenceProcessor<Object>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      List<List<Object>> list0 = wordToSentenceProcessor1.process(stack0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess10()  throws Throwable  {
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>();
      String[] stringArray0 = new String[7];
      stringArray0[0] = "Bulgarian";
      stringArray0[1] = ")";
      stringArray0[2] = "Bulgarian";
      stringArray0[3] = ".";
      stringArray0[4] = ".";
      stringArray0[5] = "*NL*";
      stringArray0[6] = ".";
      List<?> list0 = Arrays.asList(stringArray0);
      WordToSentenceProcessor<Object> wordToSentenceProcessor1 = new WordToSentenceProcessor<Object>();
      List<List<Object>> list1 = wordToSentenceProcessor1.process(list0);
      assertFalse(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      String[] stringArray0 = new String[2];
      stringArray0[0] = "";
      stringArray0[1] = "*NL*";
      List<?> list0 = Arrays.asList(stringArray0);
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      Set<String> set1 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor<Object> wordToSentenceProcessor1 = new WordToSentenceProcessor<Object>(set1);
      wordToSentenceProcessor1.process(list0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      assertEquals(0, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess11()  throws Throwable  {
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>();
      String[] stringArray0 = new String[2];
      stringArray0[0] = ".";
      stringArray0[1] = ".";
      List<?> list0 = Arrays.asList(stringArray0);
      List<List<Object>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndProcess0()  throws Throwable  {
      String[] stringArray0 = new String[3];
      stringArray0[0] = ".";
      stringArray0[1] = "fUrweT1*jPSNvp[zUC=";
      stringArray0[2] = ".";
      List<?> list0 = Arrays.asList(stringArray0);
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>(false);
      List<List<Object>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeException0()  throws Throwable  {
      String[] stringArray0 = new String[18];
      stringArray0[0] = ".";
      List<?> list0 = Arrays.asList(stringArray0);
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess12()  throws Throwable  {
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>();
      String[] stringArray0 = new String[1];
      stringArray0[0] = "";
      List<?> list0 = Arrays.asList(stringArray0);
      List<List<Object>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(1, list1.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerExceptionAndProcess1()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      wordToSentenceProcessor0.process(stack0);
      SimpleTreeFactory simpleTreeFactory0 = new SimpleTreeFactory();
      Tree tree0 = simpleTreeFactory0.newTreeNode("t\"?J#\"z\"\"e}>7\"%b7%1", (List<Tree>) null);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(tree0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException4()  throws Throwable  {
      CoreLabel coreLabel0 = new CoreLabel();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(stack0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(stack0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments0()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      HashSet<String> hashSet0 = new HashSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>((String) null, (String) null, hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, hashSet0);
      WordToSentenceProcessor.NewlineIsSentenceBreak[] wordToSentenceProcessor_NewlineIsSentenceBreakArray0 = WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      assertEquals(3, wordToSentenceProcessor_NewlineIsSentenceBreakArray0.length);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTaking7Arguments()  throws Throwable  {
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("/^(S|PP|VP)/ < (/^(S(?!YM)|PP|VP)/ $++ (CC=start $+ (RB|ADVP $+ /^(S(?!YM)|PP|VP)/) [ (< and $+ (RB=end < yet)) |   (< and $+ (RB=end < so)) |   (< and $+ (ADVP=end < (RB|IN < so))) ] ))", (String) null, set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTakingNoArguments0()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      HashSet<String> hashSet0 = new HashSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>((String) null, "=o]?%L/UCX0qo*\"T;", hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, hashSet0);
      WordToSentenceProcessor.NewlineIsSentenceBreak[] wordToSentenceProcessor_NewlineIsSentenceBreakArray0 = WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      assertEquals(3, wordToSentenceProcessor_NewlineIsSentenceBreakArray0.length);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsPatternSyntaxException0()  throws Throwable  {
      TreeSet<String> treeSet0 = new TreeSet<String>();
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("Sgeb9]l{by=xt5Q%y/y", "Sgeb9]l{by=xt5Q%y/y", treeSet0, treeSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, treeSet0);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Illegal repetition near index 6
         // Sgeb9]l{by=xt5Q%y/y
         //       ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTakingNoArguments1()  throws Throwable  {
      String string0 = "mm=0^prd++T";
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "mm=0^prd++T");
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      String string1 = "n2\"x<W";
      TreeSet<String> treeSet0 = new TreeSet<String>();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      ComplexNodePattern.StringInSetAnnotationPattern complexNodePattern_StringInSetAnnotationPattern0 = new ComplexNodePattern.StringInSetAnnotationPattern(treeSet0, 3);
      Set<String> set0 = complexNodePattern_StringInSetAnnotationPattern0.getTargets();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("n2\"x<W", "1PyOx VOo_n;", set0, treeSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
      NERClassifierCombiner.Language nERClassifierCombiner_Language0 = NERClassifierCombiner.Language.CHINESE;
      Properties properties0 = new Properties();
      String[] stringArray0 = new String[5];
      stringArray0[0] = "n2\"x<W";
      stringArray0[1] = "mm=0^prd++T";
      stringArray0[2] = "n2\"x<W";
      stringArray0[3] = "n2\"x<W";
      stringArray0[4] = "Chinese";
      NERClassifierCombiner nERClassifierCombiner0 = null;
      try {
        nERClassifierCombiner0 = new NERClassifierCombiner(false, nERClassifierCombiner_Language0, false, properties0, stringArray0);
        fail("Expecting exception: IOException");
      
      } catch(Throwable e) {
         //
         // Couldn't load classifier from n2\"x<W
         //
         verifyException("edu.stanford.nlp.ie.ClassifierCombiner", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTakingBooleanThrowsPatternSyntaxException()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = null;
      try {
        wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("_Bvs#", "]fxRnfB,V8[jb,", (Set<String>) null, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, (Set<String>) null);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Unclosed character class near index 13
         // ]fxRnfB,V8[jb,
         //              ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndCreatesWordToSentenceProcessorTaking7Arguments()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("l7II=", ">\"j\"b0@(Y)r#p`0]/k", (Set<String>) null, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, (Set<String>) null);
      assertFalse(wordToSentenceProcessor1.equals((Object)wordToSentenceProcessor0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments1()  throws Throwable  {
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("\t\u0000\u0005\u0001\u0012\u0000\u0001\u0001\u0003\u0000\u0001\u0002\u0002\u0000\u0001\u0003\u0003\u0000\u0001\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0000\n\b\u0007\u0000\u0001\t\u0001\n\u0001\u000B\u0001\f\u0001\r\u0001\u000E\u0001\u000F\u0001\u0010\u0001\u0011\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001\u0016\u0001\u0017\u0001\u0018\u0001\u0019\u0001\u001A\u0001\u001B\u0001\u001C\u0001\u001D\u0001\u001E\u0001\u001F\u0001 \u0001!\u0001\"\u0004\u0000\u0001#\u0001\u0000\u0001$\u0001\n\u0001\u000B\u0001%\u0001\r\u0001\u000E\u0001\u000F\u0001\u0010\u0001\u0011\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001\u0016\u0001\u0017\u0001&\u0001\u0019\u0001\u001A\u0001\u001B\u0001\u001C\u0001'\u0001\u001E\u0001\u001F\u0001 \u0001!\u0001\"\n\u0000\u0001\u0001I\u0000\u0001(\u0003\u0000\u0001)\u001B\u0000\u0001(\u0003\u0000\u0001)<\u0000\u0002*M\u0000\u0001+\u0199\u0000\u0001,\u000E\u0000\u0002\u0001\u0100\u0000\u0001-\u00D5\u0000\u0100.", "l7II=", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsPatternSyntaxException1()  throws Throwable  {
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("samplingSpeedUpThreshold", ")kMgEo", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Unmatched closing ')'
         // )kMgEo
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreak0()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("always");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndStringToNewlineIsSentenceBreak()  throws Throwable  {
      String string0 = "never";
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      Vector<CoreAnnotations.OriginalTextAnnotation> vector0 = new Vector<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("never");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.never
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreak1()  throws Throwable  {
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      Locale locale0 = Locale.SIMPLIFIED_CHINESE;
      Set<String> set0 = locale0.getUnicodeLocaleAttributes();
      ComplexNodePattern.StringInSetAnnotationPattern complexNodePattern_StringInSetAnnotationPattern0 = new ComplexNodePattern.StringInSetAnnotationPattern(set0, 1183);
      Set<String> set1 = ZoneId.getAvailableZoneIds();
      String string0 = WordToSentenceProcessor.DEFAULT_BOUNDARY_FOLLOWERS_REGEX;
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", "", set0, treeSet0, "", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set1, false, true);
      Pair<SequencePattern.PatternExpr, SequenceMatchAction<CoreAnnotations.OriginalTextAnnotation>> pair0 = (Pair<SequencePattern.PatternExpr, SequenceMatchAction<CoreAnnotations.OriginalTextAnnotation>>) mock(Pair.class, new ViolatedAssumptionAnswer());
      WordToSentenceProcessor.NewlineIsSentenceBreak[] wordToSentenceProcessor_NewlineIsSentenceBreakArray0 = WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor.NewlineIsSentenceBreak[] wordToSentenceProcessor_NewlineIsSentenceBreakArray1 = WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      assertFalse(wordToSentenceProcessor_NewlineIsSentenceBreakArray1.equals((Object)wordToSentenceProcessor_NewlineIsSentenceBreakArray0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      Locale locale0 = Locale.SIMPLIFIED_CHINESE;
      Set<String> set0 = locale0.getUnicodeLocaleAttributes();
      ComplexNodePattern.StringInSetAnnotationPattern complexNodePattern_StringInSetAnnotationPattern0 = new ComplexNodePattern.StringInSetAnnotationPattern(set0, 1183);
      Set<String> set1 = complexNodePattern_StringInSetAnnotationPattern0.getTargets();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(set1);
      complexNodePattern_StringInSetAnnotationPattern0.toString();
      Vector<CoreAnnotations.OriginalTextAnnotation> vector0 = new Vector<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      vector0.add(coreAnnotations_OriginalTextAnnotation0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", "", set0, treeSet0, "", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set1, false, true);
      SequencePattern.Parser<CoreAnnotations.OriginalTextAnnotation> sequencePattern_Parser0 = (SequencePattern.Parser<CoreAnnotations.OriginalTextAnnotation>) mock(SequencePattern.Parser.class, new ViolatedAssumptionAnswer());
      doReturn((Pair) null).when(sequencePattern_Parser0).parseSequenceWithAction(any(edu.stanford.nlp.ling.tokensregex.Env.class) , anyString());
      Env env0 = new Env(sequencePattern_Parser0);
      // Undeclared exception!
      try { 
        SequencePattern.compile(env0, "$VALUES");
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Error compiling $VALUES using environment edu.stanford.nlp.ling.tokensregex.Env@5
         //
         verifyException("edu.stanford.nlp.ling.tokensregex.SequencePattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking10ArgumentsThrowsPatternSyntaxException0()  throws Throwable  {
      Locale locale0 = Locale.SIMPLIFIED_CHINESE;
      Set<String> set0 = locale0.getUnicodeLocaleAttributes();
      ComplexNodePattern.StringInSetAnnotationPattern complexNodePattern_StringInSetAnnotationPattern0 = new ComplexNodePattern.StringInSetAnnotationPattern(set0, 1183);
      Set<String> set1 = ZoneId.getAvailableZoneIds();
      String string0 = WordToSentenceProcessor.DEFAULT_BOUNDARY_FOLLOWERS_REGEX;
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", "ix", set0, set1, "Z[G*H`&(le`;w7a@7%s", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0, true, false);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Unclosed character class near index 41
         // <\\s*(?:Z[G*H`&(le`;w7a@7%s)(?:\\s+[^>]+?)?>
         //                                          ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments2()  throws Throwable  {
      TreeSet<String> treeSet0 = new TreeSet<String>();
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("<@D]g6A", "<@D]g6A", treeSet0, treeSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, treeSet0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments3()  throws Throwable  {
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("/^(S|PP|VP)/ < (/^(S(?!YM)|PP|VP)/ $++ (CC=start $+ (RB|ADVP $+ /^(S(?!YM)|PP|VP)/) [ (< and $+ (RB=end < yet)) |   (< and $+ (RB=end < so)) |   (< and $+ (ADVP=end < (RB|IN < so))) ] ))", "/^(S|PP|VP)/ < (/^(S(?!YM)|PP|VP)/ $++ (CC=start $+ (RB|ADVP $+ /^(S(?!YM)|PP|VP)/) [ (< and $+ (RB=end < yet)) |   (< and $+ (RB=end < so)) |   (< and $+ (ADVP=end < (RB|IN < so))) ] ))", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>("<$>", "<$>", treeSet0, treeSet0, "<$>", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super Object>) null, treeSet0, false, false);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndProcessAndProcessWithEmptyList()  throws Throwable  {
      ArrayList<CoreAnnotations.OriginalTextAnnotation> arrayList0 = new ArrayList<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(true);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list0 = wordToSentenceProcessor0.process(arrayList0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testProcessReturningListWhereIsEmptyIsFalseAndListWhereSizeIsPositive()  throws Throwable  {
      String string0 = "";
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak1 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor1 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(wordToSentenceProcessor_NewlineIsSentenceBreak1);
      ArrayList<CoreAnnotations.OriginalTextAnnotation> arrayList0 = new ArrayList<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = List.of(coreAnnotations_OriginalTextAnnotation0);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor2 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(true);
      wordToSentenceProcessor2.process(list0);
      wordToSentenceProcessor2.process(arrayList0);
      arrayList0.spliterator();
      wordToSentenceProcessor2.process(list0);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("PRt");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.PRt
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking10ArgumentsThrowsPatternSyntaxException1()  throws Throwable  {
      Locale locale0 = Locale.CANADA;
      Set<String> set0 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(set0);
      Vector<CoreAnnotations.OriginalTextAnnotation> vector0 = new Vector<CoreAnnotations.OriginalTextAnnotation>();
      ZoneId.getAvailableZoneIds();
      String string0 = WordToSentenceProcessor.DEFAULT_BOUNDARY_FOLLOWERS_REGEX;
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = null;
      try {
        wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("-<c+UiM--><HQ", "&x1*9Z /vx", set0, set0, "-<c+UiM--><HQ", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0, false, false);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Dangling meta character '*' near index 16
         // <\\s*(?:/\\s*)?(?:*NL*)(?:\\s+[^>]+?|\\s*(?:/\\s*)?)>
         //                 ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsIllegalArgumentException()  throws Throwable  {
      HashSet<String> hashSet0 = new HashSet<String>();
      hashSet0.add("' (should be one of 'always', 'never', 'two')");
      hashSet0.add("' (should be one of 'always', 'never', 'two')");
      hashSet0.add("");
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(hashSet0);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("' (should be one of 'always', 'never', 'two')");
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("always");
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor.NewlineIsSentenceBreak[] wordToSentenceProcessor_NewlineIsSentenceBreakArray0 = WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      assertEquals(3, wordToSentenceProcessor_NewlineIsSentenceBreakArray0.length);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreak2()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("two");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testProcessDocument()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(true);
      Document<CoreAnnotations.OriginalTextAnnotation, CoreAnnotations.OriginalTextAnnotation, CoreAnnotations.OriginalTextAnnotation> document0 = null;
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.processDocument((Document<BasicSequenceMatchResult<BasicSequenceMatchResult<BasicSequenceMatchResult>>, CoreAnnotations.OriginalTextAnnotation, CoreLabel>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessDocumentThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.processDocument(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakWithNull()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("pD$KdJ A$<A9()");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'pD$KdJ A$<A9()' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentException()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("1:D5H[QAzyL1?");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '1:D5H[QAzyL1?' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndProcess1()  throws Throwable  {
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      String[] stringArray0 = new String[2];
      stringArray0[0] = "*NL*";
      stringArray0[1] = "*NL*";
      List<?> list0 = Arrays.asList(stringArray0);
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>(false);
      wordToSentenceProcessor0.process(list0);
      WordToSentenceProcessor.NewlineIsSentenceBreak[] wordToSentenceProcessor_NewlineIsSentenceBreakArray0 = WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      assertEquals(3, wordToSentenceProcessor_NewlineIsSentenceBreakArray0.length);
  }

  @Test(timeout = 4000)
  public void testProcessReturningListWhereIsEmptyIsTrueAndListWhereSizeIsZero()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag(coreLabel0);
      IndexedWord indexedWord0 = new IndexedWord(wordLemmaTag0);
      Tree[] treeArray0 = new Tree[0];
      List<Tree> list0 = List.of(treeArray0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0, list0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      indexedWord0.setTag((String) null);
      List<CoreLabel> list1 = treeGraphNode1.taggedLabeledYield(true, (-848));
      List<List<CoreLabel>> list2 = wordToSentenceProcessor0.process(list1);
      assertFalse(list2.contains(list1));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcessAndProcessWithEmptyList()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      ArrayList<CoreAnnotations.OriginalTextAnnotation> arrayList0 = new ArrayList<CoreAnnotations.OriginalTextAnnotation>();
      List<List<CoreAnnotations.OriginalTextAnnotation>> list0 = wordToSentenceProcessor0.process(arrayList0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking3ArgumentsThrowsPatternSyntaxException()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>>(true);
      String string0 = "{";
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = null;
      try {
        wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>("{", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Illegal repetition
         // {
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess13()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "^T");
      StringLabelFactory stringLabelFactory0 = new StringLabelFactory();
      Label label0 = stringLabelFactory0.newLabelFromString("^T");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(label0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(stack0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testProcessWithNull()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process((List<? extends CoreAnnotations.OriginalTextAnnotation>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking3Arguments()  throws Throwable  {
      String string0 = "";
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>("", wordToSentenceProcessor_NewlineIsSentenceBreak0, true);
      Locale locale0 = Locale.SIMPLIFIED_CHINESE;
      Set<String> set0 = locale0.getUnicodeLocaleAttributes();
      ComplexNodePattern.StringInSetAnnotationPattern complexNodePattern_StringInSetAnnotationPattern0 = new ComplexNodePattern.StringInSetAnnotationPattern(set0, 1183);
      Set<String> set1 = complexNodePattern_StringInSetAnnotationPattern0.getTargets();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(set1);
      complexNodePattern_StringInSetAnnotationPattern0.toString();
      Vector<CoreAnnotations.OriginalTextAnnotation> vector0 = new Vector<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      vector0.add(coreAnnotations_OriginalTextAnnotation0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor1.process(vector0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(set0);
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeException1()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = List.of(coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      Properties properties0 = new Properties();
      // Undeclared exception!
      try { 
        NERClassifierCombiner.getClassifier((ObjectInputStream) null, properties0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ie.ClassifierCombiner", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak2()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }
}
