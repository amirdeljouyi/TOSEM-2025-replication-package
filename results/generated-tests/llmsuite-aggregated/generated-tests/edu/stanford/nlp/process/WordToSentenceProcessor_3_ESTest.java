/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Jun 11 18:31:12 GMT 2025
 */

package edu.stanford.nlp.process;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.NERClassifierCombiner;
import edu.stanford.nlp.ie.PresetSequenceClassifier;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.tokensregex.SequencePattern;
import edu.stanford.nlp.ling.tokensregex.types.Expression;
import edu.stanford.nlp.ling.tokensregex.types.Expressions;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.WordToSentenceProcessor;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.DeltaIndex;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EmptyStackException;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.regex.PatternSyntaxException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class WordToSentenceProcessor_3_ESTest extends WordToSentenceProcessor_3_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess0()  throws Throwable  {
      Vector<String> vector0 = new Vector<String>();
      Vector<String> vector1 = new Vector<String>();
      vector1.add("*NL*");
      HashSet<String> hashSet0 = new HashSet<String>();
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(hashSet0);
      List<List<String>> list0 = wordToSentenceProcessor0.process(vector1);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException0()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.setWord("'");
      Class<CoreAnnotations.TextAnnotation> class0 = CoreAnnotations.TextAnnotation.class;
      coreLabel0.set(class0, "'");
      Class<CoreAnnotations.OriginalTextAnnotation> class1 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel0.set(class1, "'");
      CoreLabel coreLabel1 = new CoreLabel();
      coreLabel1.setWord("He");
      Class<CoreAnnotations.TextAnnotation> class2 = CoreAnnotations.TextAnnotation.class;
      coreLabel1.set(class2, "He");
      Class<CoreAnnotations.OriginalTextAnnotation> class3 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel1.set(class3, "He");
      CoreLabel coreLabel2 = new CoreLabel();
      coreLabel2.setWord("said");
      Class<CoreAnnotations.TextAnnotation> class4 = CoreAnnotations.TextAnnotation.class;
      coreLabel2.set(class4, "said");
      Class<CoreAnnotations.OriginalTextAnnotation> class5 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel2.set(class5, "said");
      CoreLabel coreLabel3 = new CoreLabel();
      coreLabel3.setWord("'");
      Class<CoreAnnotations.TextAnnotation> class6 = CoreAnnotations.TextAnnotation.class;
      coreLabel3.set(class6, "'");
      Class<CoreAnnotations.OriginalTextAnnotation> class7 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel3.set(class7, "'");
      CoreLabel coreLabel4 = new CoreLabel();
      coreLabel4.setWord(".");
      Class<CoreAnnotations.TextAnnotation> class8 = CoreAnnotations.TextAnnotation.class;
      coreLabel4.set(class8, ".");
      Class<CoreAnnotations.OriginalTextAnnotation> class9 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel4.set(class9, ".");
      CoreLabel coreLabel5 = new CoreLabel();
      coreLabel5.setWord("'");
      Class<CoreAnnotations.TextAnnotation> class10 = CoreAnnotations.TextAnnotation.class;
      coreLabel5.set(class10, "'");
      Class<CoreAnnotations.OriginalTextAnnotation> class11 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel5.set(class11, "'");
      CoreLabel[] coreLabelArray0 = new CoreLabel[6];
      coreLabelArray0[0] = coreLabel0;
      coreLabelArray0[1] = coreLabel1;
      coreLabelArray0[2] = coreLabel2;
      coreLabelArray0[3] = coreLabel3;
      coreLabelArray0[4] = coreLabel4;
      coreLabelArray0[5] = coreLabel5;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException1()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceUntilEndAnnotation> class0 = CoreAnnotations.ForcedSentenceUntilEndAnnotation.class;
      coreLabel0.set(class0, false);
      CoreLabel[] coreLabelArray0 = new CoreLabel[10];
      coreLabelArray0[0] = coreLabel0;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeException0()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.setWord("qo2Ne");
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class0 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      coreLabel0.set(class0, false);
      CoreLabel[] coreLabelArray0 = new CoreLabel[10];
      coreLabelArray0[0] = coreLabel0;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTakingBooleanThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.setWord("Token");
      Class<CoreAnnotations.ForcedSentenceUntilEndAnnotation> class0 = CoreAnnotations.ForcedSentenceUntilEndAnnotation.class;
      coreLabel0.set(class0, false);
      CoreLabel coreLabel1 = new CoreLabel();
      String string0 = "\n";
      coreLabel1.setWord("\n");
      CoreLabel coreLabel2 = new CoreLabel();
      coreLabel2.setWord("More");
      CoreLabel coreLabel3 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class1 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      boolean boolean0 = true;
      coreLabel3.set(class1, true);
      CoreLabel[] coreLabelArray0 = new CoreLabel[4];
      coreLabelArray0[0] = coreLabel0;
      coreLabelArray0[1] = coreLabel1;
      coreLabelArray0[2] = coreLabel2;
      coreLabelArray0[3] = coreLabel3;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeException1()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceUntilEndAnnotation> class0 = CoreAnnotations.ForcedSentenceUntilEndAnnotation.class;
      coreLabel0.set(class0, true);
      CoreLabel coreLabel1 = new CoreLabel();
      CoreLabel coreLabel2 = new CoreLabel();
      coreLabel2.setWord("More");
      CoreLabel coreLabel3 = CoreLabel.wordFromString("\n");
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class1 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      boolean boolean0 = true;
      coreLabel3.set(class1, true);
      CoreLabel[] coreLabelArray0 = new CoreLabel[10];
      coreLabelArray0[0] = coreLabel0;
      coreLabelArray0[1] = coreLabel1;
      coreLabelArray0[2] = coreLabel2;
      coreLabelArray0[3] = coreLabel3;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeException2()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceUntilEndAnnotation> class0 = CoreAnnotations.ForcedSentenceUntilEndAnnotation.class;
      coreLabel0.set(class0, true);
      CoreLabel[] coreLabelArray0 = new CoreLabel[16];
      coreLabelArray0[0] = coreLabel0;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeException3()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.setWord("qo2Ne");
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class0 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      coreLabel0.set(class0, true);
      CoreLabel[] coreLabelArray0 = new CoreLabel[10];
      coreLabelArray0[0] = coreLabel0;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess1()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList0);
      treeGraphNode0.yield(linkedList0);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(linkedHashSet0);
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>(linkedHashSet0);
      List<String> list0 = List.of("", "d|Y{kU`7,'d", "d|Y{kU`7,'d", "oft`V]!Y{Wv{iMq", "73I+]D<,1< x3", ".", "73I+]D<,1< x3", "useURLSequences");
      List<List<String>> list1 = wordToSentenceProcessor1.process(list0);
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testProcessAndCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak()  throws Throwable  {
      Stack<String> stack0 = new Stack<String>();
      stack0.add("*NL*");
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      List<List<String>> list0 = wordToSentenceProcessor1.process(stack0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess2()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("");
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(linkedHashSet0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTakingNoArgumentsThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class0 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      coreLabel0.set(class0, true);
      CoreLabel[] coreLabelArray0 = new CoreLabel[13];
      coreLabelArray0[0] = coreLabel0;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking3ArgumentsAndProcess0()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("\"", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\"");
      IndexedWord indexedWord0 = new IndexedWord(coreLabel0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor0.process(linkedList0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTaking7Arguments0()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "");
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      Set<String> set0 = presetSequenceClassifier0.labels();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("Pacific/Majuro", "Pacific/Majuro", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(presetSequenceClassifier0.classIndex, presetSequenceClassifier0.classIndex);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "Pacific/Majuro");
      presetSequenceClassifier0.labels();
      List<String> list0 = deltaIndex0.objectsList();
      wordToSentenceProcessor0.process(list0);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>(true);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak(")mv(z^_783a%7");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: ')mv(z^_783a%7' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndProcessWithEmptyList()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      String string0 = "";
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "");
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      Set<String> set0 = presetSequenceClassifier0.labels();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("", "Pacific/Majuro", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(presetSequenceClassifier0.classIndex, presetSequenceClassifier0.classIndex);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "L3E{drN@_");
      presetSequenceClassifier0.labels();
      List<String> list0 = deltaIndex0.objectsList();
      wordToSentenceProcessor0.process(list0);
      Vector<String> vector0 = new Vector<String>();
      wordToSentenceProcessor0.process(vector0);
      String string1 = "Expected token to be either Word or String.";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("Expected token to be either Word or String.");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'Expected token to be either Word or String.' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess3()  throws Throwable  {
      Vector<String> vector0 = new Vector<String>();
      vector0.add("*NL*");
      HashSet<String> hashSet0 = new HashSet<String>();
      hashSet0.add("*NL*");
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(hashSet0);
      wordToSentenceProcessor0.process(vector0);
      List<List<String>> list0 = wordToSentenceProcessor0.process(vector0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess4()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      IndexedWord indexedWord0 = new IndexedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("");
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(linkedHashSet0);
      wordToSentenceProcessor0.process(list0);
      Random.setNextRandom(1179);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess0()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString(")\"s>");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      Set<String> set0 = presetSequenceClassifier0.labels();
      properties0.containsKey("fw_\"e");
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, true);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("fw_\"e", "Indian/Kerguelen", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(presetSequenceClassifier0.classIndex, presetSequenceClassifier0.classIndex);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "Indian/Kerguelen");
      presetSequenceClassifier0.labels();
      List<String> list0 = deltaIndex0.objectsList();
      wordToSentenceProcessor0.process(list0);
      Vector<CoreAnnotations.OriginalTextAnnotation> vector0 = new Vector<CoreAnnotations.OriginalTextAnnotation>();
      assertTrue(vector0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess0()  throws Throwable  {
      Stack<String> stack0 = new Stack<String>();
      stack0.add("*NL*");
      stack0.add("*NL*");
      stack0.add("");
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      List<List<String>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndProcess0()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("38");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList0);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("38");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("38", "38", linkedHashSet0, linkedHashSet0, ".", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, linkedHashSet0, false, false);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess1()  throws Throwable  {
      Stack<String> stack0 = new Stack<String>();
      stack0.add("*NL*");
      stack0.add("*NL*");
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      List<List<String>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess1()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "");
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      Set<String> set0 = presetSequenceClassifier0.labels();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("", "fw_\"e", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
      DeltaIndex<String> deltaIndex0 = new DeltaIndex<String>(presetSequenceClassifier0.classIndex, presetSequenceClassifier0.classIndex);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "\u2029");
      presetSequenceClassifier0.labels();
      List<String> list0 = deltaIndex0.objectsList();
      wordToSentenceProcessor0.process(list0);
      Vector<CoreAnnotations.OriginalTextAnnotation> vector0 = new Vector<CoreAnnotations.OriginalTextAnnotation>();
      assertEquals(10, vector0.capacity());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess2()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList0);
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      TreeSet<String> treeSet0 = new TreeSet<String>();
      treeGraphNode0.yield(linkedList0);
      Set<String> set1 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", "\"", set1, treeSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(2, list0.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerExceptionAndCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      CoreLabel coreLabel0 = new CoreLabel();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList0);
      HashSet<String> hashSet0 = new HashSet<String>();
      TreeSet<String> treeSet0 = new TreeSet<String>();
      treeSet0.add("");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", "", treeSet0, hashSet0, "", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, treeSet0, false, false);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testProcessAndCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      IndexedWord indexedWord0 = new IndexedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      treeGraphNode0.yield(linkedList0);
      linkedList0.clone();
      Set<String> set0 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(set0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", "[.\u3002]|[!?\uFF01\uFF1F]+", set0, set0, "Q8}P@fkG_KuMkbv_", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0, false, false);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor1.process(list0);
      assertTrue(list1.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndProcess1()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      HashSet<String> hashSet0 = new HashSet<String>();
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", "", treeSet0, hashSet0, "", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, treeSet0, false, false);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor0.process(linkedList0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess3()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("PdqLo~!8Z");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList0);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("PdqLo~!8Z", "PdqLo~!8Z", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, linkedHashSet0);
      wordToSentenceProcessor0.process(linkedList0);
      System.setCurrentTimeMillis(18014467228958720L);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking3ArgumentsAndProcess1()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("\"", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\"");
      IndexedWord indexedWord0 = new IndexedWord(coreLabel0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      treeGraphNode0.yield(linkedList0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testProcessThrowsClassCastException()  throws Throwable  {
      Stack<String> stack0 = new Stack<String>();
      stack0.add(".");
      stack0.add("'");
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(stack0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // class java.lang.String cannot be cast to class edu.stanford.nlp.ling.Label (java.lang.String is in module java.base of loader 'bootstrap'; edu.stanford.nlp.ling.Label is in unnamed module of loader org.evosuite.instrumentation.InstrumentingClassLoader @4a876080)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking3ArgumentsAndProcess2()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("\"", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\"");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      List<CoreAnnotations.OriginalTextAnnotation> list1 = treeGraphNode0.yield(list0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list2 = wordToSentenceProcessor0.process(list1);
      assertTrue(list2.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      Locale locale0 = Locale.GERMAN;
      Set<String> set0 = locale0.getUnicodeLocaleKeys();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("4Zs#\"yxX", "4Zs#\"yxX", (Set<String>) null, treeSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list0 = wordToSentenceProcessor1.process(stack0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTaking7Arguments1()  throws Throwable  {
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      stack0.add((CoreAnnotations.OriginalTextAnnotation) null);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("Expected token to be either Word or String.", (String) null, treeSet0, treeSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, treeSet0);
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("' (should be one of 'always', 'never', 'two')");
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcessAndProcessWithEmptyList()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      IndexedWord indexedWord0 = new IndexedWord(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      Locale locale0 = Locale.JAPAN;
      Set<String> set0 = locale0.getUnicodeLocaleKeys();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      Set<String> set1 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("S=r=NP", "S=r=NP", set0, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list0 = wordToSentenceProcessor0.process(linkedList0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsPatternSyntaxException0()  throws Throwable  {
      CoreLabel.wordFromString("NEVER");
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      Locale locale0 = Locale.JAPAN;
      Set<String> set0 = locale0.getUnicodeLocaleKeys();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      Set<String> set1 = WordToSentenceProcessor.DEFAULT_SENTENCE_BOUNDARIES_TO_DISCARD;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("NEVER", "NEVER", set0, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set1);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Dangling meta character '*' near index 0
         // *NL*
         // ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsPatternSyntaxException1()  throws Throwable  {
      CoreLabel coreLabel0 = CoreLabel.wordFromString("NEVER");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList0);
      Locale locale0 = Locale.JAPAN;
      Set<String> set0 = locale0.getUnicodeLocaleKeys();
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList1 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      ArrayList<CoreAnnotations.OriginalTextAnnotation> arrayList0 = new ArrayList<CoreAnnotations.OriginalTextAnnotation>();
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList2 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList2);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("b*QtT3!^#A<{wi 0Ls", "NEVER", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set0);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Illegal repetition near index 10
         // b*QtT3!^#A<{wi 0Ls
         //           ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsPatternSyntaxException2()  throws Throwable  {
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      Locale locale0 = Locale.GERMAN;
      Set<String> set0 = locale0.getUnicodeLocaleKeys();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>((String) null, "^/6.i(N2HN0Ia4\u0003", set0, treeSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, treeSet0);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Unclosed group near index 15
         // ^/6.i(N2HN0Ia4\u0003
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTaking7Arguments()  throws Throwable  {
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("Expected token to be either Word or String.", "Expected token to be either Word or String.", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, (Set<String>) null);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments0()  throws Throwable  {
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("Expected token to be either Word or String.", "Expected token to be either Word or String.", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, (Set<String>) null);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndStringToNewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("two");
      WordToSentenceProcessor.NewlineIsSentenceBreak[] wordToSentenceProcessor_NewlineIsSentenceBreakArray0 = WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      assertEquals(3, wordToSentenceProcessor_NewlineIsSentenceBreakArray0.length);
  }

  @Test(timeout = 4000)
  public void testProcess0()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      coreLabel0.setBefore("");
      IndexedWord indexedWord0 = new IndexedWord(coreLabel0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.yield(linkedList0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      Locale locale0 = Locale.JAPAN;
      Set<String> set0 = locale0.getUnicodeLocaleKeys();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(set0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor1.process(linkedList0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess2()  throws Throwable  {
      Stack<String> stack0 = new Stack<String>();
      stack0.add(".");
      stack0.add("e");
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      List<List<String>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking3ArgumentsThrowsIllegalArgumentException()  throws Throwable  {
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      String string0 = null;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      boolean boolean0 = true;
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessAndStringToNewlineIsSentenceBreak()  throws Throwable  {
      Stack<String> stack0 = new Stack<String>();
      stack0.add("h3,`(2})");
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER, wordToSentenceProcessor_NewlineIsSentenceBreak0);
      
      List<List<String>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10Arguments0()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("[.\u3002]|[!?\uFF01\uFF1F]+", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("[.\u3002]|[!?\uFF01\uFF1F]+");
      CoreLabel coreLabel1 = new CoreLabel((CoreMap) coreLabel0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel2 = coreLabelTokenFactory0.makeToken("[.\u3002]|[!?\uFF01\uFF1F]+", "[.\u3002]|[!?\uFF01\uFF1F]+", 66, 1);
      IndexedWord indexedWord0 = new IndexedWord(coreLabel2);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel1);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      linkedList0.add(coreAnnotations_OriginalTextAnnotation0);
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      treeGraphNode0.yield(list0);
      Locale locale0 = Locale.SIMPLIFIED_CHINESE;
      Set<String> set0 = locale0.getUnicodeLocaleKeys();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor2 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(set0);
      ArrayList<CoreAnnotations.OriginalTextAnnotation> arrayList0 = new ArrayList<CoreAnnotations.OriginalTextAnnotation>();
      wordToSentenceProcessor1.process(arrayList0);
      Locale.IsoCountryCode locale_IsoCountryCode0 = Locale.IsoCountryCode.PART3;
      Set<String> set1 = Locale.getISOCountries(locale_IsoCountryCode0);
      WordToSentenceProcessor<String> wordToSentenceProcessor3 = new WordToSentenceProcessor<String>("[.\u3002]|[!?\uFF01\uFF1F]+", "[.\u3002]|[!?\uFF01\uFF1F]+", set0, set0, "D2T-4U,r;", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set1, false, false);
      Stack<Locale.LanguageRange> stack0 = new Stack<Locale.LanguageRange>();
      Expressions.ConditionalExpression expressions_ConditionalExpression0 = new Expressions.ConditionalExpression("D2T-4U,r;", (Expression) null, (Expression) null);
      // Undeclared exception!
      try { 
        expressions_ConditionalExpression0.getTags();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.tokensregex.types.Expressions$WrappedExpression", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndCreatesWordToSentenceProcessorTaking7Arguments()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("Expected token to be either Word or String.", "Expected token to be either Word or String.", (Set<String>) null, treeSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, (Set<String>) null);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndStringToNewlineIsSentenceBreak()  throws Throwable  {
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      Vector<CoreAnnotations.OriginalTextAnnotation> vector0 = new Vector<CoreAnnotations.OriginalTextAnnotation>();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("&5_>UO\"");
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("GB<J&pia3_5N>3r<G", "CK-", linkedHashSet0, linkedHashSet0, "GB<J&pia3_5N>3r<G", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0, true, true);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak1 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("' (should be one of 'always', 'never', 'two')");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE, wordToSentenceProcessor_NewlineIsSentenceBreak1);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments1()  throws Throwable  {
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>((String) null, (String) null, set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, set0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10Arguments1()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("<b", "<b", treeSet0, treeSet0, "<b", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, treeSet0, false, false);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndCreatesWordToSentenceProcessorTaking3Arguments()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      CoreLabel coreLabel1 = new CoreLabel((CoreMap) coreLabel0);
      IndexedWord indexedWord0 = new IndexedWord(coreLabel1);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("always");
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      List<CoreAnnotations.OriginalTextAnnotation> list1 = treeGraphNode0.yield(list0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list2 = wordToSentenceProcessor0.process(list1);
      assertEquals(2, list2.size());
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreak0()  throws Throwable  {
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("always");
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("two_newlines");
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("invalid");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'invalid' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("[.\u3002]|[!?\uFF01\uFF1F]+", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("[.\u3002]|[!?\uFF01\uFF1F]+");
      CoreLabel coreLabel1 = new CoreLabel((CoreMap) coreLabel0);
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory(false);
      CoreLabel coreLabel2 = coreLabelTokenFactory0.makeToken("[.\u3002]|[!?\uFF01\uFF1F]+", "[.\u3002]|[!?\uFF01\uFF1F]+", 66, 1);
      IndexedWord indexedWord0 = new IndexedWord(coreLabel2);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel1);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      List<CoreAnnotations.OriginalTextAnnotation> list1 = treeGraphNode0.yield(linkedList0);
      Locale locale0 = Locale.SIMPLIFIED_CHINESE;
      Set<String> set0 = locale0.getUnicodeLocaleKeys();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor2 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(set0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list2 = wordToSentenceProcessor2.process(list1);
      assertTrue(list2.contains(list0));
  }

  @Test(timeout = 4000)
  public void testProcess1()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("\"", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      CoreLabel.wordFromString("\"");
      Vector<String> vector0 = new Vector<String>();
      vector0.add("*NL*");
      Locale.IsoCountryCode locale_IsoCountryCode0 = Locale.IsoCountryCode.PART1_ALPHA3;
      Set<String> set0 = Locale.getISOCountries(locale_IsoCountryCode0);
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>(set0);
      List<List<String>> list0 = wordToSentenceProcessor1.process(vector0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess3()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      CoreLabel coreLabel0 = CoreLabel.wordFromString(")s*>");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list1 = wordToSentenceProcessor0.process(linkedList0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndProcess()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<String>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<String>>(true);
      Stack<WordToSentenceProcessor<String>> stack0 = new Stack<WordToSentenceProcessor<String>>();
      List<List<WordToSentenceProcessor<String>>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testProcessReturningListWhereIsEmptyIsTrueAndListWhereSizeIsZero()  throws Throwable  {
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(treeSet0);
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "Label argument lacks IndexAnnotation.");
      wordToSentenceProcessor0.process(stack0);
      stack0.add((CoreAnnotations.OriginalTextAnnotation) null);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(stack0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess4()  throws Throwable  {
      Vector<String> vector0 = new Vector<String>();
      vector0.add(".");
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      List<List<String>> list0 = wordToSentenceProcessor0.process(vector0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess5()  throws Throwable  {
      Vector<String> vector0 = new Vector<String>();
      vector0.add("s6L*");
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      List<List<String>> list0 = wordToSentenceProcessor0.process(vector0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess6()  throws Throwable  {
      Vector<String> vector0 = new Vector<String>();
      vector0.add(".");
      vector0.add(".");
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      List<List<String>> list0 = wordToSentenceProcessor0.process(vector0);
      assertEquals(2, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess7()  throws Throwable  {
      Vector<String> vector0 = new Vector<String>();
      vector0.add("*NL*");
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>();
      List<List<String>> list0 = wordToSentenceProcessor0.process(vector0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcessAndProcessWithEmptyList()  throws Throwable  {
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      List<List<CoreAnnotations.OriginalTextAnnotation>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking3ArgumentsAndProcessAndProcessReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      CoreLabel coreLabel1 = new CoreLabel((CoreMap) coreLabel0);
      IndexedWord indexedWord0 = new IndexedWord(coreLabel1);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      List<CoreAnnotations.OriginalTextAnnotation> list1 = treeGraphNode0.yield(list0);
      List<List<CoreAnnotations.OriginalTextAnnotation>> list2 = wordToSentenceProcessor0.process(list1);
      assertEquals(2, list2.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException2()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      IndexedWord indexedWord0 = new IndexedWord();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(linkedList0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testProcessDocument()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor1.processDocument(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessDocumentThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<String>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<String>>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.processDocument(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      boolean boolean0 = true;
      WordToSentenceProcessor<List<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor1 = new WordToSentenceProcessor<List<CoreAnnotations.OriginalTextAnnotation>>(true);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>> wordToSentenceProcessor2 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreLabel>>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      String string0 = "never";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("never");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.never
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>();
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreakWithNull()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcessThrowsRuntimeException()  throws Throwable  {
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(treeSet0);
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      stack0.add((CoreAnnotations.OriginalTextAnnotation) null);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(stack0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(linkedHashSet0);
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeException4()  throws Throwable  {
      WordToSentenceProcessor<Object> wordToSentenceProcessor0 = new WordToSentenceProcessor<Object>();
      Object object0 = new Object();
      List<Object> list0 = (List<Object>)Collections.singletonList(object0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessAndProcess()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", wordToSentenceProcessor_NewlineIsSentenceBreak0, true);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("");
      CoreLabel coreLabel1 = new CoreLabel((CoreMap) coreLabel0);
      IndexedWord indexedWord0 = IndexedWord.NO_WORD;
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(indexedWord0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      ArrayList<CoreAnnotations.OriginalTextAnnotation> arrayList0 = new ArrayList<CoreAnnotations.OriginalTextAnnotation>();
      treeGraphNode0.depth();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = treeGraphNode0.yield(arrayList0);
      wordToSentenceProcessor0.process(list0);
      assertEquals(1, arrayList0.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerExceptionAndProcessWithNull()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process((List<? extends CoreAnnotations.OriginalTextAnnotation>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerExceptionAndProcess()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      String string0 = null;
      String string1 = "aDAfz/0~Z}*5=6@%";
      CoreLabelTokenFactory coreLabelTokenFactory0 = new CoreLabelTokenFactory();
      CoreLabel coreLabel0 = coreLabelTokenFactory0.makeToken("_-z6_XmN", "MorL*g", 31, 3149);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(coreLabel0);
      treeGraphNode0.taggedYield(null);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process((List<? extends CoreAnnotations.OriginalTextAnnotation>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking3ArgumentsThrowsPatternSyntaxException()  throws Throwable  {
      String string0 = "P?n{N=r)$j";
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("P?n{N=r)$j", wordToSentenceProcessor_NewlineIsSentenceBreak0, true);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Illegal repetition near index 2
         // P?n{N=r)$j
         //   ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsEmptyStackException()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(false);
      Stack<CoreLabel> stack0 = new Stack<CoreLabel>();
      stack0.listIterator();
      // Undeclared exception!
      try { 
        stack0.pop();
        fail("Expecting exception: EmptyStackException");
      
      } catch(EmptyStackException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Stack", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<WordToSentenceProcessor<LabeledWord>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<LabeledWord>>();
      String string0 = "";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTakingBoolean()  throws Throwable  {
      boolean boolean0 = true;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(true);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      Vector<CoreAnnotations.OriginalTextAnnotation> vector0 = new Vector<CoreAnnotations.OriginalTextAnnotation>();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>("GB<J&pia3_5N>3r<G", "CK-", linkedHashSet0, linkedHashSet0, "GB<J&pia3_5N>3r<G", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, linkedHashSet0, true, true);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak1 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("' (should be one of 'always', 'never', 'two')");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE, wordToSentenceProcessor_NewlineIsSentenceBreak1);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreak1()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("}W'}liX^.s");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '}W'}liX^.s' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentException()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak(" (");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: ' (' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }
}
