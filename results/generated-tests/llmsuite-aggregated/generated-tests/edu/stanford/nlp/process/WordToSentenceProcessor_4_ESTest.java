/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Jun 11 18:30:00 GMT 2025
 */

package edu.stanford.nlp.process;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.stanford.nlp.ie.NERClassifierCombiner;
import edu.stanford.nlp.ie.PresetSequenceClassifier;
import edu.stanford.nlp.ling.BasicDocument;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Document;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.ling.tokensregex.BasicSequenceMatchResult;
import edu.stanford.nlp.ling.tokensregex.SequencePattern;
import edu.stanford.nlp.process.PTBTokenizer;
import edu.stanford.nlp.process.WordToSentenceProcessor;
import edu.stanford.nlp.sequences.TrueCasingForNISTDocumentReaderAndWriter;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.util.MapFactory;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.regex.PatternSyntaxException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class WordToSentenceProcessor_4_ESTest extends WordToSentenceProcessor_4_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking3ArgumentsAndProcess0()  throws Throwable  {
      ArrayList<HasWord> arrayList0 = new ArrayList<HasWord>();
      Word word0 = new Word("'");
      arrayList0.add((HasWord) word0);
      arrayList0.add((HasWord) word0);
      arrayList0.add((HasWord) word0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>("'", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(arrayList0);
      assertEquals(2, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess0()  throws Throwable  {
      LabeledWord labeledWord0 = new LabeledWord();
      labeledWord0.setFromString("*NL*");
      Stack<HasWord> stack0 = new Stack<HasWord>();
      stack0.add((HasWord) labeledWord0);
      TaggedWord taggedWord0 = new TaggedWord("*NL*");
      stack0.add((HasWord) labeledWord0);
      Locale locale0 = Locale.JAPAN;
      Locale locale1 = locale0.stripExtensions();
      Set<String> set0 = locale1.getUnicodeLocaleAttributes();
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>(set0);
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess1()  throws Throwable  {
      LabeledWord labeledWord0 = new LabeledWord();
      labeledWord0.setFromString("*NL*");
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(treeSet0);
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(labeledWord0);
      ArrayList<CoreLabel> arrayList0 = treeGraphNode0.yieldHasWord();
      ArrayList<CoreLabel> arrayList1 = treeGraphNode0.yieldHasWord(arrayList0);
      List<List<CoreLabel>> list0 = wordToSentenceProcessor0.process(arrayList1);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testProcessDocumentAndProcessDocumentReturningDocumentWhereIsEmptyIsTrue()  throws Throwable  {
      System.setCurrentTimeMillis(0L);
      WordToSentenceProcessor<CoreLabel.OutputFormat> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel.OutputFormat>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<Word> wordToSentenceProcessor1 = new WordToSentenceProcessor<Word>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      PTBTokenizer.PTBTokenizerFactory<Word> pTBTokenizer_PTBTokenizerFactory0 = PTBTokenizer.PTBTokenizerFactory.newWordTokenizerFactory("VP-`*=rNA? [Y~+4U");
      BasicDocument<Word> basicDocument0 = new BasicDocument<Word>(pTBTokenizer_PTBTokenizerFactory0);
      wordToSentenceProcessor1.processDocument(basicDocument0);
      Random.setNextRandom((-1717986916));
      WordToSentenceProcessor.NewlineIsSentenceBreak[] wordToSentenceProcessor_NewlineIsSentenceBreakArray0 = WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      assertEquals(3, wordToSentenceProcessor_NewlineIsSentenceBreakArray0.length);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess0()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      linkedHashSet0.add("");
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("", "", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, linkedHashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("<?:>");
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
      
      System.setCurrentTimeMillis(337L);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess0()  throws Throwable  {
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      ArrayList<HasWord> arrayList0 = new ArrayList<HasWord>();
      LabeledWord labeledWord0 = new LabeledWord("\"");
      arrayList0.add((HasWord) labeledWord0);
      TaggedWord taggedWord0 = new TaggedWord(".");
      arrayList0.add((HasWord) taggedWord0);
      TaggedWord taggedWord1 = new TaggedWord("\"");
      arrayList0.add((HasWord) taggedWord1);
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(arrayList0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess1()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      Word word0 = new Word("*IL*");
      Vector<HasWord> vector0 = new Vector<HasWord>();
      vector0.add((HasWord) word0);
      CoreLabel coreLabel0 = CoreLabel.wordFromString("\u2029");
      vector0.add((HasWord) coreLabel0);
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      wordToSentenceProcessor0.process(vector0);
      Vector<String> vector1 = new Vector<String>();
      System.setCurrentTimeMillis(4056L);
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException0()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.setWord("'");
      Class<CoreAnnotations.TextAnnotation> class0 = CoreAnnotations.TextAnnotation.class;
      coreLabel0.set(class0, "'");
      Class<CoreAnnotations.OriginalTextAnnotation> class1 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel0.set(class1, "'");
      CoreLabel coreLabel1 = new CoreLabel();
      coreLabel1.setWord("He");
      Class<CoreAnnotations.TextAnnotation> class2 = CoreAnnotations.TextAnnotation.class;
      coreLabel1.set(class2, "He");
      Class<CoreAnnotations.OriginalTextAnnotation> class3 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel1.set(class3, "He");
      CoreLabel coreLabel2 = new CoreLabel();
      coreLabel2.setWord("said");
      Class<CoreAnnotations.TextAnnotation> class4 = CoreAnnotations.TextAnnotation.class;
      coreLabel2.set(class4, "said");
      Class<CoreAnnotations.OriginalTextAnnotation> class5 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel2.set(class5, "said");
      CoreLabel coreLabel3 = new CoreLabel();
      coreLabel3.setWord("'");
      Class<CoreAnnotations.TextAnnotation> class6 = CoreAnnotations.TextAnnotation.class;
      coreLabel3.set(class6, "'");
      Class<CoreAnnotations.OriginalTextAnnotation> class7 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel3.set(class7, "'");
      CoreLabel coreLabel4 = new CoreLabel();
      coreLabel4.setWord(".");
      Class<CoreAnnotations.TextAnnotation> class8 = CoreAnnotations.TextAnnotation.class;
      coreLabel4.set(class8, ".");
      Class<CoreAnnotations.OriginalTextAnnotation> class9 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel4.set(class9, ".");
      CoreLabel coreLabel5 = new CoreLabel();
      coreLabel5.setWord("'");
      Class<CoreAnnotations.TextAnnotation> class10 = CoreAnnotations.TextAnnotation.class;
      coreLabel5.set(class10, "'");
      Class<CoreAnnotations.OriginalTextAnnotation> class11 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel5.set(class11, "'");
      CoreLabel[] coreLabelArray0 = new CoreLabel[6];
      coreLabelArray0[0] = coreLabel0;
      coreLabelArray0[1] = coreLabel1;
      coreLabelArray0[2] = coreLabel2;
      coreLabelArray0[3] = coreLabel3;
      coreLabelArray0[4] = coreLabel4;
      coreLabelArray0[5] = coreLabel5;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking3ArgumentsAndProcess1()  throws Throwable  {
      ArrayList<HasWord> arrayList0 = new ArrayList<HasWord>();
      Word word0 = new Word("'");
      arrayList0.add((HasWord) word0);
      arrayList0.add((HasWord) word0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>("'", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(arrayList0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking3ArgumentsAndProcess2()  throws Throwable  {
      ArrayList<HasWord> arrayList0 = new ArrayList<HasWord>();
      Word word0 = new Word("p");
      arrayList0.add((HasWord) word0);
      arrayList0.add((HasWord) word0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>("p", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(arrayList0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException1()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.setWord("He");
      Class<CoreAnnotations.TextAnnotation> class0 = CoreAnnotations.TextAnnotation.class;
      coreLabel0.set(class0, "He");
      Class<CoreAnnotations.OriginalTextAnnotation> class1 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel0.set(class1, "He");
      CoreLabel coreLabel1 = new CoreLabel();
      coreLabel1.setWord("said");
      Class<CoreAnnotations.TextAnnotation> class2 = CoreAnnotations.TextAnnotation.class;
      coreLabel1.set(class2, "said");
      Class<CoreAnnotations.OriginalTextAnnotation> class3 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel1.set(class3, "said");
      CoreLabel coreLabel2 = new CoreLabel();
      coreLabel2.setWord(":");
      Class<CoreAnnotations.TextAnnotation> class4 = CoreAnnotations.TextAnnotation.class;
      coreLabel2.set(class4, ":");
      Class<CoreAnnotations.OriginalTextAnnotation> class5 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel2.set(class5, ":");
      CoreLabel coreLabel3 = new CoreLabel();
      coreLabel3.setWord("\"");
      Class<CoreAnnotations.TextAnnotation> class6 = CoreAnnotations.TextAnnotation.class;
      coreLabel3.set(class6, "\"");
      Class<CoreAnnotations.OriginalTextAnnotation> class7 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel3.set(class7, "\"");
      CoreLabel coreLabel4 = new CoreLabel();
      coreLabel4.setWord("Yes");
      Class<CoreAnnotations.TextAnnotation> class8 = CoreAnnotations.TextAnnotation.class;
      coreLabel4.set(class8, "Yes");
      Class<CoreAnnotations.OriginalTextAnnotation> class9 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel4.set(class9, "Yes");
      CoreLabel coreLabel5 = new CoreLabel();
      coreLabel5.setWord(".");
      Class<CoreAnnotations.TextAnnotation> class10 = CoreAnnotations.TextAnnotation.class;
      coreLabel5.set(class10, ".");
      Class<CoreAnnotations.OriginalTextAnnotation> class11 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel5.set(class11, ".");
      CoreLabel coreLabel6 = new CoreLabel();
      coreLabel6.setWord("\"");
      Class<CoreAnnotations.TextAnnotation> class12 = CoreAnnotations.TextAnnotation.class;
      coreLabel6.set(class12, "\"");
      Class<CoreAnnotations.OriginalTextAnnotation> class13 = CoreAnnotations.OriginalTextAnnotation.class;
      coreLabel6.set(class13, "\"");
      CoreLabel[] coreLabelArray0 = new CoreLabel[7];
      coreLabelArray0[0] = coreLabel0;
      coreLabelArray0[1] = coreLabel1;
      coreLabelArray0[2] = coreLabel2;
      coreLabelArray0[3] = coreLabel3;
      coreLabelArray0[4] = coreLabel4;
      coreLabelArray0[5] = coreLabel5;
      coreLabelArray0[6] = coreLabel6;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess2()  throws Throwable  {
      LabeledWord labeledWord0 = new LabeledWord();
      Stack<HasWord> stack0 = new Stack<HasWord>();
      CoreLabel coreLabel0 = CoreLabel.wordFromString("*NL*");
      stack0.add((HasWord) coreLabel0);
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(stack0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess3()  throws Throwable  {
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      ArrayList<HasWord> arrayList0 = new ArrayList<HasWord>();
      Word word0 = new Word(".");
      arrayList0.add((HasWord) word0);
      TaggedWord taggedWord0 = new TaggedWord("\"");
      arrayList0.add((HasWord) taggedWord0);
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(arrayList0);
      assertEquals(2, list0.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException2()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceUntilEndAnnotation> class0 = CoreAnnotations.ForcedSentenceUntilEndAnnotation.class;
      coreLabel0.set(class0, false);
      CoreLabel coreLabel1 = new CoreLabel();
      CoreLabel coreLabel2 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class1 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      coreLabel2.set(class1, false);
      CoreLabel coreLabel3 = new CoreLabel();
      String string0 = ".";
      coreLabel3.setWord(".");
      CoreLabel[] coreLabelArray0 = new CoreLabel[8];
      coreLabelArray0[0] = coreLabel0;
      coreLabel2.equals(coreLabel0);
      coreLabelArray0[1] = coreLabel1;
      coreLabelArray0[2] = coreLabel2;
      coreLabelArray0[4] = coreLabel3;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerExceptionAndCreatesWordToSentenceProcessorTakingBoolean()  throws Throwable  {
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceUntilEndAnnotation> class0 = CoreAnnotations.ForcedSentenceUntilEndAnnotation.class;
      coreLabel0.set(class0, false);
      Vector<HasWord> vector0 = new Vector<HasWord>();
      vector0.add((HasWord) coreLabel0);
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>(false);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException3()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class0 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      coreLabel0.set(class0, false);
      CoreLabel[] coreLabelArray0 = new CoreLabel[1];
      coreLabelArray0[0] = coreLabel0;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess2()  throws Throwable  {
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceUntilEndAnnotation> class0 = CoreAnnotations.ForcedSentenceUntilEndAnnotation.class;
      coreLabel0.set(class0, true);
      Stack<HasWord> stack0 = new Stack<HasWord>();
      stack0.add((HasWord) coreLabel0);
      stack0.add((HasWord) coreLabel0);
      TaggedWord taggedWord0 = new TaggedWord();
      taggedWord0.setFromString("' (should be one of 'always', 'never', 'two')");
      stack0.add((HasWord) taggedWord0);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("' (should be one of 'always', 'never', 'two')");
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>(linkedHashSet0);
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(stack0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException4()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceUntilEndAnnotation> class0 = CoreAnnotations.ForcedSentenceUntilEndAnnotation.class;
      coreLabel0.set(class0, true);
      CoreLabel coreLabel1 = new CoreLabel();
      CoreLabel coreLabel2 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class1 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      coreLabel2.set(class1, true);
      CoreLabel[] coreLabelArray0 = new CoreLabel[8];
      coreLabelArray0[0] = coreLabel0;
      coreLabelArray0[1] = coreLabel1;
      coreLabelArray0[2] = coreLabel2;
      coreLabelArray0[4] = coreLabel1;
      List<CoreLabel> list0 = (List<CoreLabel>)Arrays.asList(coreLabelArray0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess4()  throws Throwable  {
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceUntilEndAnnotation> class0 = CoreAnnotations.ForcedSentenceUntilEndAnnotation.class;
      coreLabel0.set(class0, true);
      Vector<HasWord> vector0 = new Vector<HasWord>();
      vector0.add((HasWord) coreLabel0);
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(vector0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException5()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class0 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      coreLabel0.set(class0, true);
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess5()  throws Throwable  {
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      ArrayList<HasWord> arrayList0 = new ArrayList<HasWord>();
      TaggedWord taggedWord0 = new TaggedWord(".");
      arrayList0.add((HasWord) taggedWord0);
      arrayList0.add((HasWord) taggedWord0);
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(arrayList0);
      assertEquals(2, list0.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess6()  throws Throwable  {
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      ArrayList<HasWord> arrayList0 = new ArrayList<HasWord>();
      TaggedWord taggedWord0 = new TaggedWord(".");
      arrayList0.add((HasWord) taggedWord0);
      TaggedWord taggedWord1 = new TaggedWord("\"");
      arrayList0.add((HasWord) taggedWord1);
      arrayList0.add((HasWord) taggedWord0);
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(arrayList0);
      assertEquals(2, list0.size());
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply(" %iY!\"W");
      MapFactory<String, CoreLabel> mapFactory0 = MapFactory.linkedHashMapFactory();
      Set<String> set0 = mapFactory0.newSet();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("$iY#xYRuUr=", " %iY!\"W", set0, set0, "$iY#xYRuUr=", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, set0, false, true);
      wordToSentenceProcessor0.process(list0);
      Set<String> set1 = mapFactory0.newSet();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(set1);
      Vector<CoreLabel> vector0 = new Vector<CoreLabel>();
      wordToSentenceProcessor0.process(list0);
      System.setCurrentTimeMillis(18014398509481984L);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak(" %iY!\"W");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: ' %iY!\"W' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndProcess()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply(" %YW");
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(" %YW", " %YW", linkedHashSet0, linkedHashSet0, " %YW", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, linkedHashSet0, false, false);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndCreatesWordToSentenceProcessorTaking7Arguments()  throws Throwable  {
      HashSet<String> hashSet0 = new HashSet<String>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      HashSet<String> hashSet1 = new HashSet<String>();
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      hashSet1.add("");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("", "", hashSet0, hashSet1, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet1);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("");
      wordToSentenceProcessor0.process(list0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak1 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<TaggedWord> wordToSentenceProcessor1 = new WordToSentenceProcessor<TaggedWord>("", "[p{Pe}p{Pf}\"'>\uFF02\uFF07\uFF1E)}]]|''|\u2019\u2019|-R[CRS]B-", hashSet0, hashSet1, "[p{Pe}p{Pf}\"'>\uFF02\uFF07\uFF1E)}]]|''|\u2019\u2019|-R[CRS]B-", wordToSentenceProcessor_NewlineIsSentenceBreak1, (SequencePattern<? super TaggedWord>) null, hashSet1, false, true);
      TreeGraphNode treeGraphNode0 = null;
      try {
        treeGraphNode0 = new TreeGraphNode((Label) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.ling.CoreLabel$CoreLabelFactory", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess1()  throws Throwable  {
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      linkedHashSet0.add("");
      Properties properties0 = new Properties();
      PresetSequenceClassifier<CoreLabel> presetSequenceClassifier0 = new PresetSequenceClassifier<CoreLabel>(properties0);
      Set<String> set0 = presetSequenceClassifier0.labels();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("", "", set0, set0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, linkedHashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("");
      wordToSentenceProcessor0.process(list0);
      WordToSentenceProcessor.NewlineIsSentenceBreak[] wordToSentenceProcessor_NewlineIsSentenceBreakArray0 = WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      assertEquals(3, wordToSentenceProcessor_NewlineIsSentenceBreakArray0.length);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess7()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      CoreLabel coreLabel0 = new CoreLabel();
      coreLabel0.setWord("35+9GCDwuVgG");
      Class<CoreAnnotations.ForcedSentenceEndAnnotation> class0 = CoreAnnotations.ForcedSentenceEndAnnotation.class;
      coreLabel0.set(class0, true);
      List<CoreLabel> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(5, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10ArgumentsAndStringToNewlineIsSentenceBreakThrowsIllegalArgumentException()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      Stack<String> stack0 = new Stack<String>();
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("S?H]");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak1 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      FileSystemHandling.shouldAllThrowIOExceptions();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>("3$x$mnODjR]vs\"S", (String) null, linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak1, (SequencePattern<? super CoreLabel>) null, linkedHashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("{yo^dfv$f0brz.`");
      String string0 = "Zd|V#E0Cf3,vqed.2z";
      HashSet<String> hashSet0 = new HashSet<String>();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor2 = new WordToSentenceProcessor<CoreLabel>("Zd|V#E0Cf3,vqed.2z", "Zd|V#E0Cf3,vqed.2z", linkedHashSet0, linkedHashSet0, "coquet", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet0, true, true);
      wordToSentenceProcessor2.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak(")(?:s+[^>]+?|s*(?:/s*)?)>");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: ')(?:s+[^>]+?|s*(?:/s*)?)>' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking10Arguments()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(" %iY!FTn\"W", " %iY!FTn\"W", linkedHashSet0, linkedHashSet0, " %iY!FTn\"W", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, linkedHashSet0, true, true);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentException0()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      ArrayList<CoreAnnotations.OriginalTextAnnotation> arrayList0 = new ArrayList<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      String string0 = "[.\u3002]|[!?\uFF01\uFF1F]+";
      HashSet<String> hashSet0 = new HashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      hashSet0.add("[.\u3002]|[!?\uFF01\uFF1F]+");
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>("[.\u3002]|[!?\uFF01\uFF1F]+", "[.\u3002]|[!?\uFF01\uFF1F]+", hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("[.\u3002]|[!?\uFF01\uFF1F]+");
      wordToSentenceProcessor1.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("[.\u3002]|[!?\uFF01\uFF1F]+");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '[.\u3002]|[!?\uFF01\uFF1F]+' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak0()  throws Throwable  {
      LabeledWord labeledWord0 = new LabeledWord();
      labeledWord0.setFromString("*NL*");
      Stack<HasWord> stack0 = new Stack<HasWord>();
      stack0.add((HasWord) labeledWord0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentException1()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      ArrayList<CoreAnnotations.OriginalTextAnnotation> arrayList0 = new ArrayList<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      HashSet<String> hashSet0 = new HashSet<String>();
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      hashSet0.add("h]aqnfv");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>("", "h]aqnfv", hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply(" >B$d[`QF.54}+");
      wordToSentenceProcessor1.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("Lcr}*Vw");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'Lcr}*Vw' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTaking7Arguments0()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      HashSet<String> hashSet0 = new HashSet<String>();
      hashSet0.add("[.\u3002]|[!?\uFF01\uFF1F]+");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      BasicSequenceMatchResult<Object> basicSequenceMatchResult1 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult1.pattern();
      hashSet0.add("[.\u3002]|[!?\uFF01\uFF1F]+");
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>("/t", "[.\u3002]|[!?\uFF01\uFF1F]+", (Set<String>) null, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, (Set<String>) null);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser1 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser1.apply("useDualDecomp");
      wordToSentenceProcessor1.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("useDualDecomp");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'useDualDecomp' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentException2()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      HashSet<String> hashSet0 = new HashSet<String>();
      hashSet0.add("[.\u3002]|[!?\uFF01\uFF1F]+");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>("/t", "[.\u3002]|[!?\uFF01\uFF1F]+", hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser1 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser1.apply("/t");
      wordToSentenceProcessor1.process(list0);
      String string0 = ">U0J=Vn}\"8;^r#3>";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak(">U0J=Vn}\"8;^r#3>");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '>U0J=Vn}\"8;^r#3>' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess3()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply(" %iY!\"W");
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(treeSet0);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertEquals(2, list1.size());
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentException3()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      String string0 = "[.\u3002]|[!?\uFF01\uFF1F]+";
      HashSet<String> hashSet0 = new HashSet<String>();
      hashSet0.add("[.\u3002]|[!?\uFF01\uFF1F]+");
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      String string1 = "/t";
      hashSet0.add("/t");
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>("/t", "[.\u3002]|[!?\uFF01\uFF1F]+", hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      String string2 = "<\\s*(?:";
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser1 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser1.apply("/t");
      wordToSentenceProcessor1.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("[.\u3002]|[!?\uFF01\uFF1F]+");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '[.\u3002]|[!?\uFF01\uFF1F]+' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSetAndProcess4()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("0");
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser1 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser1.apply("0");
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(linkedHashSet0);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.isEmpty());
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess8()  throws Throwable  {
      LabeledWord labeledWord0 = new LabeledWord();
      labeledWord0.setFromString("*NL*");
      Stack<HasWord> stack0 = new Stack<HasWord>();
      stack0.add((HasWord) labeledWord0);
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      stack0.add((HasWord) labeledWord0);
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(stack0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess9()  throws Throwable  {
      LabeledWord labeledWord0 = new LabeledWord("*IL*");
      labeledWord0.setFromString("*NL*");
      Stack<HasWord> stack0 = new Stack<HasWord>();
      stack0.add((HasWord) labeledWord0);
      stack0.add((HasWord) labeledWord0);
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      wordToSentenceProcessor0.process(stack0);
      WordToSentenceProcessor.NewlineIsSentenceBreak[] wordToSentenceProcessor_NewlineIsSentenceBreakArray0 = WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      assertEquals(3, wordToSentenceProcessor_NewlineIsSentenceBreakArray0.length);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess10()  throws Throwable  {
      LabeledWord labeledWord0 = new LabeledWord();
      labeledWord0.setFromString("*NL*");
      Stack<HasWord> stack0 = new Stack<HasWord>();
      stack0.add((HasWord) labeledWord0);
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      List<List<HasWord>> list0 = wordToSentenceProcessor0.process(stack0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess2()  throws Throwable  {
      HashSet<String> hashSet0 = new HashSet<String>();
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      hashSet0.add("0");
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("0", "0", hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("0");
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertFalse(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess3()  throws Throwable  {
      HashSet<String> hashSet0 = new HashSet<String>();
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      hashSet0.add("uf$OX;=03");
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("uf$OX;=03", "uf$OX;=03", hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("uf$OX;=03");
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentException4()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      ArrayList<CoreAnnotations.OriginalTextAnnotation> arrayList0 = new ArrayList<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      String string0 = "[.\u3002]|[!?\uFF01\uFF1F]+";
      HashSet<String> hashSet0 = new HashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      hashSet0.add("[.\u3002]|[!?\uFF01\uFF1F]+");
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>("[.\u3002]|[!?\uFF01\uFF1F]+", "[.\u3002]|[!?\uFF01\uFF1F]+", hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("<s*(?:");
      wordToSentenceProcessor1.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("[.\u3002]|[!?\uFF01\uFF1F]+");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '[.\u3002]|[!?\uFF01\uFF1F]+' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndProcess4()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply(" %YW");
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(" %YW", " %YW", linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, linkedHashSet0);
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak1()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      Stack<String> stack0 = new Stack<String>();
      stack0.push("Y.-1p-C;$tY");
      List<List<String>> list0 = wordToSentenceProcessor0.process(stack0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException6()  throws Throwable  {
      LabeledWord labeledWord0 = new LabeledWord();
      List<HasWord> list0 = List.of(labeledWord0, labeledWord0, labeledWord0, labeledWord0);
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      HashSet<String> hashSet0 = new HashSet<String>();
      hashSet0.add("[.\u3002]|[!?\uFF01\uFF1F]+");
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("[.\u3002]|[!?\uFF01\uFF1F]+");
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>(hashSet0);
      wordToSentenceProcessor1.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("<s*/s*(?:");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '<s*_/s*(?:' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("");
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      wordToSentenceProcessor0.process(list0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcess11()  throws Throwable  {
      TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0 = new TrueCasingForNISTDocumentReaderAndWriter.LineToTrueCasesParser();
      List<CoreLabel> list0 = trueCasingForNISTDocumentReaderAndWriter_LineToTrueCasesParser0.apply("\u2029");
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      List<List<CoreLabel>> list1 = wordToSentenceProcessor0.process(list0);
      assertTrue(list1.contains(list0));
  }

  @Test(timeout = 4000)
  public void testProcessThrowsNullPointerException7()  throws Throwable  {
      CoreLabel coreLabel0 = new CoreLabel();
      List<HasWord> list0 = List.of(coreLabel0, coreLabel0, coreLabel0, coreLabel0);
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7ArgumentsAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      Stack<HasWord> stack0 = new Stack<HasWord>();
      WordToSentenceProcessor<HasWord> wordToSentenceProcessor0 = new WordToSentenceProcessor<HasWord>();
      wordToSentenceProcessor0.process(stack0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>("m%q]@U", "p", (Set<String>) null, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super String>) null, (Set<String>) null);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreak0()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("'two')");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTaking7Arguments1()  throws Throwable  {
      HashSet<String> hashSet0 = new HashSet<String>();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      linkedHashSet0.add("5GVyllKn$aMY#6");
      FileSystemHandling.shouldAllThrowIOExceptions();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("5GVyllKn$aMY#6", (String) null, linkedHashSet0, linkedHashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, linkedHashSet0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsPatternSyntaxException()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      String string0 = "A5WD-&]b";
      TreeSet<String> treeSet0 = new TreeSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = null;
      try {
        wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>("U35(.AC", "A5WD-&]b", treeSet0, treeSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, treeSet0);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Unclosed group near index 7
         // U35(.AC
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking10ArgumentsThrowsPatternSyntaxException()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      Document<WordToSentenceProcessor.NewlineIsSentenceBreak, CoreAnnotations.OriginalTextAnnotation, CoreAnnotations.OriginalTextAnnotation> document0 = null;
      Locale.IsoCountryCode locale_IsoCountryCode0 = Locale.IsoCountryCode.PART1_ALPHA2;
      Set<String> set0 = Locale.getISOCountries(locale_IsoCountryCode0);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      Locale locale0 = Locale.GERMANY;
      Set<String> set1 = ZoneId.getAvailableZoneIds();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = null;
      try {
        wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("7)V&Q69,hQk}.", "7)V&Q69,hQk}.", set0, set0, "pettifog", wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreAnnotations.OriginalTextAnnotation>) null, set1, false, false);
        fail("Expecting exception: PatternSyntaxException");
      
      } catch(PatternSyntaxException e) {
         //
         // Unmatched closing ')' near index 0
         // 7)V&Q69,hQk}.
         // ^
         //
         verifyException("java.util.regex.Pattern", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTaking7ArgumentsThrowsNullPointerException()  throws Throwable  {
      String string0 = null;
      HashSet<String> hashSet0 = new HashSet<String>();
      hashSet0.add((String) null);
      hashSet0.add((String) null);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>((String) null, (String) null, hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTaking7Arguments2()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Locale locale0 = Locale.FRANCE;
      Set<String> set0 = locale0.getUnicodeLocaleAttributes();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel>("CpCp2Cp3C", "CpCp2Cp3C", set0, (Set<String>) null, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, set0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("CpCp2Cp3C");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'CpCp2Cp3C' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndCreatesWordToSentenceProcessorTaking7Arguments3()  throws Throwable  {
      HashSet<String> hashSet0 = new HashSet<String>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>((String) null, (String) null, hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsNullPointerException()  throws Throwable  {
      String string0 = null;
      HashSet<String> hashSet0 = new HashSet<String>();
      hashSet0.add((String) null);
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = null;
      try {
        wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>((String) null, (String) null, hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking7Arguments()  throws Throwable  {
      HashSet<String> hashSet0 = new HashSet<String>();
      BasicSequenceMatchResult<Object> basicSequenceMatchResult0 = new BasicSequenceMatchResult<Object>();
      basicSequenceMatchResult0.pattern();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>("/t", "/t", hashSet0, hashSet0, wordToSentenceProcessor_NewlineIsSentenceBreak0, (SequencePattern<? super CoreLabel>) null, hashSet0);
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreak()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("always");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS, wordToSentenceProcessor_NewlineIsSentenceBreak0);
      
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessDocumentAndProcessDocumentThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor1 = new WordToSentenceProcessor<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> stack0 = new Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      wordToSentenceProcessor1.process(stack0);
      Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>> stack1 = new Stack<WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>>();
      wordToSentenceProcessor1.process(stack1);
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor2 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(false);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor2.processDocument(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessDocumentThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.processDocument(null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndProcess()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      boolean boolean0 = true;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(true);
      String string0 = "never";
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("never", wordToSentenceProcessor_NewlineIsSentenceBreak0, true);
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = List.of(coreAnnotations_OriginalTextAnnotation0);
      wordToSentenceProcessor1.process(list0);
      String string1 = "&B*2\"N3";
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      String string2 = "/'Q6XpH9hFgH\"I3";
      String string3 = "?W6Jf.\\N.sE3E5Uy2";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("?W6Jf.N.sE3E5Uy2");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.?W6Jf.N.sE3E5Uy2
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreak1()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.stringToNewlineIsSentenceBreak("never");
      assertEquals(WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER, wordToSentenceProcessor_NewlineIsSentenceBreak0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBooleanAndProcess()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor<String> wordToSentenceProcessor0 = new WordToSentenceProcessor<String>(true);
      Vector<String> vector0 = new Vector<String>();
      List<List<String>> list0 = wordToSentenceProcessor0.process(vector0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testProcessReturningListWhereIsEmptyIsFalseAndListWhereSizeIsPositive()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.ALWAYS;
      boolean boolean0 = true;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("jNUE><I>*A", wordToSentenceProcessor_NewlineIsSentenceBreak0, true);
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = List.of(coreAnnotations_OriginalTextAnnotation0);
      wordToSentenceProcessor0.process(list0);
      String string0 = "&B*2\"N3";
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("&B*2\"N3");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '&B*2\"N3' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessWithNull()  throws Throwable  {
      Set<String> set0 = NERClassifierCombiner.DEFAULT_PASS_DOWN_PROPERTIES;
      WordToSentenceProcessor<WordToSentenceProcessor<WordTag>> wordToSentenceProcessor0 = new WordToSentenceProcessor<WordToSentenceProcessor<WordTag>>(set0);
      WordToSentenceProcessor.NewlineIsSentenceBreak.values();
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor1.process((List<? extends CoreAnnotations.OriginalTextAnnotation>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessReturningListWhereIsEmptyIsTrueAndListWhereSizeIsZero()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      LinkedList<CoreAnnotations.OriginalTextAnnotation> linkedList0 = new LinkedList<CoreAnnotations.OriginalTextAnnotation>();
      wordToSentenceProcessor0.process(linkedList0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("U35(.AC");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'U35(.AC' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateWordToSentenceProcessorTakingSetThrowsNullPointerException()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor<CoreLabel.GenericAnnotation<CoreAnnotations.OriginalTextAnnotation>> wordToSentenceProcessor1 = null;
      try {
        wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreLabel.GenericAnnotation<CoreAnnotations.OriginalTextAnnotation>>((Set<String>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Collections$UnmodifiableCollection", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingSet()  throws Throwable  {
      HashSet<String> hashSet0 = new HashSet<String>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(hashSet0);
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTaking3Arguments()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      boolean boolean0 = false;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>("", wordToSentenceProcessor_NewlineIsSentenceBreak0, false);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreakWithNull()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'null' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingBoolean()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(true);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf(" bare leaves; ");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak. bare leaves; 
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakAndCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      WordToSentenceProcessor.stringToNewlineIsSentenceBreak("' (should be one of 'always', 'never', 'two')");
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.NewlineIsSentenceBreak.valueOf("<s*(?:");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant edu.stanford.nlp.process.WordToSentenceProcessor.NewlineIsSentenceBreak.<s*(?:
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void testStringToNewlineIsSentenceBreakThrowsIllegalArgumentExceptionAndStringToNewlineIsSentenceBreakWithNonEmptyString()  throws Throwable  {
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("O");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: 'O' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingWordToSentenceProcessor$NewlineIsSentenceBreak2()  throws Throwable  {
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.NEVER;
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      // Undeclared exception!
      try { 
        WordToSentenceProcessor.stringToNewlineIsSentenceBreak("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Not a valid NewlineIsSentenceBreak name: '' (should be one of 'always', 'never', 'two')
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcess()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      stack0.listIterator();
      List<List<CoreAnnotations.OriginalTextAnnotation>> list0 = wordToSentenceProcessor0.process(stack0);
      assertTrue(list0.isEmpty());
      
      WordToSentenceProcessor.NewlineIsSentenceBreak wordToSentenceProcessor_NewlineIsSentenceBreak0 = WordToSentenceProcessor.NewlineIsSentenceBreak.TWO_CONSECUTIVE;
      WordToSentenceProcessor<String> wordToSentenceProcessor1 = new WordToSentenceProcessor<String>(wordToSentenceProcessor_NewlineIsSentenceBreak0);
      Stack<String> stack1 = new Stack<String>();
      stack1.push("hvae");
      List<List<String>> list1 = wordToSentenceProcessor1.process(stack1);
      assertEquals(1, list1.size());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArgumentsAndProcessAndProcessWithEmptyList()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      ArrayList<CoreAnnotations.OriginalTextAnnotation> arrayList0 = new ArrayList<CoreAnnotations.OriginalTextAnnotation>();
      List<List<CoreAnnotations.OriginalTextAnnotation>> list0 = wordToSentenceProcessor0.process(arrayList0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testCreatesWordToSentenceProcessorTakingNoArguments()  throws Throwable  {
      WordToSentenceProcessor<CoreLabel> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreLabel>();
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor1 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      Stack<CoreAnnotations.OriginalTextAnnotation> stack0 = new Stack<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      stack0.add(coreAnnotations_OriginalTextAnnotation0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor1.process(stack0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }

  @Test(timeout = 4000)
  public void testProcessThrowsRuntimeException()  throws Throwable  {
      WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation> wordToSentenceProcessor0 = new WordToSentenceProcessor<CoreAnnotations.OriginalTextAnnotation>();
      CoreAnnotations.OriginalTextAnnotation coreAnnotations_OriginalTextAnnotation0 = new CoreAnnotations.OriginalTextAnnotation();
      List<CoreAnnotations.OriginalTextAnnotation> list0 = List.of(coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0, coreAnnotations_OriginalTextAnnotation0);
      // Undeclared exception!
      try { 
        wordToSentenceProcessor0.process(list0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Expected token to be either Word or String.
         //
         verifyException("edu.stanford.nlp.process.WordToSentenceProcessor", e);
      }
  }
}
