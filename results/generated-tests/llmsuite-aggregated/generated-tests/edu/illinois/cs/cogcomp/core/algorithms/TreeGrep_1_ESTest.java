/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 08:40:45 GMT 2025
 */

package edu.illinois.cs.cogcomp.core.algorithms;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrep;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch;
import edu.illinois.cs.cogcomp.core.datastructures.trees.Tree;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.trees.TreeGraphNode;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;
import org.ojalgo.function.aggregator.Aggregator;
import org.ojalgo.scalar.ComplexNumber;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class TreeGrep_1_ESTest extends TreeGrep_1_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereHasEdgeLabelsIsTrue()  throws Throwable  {
      ArrayList<Object> arrayList0 = new ArrayList<Object>();
      Tree<List<Object>> tree0 = new Tree<List<Object>>(arrayList0);
      Tree<List<Object>> tree1 = new Tree<List<Object>>();
      LinkedList<Object> linkedList0 = new LinkedList<Object>();
      tree1.addLeaf((List<Object>) linkedList0);
      tree0.addSubtree(tree1);
      arrayList0.add((Object) tree0);
      Tree<List<Object>> tree2 = tree0.getChild(0);
      TreeGrep<List<Object>> treeGrep0 = new TreeGrep<List<Object>>(tree2);
      treeGrep0.getPattern();
      Tree<Object> tree3 = new Tree<Object>(treeGrep0);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree3);
      // Undeclared exception!
      try { 
        WordTag.valueOf("skir", "");
        fail("Expecting exception: StringIndexOutOfBoundsException");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereHasEdgeLabelsIsFalse()  throws Throwable  {
      ArrayList<Object> arrayList0 = new ArrayList<Object>();
      Tree<List<Object>> tree0 = new Tree<List<Object>>(arrayList0);
      Tree<List<Object>> tree1 = new Tree<List<Object>>();
      tree0.addSubtree(tree1);
      arrayList0.add((Object) tree0);
      Tree<List<Object>> tree2 = tree0.getChild(0);
      TreeGrep<List<Object>> treeGrep0 = new TreeGrep<List<Object>>(tree2);
      treeGrep0.getPattern();
      Tree<Object> tree3 = new Tree<Object>(treeGrep0);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree3);
      // Undeclared exception!
      try { 
        WordTag.valueOf("skir", "");
        fail("Expecting exception: StringIndexOutOfBoundsException");
      
      } catch(StringIndexOutOfBoundsException e) {
      }
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      Integer integer0 = new Integer(1693);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
      
      ArrayList<List<TreeGrepMatch<Integer>>> arrayList0 = new ArrayList<List<TreeGrepMatch<Integer>>>();
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      stack0.stream();
      arrayList0.add((List<TreeGrepMatch<Integer>>) stack0);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      TaggedWord taggedWord0 = new TaggedWord();
      Object object0 = new Object();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      TreeGrepMatch<Integer> treeGrepMatch1 = new TreeGrepMatch<Integer>(treeGrepMatch0);
      stack0.add(treeGrepMatch1);
      linkedList0.remove(object0);
      taggedWord0.equals(arrayList0);
      taggedWord0.setTag("");
      treeGrep0.mergeChildrenMatches(arrayList0, stack0);
      treeGrep0.getMatches();
      tree0.clone();
      Tree<TaggedWord> tree1 = new Tree<TaggedWord>(taggedWord0);
      tree1.toString();
      // Undeclared exception!
      try { 
        tree1.getChild(1693);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 1693, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndDoesNodeMatchPattern()  throws Throwable  {
      Integer integer0 = new Integer((-2345));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      linkedList0.add(treeGrepMatch0);
      treeGrep0.verbose = true;
      linkedList0.add(treeGrepMatch0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      Integer integer0 = new Integer((-2345));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse0()  throws Throwable  {
      Integer integer0 = new Integer((-2345));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      Integer integer1 = new Integer((-2345));
      Integer integer2 = new Integer((-2345));
      Integer integer3 = new Integer((-1961020605));
      tree0.addLeaf(integer3);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      Integer integer4 = new Integer((-1487));
      tree0.clone();
      Integer integer5 = new Integer((-2345));
      tree0.addLeaf(integer5);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree0);
      boolean boolean0 = treeGrep1.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse1()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      Integer integer0 = new Integer((-1954));
      Integer integer1 = new Integer(0);
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      Integer integer2 = new Integer((-1954));
      Integer integer3 = new Integer(0);
      tree1.addLeaf(integer3);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      Integer integer4 = new Integer(0);
      tree1.clone();
      tree1.addLeaf(integer1);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree1);
      boolean boolean0 = treeGrep0.matches(tree1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndMatches()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      Integer integer0 = new Integer((-1954));
      Integer integer1 = new Integer(0);
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      Integer integer2 = new Integer(375);
      Integer integer3 = new Integer(0);
      tree1.addLeaf(integer3);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      Integer integer4 = new Integer(375);
      tree1.clone();
      Integer integer5 = new Integer(0);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree1);
      linkedList0.add(treeGrepMatch0);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree1);
      List<TreeGrepMatch<Integer>> list0 = treeGrep1.doesNodeMatchPattern(tree1, tree1, linkedList0);
      assertFalse(list0.isEmpty());
      assertFalse(list0.contains(treeGrepMatch0));
      
      Integer integer6 = new Integer((-2147483645));
      Tree<Integer> tree2 = new Tree<Integer>(integer1);
      boolean boolean0 = treeGrep1.matches(tree2);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndGetMatches()  throws Throwable  {
      Integer integer0 = new Integer(2354);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.addLeaf(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
      
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesReturningTrue()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      int int0 = (-1954);
      Integer integer0 = new Integer((-1954));
      Integer integer1 = new Integer(0);
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      Integer integer2 = new Integer(375);
      Integer integer3 = Integer.valueOf(0);
      tree1.addLeaf(integer3);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      Integer integer4 = new Integer(375);
      treeGrep0.verbose = true;
      tree1.clone();
      Integer integer5 = new Integer(0);
      treeGrep0.toString();
      Tree<Object> tree2 = new Tree<Object>();
      tree2.getParent();
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>((Tree<Object>) null);
      treeGrep0.doesLabelMatchPatternLabel(integer1, (Integer) null);
      treeGrep0.matches(tree1);
      Tree<Integer> tree3 = treeGrep0.getPattern();
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      // Undeclared exception!
      tree3.addSubtree(tree1);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse2()  throws Throwable  {
      Integer integer0 = new Integer((-2068082857));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      Integer integer1 = new Integer((-2448));
      tree0.addLeaf(integer1);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse3()  throws Throwable  {
      Integer integer0 = new Integer((-743));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.addLeaf(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse4()  throws Throwable  {
      Integer integer0 = new Integer(1693);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      Integer integer1 = new Integer((-2095));
      tree0.addLeaf(integer1, integer0);
      Integer integer2 = new Integer(1693);
      Tree<Integer> tree1 = new Tree<Integer>(integer2);
      tree1.addLeaf(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      TreeGrepMatch<Integer> treeGrepMatch1 = new TreeGrepMatch<Integer>(treeGrepMatch0);
      treeGrep0.matches(tree1);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree1);
      treeGrep1.matches(tree0);
      Tree<CoreLabel> tree2 = new Tree<CoreLabel>();
      // Undeclared exception!
      try { 
        tree2.getChild(691);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 691, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesWithTreeWhereHasEdgeLabelsIsTrueAndTreeWhereIsRootIsFalse()  throws Throwable  {
      Integer integer0 = new Integer(26);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.addLeaf(integer0);
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      tree1.addSubtree(tree0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternAndDoesLabelMatchPatternLabelAndMatches()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      int int0 = (-1954);
      Integer integer0 = new Integer((-1954));
      Integer integer1 = new Integer(0);
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      Integer integer2 = new Integer(375);
      Integer integer3 = new Integer(0);
      tree1.addLeaf(integer3);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      Integer integer4 = new Integer(375);
      tree1.clone();
      Integer integer5 = new Integer(0);
      treeGrep0.doesLabelMatchPatternLabel(integer1, (Integer) null);
      treeGrep0.matches(tree1);
      Tree<Integer> tree2 = treeGrep0.getPattern();
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      // Undeclared exception!
      tree2.addSubtree(tree1);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatch0()  throws Throwable  {
      Integer integer0 = new Integer(4096);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue0()  throws Throwable  {
      Integer integer0 = new Integer((-743));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      Integer integer0 = new Integer((-1));
      Integer integer1 = new Integer(0);
      Tree<Integer> tree0 = new Tree<Integer>(integer1);
      Integer integer2 = new Integer(0);
      tree0.addLeaf(integer2);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      Integer integer3 = new Integer(0);
      tree0.clone();
      Integer integer4 = new Integer((-3547));
      treeGrep0.doesLabelMatchPatternLabel(integer3, integer4);
      treeGrep0.matches(tree0);
      Tree<Integer> tree1 = treeGrep0.getPattern();
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      tree1.addSubtree(tree0);
  }

  @Test(timeout = 4000)
  public void testGetMatchesReturningListWhereIsEmptyIsTrueAndListWhereSizeIsZero()  throws Throwable  {
      Integer integer0 = new Integer(1693);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      Integer integer1 = new Integer(1097);
      Tree<Integer> tree1 = new Tree<Integer>(integer1);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.doesThisTreeMatch(tree1);
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      treeGrep0.getMatches();
      Tree<Tree<IndexedWord>> tree2 = new Tree<Tree<IndexedWord>>();
      // Undeclared exception!
      try { 
        tree2.getChild((-2044987295));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelAndDoesNodeMatchPattern()  throws Throwable  {
      Integer integer0 = new Integer((-2345));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      tree0.addLeaf(integer0);
      Integer integer1 = new Integer(1060);
      boolean boolean0 = treeGrep0.doesLabelMatchPatternLabel(integer0, integer1);
      assertFalse(boolean0);
      
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      linkedList0.add(treeGrepMatch0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertFalse(list0.contains(treeGrepMatch0));
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern0()  throws Throwable  {
      Integer integer0 = new Integer((-2345));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.addLeaf(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      linkedList0.add(treeGrepMatch0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertFalse(list0.contains(treeGrepMatch0));
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternWithEmptyList()  throws Throwable  {
      Integer integer0 = new Integer((-2345));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      tree0.addLeaf(integer0);
      Integer integer1 = new Integer(1060);
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      linkedList0.add(treeGrepMatch0);
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>();
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertEquals(0, vector0.size());
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchReturningFalse()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      Integer integer0 = new Integer(4096);
      Tree<Integer> tree2 = new Tree<Integer>(integer0);
      tree2.clone();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree1);
      treeGrep0.matches(tree1);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree2);
      linkedList0.add(treeGrepMatch0);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree2);
      treeGrep1.doesNodeMatchPattern(tree2, tree2, linkedList0);
      assertEquals(1, linkedList0.size());
      
      TreeGrep<Integer> treeGrep2 = new TreeGrep<Integer>(tree2);
      boolean boolean0 = treeGrep2.matches(tree2);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternReturningListWhereIsEmptyIsTrue()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      Integer integer0 = new Integer(4096);
      Tree<Integer> tree2 = new Tree<Integer>(integer0);
      tree2.clone();
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      LinkedList<TreeGrepMatch<Integer>> linkedList1 = new LinkedList<TreeGrepMatch<Integer>>();
      Tree<Integer> tree3 = new Tree<Integer>();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree3);
      TreeGrepMatch<Integer> treeGrepMatch1 = new TreeGrepMatch<Integer>(treeGrepMatch0);
      linkedList1.add(treeGrepMatch1);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree3);
      treeGrep0.doesNodeMatchPattern(tree2, tree3, linkedList1);
      boolean boolean0 = treeGrep0.matches(tree2);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetMatchesReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      Integer integer0 = new Integer(1693);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      ArrayList<List<TreeGrepMatch<Integer>>> arrayList0 = new ArrayList<List<TreeGrepMatch<Integer>>>();
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      stack0.stream();
      arrayList0.add((List<TreeGrepMatch<Integer>>) stack0);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      TaggedWord taggedWord0 = new TaggedWord();
      Object object0 = new Object();
      linkedList0.remove(object0);
      taggedWord0.setTag("");
      treeGrep0.mergeChildrenMatches(arrayList0, stack0);
      treeGrep0.getMatches();
      Tree<TaggedWord> tree1 = new Tree<TaggedWord>(taggedWord0);
      // Undeclared exception!
      try { 
        tree1.getChild(1693);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 1693, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateTreeGrepThrowsNullPointerException()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      Integer integer0 = new Integer(4096);
      Tree<Integer> tree2 = new Tree<Integer>(integer0);
      tree2.clone();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsNullPointerException()  throws Throwable  {
      Tree<Word> tree0 = new Tree<Word>();
      TreeGrep<Word> treeGrep0 = new TreeGrep<Word>(tree0);
      treeGrep0.verbose = true;
      LinkedList<TreeGrepMatch<Word>> linkedList0 = new LinkedList<TreeGrepMatch<Word>>();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerException0()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatch()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      Integer integer0 = new Integer(4096);
      Tree<Integer> tree2 = new Tree<Integer>(integer0);
      tree2.clone();
      Tree<Integer> tree3 = new Tree<Integer>((Integer) null);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree2);
      treeGrep0.verbose = true;
      treeGrep0.doesThisTreeMatch(tree2);
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      assertEquals(0, stack0.size());
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsIllegalArgumentException()  throws Throwable  {
      Integer integer0 = new Integer(1693);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      treeGrep0.matches(tree0);
      Integer integer1 = new Integer(67);
      TaggedWord taggedWord0 = new TaggedWord("", "*B^Z`g-W`JMRPCa<");
      taggedWord0.setTag("WARNING!!!  You have hashed an IndexedWord with no docID, sentIndex or wordIndex. You will almost certainly lose");
      Stack<List<TreeGrepMatch<Integer>>> stack0 = new Stack<List<TreeGrepMatch<Integer>>>();
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>();
      // Undeclared exception!
      try { 
        treeGrep0.mergeChildrenMatches(stack0, arrayList0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // fromIndex(0) > toIndex(-1)
         //
         verifyException("java.util.SubList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue1()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Tree<Object> tree1 = new Tree<Object>(treeGrep0);
      boolean boolean0 = treeGrep0.matches(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatch1()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Tree<Object> tree1 = new Tree<Object>(treeGrep0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndDoesNodeMatchPattern0()  throws Throwable  {
      Integer integer0 = new Integer(59);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      Tree<Integer> tree1 = treeGrepMatch0.getPattern();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      TreeGrep.startOfChildrenString = "";
      linkedList0.add(treeGrepMatch0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree1, linkedList0);
      assertEquals(1, linkedList0.size());
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      linkedList0.add(treeGrepMatch0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertEquals(1, linkedList0.size());
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue2()  throws Throwable  {
      Integer integer0 = new Integer(2354);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testToString()  throws Throwable  {
      Integer integer0 = new Integer((-2345));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      tree0.addLeaf(integer0);
      Integer integer1 = new Integer(1060);
      treeGrep0.doesLabelMatchPatternLabel(integer0, integer1);
      treeGrep0.matches(tree0);
      String string0 = treeGrep0.toString();
      assertNotNull(string0);
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsClassCastException()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      tree0.getParent();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      tree0.clone();
      ArrayList<List<TreeGrepMatch<Integer>>> arrayList0 = new ArrayList<List<TreeGrepMatch<Integer>>>();
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      stack0.stream();
      arrayList0.add((List<TreeGrepMatch<Integer>>) stack0);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      TaggedWord taggedWord0 = new TaggedWord("", "");
      linkedList0.remove((Object) taggedWord0);
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(taggedWord0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      TreeGraphNode treeGraphNode2 = treeGraphNode1.highestNodeWithSameHead();
      List<TreeGrepMatch<Integer>> list0 = treeGraphNode2.yield(stack0);
      // Undeclared exception!
      try { 
        treeGrep0.mergeChildrenMatches(arrayList0, list0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // edu.stanford.nlp.ling.CoreLabel cannot be cast to edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse5()  throws Throwable  {
      Integer integer0 = new Integer((-2345));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.addLeaf(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetMatches()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateTreeGrepThrowsIndexOutOfBoundsException()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      tree0.getParent();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      tree0.clone();
      ArrayList<List<TreeGrepMatch<Integer>>> arrayList0 = new ArrayList<List<TreeGrepMatch<Integer>>>();
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      stack0.stream();
      arrayList0.add((List<TreeGrepMatch<Integer>>) stack0);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      TaggedWord taggedWord0 = new TaggedWord();
      linkedList0.remove((Object) taggedWord0);
      taggedWord0.setTag("WARNING!!!  You have hashed an IndexedWord with no docID, sentIndex or wordIndex. You will almost certainly lose");
      treeGrep0.mergeChildrenMatches(arrayList0, linkedList0);
      treeGrep0.getMatches();
      Tree<TaggedWord> tree1 = new Tree<TaggedWord>(taggedWord0);
      // Undeclared exception!
      try { 
        tree1.getChild(59);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 59, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelReturningTrue()  throws Throwable  {
      Tree<LinkedList<Object>> tree0 = new Tree<LinkedList<Object>>();
      TreeGrep<LinkedList<Object>> treeGrep0 = new TreeGrep<LinkedList<Object>>(tree0);
      LinkedList<Object> linkedList0 = new LinkedList<Object>();
      treeGrep0.doesLabelMatchPatternLabel(linkedList0, linkedList0);
      Tree<Object> tree1 = new Tree<Object>();
      Tree<Tree<Object>> tree2 = new Tree<Tree<Object>>(tree1);
      tree2.getParent();
      TreeGrep<Tree<Object>> treeGrep1 = new TreeGrep<Tree<Object>>((Tree<Tree<Object>>) null);
      // Undeclared exception!
      try { 
        treeGrep1.doesThisTreeMatch(tree2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      Integer integer0 = new Integer((-2345));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.addLeaf(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertEquals(0, linkedList0.size());
      
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereSizeIsPositive()  throws Throwable  {
      Integer integer0 = new Integer(7);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.getPositionAmongParentsChildren();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      Tree<Integer> tree1 = treeGrepMatch0.getPattern();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, arrayList0);
      treeGrep0.toString();
      Integer integer1 = new Integer(7);
      Integer integer2 = Integer.valueOf(1583);
      treeGrep0.doesLabelMatchPatternLabel(integer1, integer2);
      Tree<WordLemmaTag> tree2 = new Tree<WordLemmaTag>();
      TreeGrep<WordLemmaTag> treeGrep1 = new TreeGrep<WordLemmaTag>(tree2);
      treeGrep1.getPattern();
      // Undeclared exception!
      try { 
        treeGrep1.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelAndDoesThisTreeMatchThrowsNullPointerException()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      tree0.getParent();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag("6)d7P!S");
      treeGrep0.doesLabelMatchPatternLabel(tree0, wordLemmaTag0);
      TreeGrep<LinkedList<Integer>> treeGrep1 = new TreeGrep<LinkedList<Integer>>((Tree<LinkedList<Integer>>) null);
      // Undeclared exception!
      try { 
        treeGrep1.doesThisTreeMatch((Tree<LinkedList<Integer>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesReturningFalse()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      Integer integer0 = new Integer(4096);
      Tree<Integer> tree2 = new Tree<Integer>(integer0);
      tree2.clone();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.matches(tree1);
      Tree<ComplexNumber> tree3 = new Tree<ComplexNumber>();
      TreeGrep<ComplexNumber> treeGrep1 = new TreeGrep<ComplexNumber>(tree3);
      LinkedList<TreeGrepMatch<ComplexNumber>> linkedList0 = new LinkedList<TreeGrepMatch<ComplexNumber>>();
      assertEquals(0, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesThrowsNullPointerException()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      TreeGrepMatch<Integer> treeGrepMatch1 = new TreeGrepMatch<Integer>(treeGrepMatch0);
      Tree<Integer> tree1 = treeGrepMatch1.getPattern();
      tree1.getHeight();
      treeGrepMatch0.addMatch(tree0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsNullPointerException()  throws Throwable  {
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>();
      tree0.getParent();
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>((Tree<RoundingMode>) null);
      // Undeclared exception!
      try { 
        treeGrep0.mergeChildrenMatches((List<List<TreeGrepMatch<RoundingMode>>>) null, (List<TreeGrepMatch<RoundingMode>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.math.Permutations", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetPatternAndDoesNodeMatchPatternThrowsNullPointerException()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      tree0.getParent();
      Object object0 = new Object();
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      treeGrep0.getPattern();
      TreeGrep.endOfChildrenString = "";
      Tree<Tree<Object>> tree1 = new Tree<Tree<Object>>((Tree<Object>) null);
      TreeGrepMatch<Tree<Object>> treeGrepMatch0 = new TreeGrepMatch<Tree<Object>>(tree1);
      Tree<Tree<Object>> tree2 = treeGrepMatch0.getPattern();
      TreeGrep<Tree<Object>> treeGrep1 = new TreeGrep<Tree<Object>>(tree2);
      // Undeclared exception!
      try { 
        treeGrep1.doesNodeMatchPattern(tree2, tree1, (List<TreeGrepMatch<Tree<Object>>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern2()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertEquals(1, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndDoesNodeMatchPattern1()  throws Throwable  {
      Integer integer0 = new Integer(59);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      Tree<Integer> tree1 = treeGrepMatch0.getPattern();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      LinkedList<TreeGrepMatch<Integer>> linkedList0 = new LinkedList<TreeGrepMatch<Integer>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree1, linkedList0);
      assertEquals(1, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternWithNull()  throws Throwable  {
      Aggregator aggregator0 = Aggregator.SUM2;
      Tree<Aggregator> tree0 = new Tree<Aggregator>(aggregator0);
      TreeGrep<Aggregator> treeGrep0 = new TreeGrep<Aggregator>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, (List<TreeGrepMatch<Aggregator>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesTreeGrep()  throws Throwable  {
      Tree<ComplexNumber> tree0 = new Tree<ComplexNumber>();
      TreeGrep<ComplexNumber> treeGrep0 = new TreeGrep<ComplexNumber>(tree0);
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerException1()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      TreeGrep<Tree<Integer>> treeGrep0 = new TreeGrep<Tree<Integer>>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testToStringThrowsNullPointerException()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      TreeGrep<Tree<Integer>> treeGrep0 = new TreeGrep<Tree<Integer>>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesTreeGrepAndCallsToString()  throws Throwable  {
      Integer integer0 = new Integer(21);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      treeGrepMatch0.currentPosition = 303;
      TreeGrepMatch<Integer> treeGrepMatch1 = new TreeGrepMatch<Integer>(treeGrepMatch0);
      treeGrepMatch1.mergeMatches(treeGrepMatch0);
      Tree<Integer> tree1 = treeGrepMatch1.getPattern();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      String string0 = treeGrep0.toString();
      assertNotNull(string0);
  }
}
