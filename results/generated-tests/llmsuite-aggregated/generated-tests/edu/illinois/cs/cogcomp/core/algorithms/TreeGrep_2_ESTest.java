/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 08:40:45 GMT 2025
 */

package edu.illinois.cs.cogcomp.core.algorithms;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrep;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch;
import edu.illinois.cs.cogcomp.core.datastructures.trees.Tree;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.trees.TreeGraphNode;
import java.math.RoundingMode;
import java.time.chrono.IsoEra;
import java.time.chrono.MinguoEra;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class TreeGrep_2_ESTest extends TreeGrep_2_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testGetMatchesThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Integer integer0 = new Integer((-1058));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      Tree<Integer> tree1 = treeGrep0.getPattern();
      tree1.toString();
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>();
      treeGrep0.matchesList = (List<TreeGrepMatch<Integer>>) arrayList0;
      Tree<Integer> tree2 = new Tree<Integer>();
      tree0.addLeaf(integer0, integer0);
      tree2.addSubtree(tree0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      arrayList0.sort(comparator0);
      treeGrep0.doesNodeMatchPattern(tree1, tree2, (List<TreeGrepMatch<Integer>>) null);
      treeGrep0.getMatches();
      treeGrep0.getPattern();
      Tree<Tree<Integer>> tree3 = new Tree<Tree<Integer>>();
      // Undeclared exception!
      try { 
        tree3.getChild((-2004012733));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_UP;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      Stack<List<TreeGrepMatch<RoundingMode>>> stack0 = new Stack<List<TreeGrepMatch<RoundingMode>>>();
      Stack<TreeGrepMatch<RoundingMode>> stack1 = new Stack<TreeGrepMatch<RoundingMode>>();
      TreeGrepMatch<RoundingMode> treeGrepMatch0 = new TreeGrepMatch<RoundingMode>(tree0);
      TreeGrepMatch<RoundingMode> treeGrepMatch1 = new TreeGrepMatch<RoundingMode>(treeGrepMatch0);
      stack1.add(treeGrepMatch1);
      int int0 = (-963);
      stack1.ensureCapacity((-963));
      stack0.add((List<TreeGrepMatch<RoundingMode>>) stack1);
      treeGrep0.mergeChildrenMatches(stack0, stack1);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>((Tree<Object>) null);
      Stack<TreeGrepMatch<Object>> stack2 = new Stack<TreeGrepMatch<Object>>();
      treeGrep1.matchesList = (List<TreeGrepMatch<Object>>) stack2;
      TreeGrepMatch<Object> treeGrepMatch2 = null;
      try {
        treeGrepMatch2 = new TreeGrepMatch<Object>((Tree<Object>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testToString()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_UP;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      TreeGrepMatch<RoundingMode> treeGrepMatch0 = new TreeGrepMatch<RoundingMode>(tree0);
      vector0.add(treeGrepMatch0);
      Vector<TreeGrepMatch<RoundingMode>> vector1 = new Vector<TreeGrepMatch<RoundingMode>>();
      vector1.clone();
      RoundingMode roundingMode1 = RoundingMode.HALF_DOWN;
      RoundingMode roundingMode2 = RoundingMode.CEILING;
      tree0.addLeaf(roundingMode1, roundingMode2);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.toString();
      RoundingMode roundingMode3 = RoundingMode.CEILING;
      tree0.addLeaf(roundingMode1, roundingMode3);
      TreeGrep<RoundingMode> treeGrep1 = new TreeGrep<RoundingMode>(tree0);
      boolean boolean0 = treeGrep1.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereHasEdgeLabelsIsFalse()  throws Throwable  {
      Integer integer0 = new Integer((-1058));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      Tree<Integer> tree1 = treeGrep0.getPattern();
      tree1.toString();
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>();
      treeGrep0.matchesList = (List<TreeGrepMatch<Integer>>) arrayList0;
      Tree<Integer> tree2 = new Tree<Integer>();
      tree2.addSubtree(tree0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      arrayList0.sort(comparator0);
      treeGrep0.doesNodeMatchPattern(tree1, tree2, (List<TreeGrepMatch<Integer>>) null);
      treeGrep0.getMatches();
      treeGrep0.getPattern();
      Tree<Tree<Integer>> tree3 = new Tree<Tree<Integer>>();
      TreeGrep<Tree<Integer>> treeGrep1 = new TreeGrep<Tree<Integer>>(tree3);
      List<TreeGrepMatch<Tree<Integer>>> list0 = treeGrep1.getMatches();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndMatches()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.toString();
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      TreeGrepMatch<RoundingMode> treeGrepMatch0 = new TreeGrepMatch<RoundingMode>(tree0);
      TreeGrepMatch<RoundingMode> treeGrepMatch1 = new TreeGrepMatch<RoundingMode>(treeGrepMatch0);
      vector0.add(treeGrepMatch1);
      List<TreeGrepMatch<RoundingMode>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertFalse(list0.contains(treeGrepMatch1));
      assertFalse(list0.isEmpty());
      
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrepMatch<RoundingMode> treeGrepMatch2 = new TreeGrepMatch<RoundingMode>(tree0);
      TreeGrepMatch<RoundingMode> treeGrepMatch3 = new TreeGrepMatch<RoundingMode>(treeGrepMatch2);
      Stack<TreeGrepMatch<RoundingMode>> stack0 = new Stack<TreeGrepMatch<RoundingMode>>();
      stack0.clone();
      RoundingMode roundingMode1 = RoundingMode.HALF_UP;
      RoundingMode roundingMode2 = RoundingMode.UP;
      tree0.addLeaf(roundingMode1, roundingMode2);
      TreeGrep<RoundingMode> treeGrep1 = new TreeGrep<RoundingMode>(tree0);
      treeGrep1.verbose = true;
      boolean boolean0 = treeGrep1.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndDoesNodeMatchPatternWithEmptyList()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_DOWN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.toString();
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      Stack<TreeGrepMatch<RoundingMode>> stack0 = new Stack<TreeGrepMatch<RoundingMode>>();
      stack0.clone();
      RoundingMode roundingMode1 = RoundingMode.DOWN;
      tree0.addLeaf(roundingMode1, roundingMode1);
      tree0.addLeaf(roundingMode1, roundingMode0);
      List<TreeGrepMatch<RoundingMode>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertFalse(list0.isEmpty());
      assertEquals(0, vector0.size());
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse0()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.DOWN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      TreeGrepMatch<RoundingMode> treeGrepMatch0 = new TreeGrepMatch<RoundingMode>(tree0);
      vector0.add(treeGrepMatch0);
      vector0.clone();
      RoundingMode roundingMode1 = RoundingMode.HALF_DOWN;
      tree0.addLeaf(roundingMode1, roundingMode1);
      TreeGrep<RoundingMode> treeGrep1 = new TreeGrep<RoundingMode>(tree0);
      treeGrep1.verbose = true;
      boolean boolean0 = treeGrep1.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse1()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      RoundingMode roundingMode1 = RoundingMode.HALF_DOWN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode1);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.verbose = true;
      tree0.addLeaf(roundingMode0, roundingMode0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndMatchesWithTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      Tree<IsoEra> tree0 = new Tree<IsoEra>();
      RoundingMode roundingMode0 = RoundingMode.CEILING;
      Tree<RoundingMode> tree1 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree1);
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      ArrayList<TreeGrepMatch<RoundingMode>> arrayList0 = new ArrayList<TreeGrepMatch<RoundingMode>>(vector0);
      TreeGrepMatch<RoundingMode> treeGrepMatch0 = new TreeGrepMatch<RoundingMode>(tree1);
      arrayList0.add(treeGrepMatch0);
      treeGrep0.doesNodeMatchPattern(tree1, tree1, arrayList0);
      RoundingMode roundingMode1 = RoundingMode.DOWN;
      RoundingMode roundingMode2 = RoundingMode.UP;
      TreeGrep.startOfChildrenString = "java.math.RoundingMode@0000000006";
      tree1.addLeaf(roundingMode1, roundingMode2);
      treeGrep0.doesNodeMatchPattern(tree1, tree1, vector0);
      treeGrep0.matches(tree1);
      int int0 = 244;
      Integer integer0 = new Integer(int0);
      Tree<Integer> tree2 = new Tree<Integer>(integer0);
      int int1 = 0;
      // Undeclared exception!
      try { 
        tree2.getChild(int1);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse2()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_DOWN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsIllegalArgumentException()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.verbose = true;
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      TreeGrepMatch<RoundingMode> treeGrepMatch0 = new TreeGrepMatch<RoundingMode>(tree0);
      vector0.add(treeGrepMatch0);
      vector0.clone();
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep1 = new TreeGrep<RoundingMode>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // fromIndex(0) > toIndex(-1)
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse3()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern0()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      TreeGrepMatch<RoundingMode> treeGrepMatch0 = new TreeGrepMatch<RoundingMode>(tree0);
      vector0.add(treeGrepMatch0);
      List<TreeGrepMatch<RoundingMode>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertFalse(list0.contains(treeGrepMatch0));
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsNullPointerException()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      vector0.setSize(232);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsIllegalArgumentException()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      TreeGrepMatch<RoundingMode> treeGrepMatch0 = new TreeGrepMatch<RoundingMode>(tree0);
      TreeGrepMatch<RoundingMode> treeGrepMatch1 = new TreeGrepMatch<RoundingMode>(treeGrepMatch0);
      vector0.add(treeGrepMatch1);
      vector0.setSize(232);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // fromIndex(0) > toIndex(-1)
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException0()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.CEILING;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndDoesNodeMatchPattern()  throws Throwable  {
      Integer integer0 = Integer.valueOf((-2147483634));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("java.math.Round#ngMode@0000000005");
      tree0.getPositionAmongParentsChildren();
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      TreeGrepMatch<Integer> treeGrepMatch1 = new TreeGrepMatch<Integer>(treeGrepMatch0);
      stack0.add(treeGrepMatch1);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.verbose = true;
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree0);
      treeGrep0.doesNodeMatchPattern(tree0, tree0, stack0);
      TreeGrep<RoundingMode> treeGrep2 = new TreeGrep<RoundingMode>((Tree<RoundingMode>) null);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern1()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.verbose = true;
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      TreeGrepMatch<RoundingMode> treeGrepMatch0 = new TreeGrepMatch<RoundingMode>(tree0);
      vector0.add(treeGrepMatch0);
      treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertEquals(1, vector0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern2()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      TreeGrepMatch<RoundingMode> treeGrepMatch0 = new TreeGrepMatch<RoundingMode>(tree0);
      vector0.add(treeGrepMatch0);
      treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertEquals(1, vector0.size());
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      RoundingMode roundingMode1 = RoundingMode.HALF_UP;
      tree0.addLeaf(roundingMode1, roundingMode1);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.toString();
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<Object> tree1 = new Tree<Object>(tree0);
      tree1.addLeaf((Object) tree0);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree1);
      Tree<Object> tree2 = treeGrep1.getPattern();
      assertSame(tree2, tree1);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternReturningListWhereIsEmptyIsTrue()  throws Throwable  {
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>();
      Integer integer0 = Integer.valueOf((-2147483645));
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("");
      LinkedList<edu.stanford.nlp.trees.Tree> linkedList0 = new LinkedList<edu.stanford.nlp.trees.Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0, linkedList0);
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      treeGraphNode0.yield(stack0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      Tree<Integer> tree2 = new Tree<Integer>();
      treeGrep0.doesNodeMatchPattern(tree1, tree2, stack0);
      Tree<RoundingMode> tree3 = tree0.getParent();
      assertNull(tree3);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatch0()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.UNNECESSARY;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse4()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.verbose = true;
      tree0.addLeaf(roundingMode0, roundingMode0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue0()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerExceptionAndMatches()  throws Throwable  {
      Tree<IsoEra> tree0 = new Tree<IsoEra>();
      tree0.getPositionAmongParentsChildren();
      TreeGrep<IsoEra> treeGrep0 = new TreeGrep<IsoEra>(tree0);
      IsoEra isoEra0 = IsoEra.BCE;
      treeGrep0.verbose = true;
      Tree<IsoEra> tree1 = new Tree<IsoEra>(isoEra0);
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternWithNullAndNull()  throws Throwable  {
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern((Tree<Object>) null, (Tree<Object>) null, (List<TreeGrepMatch<Object>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerException0()  throws Throwable  {
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>();
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testToStringThrowsNullPointerExceptionAndMatches()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      Tree<RoundingMode> tree1 = new Tree<RoundingMode>(roundingMode0);
      tree0.addSubtree(tree1, roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.matches(tree0);
      Tree<Word> tree2 = new Tree<Word>();
      TreeGrep<Word> treeGrep1 = new TreeGrep<Word>(tree2);
      // Undeclared exception!
      try { 
        treeGrep1.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesWithTreeWhereHasEdgeLabelsIsTrue()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.UNNECESSARY;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      Tree<RoundingMode> tree1 = tree0.getChild(0);
      RoundingMode roundingMode1 = RoundingMode.DOWN;
      tree1.addLeaf(roundingMode1);
      treeGrep0.matches(tree1);
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // fromIndex(0) > toIndex(-1)
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse5()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_UP;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      Tree<RoundingMode> tree1 = new Tree<RoundingMode>(roundingMode0);
      tree1.addLeaf(roundingMode0, roundingMode0);
      tree0.addSubtree(tree1, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsClassCastException()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.UP;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      RoundingMode roundingMode1 = RoundingMode.FLOOR;
      RoundingMode roundingMode2 = RoundingMode.CEILING;
      tree0.addLeaf(roundingMode1, roundingMode2);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      RoundingMode roundingMode3 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree1 = new Tree<RoundingMode>(roundingMode3);
      Integer integer0 = new Integer(281);
      Integer integer1 = Integer.valueOf(281);
      Tree<Integer> tree2 = new Tree<Integer>(integer1);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("nBVdtKpto");
      LinkedList<edu.stanford.nlp.trees.Tree> linkedList0 = new LinkedList<edu.stanford.nlp.trees.Tree>();
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(categoryWordTag0, linkedList0);
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      List<TreeGrepMatch<Integer>> list0 = treeGraphNode0.yield(stack0);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree2);
      // Undeclared exception!
      try { 
        treeGrep1.doesNodeMatchPattern(tree2, tree2, list0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // edu.stanford.nlp.ling.CoreLabel cannot be cast to edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException1()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_DOWN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesWithTreeWhereHasEdgeLabelsIsFalse()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.UNNECESSARY;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      Tree<RoundingMode> tree1 = tree0.getChild(0);
      boolean boolean0 = treeGrep0.matches(tree1);
      boolean boolean1 = treeGrep0.doesThisTreeMatch(tree0);
      assertFalse(boolean1 == boolean0);
      
      boolean boolean2 = treeGrep0.doesLabelMatchPatternLabel(roundingMode0, roundingMode0);
      assertTrue(boolean2 == boolean1);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatch1()  throws Throwable  {
      Tree<String> tree0 = new Tree<String>("S");
      Tree<String> tree1 = new Tree<String>("NP");
      TreeGrep<String> treeGrep0 = new TreeGrep<String>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchReturningFalse()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.UP;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      RoundingMode roundingMode1 = RoundingMode.FLOOR;
      RoundingMode roundingMode2 = RoundingMode.CEILING;
      tree0.addLeaf(roundingMode1, roundingMode2);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      RoundingMode roundingMode3 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree1 = new Tree<RoundingMode>(roundingMode3);
      treeGrep0.toString();
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree1);
      assertFalse(boolean0);
      
      RoundingMode roundingMode4 = RoundingMode.CEILING;
      RoundingMode roundingMode5 = RoundingMode.CEILING;
      boolean boolean1 = treeGrep0.doesLabelMatchPatternLabel(roundingMode4, roundingMode5);
      assertFalse(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse6()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.CEILING;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue1()  throws Throwable  {
      Tree<IsoEra> tree0 = new Tree<IsoEra>();
      TreeGrep<IsoEra> treeGrep0 = new TreeGrep<IsoEra>(tree0);
      IsoEra isoEra0 = IsoEra.BCE;
      Tree<IsoEra> tree1 = new Tree<IsoEra>(isoEra0);
      boolean boolean0 = treeGrep0.matches(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelReturningTrue()  throws Throwable  {
      IsoEra isoEra0 = IsoEra.CE;
      Tree<IsoEra> tree0 = new Tree<IsoEra>();
      IsoEra isoEra1 = IsoEra.CE;
      tree0.addLeaf(isoEra1);
      TreeGrep<IsoEra> treeGrep0 = new TreeGrep<IsoEra>(tree0);
      IsoEra isoEra2 = IsoEra.CE;
      treeGrep0.doesLabelMatchPatternLabel(isoEra0, isoEra2);
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndDoesLabelMatchPatternLabelAndDoesThisTreeMatch()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      TreeGrep.endOfChildrenString = "nBVdtKpto";
      treeGrep0.doesThisTreeMatch(tree0);
      RoundingMode roundingMode1 = RoundingMode.HALF_UP;
      treeGrep0.doesLabelMatchPatternLabel(roundingMode0, roundingMode1);
      Integer integer0 = new Integer(0);
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree1);
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>();
      treeGrep1.doesNodeMatchPattern(tree1, tree1, vector0);
      assertEquals(1, vector0.size());
      assertFalse(vector0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue2()  throws Throwable  {
      IsoEra isoEra0 = IsoEra.CE;
      Tree<IsoEra> tree0 = new Tree<IsoEra>(isoEra0);
      TreeGrep<IsoEra> treeGrep0 = new TreeGrep<IsoEra>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatches()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.UNNECESSARY;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.verbose = true;
      treeGrep0.matches(tree0);
      IsoEra isoEra0 = IsoEra.BCE;
      Tree<IsoEra> tree1 = new Tree<IsoEra>(isoEra0);
      assertTrue(tree1.isLeaf());
  }

  @Test(timeout = 4000)
  public void testGetPatternAndMatches()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<MinguoEra> tree1 = treeGrep0.getPattern();
      treeGrep0.matches(tree1);
      Tree.readTreeFromString("DwBD6");
      Object object0 = new Object();
      Tree<Object> tree2 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree2);
      treeGrep1.getMatches();
      // Undeclared exception!
      try { 
        tree2.getChild(1335);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 1335, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatches()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      tree0.getParent();
      TreeGrep<Tree<Integer>> treeGrep0 = new TreeGrep<Tree<Integer>>((Tree<Tree<Integer>>) null);
      Stack<List<TreeGrepMatch<Tree<Integer>>>> stack0 = new Stack<List<TreeGrepMatch<Tree<Integer>>>>();
      Stack<TreeGrepMatch<Tree<Integer>>> stack1 = new Stack<TreeGrepMatch<Tree<Integer>>>();
      stack0.add((List<TreeGrepMatch<Tree<Integer>>>) stack1);
      List<TreeGrepMatch<Tree<Integer>>> list0 = treeGrep0.mergeChildrenMatches(stack0, (List<TreeGrepMatch<Tree<Integer>>>) null);
      assertTrue(stack0.contains(list0));
      assertNotNull(list0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatch()  throws Throwable  {
      Integer integer0 = new Integer(48);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<LinkedList<Integer>> tree1 = null;
      TreeGrep<LinkedList<Integer>> treeGrep1 = new TreeGrep<LinkedList<Integer>>((Tree<LinkedList<Integer>>) null);
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      stack0.add((TreeGrepMatch<Integer>) null);
      ArrayList<TreeGrepMatch<LinkedList<Integer>>> arrayList0 = new ArrayList<TreeGrepMatch<LinkedList<Integer>>>();
      TreeGrepMatch<LinkedList<Integer>> treeGrepMatch0 = null;
      try {
        treeGrepMatch0 = new TreeGrepMatch<LinkedList<Integer>>((Tree<LinkedList<Integer>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchWithNull()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.UNNECESSARY;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.verbose = true;
      TreeGrep<RoundingMode> treeGrep1 = new TreeGrep<RoundingMode>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      TreeGrep<Object> treeGrep2 = new TreeGrep<Object>((Tree<Object>) null);
      // Undeclared exception!
      try { 
        treeGrep2.doesThisTreeMatch((Tree<Object>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerExceptionAndDoesLabelMatchPatternLabel()  throws Throwable  {
      Tree<IsoEra> tree0 = new Tree<IsoEra>();
      TreeGrep<IsoEra> treeGrep0 = new TreeGrep<IsoEra>(tree0);
      IsoEra isoEra0 = IsoEra.CE;
      IsoEra isoEra1 = IsoEra.CE;
      tree0.addLeaf(isoEra1);
      IsoEra isoEra2 = IsoEra.BCE;
      treeGrep0.doesLabelMatchPatternLabel(isoEra0, isoEra2);
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsIllegalArgumentException()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      RoundingMode roundingMode1 = RoundingMode.UNNECESSARY;
      treeGrep0.doesLabelMatchPatternLabel(roundingMode0, roundingMode1);
      Integer integer0 = new Integer(61);
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree1);
      LinkedList<List<TreeGrepMatch<Integer>>> linkedList0 = new LinkedList<List<TreeGrepMatch<Integer>>>();
      // Undeclared exception!
      try { 
        treeGrep1.mergeChildrenMatches(linkedList0, (List<TreeGrepMatch<Integer>>) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // fromIndex(0) > toIndex(-1)
         //
         verifyException("java.util.SubList", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetPatternAndGetPattern()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.FLOOR;
      Tree<Object> tree0 = new Tree<Object>(roundingMode0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Tree<Object> tree1 = treeGrep0.getPattern();
      assertTrue(tree1.isRoot());
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabel()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      RoundingMode roundingMode1 = RoundingMode.FLOOR;
      boolean boolean0 = treeGrep0.doesLabelMatchPatternLabel(roundingMode0, roundingMode1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningNull()  throws Throwable  {
      TreeGrep<Tree<Object>> treeGrep0 = new TreeGrep<Tree<Object>>((Tree<Tree<Object>>) null);
      Tree<Tree<Object>> tree0 = treeGrep0.getPattern();
      assertNull(tree0);
  }

  @Test(timeout = 4000)
  public void testToStringThrowsNullPointerException()  throws Throwable  {
      Tree<Word> tree0 = new Tree<Word>();
      TreeGrep<Word> treeGrep0 = new TreeGrep<Word>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testToStringThrowsIndexOutOfBoundsException()  throws Throwable  {
      Integer integer0 = new Integer(4090);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.matchesList;
      treeGrep0.matchesList = null;
      ArrayDeque<Tree<Integer>> arrayDeque0 = new ArrayDeque<Tree<Integer>>(4090);
      tree0.addSubtrees((Iterable<Tree<Integer>>) arrayDeque0);
      treeGrep0.toString();
      treeGrep0.toString();
      Tree<Tree<Object>> tree1 = new Tree<Tree<Object>>();
      TreeGrep<Tree<Object>> treeGrep1 = new TreeGrep<Tree<Object>>(tree1);
      Object object0 = new Object();
      Tree<Object> tree2 = new Tree<Object>(object0);
      // Undeclared exception!
      try { 
        tree2.getChild(0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndDoesLabelMatchPatternLabelAndDoesThisTreeMatch()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.UNNECESSARY;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      tree0.addLeaf(roundingMode0, roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
      
      Vector<TreeGrepMatch<RoundingMode>> vector0 = new Vector<TreeGrepMatch<RoundingMode>>();
      treeGrep0.matchesList = (List<TreeGrepMatch<RoundingMode>>) vector0;
      tree0.getYield();
      boolean boolean1 = treeGrep0.doesThisTreeMatch(tree0);
      RoundingMode roundingMode1 = RoundingMode.HALF_UP;
      boolean boolean2 = treeGrep0.doesLabelMatchPatternLabel(roundingMode0, roundingMode1);
      assertFalse(boolean2 == boolean1);
      assertFalse(boolean2);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternWithNull()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, (List<TreeGrepMatch<MinguoEra>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatch2()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.UNNECESSARY;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      TreeGrep<RoundingMode> treeGrep0 = new TreeGrep<RoundingMode>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndMatchesWithTreeWhereGetNumberOfChildrenIsZero()  throws Throwable  {
      RoundingMode roundingMode0 = RoundingMode.HALF_EVEN;
      Tree<RoundingMode> tree0 = new Tree<RoundingMode>(roundingMode0);
      Integer integer0 = Integer.valueOf((-2147483634));
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      CategoryWordTag categoryWordTag0 = new CategoryWordTag("java.math.RoundingMode@0000000005");
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree1);
      TreeGrepMatch<Integer> treeGrepMatch1 = new TreeGrepMatch<Integer>(treeGrepMatch0);
      stack0.add(treeGrepMatch0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree1);
      treeGrep1.doesNodeMatchPattern(tree1, tree1, stack0);
      assertEquals(1, stack0.size());
      
      tree0.getParent();
      boolean boolean0 = treeGrep0.matches(tree1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetMatchesAndDoesThisTreeMatchThrowsNullPointerException()  throws Throwable  {
      Tree<Integer> tree0 = null;
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      treeGrep0.getMatches();
      Tree<WordLemmaTag> tree1 = new Tree<WordLemmaTag>();
      TreeGrep<WordLemmaTag> treeGrep1 = new TreeGrep<WordLemmaTag>(tree1);
      Vector<TreeGrepMatch<WordLemmaTag>> vector0 = new Vector<TreeGrepMatch<WordLemmaTag>>();
      // Undeclared exception!
      try { 
        treeGrep1.doesThisTreeMatch(tree1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetMatches()  throws Throwable  {
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerException1()  throws Throwable  {
      Tree<IsoEra> tree0 = new Tree<IsoEra>();
      TreeGrep<IsoEra> treeGrep0 = new TreeGrep<IsoEra>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesTreeGrep()  throws Throwable  {
      Tree<Tree<CoreLabel>> tree0 = new Tree<Tree<CoreLabel>>();
      TreeGrep<Tree<CoreLabel>> treeGrep0 = new TreeGrep<Tree<CoreLabel>>(tree0);
      tree0.getParent();
      Tree<CoreLabel> tree1 = new Tree<CoreLabel>();
      int int0 = (-3630);
      // Undeclared exception!
      try { 
        tree1.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }
}
