/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 08:40:52 GMT 2025
 */

package edu.illinois.cs.cogcomp.core.algorithms;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrep;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch;
import edu.illinois.cs.cogcomp.core.datastructures.trees.Tree;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.trees.HeadFinder;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.UniversalSemanticHeadFinder;
import java.lang.reflect.Array;
import java.time.chrono.HijrahEra;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.junit.runner.RunWith;
import org.ojalgo.scalar.Money;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class TreeGrep_3_ESTest extends TreeGrep_3_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereHasEdgeLabelsIsTrue()  throws Throwable  {
      ArrayList<TreeGrepMatch<Object>> arrayList0 = new ArrayList<TreeGrepMatch<Object>>();
      Tree<Object> tree0 = new Tree<Object>(arrayList0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree0);
      treeGrep0.toString();
      treeGrep1.doesThisTreeMatch(tree0);
      Tree<Object> tree1 = new Tree<Object>(treeGrep0);
      tree0.addSubtree(tree1);
      treeGrep1.doesThisTreeMatch(tree0);
      Tree<Integer> tree2 = new Tree<Integer>();
      tree2.getParent();
      TreeGrep<Integer> treeGrep2 = new TreeGrep<Integer>((Tree<Integer>) null);
      Tree<Integer> tree3 = new Tree<Integer>();
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>();
      tree1.addLeaf((Object) treeGrep2);
      TreeGrep<Object> treeGrep3 = new TreeGrep<Object>(tree1);
      treeGrep0.matches(tree1);
      Tree<Object> tree4 = treeGrep3.getPattern();
      treeGrep2.getMatches();
      List<TreeGrepMatch<Object>> list0 = treeGrep3.doesNodeMatchPattern(tree4, tree0, arrayList0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      System.setCurrentTimeMillis(1441L);
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      ArrayList<List<TreeGrepMatch<Object>>> arrayList0 = new ArrayList<List<TreeGrepMatch<Object>>>();
      ArrayList<TreeGrepMatch<Object>> arrayList1 = new ArrayList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      arrayList0.add((List<TreeGrepMatch<Object>>) arrayList1);
      TreeGrepMatch<Object> treeGrepMatch1 = new TreeGrepMatch<Object>(tree0);
      treeGrepMatch0.mergeMatches(treeGrepMatch1);
      TreeGrepMatch<Object> treeGrepMatch2 = new TreeGrepMatch<Object>(treeGrepMatch0);
      arrayList1.add(treeGrepMatch2);
      treeGrep0.mergeChildrenMatches(arrayList0, arrayList1);
      int int0 = (-2097920986);
      Integer integer0 = new Integer((-2097920986));
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      tree1.getParent();
      // Undeclared exception!
      try { 
        Tree.readTreeFromString((String) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerExceptionAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      Tree<Object> tree1 = new Tree<Object>();
      tree0.addSubtree(tree1, (Object) tree1);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      TreeGrepMatch<Object> treeGrepMatch1 = new TreeGrepMatch<Object>(treeGrepMatch0);
      tree0.addLeaf((Object) treeGrepMatch1);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      TreeGrepMatch<Object> treeGrepMatch1 = new TreeGrepMatch<Object>(treeGrepMatch0);
      tree0.addLeaf((Object) treeGrepMatch1);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.matches(tree0);
      System.setCurrentTimeMillis(1L);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndDoesNodeMatchPattern()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Tree<Object>[] treeArray0 = (Tree<Object>[]) Array.newInstance(Tree.class, 9);
      treeArray0[0] = tree0;
      Tree<String> tree1 = new Tree<String>("see");
      treeArray0[1] = tree0;
      treeArray0[2] = tree0;
      treeArray0[0] = tree0;
      treeArray0[4] = tree0;
      treeArray0[5] = tree0;
      treeArray0[6] = tree0;
      treeArray0[7] = tree0;
      treeArray0[8] = tree0;
      treeGrepMatch0.dfs = treeArray0;
      linkedList0.add(treeGrepMatch0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      Tree<Money> tree2 = new Tree<Money>();
      Tree<Tree<Money>> tree3 = new Tree<Tree<Money>>(tree2);
      // Undeclared exception!
      try { 
        tree3.getChild(5843);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 5843, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      tree0.addLeaf((Object) treeGrepMatch0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse2()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
      
      Tree<WordTag> tree1 = new Tree<WordTag>();
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree0);
      assertFalse(treeGrep1.equals((Object)treeGrep0));
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndDoesNodeMatchPattern0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      tree0.getPositionAmongParentsChildren();
      treeGrep0.verbose = true;
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      TreeGrepMatch<Object> treeGrepMatch1 = new TreeGrepMatch<Object>(treeGrepMatch0);
      linkedList0.add(treeGrepMatch1);
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetPatternAndToString()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Tree<Object> tree1 = new Tree<Object>(treeGrep0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree1, linkedList0);
      List<TreeGrepMatch<Object>> list1 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      treeGrep0.verbose = true;
      treeGrep0.matchesList = list1;
      Tree<CategoryWordTag> tree2 = new Tree<CategoryWordTag>();
      treeGrep0.doesNodeMatchPattern(tree1, tree0, list0);
      treeGrep0.getPattern();
      IndexedWord indexedWord0 = new IndexedWord("a0", (-4400), (-4400));
      IndexedWord indexedWord1 = indexedWord0.makeSoftCopy();
      Tree<IndexedWord> tree3 = new Tree<IndexedWord>(indexedWord1);
      TreeGrep<IndexedWord> treeGrep1 = new TreeGrep<IndexedWord>(tree3);
      String string0 = treeGrep1.toString();
      assertNotNull(string0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse3()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      tree0.addLeaf((Object) treeGrepMatch0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse4()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      linkedList0.add(treeGrepMatch0);
      Object object1 = new Object();
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.matches(tree0);
      Tree<WordTag> tree1 = new Tree<WordTag>();
      // Undeclared exception!
      try { 
        tree1.getChild(3944);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 3944, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetMatchesReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
      
      boolean boolean1 = treeGrep0.matches(tree0);
      assertTrue(boolean1 == boolean0);
      
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Tree<Object>[] treeArray0 = (Tree<Object>[]) Array.newInstance(Tree.class, 9);
      treeArray0[0] = tree0;
      Tree.readTreeFromString("see");
      treeArray0[1] = tree0;
      treeArray0[2] = tree0;
      treeArray0[3] = tree0;
      treeArray0[4] = tree0;
      treeArray0[5] = tree0;
      treeArray0[6] = tree0;
      treeArray0[7] = tree0;
      treeArray0[8] = tree0;
      treeGrepMatch0.dfs = treeArray0;
      linkedList0.add(treeGrepMatch0);
      tree0.addLeaf((Object) linkedList0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      tree0.addLeaf(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      linkedList0.add(treeGrepMatch0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertEquals(1, list0.size());
      assertFalse(list0.contains(treeGrepMatch0));
  }

  @Test(timeout = 4000)
  public void testToStringThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      linkedList0.add(treeGrepMatch0);
      LinkedList<HijrahEra> linkedList1 = new LinkedList<HijrahEra>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndDoesNodeMatchPattern1()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesReturningListWhereIsEmptyIsTrue()  throws Throwable  {
      ArrayList<TreeGrepMatch<Object>> arrayList0 = new ArrayList<TreeGrepMatch<Object>>();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      ArrayList<List<TreeGrepMatch<Integer>>> arrayList1 = new ArrayList<List<TreeGrepMatch<Integer>>>();
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>();
      arrayList1.add((List<TreeGrepMatch<Integer>>) vector0);
      arrayList1.add((List<TreeGrepMatch<Integer>>) null);
      treeGrep0.getPattern();
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.mergeChildrenMatches(arrayList1, (List<TreeGrepMatch<Integer>>) null);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndDoesNodeMatchPattern2()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      linkedList0.add(treeGrepMatch0);
      linkedList0.add(treeGrepMatch0);
      Object object1 = new Object();
      tree0.addLeaf(object1);
      linkedList0.clone();
      linkedList0.clone();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerExceptionAndMatches()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse5()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      TreeGrepMatch<Object> treeGrepMatch1 = new TreeGrepMatch<Object>(treeGrepMatch0);
      tree0.addLeaf((Object) treeGrepMatch0);
      tree0.addLeaf((Object) treeGrepMatch1);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      TreeGrepMatch<Object> treeGrepMatch1 = new TreeGrepMatch<Object>(treeGrepMatch0);
      treeGrepMatch1.currentPosition = 786;
      linkedList0.add(treeGrepMatch1);
      Object object1 = new Object();
      tree0.addLeaf(object1);
      linkedList0.clone();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      TreeGrep.startOfChildrenString = "Labels don't match";
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 786
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndGetMatches()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      tree0.addLeaf(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
      
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatch0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      UniversalSemanticHeadFinder universalSemanticHeadFinder0 = new UniversalSemanticHeadFinder();
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.verbose;
      Tree<Object> tree1 = new Tree<Object>(tree0);
      tree0.addSubtree(tree1);
      boolean boolean1 = treeGrep0.verbose;
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      linkedList0.clone();
      List<TreeGrepMatch<Object>> list0 = new Vector<TreeGrepMatch<Object>>();
      treeGrep0.getPattern();
      System.setCurrentTimeMillis((-674L));
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsNullPointerException()  throws Throwable  {
      ArrayList<TreeGrepMatch<Object>> arrayList0 = new ArrayList<TreeGrepMatch<Object>>();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      ArrayList<List<TreeGrepMatch<Integer>>> arrayList1 = new ArrayList<List<TreeGrepMatch<Integer>>>();
      arrayList1.add((List<TreeGrepMatch<Integer>>) null);
      treeGrep0.getPattern();
      // Undeclared exception!
      try { 
        treeGrep0.mergeChildrenMatches(arrayList1, (List<TreeGrepMatch<Integer>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.math.Permutations", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndMatches0()  throws Throwable  {
      ArrayList<TreeGrepMatch<Object>> arrayList0 = new ArrayList<TreeGrepMatch<Object>>();
      Tree<Object> tree0 = new Tree<Object>(arrayList0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree0);
      Object object0 = new Object();
      tree0.addLeaf((Object) treeGrep0, object0);
      treeGrep0.matchesList = (List<TreeGrepMatch<Object>>) arrayList0;
      Tree<Object> tree1 = new Tree<Object>(arrayList0);
      tree1.addSubtree(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree1);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree1);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      linkedList0.add(treeGrepMatch0);
      linkedList0.clone();
      TreeGrep<Object> treeGrep2 = new TreeGrep<Object>(tree1);
      boolean boolean1 = treeGrep2.matches(tree1);
      assertFalse(boolean1 == boolean0);
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      ArrayList<TreeGrepMatch<Object>> arrayList0 = new ArrayList<TreeGrepMatch<Object>>();
      Tree<Object> tree0 = new Tree<Object>(arrayList0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree0);
      treeGrep1.doesThisTreeMatch(tree0);
      Tree<Object> tree1 = new Tree<Object>(treeGrep0);
      tree0.addSubtree(tree1);
      treeGrep1.doesThisTreeMatch(tree0);
      // Undeclared exception!
      try { 
        tree1.getChild(2333);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 2333, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerException0()  throws Throwable  {
      Object object0 = new Object();
      Tree<Tree<Word>> tree0 = new Tree<Tree<Word>>();
      Tree<Object> tree1 = new Tree<Object>(tree0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerException1()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue1()  throws Throwable  {
      UniversalSemanticHeadFinder universalSemanticHeadFinder0 = new UniversalSemanticHeadFinder();
      Object object0 = new Object();
      TaggedWord taggedWord0 = new TaggedWord();
      Tree<Word> tree0 = new Tree<Word>(taggedWord0);
      Tree<Tree<Word>> tree1 = new Tree<Tree<Word>>(tree0);
      TreeGrep<Tree<Word>> treeGrep0 = new TreeGrep<Tree<Word>>(tree1);
      boolean boolean0 = treeGrep0.matches(tree1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereHasEdgeLabelsIsFalse()  throws Throwable  {
      UniversalSemanticHeadFinder universalSemanticHeadFinder0 = new UniversalSemanticHeadFinder();
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<Object> tree1 = new Tree<Object>(tree0);
      tree1.addSubtree(tree0);
      treeGrep0.doesThisTreeMatch(tree1);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      linkedList0.clone();
      LinkedList<TreeGrepMatch<Object>> linkedList1 = new LinkedList<TreeGrepMatch<Object>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList1);
      treeGrep0.getPattern();
      System.setCurrentTimeMillis((-674L));
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndDoesNodeMatchPatternReturningListWhereSizeIsPositive()  throws Throwable  {
      Object object0 = new Object();
      Object object1 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      TreeGrepMatch<Object> treeGrepMatch1 = new TreeGrepMatch<Object>(treeGrepMatch0);
      linkedList0.add(treeGrepMatch1);
      linkedList0.push(treeGrepMatch0);
      linkedList0.clone();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertEquals(2, linkedList0.size());
      assertEquals(2, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern2()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      linkedList0.add(treeGrepMatch0);
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertEquals(1, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndMatches1()  throws Throwable  {
      ArrayList<TreeGrepMatch<Object>> arrayList0 = new ArrayList<TreeGrepMatch<Object>>();
      Tree<Object> tree0 = new Tree<Object>(arrayList0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree0);
      Tree<Object> tree1 = new Tree<Object>(arrayList0);
      tree1.addSubtree(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree1);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree1);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      tree1.addLeaf((Object) treeGrep1);
      linkedList0.clone();
      TreeGrep<Object> treeGrep2 = new TreeGrep<Object>(tree1);
      boolean boolean1 = treeGrep2.matches(tree1);
      assertTrue(boolean1 == boolean0);
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue2()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndDoesNodeMatchPatternAndDoesThisTreeMatch()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      Tree<Object> tree1 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertEquals(1, linkedList0.size());
      
      treeGrep0.verbose = true;
      treeGrep0.doesThisTreeMatch(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatches()  throws Throwable  {
      UniversalSemanticHeadFinder universalSemanticHeadFinder0 = new UniversalSemanticHeadFinder();
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.matches(tree0);
      Tree<Word> tree1 = new Tree<Word>();
      TreeGrep<Word> treeGrep1 = new TreeGrep<Word>(tree1);
      Tree<Tree<Word>> tree2 = new Tree<Tree<Word>>(tree1);
      int int0 = 1;
      // Undeclared exception!
      try { 
        tree2.getChild(1);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 1, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternReturningListWhereIsEmptyIsTrueAndListWhereSizeIsZero()  throws Throwable  {
      UniversalSemanticHeadFinder universalSemanticHeadFinder0 = new UniversalSemanticHeadFinder();
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
      
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      linkedList0.add(treeGrepMatch0);
      linkedList0.push(treeGrepMatch0);
      linkedList0.clone();
      CategoryWordTag categoryWordTag0 = new CategoryWordTag();
      Tree<Object> tree1 = new Tree<Object>(categoryWordTag0);
      Tree<Object> tree2 = new Tree<Object>();
      List<TreeGrepMatch<Object>> list0 = treeGrep0.matchesList;
      List<TreeGrepMatch<Object>> list1 = treeGrep0.doesNodeMatchPattern(tree1, tree2, list0);
      assertEquals(1, list0.size());
      assertFalse(list1.equals((Object)list0));
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      UniversalSemanticHeadFinder universalSemanticHeadFinder0 = new UniversalSemanticHeadFinder();
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      boolean boolean0 = treeGrep0.verbose;
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      linkedList0.add(treeGrepMatch0);
      linkedList0.push(treeGrepMatch0);
      linkedList0.clone();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndDoesNodeMatchPattern3()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternReturningListWhereIsEmptyIsFalse()  throws Throwable  {
      UniversalSemanticHeadFinder universalSemanticHeadFinder0 = new UniversalSemanticHeadFinder();
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, vector0);
      assertEquals(1, vector0.size());
      assertFalse(vector0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndDoesThisTreeMatch()  throws Throwable  {
      UniversalSemanticHeadFinder universalSemanticHeadFinder0 = new UniversalSemanticHeadFinder();
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>();
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      linkedList0.clone();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertEquals(1, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatch1()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Tree<Object> tree1 = new Tree<Object>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchReturningFalse()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      ArrayList<TreeGrepMatch<Object>> arrayList0 = new ArrayList<TreeGrepMatch<Object>>();
      TreeGrep<Tree<Word>> treeGrep1 = new TreeGrep<Tree<Word>>((Tree<Tree<Word>>) null);
      Object object0 = new Object();
      Integer integer0 = new Integer(1601);
      Tree<Object> tree1 = new Tree<Object>(integer0);
      TreeGrep<Object> treeGrep2 = new TreeGrep<Object>(tree0);
      treeGrep2.doesThisTreeMatch(tree1);
      Vector<List<TreeGrepMatch<Integer>>> vector0 = new Vector<List<TreeGrepMatch<Integer>>>(1601);
      ArrayList<TreeGrepMatch<Integer>> arrayList1 = new ArrayList<TreeGrepMatch<Integer>>();
      Tree<Integer> tree2 = new Tree<Integer>();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree2);
      TreeGrepMatch<Integer> treeGrepMatch1 = new TreeGrepMatch<Integer>(treeGrepMatch0);
      // Undeclared exception!
      try { 
        treeGrepMatch1.getRootMatch();
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue3()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Tree<Object> tree1 = new Tree<Object>(tree0);
      boolean boolean0 = treeGrep0.matches(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndDoesThisTreeMatch()  throws Throwable  {
      UniversalSemanticHeadFinder universalSemanticHeadFinder0 = new UniversalSemanticHeadFinder();
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      linkedList0.add(treeGrepMatch0);
      linkedList0.push(treeGrepMatch0);
      linkedList0.clone();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchWithTreeWhereHasEdgeLabelsIsFalse()  throws Throwable  {
      UniversalSemanticHeadFinder universalSemanticHeadFinder0 = new UniversalSemanticHeadFinder();
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<Object> tree1 = new Tree<Object>(tree0);
      tree0.addSubtree(tree1);
      treeGrep0.doesThisTreeMatch(tree1);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      linkedList0.clone();
      // Undeclared exception!
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsIllegalArgumentException()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      tree0.getParent();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      WordTag wordTag0 = WordTag.valueOf(";Ui]_!k>5mG$kk8");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      UniversalSemanticHeadFinder universalSemanticHeadFinder0 = new UniversalSemanticHeadFinder();
      treeGraphNode0.headTerminal((HeadFinder) universalSemanticHeadFinder0, (edu.stanford.nlp.trees.Tree) treeGraphNode1);
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree1);
      treeGrep1.doesThisTreeMatch(tree1);
      Vector<List<TreeGrepMatch<Integer>>> vector0 = new Vector<List<TreeGrepMatch<Integer>>>(1648);
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>();
      // Undeclared exception!
      try { 
        treeGrep0.mergeChildrenMatches(vector0, arrayList0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // fromIndex(0) > toIndex(-1)
         //
         verifyException("java.util.SubList", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatch()  throws Throwable  {
      UniversalSemanticHeadFinder universalSemanticHeadFinder0 = new UniversalSemanticHeadFinder();
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.verbose = true;
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<Object> tree1 = new Tree<Object>(tree0);
      tree0.addSubtree(tree1);
      Tree<Object> tree2 = new Tree<Object>(treeGrep0);
      // Undeclared exception!
      tree1.getPositionAmongParentsChildren();
  }

  @Test(timeout = 4000)
  public void testMatchesReturningFalse()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      Object object0 = new Object();
      TaggedWord taggedWord0 = new TaggedWord();
      Tree<Word> tree1 = new Tree<Word>(taggedWord0);
      Tree<Tree<Word>> tree2 = new Tree<Tree<Word>>(tree1);
      Tree<Tree<Word>> tree3 = new Tree<Tree<Word>>();
      TreeGrep<Tree<Word>> treeGrep0 = new TreeGrep<Tree<Word>>(tree3);
      boolean boolean0 = treeGrep0.matches(tree2);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereSizeIsPositive()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      ArrayList<TreeGrepMatch<Object>> arrayList0 = new ArrayList<TreeGrepMatch<Object>>();
      TreeGrep<Tree<Word>> treeGrep1 = new TreeGrep<Tree<Word>>((Tree<Tree<Word>>) null);
      Tree<Word> tree1 = new Tree<Word>();
      TreeGrep<Word> treeGrep2 = new TreeGrep<Word>(tree1);
      Tree<Word> tree2 = treeGrep2.getPattern();
      Tree<Tree<Word>> tree3 = new Tree<Tree<Word>>(tree2);
      // Undeclared exception!
      try { 
        treeGrep1.matches(tree3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelReturningFalse()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Object object0 = new Object();
      treeGrep0.doesLabelMatchPatternLabel(tree0, object0);
      TreeGrep<Tree<Word>> treeGrep1 = new TreeGrep<Tree<Word>>((Tree<Tree<Word>>) null);
      // Undeclared exception!
      try { 
        treeGrep1.matches((Tree<Tree<Word>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.datastructures.trees.TreeTraversal", e);
      }
  }

  @Test(timeout = 4000)
  public void testToStringReturningNonEmptyString()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      tree0.getParent();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      WordTag wordTag0 = new WordTag("a0", ";Ui]_!k>5mG$kk8");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Vector<List<TreeGrepMatch<Integer>>> vector0 = new Vector<List<TreeGrepMatch<Integer>>>();
      treeGraphNode1.yield(vector0);
      Tree<TaggedWord> tree1 = new Tree<TaggedWord>();
      Tree<Tree<TaggedWord>> tree2 = new Tree<Tree<TaggedWord>>(tree1);
      TreeGrep<Tree<TaggedWord>> treeGrep1 = new TreeGrep<Tree<TaggedWord>>(tree2);
      String string0 = treeGrep1.toString();
      assertNotNull(string0);
  }

  @Test(timeout = 4000)
  public void testMatchesWithNull()  throws Throwable  {
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      edu.stanford.nlp.trees.Tree.valueOf("a0");
      CoreLabel.wordFromString("a0");
      // Undeclared exception!
      try { 
        treeGrep0.matches((Tree<Integer>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.datastructures.trees.TreeTraversal", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetMatchesAndGetMatches()  throws Throwable  {
      Tree<LinkedList<Integer>> tree0 = new Tree<LinkedList<Integer>>();
      tree0.getParent();
      TreeGrep<LinkedList<Integer>> treeGrep0 = new TreeGrep<LinkedList<Integer>>((Tree<LinkedList<Integer>>) null);
      treeGrep0.getMatches();
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>((Tree<Object>) null);
      List<TreeGrepMatch<Object>> list0 = treeGrep1.getMatches();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testGetMatches()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.getMatches();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testGetPattern()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      tree0.getParent();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      treeGrep0.verbose = true;
      Vector<TreeGrepMatch<Object>> vector0 = new Vector<TreeGrepMatch<Object>>();
      treeGrep0.matchesList = (List<TreeGrepMatch<Object>>) vector0;
      treeGrep0.getPattern();
      Tree<Integer> tree1 = new Tree<Integer>();
      Tree<Tree<Integer>> tree2 = new Tree<Tree<Integer>>(tree1);
      tree2.getParent();
      TreeGrep<Tree<Integer>> treeGrep1 = new TreeGrep<Tree<Integer>>((Tree<Tree<Integer>>) null);
      // Undeclared exception!
      try { 
        treeGrep1.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerException2()  throws Throwable  {
      Tree<LinkedList<Integer>> tree0 = new Tree<LinkedList<Integer>>();
      TreeGrep<LinkedList<Integer>> treeGrep0 = new TreeGrep<LinkedList<Integer>>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelReturningTrue()  throws Throwable  {
      LabeledWord labeledWord0 = new LabeledWord("U", (Label) null);
      LabeledWord labeledWord1 = new LabeledWord(labeledWord0, labeledWord0);
      Tree<LabeledWord> tree0 = new Tree<LabeledWord>(labeledWord1);
      TreeGrep<LabeledWord> treeGrep0 = new TreeGrep<LabeledWord>(tree0);
      treeGrep0.doesLabelMatchPatternLabel(labeledWord0, labeledWord0);
      Integer integer0 = new Integer((-2406));
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree1);
      // Undeclared exception!
      try { 
        treeGrepMatch0.getRootMatch();
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsClassCastException()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      tree0.getParent();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      WordTag wordTag0 = WordTag.valueOf(";Ui]_!k>5mG$kk8");
      TreeGraphNode treeGraphNode0 = new TreeGraphNode(wordTag0);
      TreeGraphNode treeGraphNode1 = treeGraphNode0.highestNodeWithSameHead();
      Vector<List<TreeGrepMatch<Integer>>> vector0 = new Vector<List<TreeGrepMatch<Integer>>>();
      List<List<TreeGrepMatch<Integer>>> list0 = treeGraphNode1.yield(vector0);
      treeGraphNode0.taggedYield(null);
      // Undeclared exception!
      try { 
        treeGrep0.mergeChildrenMatches(list0, (List<TreeGrepMatch<Integer>>) null);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // edu.stanford.nlp.ling.CoreLabel cannot be cast to java.util.List
         //
         verifyException("edu.illinois.cs.cogcomp.core.math.Permutations", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerException()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsNullPointerException()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      ArrayList<TreeGrepMatch<Object>> arrayList0 = new ArrayList<TreeGrepMatch<Object>>();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabel()  throws Throwable  {
      Tree<Tree<Integer>> tree0 = new Tree<Tree<Integer>>();
      TreeGrep<Tree<Integer>> treeGrep0 = new TreeGrep<Tree<Integer>>(tree0);
      Tree<Integer> tree1 = new Tree<Integer>();
      // Undeclared exception!
      try { 
        treeGrep0.doesLabelMatchPatternLabel(tree1, tree1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelThrowsNullPointerException()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.doesLabelMatchPatternLabel(tree0, tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testToStringThrowsNullPointerException()  throws Throwable  {
      TreeGrep<Tree<TaggedWord>> treeGrep0 = new TreeGrep<Tree<TaggedWord>>((Tree<Tree<TaggedWord>>) null);
      // Undeclared exception!
      try { 
        treeGrep0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesTreeGrepAndCallsToString()  throws Throwable  {
      Tree<Integer> tree0 = null;
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      Integer integer0 = new Integer((-4619));
      TreeGrep.startOfChildrenString = ";Ui]_!k>5mG$kk8";
      int int0 = 39;
      // Undeclared exception!
      try { 
        treeGrep0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }
}
