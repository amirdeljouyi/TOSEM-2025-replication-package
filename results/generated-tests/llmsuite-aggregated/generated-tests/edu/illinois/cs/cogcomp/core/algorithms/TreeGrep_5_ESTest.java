/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 08:40:45 GMT 2025
 */

package edu.illinois.cs.cogcomp.core.algorithms;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrep;
import edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch;
import edu.illinois.cs.cogcomp.core.datastructures.trees.Tree;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.WordLemmaTag;
import edu.stanford.nlp.ling.WordTag;
import edu.stanford.nlp.util.ArrayCoreMap;
import java.lang.reflect.Array;
import java.math.RoundingMode;
import java.time.Month;
import java.time.chrono.MinguoEra;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class TreeGrep_5_ESTest extends TreeGrep_5_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testGetPatternThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      MinguoEra minguoEra0 = MinguoEra.ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      Tree<Object> tree1 = new Tree<Object>(tree0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree1);
      tree1.clone();
      Integer.getInteger("");
      Tree<Object>[] treeArray0 = (Tree<Object>[]) Array.newInstance(Tree.class, 5);
      treeArray0[0] = tree1;
      treeArray0[1] = tree1;
      treeArray0[2] = tree1;
      treeArray0[3] = tree1;
      treeArray0[4] = tree1;
      treeGrepMatch0.dfs = treeArray0;
      Object object0 = new Object();
      tree1.addLeaf(object0, (Object) treeGrepMatch0);
      linkedList0.add(treeGrepMatch0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      treeGrep0.doesNodeMatchPattern(tree1, tree1, linkedList0);
      System.setCurrentTimeMillis((-2305L));
      Tree<Tree<Object>> tree2 = new Tree<Tree<Object>>(tree1);
      TreeGrep<Tree<Object>> treeGrep1 = new TreeGrep<Tree<Object>>((Tree<Tree<Object>>) null);
      treeGrep1.getMatches();
      Tree<Integer> tree3 = new Tree<Integer>();
      // Undeclared exception!
      try { 
        tree3.getChild((-1969369861));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      Tree<Object> tree0 = new Tree<Object>(linkedList0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      Integer.getInteger("=v85D<YZVAOlDcd");
      tree0.addLeaf((Object) treeGrepMatch0, (Object) null);
      linkedList0.add(treeGrepMatch0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern0()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      tree0.addLeaf(minguoEra0, minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      Stack<TreeGrepMatch<MinguoEra>> stack0 = new Stack<TreeGrepMatch<MinguoEra>>();
      TreeGrepMatch<MinguoEra> treeGrepMatch0 = new TreeGrepMatch<MinguoEra>(tree0);
      stack0.add(treeGrepMatch0);
      List<TreeGrepMatch<MinguoEra>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, stack0);
      assertFalse(list0.contains(treeGrepMatch0));
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive0()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree1 = new Tree<MinguoEra>(minguoEra0);
      tree1.addLeaf(minguoEra0, minguoEra0);
      MinguoEra minguoEra1 = MinguoEra.BEFORE_ROC;
      MinguoEra minguoEra2 = MinguoEra.BEFORE_ROC;
      tree1.addLeaf(minguoEra1, minguoEra2);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree1);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testToStringAndDoesThisTreeMatch()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      MinguoEra minguoEra1 = MinguoEra.BEFORE_ROC;
      tree0.addLeaf(minguoEra1, minguoEra0);
      tree0.toString();
      tree0.addLeaf(minguoEra0, minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      treeGrep0.toString();
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndMatches()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      MinguoEra minguoEra0 = MinguoEra.ROC;
      Tree<MinguoEra> tree1 = new Tree<MinguoEra>(minguoEra0);
      MinguoEra minguoEra1 = MinguoEra.BEFORE_ROC;
      MinguoEra minguoEra2 = MinguoEra.BEFORE_ROC;
      MinguoEra minguoEra3 = MinguoEra.ROC;
      Tree<MinguoEra> tree2 = new Tree<MinguoEra>(minguoEra3);
      tree1.addSubtree(tree2, minguoEra1);
      tree1.addLeaf(minguoEra1, minguoEra2);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree1);
      TreeGrepMatch<MinguoEra> treeGrepMatch0 = new TreeGrepMatch<MinguoEra>(tree1);
      TreeGrepMatch<MinguoEra> treeGrepMatch1 = new TreeGrepMatch<MinguoEra>(treeGrepMatch0);
      treeGrep0.verbose = true;
      Tree<MinguoEra> tree3 = treeGrepMatch1.getPattern();
      boolean boolean0 = treeGrep0.matches(tree1);
      assertTrue(boolean0);
      
      Object object0 = new Object();
      Tree<Object> tree4 = new Tree<Object>();
      TreeGrep<MinguoEra> treeGrep1 = new TreeGrep<MinguoEra>(tree3);
      boolean boolean1 = treeGrep0.doesThisTreeMatch(tree3);
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsZero0()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      MinguoEra minguoEra1 = MinguoEra.BEFORE_ROC;
      treeGrep0.verbose = true;
      Tree<MinguoEra> tree1 = new Tree<MinguoEra>(minguoEra1);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive1()  throws Throwable  {
      Tree<String> tree0 = new Tree<String>("A");
      Tree<String> tree1 = new Tree<String>("B");
      Tree<String> tree2 = new Tree<String>("C");
      tree0.addSubtree(tree1);
      tree1.addSubtree(tree2);
      Tree<String> tree3 = new Tree<String>("A");
      Tree<String> tree4 = new Tree<String>("B");
      Tree<String> tree5 = new Tree<String>("MISMATCH");
      tree4.addSubtree(tree5);
      tree3.addSubtree(tree4);
      TreeGrep<String> treeGrep0 = new TreeGrep<String>(tree3);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive2()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      MinguoEra minguoEra1 = MinguoEra.ROC;
      tree0.addLeaf(minguoEra1);
      tree0.addLeaf(minguoEra0, minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern1()  throws Throwable  {
      System.setCurrentTimeMillis((-146L));
      System.setCurrentTimeMillis((-146L));
      ArrayCoreMap arrayCoreMap0 = new ArrayCoreMap();
      CoreLabel coreLabel0 = new CoreLabel(arrayCoreMap0);
      IndexedWord indexedWord0 = new IndexedWord(coreLabel0);
      Tree<IndexedWord> tree0 = new Tree<IndexedWord>(indexedWord0);
      TreeGrep<IndexedWord> treeGrep0 = new TreeGrep<IndexedWord>(tree0);
      indexedWord0.setBefore("VtZ20RgM/s*D.J");
      arrayCoreMap0.compact();
      ArrayList<TreeGrepMatch<IndexedWord>> arrayList0 = new ArrayList<TreeGrepMatch<IndexedWord>>();
      TreeGrepMatch<IndexedWord> treeGrepMatch0 = new TreeGrepMatch<IndexedWord>(tree0);
      Tree<IndexedWord>[] treeArray0 = (Tree<IndexedWord>[]) Array.newInstance(Tree.class, 0);
      TreeGrepMatch<IndexedWord> treeGrepMatch1 = new TreeGrepMatch<IndexedWord>(treeGrepMatch0);
      Stack<Tree<IndexedWord>> stack0 = new Stack<Tree<IndexedWord>>();
      treeGrepMatch1.patternLeafMatches = (List<Tree<IndexedWord>>) stack0;
      arrayList0.add(treeGrepMatch1);
      treeGrep0.verbose = true;
      treeGrep0.doesNodeMatchPattern(tree0, tree0, arrayList0);
      Tree<Object> tree1 = new Tree<Object>(tree0);
      tree1.getParent();
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>((Tree<Object>) null);
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternAndDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      System.setCurrentTimeMillis((-146L));
      System.setCurrentTimeMillis((-146L));
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "^h#R8B0/QXu");
      ArrayCoreMap arrayCoreMap0 = new ArrayCoreMap();
      CoreLabel coreLabel0 = new CoreLabel(arrayCoreMap0);
      IndexedWord indexedWord0 = new IndexedWord(coreLabel0);
      Tree<IndexedWord> tree0 = new Tree<IndexedWord>(indexedWord0);
      TreeGrep<IndexedWord> treeGrep0 = new TreeGrep<IndexedWord>(tree0);
      indexedWord0.setBefore("VtZ20RgM/s*D.J");
      arrayCoreMap0.compact();
      ArrayList<TreeGrepMatch<IndexedWord>> arrayList0 = new ArrayList<TreeGrepMatch<IndexedWord>>();
      TreeGrepMatch<IndexedWord> treeGrepMatch0 = new TreeGrepMatch<IndexedWord>(tree0);
      Tree<IndexedWord>[] treeArray0 = (Tree<IndexedWord>[]) Array.newInstance(Tree.class, 0);
      treeGrepMatch0.dfs = treeArray0;
      TreeGrepMatch<IndexedWord> treeGrepMatch1 = new TreeGrepMatch<IndexedWord>(treeGrepMatch0);
      arrayList0.add(treeGrepMatch1);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, arrayList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 0
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsArrayIndexOutOfBoundsExceptionAndDoesNodeMatchPattern()  throws Throwable  {
      Integer integer0 = new Integer(1048576);
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      Stack<TreeGrepMatch<Integer>> stack0 = new Stack<TreeGrepMatch<Integer>>();
      treeGrep0.verbose = true;
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, stack0);
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrepMatch", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive3()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      tree0.addLeaf(minguoEra0, minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
      
      Tree<Object> tree1 = new Tree<Object>(minguoEra0);
      tree1.getParent();
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive4()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      tree0.addLeaf(minguoEra0, minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndGetPattern()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      tree0.getPositionAmongParentsChildren();
      tree0.addLeaf(minguoEra0, minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<Integer> tree1 = new Tree<Integer>();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree1);
      treeGrep1.getPattern();
      Tree<LabeledWord> tree2 = new Tree<LabeledWord>();
      TreeGrepMatch<LabeledWord> treeGrepMatch0 = new TreeGrepMatch<LabeledWord>(tree2);
      // Undeclared exception!
      try { 
        treeGrepMatch0.getRootMatch();
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 0, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse0()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      tree0.addLeaf(minguoEra0, minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive5()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      tree0.addLeaf(minguoEra0, minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsZero1()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue0()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      treeGrep0.verbose = true;
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateTreeGrepThrowsIndexOutOfBoundsException()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>();
      MinguoEra minguoEra0 = MinguoEra.ROC;
      Tree<MinguoEra> tree1 = new Tree<MinguoEra>(minguoEra0);
      MinguoEra minguoEra1 = MinguoEra.BEFORE_ROC;
      tree1.addLeaf(minguoEra0, minguoEra1);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree1);
      treeGrep0.matches(tree1);
      Tree<Object> tree2 = new Tree<Object>(tree1);
      // Undeclared exception!
      try { 
        tree2.getChild(849);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 849, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesWithNull()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>();
      MinguoEra minguoEra0 = MinguoEra.ROC;
      Tree<MinguoEra> tree1 = new Tree<MinguoEra>(minguoEra0);
      MinguoEra minguoEra1 = MinguoEra.BEFORE_ROC;
      MinguoEra minguoEra2 = MinguoEra.BEFORE_ROC;
      tree1.addLeaf(minguoEra1, minguoEra2);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree1);
      treeGrep0.doesThisTreeMatch(tree1);
      Tree<Object> tree2 = new Tree<Object>();
      ArrayList<List<TreeGrepMatch<Object>>> arrayList0 = new ArrayList<List<TreeGrepMatch<Object>>>();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree0);
      tree0.getParent();
      // Undeclared exception!
      try { 
        treeGrep1.matches((Tree<Integer>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.datastructures.trees.TreeTraversal", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchReturningFalse()  throws Throwable  {
      Integer integer0 = new Integer((-8));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.getYield();
      Integer integer1 = new Integer((-136));
      Tree<Integer> tree1 = new Tree<Integer>(integer1);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>();
      treeGrep0.doesNodeMatchPattern(tree1, tree0, arrayList0);
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<Tree<WordLemmaTag>> tree2 = new Tree<Tree<WordLemmaTag>>();
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.matchesList;
      ArrayList<TreeGrepMatch<Integer>> arrayList1 = new ArrayList<TreeGrepMatch<Integer>>();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree0);
      treeGrep1.getMatches();
      treeGrep1.matchesList = (List<TreeGrepMatch<Integer>>) arrayList0;
      Tree<WordLemmaTag> tree3 = new Tree<WordLemmaTag>();
      Integer integer2 = new Integer((-8));
      Tree<Integer> tree4 = new Tree<Integer>(integer2);
      List<TreeGrepMatch<Integer>> list1 = new Vector<TreeGrepMatch<Integer>>();
      treeGrep0.matches(tree4);
      TreeGrep<Integer> treeGrep2 = new TreeGrep<Integer>(tree1);
      assertFalse(treeGrep2.equals((Object)treeGrep0));
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternThrowsNullPointerException()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>();
      Vector<List<TreeGrepMatch<Integer>>> vector1 = new Vector<List<TreeGrepMatch<Integer>>>();
      TreeGrepMatch<Integer> treeGrepMatch0 = new TreeGrepMatch<Integer>(tree0);
      vector0.add(treeGrepMatch0);
      vector1.add((List<TreeGrepMatch<Integer>>) vector0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.mergeChildrenMatches(vector1, vector0);
      Tree<Object> tree2 = new Tree<Object>();
      Tree<Object> tree3 = new Tree<Object>();
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree0, list0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereHasEdgeLabelsIsFalse()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      Tree<Object> tree2 = new Tree<Object>();
      tree2.addSubtree(tree1);
      treeGrep0.doesThisTreeMatch(tree1);
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree1);
      TreeGrep<Object> treeGrep2 = new TreeGrep<Object>(tree2);
      treeGrep2.getPattern();
      treeGrep0.getPattern();
      TreeGrep<RoundingMode> treeGrep3 = new TreeGrep<RoundingMode>((Tree<RoundingMode>) null);
      Tree<RoundingMode> tree3 = treeGrep3.getPattern();
      assertNull(tree3);
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesReturningListWhereIsEmptyIsTrue()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>();
      Vector<List<TreeGrepMatch<Integer>>> vector1 = new Vector<List<TreeGrepMatch<Integer>>>();
      vector1.add((List<TreeGrepMatch<Integer>>) vector0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.mergeChildrenMatches(vector1, vector0);
      Tree<Object> tree2 = new Tree<Object>();
      TreeGrep<Object> treeGrep1 = new TreeGrep<Object>(tree1);
      Tree<Object> tree3 = treeGrep1.getPattern();
      assertEquals(1, tree3.size());
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerExceptionAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      Tree<Object> tree2 = new Tree<Object>();
      tree1.addSubtree(tree2);
      treeGrep0.verbose = false;
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetMatchesThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Integer integer0 = new Integer((-8));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.getYield();
      Integer integer1 = new Integer((-136));
      Tree<Integer> tree1 = new Tree<Integer>(integer1);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>();
      treeGrep0.doesNodeMatchPattern(tree1, tree0, arrayList0);
      treeGrep0.matches(tree1);
      Tree<Tree<WordLemmaTag>> tree2 = new Tree<Tree<WordLemmaTag>>();
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.matchesList;
      ArrayList<TreeGrepMatch<Integer>> arrayList1 = new ArrayList<TreeGrepMatch<Integer>>();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree0);
      treeGrep1.getMatches();
      Tree<WordLemmaTag> tree3 = new Tree<WordLemmaTag>();
      List<TreeGrepMatch<Integer>> list1 = treeGrep0.matchesList;
      Integer integer2 = new Integer((-8));
      Tree<Integer> tree4 = new Tree<Integer>(integer2);
      // Undeclared exception!
      try { 
        treeGrep1.doesNodeMatchPattern(tree0, tree4, list1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsPositiveAndMatchesWithTreeWhereIsLeafIsFalse1()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      tree0.addLeaf(minguoEra0, minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsZero2()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      Tree<MinguoEra> tree1 = new Tree<MinguoEra>();
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree1);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesReturningFalse()  throws Throwable  {
      Integer integer0 = new Integer((-8));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.getYield();
      Integer integer1 = new Integer((-8));
      Tree<Integer> tree1 = new Tree<Integer>((Integer) null);
      tree0.getYield();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>();
      Tree<Integer> tree2 = new Tree<Integer>(integer0);
      treeGrep0.doesNodeMatchPattern(tree0, tree2, arrayList0);
      treeGrep0.matches(tree2);
      Tree<Tree<WordLemmaTag>> tree3 = new Tree<Tree<WordLemmaTag>>();
      TreeGrep<Tree<WordLemmaTag>> treeGrep1 = new TreeGrep<Tree<WordLemmaTag>>(tree3);
      // Undeclared exception!
      try { 
        treeGrep1.doesThisTreeMatch(tree3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetMatchesReturningListWhereIsEmptyIsTrueAndListWhereSizeIsZero()  throws Throwable  {
      Tree<Tree<WordLemmaTag>> tree0 = new Tree<Tree<WordLemmaTag>>();
      TreeGrep<Tree<WordLemmaTag>> treeGrep0 = new TreeGrep<Tree<WordLemmaTag>>(tree0);
      treeGrep0.getMatches();
      Integer integer0 = new Integer((-3));
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      tree1.getYield();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree1);
      Tree<Month> tree2 = new Tree<Month>();
      tree2.getParent();
      TreeGrep<Month> treeGrep2 = new TreeGrep<Month>(tree2);
      Stack<TreeGrepMatch<Month>> stack0 = new Stack<TreeGrepMatch<Month>>();
      treeGrep2.matchesList = (List<TreeGrepMatch<Month>>) stack0;
      List<TreeGrepMatch<Month>> list0 = treeGrep2.getMatches();
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabelReturningFalse()  throws Throwable  {
      LinkedList<Object> linkedList0 = new LinkedList<Object>();
      Tree<LinkedList<Object>> tree0 = new Tree<LinkedList<Object>>(linkedList0);
      TreeGrep<LinkedList<Object>> treeGrep0 = new TreeGrep<LinkedList<Object>>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<Month> tree1 = new Tree<Month>();
      tree1.getParent();
      TreeGrep<Month> treeGrep1 = new TreeGrep<Month>((Tree<Month>) null);
      treeGrep1.getMatches();
      Tree<Object> tree2 = new Tree<Object>(linkedList0);
      tree2.getParent();
      tree2.toString();
      TreeGrep<Object> treeGrep2 = new TreeGrep<Object>((Tree<Object>) null);
      Integer integer0 = new Integer((-1552));
      treeGrep2.doesLabelMatchPatternLabel(integer0, (Object) null);
      System.setCurrentTimeMillis((-1885L));
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPatternReturningListWhereSizeIsPositive()  throws Throwable  {
      Integer integer0 = new Integer((-330));
      Tree<Object> tree0 = new Tree<Object>(integer0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      TreeGrepMatch<Object> treeGrepMatch1 = new TreeGrepMatch<Object>(treeGrepMatch0);
      linkedList0.add(treeGrepMatch1);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertEquals(1, linkedList0.size());
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testFailsToCreateTreeGrepThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      Integer integer0 = new Integer((-3));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      tree0.getYield();
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree1);
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, arrayList0);
      treeGrep0.matches(tree0);
      Tree<Tree<WordLemmaTag>> tree2 = new Tree<Tree<WordLemmaTag>>();
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.matchesList;
      ArrayList<TreeGrepMatch<Integer>> arrayList1 = new ArrayList<TreeGrepMatch<Integer>>();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree0);
      treeGrep1.getMatches();
      Tree<WordLemmaTag> tree3 = new Tree<WordLemmaTag>();
      List<TreeGrepMatch<Integer>> list1 = treeGrep1.matchesList;
      // Undeclared exception!
      try { 
        treeGrep0.doesNodeMatchPattern(tree0, tree1, arrayList0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void testDoesNodeMatchPattern2()  throws Throwable  {
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      Tree<Object> tree0 = new Tree<Object>(linkedList0);
      TreeGrepMatch<Object> treeGrepMatch0 = new TreeGrepMatch<Object>(tree0);
      linkedList0.add(treeGrepMatch0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertEquals(1, linkedList0.size());
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void testGetPatternThrowsIndexOutOfBoundsException()  throws Throwable  {
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>();
      LinkedHashSet<Tree<MinguoEra>> linkedHashSet0 = new LinkedHashSet<Tree<MinguoEra>>();
      Integer integer0 = new Integer((-388));
      Integer integer1 = new Integer((-951));
      Tree<Integer> tree1 = new Tree<Integer>(integer1);
      tree1.getYield();
      Tree<Integer> tree2 = new Tree<Integer>(integer1);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree2);
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>();
      treeGrep0.doesNodeMatchPattern(tree2, tree1, arrayList0);
      treeGrep0.matches(tree1);
      Tree<Tree<WordLemmaTag>> tree3 = new Tree<Tree<WordLemmaTag>>();
      List<TreeGrepMatch<Integer>> list0 = treeGrep0.matchesList;
      ArrayList<TreeGrepMatch<Integer>> arrayList1 = new ArrayList<TreeGrepMatch<Integer>>();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>((Tree<Integer>) null);
      treeGrep0.getMatches();
      Tree<WordLemmaTag> tree4 = new Tree<WordLemmaTag>();
      WordLemmaTag wordLemmaTag0 = new WordLemmaTag();
      Tree<WordLemmaTag> tree5 = new Tree<WordLemmaTag>(wordLemmaTag0);
      // Undeclared exception!
      try { 
        tree5.getChild(105);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 105, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndGetMatchesAndGetPattern()  throws Throwable  {
      LinkedList<Object> linkedList0 = new LinkedList<Object>();
      Tree<LinkedList<Object>> tree0 = new Tree<LinkedList<Object>>(linkedList0);
      TreeGrep<LinkedList<Object>> treeGrep0 = new TreeGrep<LinkedList<Object>>(tree0);
      treeGrep0.doesThisTreeMatch(tree0);
      Tree<Tree<Integer>> tree1 = new Tree<Tree<Integer>>();
      TreeGrep<Tree<Integer>> treeGrep1 = new TreeGrep<Tree<Integer>>(tree1);
      treeGrep1.getPattern();
      Tree<Month> tree2 = new Tree<Month>();
      tree2.getParent();
      TreeGrep<Month> treeGrep2 = new TreeGrep<Month>((Tree<Month>) null);
      List<TreeGrepMatch<Month>> list0 = treeGrep2.getMatches();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatch()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      Object object0 = new Object();
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree1 = new Tree<MinguoEra>(minguoEra0);
      tree1.addLeaf(minguoEra0, minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree1);
      treeGrep0.verbose = true;
      treeGrep0.doesThisTreeMatch(tree1);
      Tree<Object> tree2 = new Tree<Object>();
      assertTrue(tree2.isRoot());
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerException0()  throws Throwable  {
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>();
      LinkedHashSet<Tree<MinguoEra>> linkedHashSet0 = new LinkedHashSet<Tree<MinguoEra>>();
      tree0.addSubtrees((Iterable<Tree<MinguoEra>>) linkedHashSet0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      Tree<LinkedList<WordTag>> tree1 = new Tree<LinkedList<WordTag>>();
      TreeGrep<LinkedList<WordTag>> treeGrep1 = new TreeGrep<LinkedList<WordTag>>(tree1);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerException1()  throws Throwable  {
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>();
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testToStringReturningNonEmptyString()  throws Throwable  {
      Object object0 = new Object();
      Tree<Object> tree0 = new Tree<Object>(object0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      treeGrep0.toString();
      LinkedList<Object> linkedList0 = new LinkedList<Object>();
      // Undeclared exception!
      try { 
        tree0.getChild(685);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 685, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testToStringAndToStringThrowsNullPointerException()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      TreeGrep.startOfChildrenString = "W(RRyu:Hxd!Hf~`v$";
      // Undeclared exception!
      try { 
        treeGrep0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.System", e);
      }
  }

  @Test(timeout = 4000)
  public void testToStringThrowsNullPointerException()  throws Throwable  {
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      // Undeclared exception!
      try { 
        treeGrep0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesLabelMatchPatternLabel()  throws Throwable  {
      Word word0 = Word.EMPTY;
      Tree<Word> tree0 = new Tree<Word>(word0);
      TreeGrep<Word> treeGrep0 = new TreeGrep<Word>(tree0);
      boolean boolean0 = treeGrep0.doesLabelMatchPatternLabel(word0, word0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMergeChildrenMatchesThrowsIllegalArgumentException()  throws Throwable  {
      Tree<WordLemmaTag> tree0 = new Tree<WordLemmaTag>();
      tree0.clone();
      tree0.getYield();
      TreeGrep<WordLemmaTag> treeGrep0 = new TreeGrep<WordLemmaTag>(tree0);
      ArrayList<List<TreeGrepMatch<WordLemmaTag>>> arrayList0 = new ArrayList<List<TreeGrepMatch<WordLemmaTag>>>();
      LinkedList<TreeGrepMatch<WordLemmaTag>> linkedList0 = new LinkedList<TreeGrepMatch<WordLemmaTag>>();
      // Undeclared exception!
      try { 
        treeGrep0.mergeChildrenMatches(arrayList0, linkedList0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // fromIndex(0) > toIndex(-1)
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningTreeWhereGetNumberOfChildrenIsPositive()  throws Throwable  {
      Integer integer0 = new Integer((-292));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      Integer integer1 = new Integer((-825));
      tree0.addLeaf(integer1);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      treeGrep0.getPattern();
      Tree<Object> tree1 = new Tree<Object>();
      Tree<Object> tree2 = new Tree<Object>();
      tree2.getParent();
      // Undeclared exception!
      try { 
        tree1.addSubtree((Tree<Object>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.datastructures.trees.Tree", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue1()  throws Throwable  {
      Integer integer0 = new Integer((-1232));
      Tree<Integer> tree0 = new Tree<Integer>(integer0);
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testMatchesWithTreeWhereHasEdgeLabelsIsFalseAndTreeWhereIsRootIsFalse()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      Object object0 = new Object();
      Tree<Object> tree1 = new Tree<Object>();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree1);
      Tree<Object> tree2 = new Tree<Object>(tree0);
      tree1.addSubtree(tree2);
      treeGrep0.verbose = true;
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.datastructures.trees.Tree", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndMatchesWithTreeWhereGetNumberOfChildrenIsZeroAndMatchesWithTreeWhereIsLeafIsTrue2()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.BEFORE_ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      boolean boolean0 = treeGrep0.matches(tree0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsIndexOutOfBoundsException()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      Vector<TreeGrepMatch<Integer>> vector0 = new Vector<TreeGrepMatch<Integer>>();
      MinguoEra minguoEra0 = MinguoEra.ROC;
      Tree<MinguoEra> tree1 = new Tree<MinguoEra>(minguoEra0);
      MinguoEra minguoEra1 = MinguoEra.BEFORE_ROC;
      tree1.addLeaf(minguoEra0, minguoEra1);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree1);
      treeGrep0.verbose = true;
      treeGrep0.matches(tree1);
      Tree<Object> tree2 = new Tree<Object>(tree1);
      // Undeclared exception!
      try { 
        tree2.getChild(849);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Index: 849, Size: 0
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void testMatchesAndDoesThisTreeMatchThrowsNullPointerException()  throws Throwable  {
      Tree<Tree<WordLemmaTag>> tree0 = new Tree<Tree<WordLemmaTag>>();
      TreeGrep<Tree<WordLemmaTag>> treeGrep0 = new TreeGrep<Tree<WordLemmaTag>>(tree0);
      treeGrep0.getMatches();
      Integer integer0 = new Integer((-3));
      Tree<Integer> tree1 = new Tree<Integer>(integer0);
      tree1.getYield();
      TreeGrep<Integer> treeGrep1 = new TreeGrep<Integer>(tree1);
      ArrayList<TreeGrepMatch<Integer>> arrayList0 = new ArrayList<TreeGrepMatch<Integer>>();
      treeGrep1.doesNodeMatchPattern(tree1, tree1, arrayList0);
      treeGrep1.matches(tree1);
      Tree<Tree<WordLemmaTag>> tree2 = new Tree<Tree<WordLemmaTag>>();
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testGetPatternReturningNull()  throws Throwable  {
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      Tree<Object> tree0 = treeGrep0.getPattern();
      assertNull(tree0);
  }

  @Test(timeout = 4000)
  public void testGetMatches()  throws Throwable  {
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>((Tree<Object>) null);
      List<TreeGrepMatch<Object>> list0 = treeGrep0.getMatches();
      assertNull(list0);
  }

  @Test(timeout = 4000)
  public void testGetMatchesAndGetPattern()  throws Throwable  {
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>((Tree<Integer>) null);
      treeGrep0.getMatches();
      Tree<WordLemmaTag> tree0 = new Tree<WordLemmaTag>();
      TreeGrep<WordLemmaTag> treeGrep1 = new TreeGrep<WordLemmaTag>(tree0);
      Tree<WordLemmaTag> tree1 = treeGrep1.getPattern();
      assertSame(tree0, tree1);
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchThrowsNullPointerException2()  throws Throwable  {
      Tree<Object> tree0 = new Tree<Object>();
      tree0.getHeight();
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      Stack<TreeGrepMatch<Object>> stack0 = new Stack<TreeGrepMatch<Object>>();
      treeGrep0.matchesList = (List<TreeGrepMatch<Object>>) stack0;
      // Undeclared exception!
      try { 
        treeGrep0.doesThisTreeMatch(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesTreeGrep()  throws Throwable  {
      Integer integer0 = new Integer((-330));
      Tree<Object> tree0 = new Tree<Object>(integer0);
      TreeGrep<Object> treeGrep0 = new TreeGrep<Object>(tree0);
      LinkedList<TreeGrepMatch<Object>> linkedList0 = new LinkedList<TreeGrepMatch<Object>>();
      treeGrep0.doesNodeMatchPattern(tree0, tree0, linkedList0);
      assertEquals(1, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void testMatchesThrowsNullPointerException()  throws Throwable  {
      Tree<Integer> tree0 = new Tree<Integer>();
      TreeGrep<Integer> treeGrep0 = new TreeGrep<Integer>(tree0);
      // Undeclared exception!
      try { 
        treeGrep0.matches(tree0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("edu.illinois.cs.cogcomp.core.algorithms.TreeGrep", e);
      }
  }

  @Test(timeout = 4000)
  public void testDoesThisTreeMatchAndDoesThisTreeMatchWithTreeWhereGetNumberOfChildrenIsZero3()  throws Throwable  {
      MinguoEra minguoEra0 = MinguoEra.ROC;
      Tree<MinguoEra> tree0 = new Tree<MinguoEra>(minguoEra0);
      TreeGrep<MinguoEra> treeGrep0 = new TreeGrep<MinguoEra>(tree0);
      boolean boolean0 = treeGrep0.doesThisTreeMatch(tree0);
      assertTrue(boolean0);
  }
}
