/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 20:39:51 GMT 2025
 */

package opennlp.tools.namefind;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.IOException;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import opennlp.tools.dictionary.Dictionary;
import opennlp.tools.ml.model.Context;
import opennlp.tools.ml.model.SequenceClassificationModel;
import opennlp.tools.ml.naivebayes.NaiveBayesModel;
import opennlp.tools.ml.perceptron.PerceptronModel;
import opennlp.tools.namefind.BilouNameFinderSequenceValidator;
import opennlp.tools.namefind.BioCodec;
import opennlp.tools.namefind.NameContextGenerator;
import opennlp.tools.namefind.NameFinderME;
import opennlp.tools.namefind.NameSample;
import opennlp.tools.namefind.TokenNameFinderFactory;
import opennlp.tools.namefind.TokenNameFinderModel;
import opennlp.tools.sentdetect.SentenceDetectorFactory;
import opennlp.tools.util.CollectionObjectStream;
import opennlp.tools.util.ObjectStream;
import opennlp.tools.util.Sequence;
import opennlp.tools.util.SequenceCodec;
import opennlp.tools.util.SequenceValidator;
import opennlp.tools.util.Span;
import opennlp.tools.util.TrainingParameters;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class NameFinderME_5_ESTest extends NameFinderME_5_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testDropOverlappingSpansWithEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[19];
      Span span0 = new Span(19, 19);
      spanArray0[0] = span0;
      BioCodec bioCodec0 = new BioCodec();
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[23];
      stack0.add("start");
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      Span[] spanArray1 = nameFinderME0.find((String[]) null);
      Span[] spanArray2 = new Span[0];
      NameFinderME.dropOverlappingSpans(spanArray2);
      // Undeclared exception!
      try { 
        nameFinderME0.probs(spanArray1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot load from double array
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testProbsTakingSpanArrayReturningEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span span0 = new Span(10, 10, 0.0);
      BioCodec bioCodec0 = new BioCodec();
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[0];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      LinkedHashSet<Span> linkedHashSet0 = new LinkedHashSet<Span>();
      stack0.removeAll(linkedHashSet0);
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      System.setCurrentTimeMillis(10);
      Span[] spanArray0 = nameFinderME0.find((String[]) null);
      double[] doubleArray1 = nameFinderME0.probs(spanArray0);
      assertEquals(0, doubleArray1.length);
  }

  @Test(timeout = 4000)
  public void testFindTaking2ArgumentsReturningEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(10, 10);
      Span span1 = new Span(10, 10, 0.0);
      spanArray0[1] = span0;
      BioCodec bioCodec0 = new BioCodec();
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[0];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0, (Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      System.setCurrentTimeMillis(10);
      nameFinderME0.find((String[]) null);
      String[][] stringArray0 = new String[9][4];
      String[] stringArray1 = new String[6];
      stringArray1[0] = "]-lz!0\";x*U@,&X&";
      stringArray1[1] = "\u0000-0";
      stringArray1[2] = "tagdict";
      stringArray1[3] = "|i`hcM%,r(R";
      stringArray1[4] = "";
      stringArray1[5] = "pl";
      stringArray0[0] = stringArray1;
      stringArray0[1] = null;
      stringArray0[2] = null;
      stringArray0[3] = null;
      stringArray0[4] = null;
      stringArray0[5] = null;
      stringArray0[6] = null;
      stringArray0[7] = null;
      stringArray0[8] = null;
      // Undeclared exception!
      try { 
        nameFinderME0.find((String[]) null, stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testProbsTakingNoArgumentsReturningNonEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(10, 10);
      spanArray0[0] = span0;
      Span span1 = new Span(10, 10, 0.0);
      spanArray0[1] = span0;
      SequenceCodec<String> sequenceCodec0 = new BioCodec();
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[1];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) doubleArray0, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      NameFinderME.dropOverlappingSpans(spanArray0);
      System.setCurrentTimeMillis(10);
      nameFinderME0.find((String[]) null);
      nameFinderME0.probs(spanArray0);
      NameFinderME.extractNameType("");
      double[] doubleArray1 = nameFinderME0.probs();
      assertNull(doubleArray1);
  }

  @Test(timeout = 4000)
  public void testTrainWithNull()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      String[] stringArray0 = new String[6];
      stringArray0[0] = "\u0000-0";
      stringArray0[1] = "-NONE-";
      stringArray0[2] = "\u0000-0";
      stringArray0[3] = "\u0000-0";
      stringArray0[4] = "\u0000-0";
      stringArray0[5] = "\u0000-0";
      TrainingParameters trainingParameters0 = TrainingParameters.setParams(stringArray0);
      trainingParameters0.put("Algorithm", "Cutoff");
      // Undeclared exception!
      try { 
        NameFinderME.train("Cutoff", "\u0000-0", (ObjectStream<NameSample>) null, trainingParameters0, (TokenNameFinderFactory) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Unexpected trainer type!
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testTrainThrowsIllegalStateException()  throws Throwable  {
      TrainingParameters trainingParameters0 = new TrainingParameters();
      trainingParameters0.put("Algorithm", "Algorithm");
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      // Undeclared exception!
      try { 
        NameFinderME.train("Algorithm", "Algorithm", (ObjectStream<NameSample>) null, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Unexpected trainer type!
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesNameFinderMEAndFindTakingStringArray0()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[19];
      Span span0 = new Span(19, 19);
      spanArray0[0] = span0;
      BioCodec bioCodec0 = new BioCodec();
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[23];
      stack0.add("start");
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      Span[] spanArray1 = nameFinderME0.find((String[]) null);
      assertEquals(1, spanArray1.length);
  }

  @Test(timeout = 4000)
  public void testFindTakingStringArrayReturningEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(3, 3, "", 3);
      Span span1 = new Span(span0, 3);
      spanArray0[0] = span1;
      Span span2 = new Span(1584, 1584, 0.0);
      Span span3 = new Span(span2, 1584);
      span0.trim("");
      spanArray0[1] = span3;
      span3.equals(span2);
      SequenceCodec<String> sequenceCodec0 = new BioCodec();
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[0];
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "");
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      System.setCurrentTimeMillis((-15L));
      nameFinderME0.find((String[]) null);
      System.setCurrentTimeMillis((-15L));
      LinkedHashSet<NameSample> linkedHashSet0 = new LinkedHashSet<NameSample>();
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedHashSet0);
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      Map<String, Object> map0 = tokenNameFinderFactory1.createArtifactMap();
      NameFinderME.extractNameType("");
      nameFinderME0.probs();
      TrainingParameters trainingParameters0 = new TrainingParameters(map0);
      try { 
        NameFinderME.train("Dba1%", "b[YS>W[+>dFR+hcVV", collectionObjectStream0, trainingParameters0, tokenNameFinderFactory1);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Insufficient training data to create model.
         //
         verifyException("opennlp.tools.ml.model.AbstractDataIndexer", e);
      }
  }

  @Test(timeout = 4000)
  public void testProbsTakingNoArgumentsReturningEmptyArray()  throws Throwable  {
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "-\"vscd");
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(3, 3, "", 3);
      Span span1 = new Span(span0, 3);
      spanArray0[0] = span1;
      Span span2 = new Span(1584, 1584, 0.0);
      Span span3 = new Span(span2, 1584);
      spanArray0[1] = span3;
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[0];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      System.setCurrentTimeMillis(0L);
      nameFinderME0.find((String[]) null);
      System.setCurrentTimeMillis(0L);
      nameFinderME0.probs(doubleArray0);
      NameFinderME.extractNameType("");
      nameFinderME0.clearAdaptiveData();
      double[] doubleArray1 = nameFinderME0.probs();
      assertNull(doubleArray1);
  }

  @Test(timeout = 4000)
  public void testProbsTakingSpanArrayReturningNonEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(3, 3, "", 3);
      Span span1 = new Span(span0, 3);
      spanArray0[0] = span1;
      Span span2 = new Span(1584, 1584, 0.0);
      Span span3 = new Span(span2, 1584);
      spanArray0[1] = span3;
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[0];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      System.setCurrentTimeMillis(0L);
      nameFinderME0.find((String[]) null);
      System.setCurrentTimeMillis(0L);
      nameFinderME0.probs(doubleArray0);
      NameFinderME.extractNameType("");
      nameFinderME0.clearAdaptiveData();
      double[] doubleArray1 = nameFinderME0.probs(spanArray0);
      assertArrayEquals(new double[] {Double.NaN, Double.NaN}, doubleArray1, 0.01);
      assertNotNull(doubleArray1);
  }

  @Test(timeout = 4000)
  public void testFindTaking2ArgumentsReturningNonEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(3, 3, "", 3);
      Span span1 = new Span(span0, 3);
      spanArray0[0] = span1;
      Span span2 = new Span(1584, 1584, 0.0);
      Span span3 = new Span(span2, 1584);
      spanArray0[1] = span3;
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = (double) 3;
      doubleArray0[1] = (double) 3;
      doubleArray0[2] = (double) 1584;
      doubleArray0[3] = (double) 1584;
      doubleArray0[4] = (double) 1584;
      doubleArray0[5] = 1082.964083;
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0, (Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray1 = new double[12];
      System.setCurrentTimeMillis(2961L);
      Span[] spanArray1 = nameFinderME0.find((String[]) null);
      doubleArray1[0] = 0.0;
      doubleArray1[2] = 0.0;
      NameFinderME.dropOverlappingSpans(spanArray1);
      String[][] stringArray0 = new String[4][4];
      stringArray0[0] = null;
      stringArray0[1] = null;
      String[] stringArray1 = new String[7];
      stringArray1[0] = "";
      stringArray1[1] = "";
      stringArray1[2] = "";
      stringArray1[3] = "";
      stringArray1[4] = "";
      stringArray1[5] = "";
      stringArray1[6] = "";
      stringArray0[2] = stringArray1;
      stringArray0[3] = null;
      // Undeclared exception!
      try { 
        nameFinderME0.find((String[]) null, stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testProbsTakingSpanArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(1867, 1867, "type must not be null", (-229.4915));
      spanArray0[0] = span0;
      // Undeclared exception!
      try { 
        nameFinderME0.probs(spanArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testFindTakingStringArrayThrowsArrayIndexOutOfBoundsException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(3, 3, "", 3);
      Span span1 = new Span(span0, 3);
      spanArray0[0] = span0;
      Span span2 = new Span(1584, 1584, 0.0);
      Span span3 = new Span(3, 1584, "");
      spanArray0[1] = span3;
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[0];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      long long0 = 0L;
      System.setCurrentTimeMillis(0L);
      // Undeclared exception!
      try { 
        nameFinderME0.find((String[]) null);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 3 out of bounds for length 0
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testProbsTakingSpanArrayThrowsNullPointerExceptionAndFindTakingStringArray0()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[19];
      Span span0 = new Span(14, 14);
      spanArray0[0] = span0;
      BioCodec bioCodec0 = new BioCodec();
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[13];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.find((String[]) null);
      // Undeclared exception!
      try { 
        nameFinderME0.probs(spanArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Span.getStart()\" because \"spans[...]\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testFindTakingStringArrayWithEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(10, 10);
      spanArray0[0] = span0;
      spanArray0[1] = span0;
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[0];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[0];
      Span[] spanArray1 = nameFinderME0.find(stringArray0);
      assertEquals(2, spanArray1.length);
  }

  @Test(timeout = 4000)
  public void testProbsTakingSpanArrayThrowsNullPointerExceptionAndFindTakingStringArray1()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[19];
      BioCodec bioCodec0 = new BioCodec();
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[1];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.find((String[]) null);
      // Undeclared exception!
      try { 
        nameFinderME0.probs(spanArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Span.getStart()\" because \"spans[...]\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testFindTakingStringArrayReturningNonEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(3, 3, "", 3);
      Span span1 = new Span(span0, 3);
      spanArray0[0] = span1;
      Span span2 = new Span(1584, 1584, 0.0);
      Span span3 = new Span(span2, 1584);
      spanArray0[1] = span3;
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      Stack<String> stack0 = new Stack<String>();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((double[]) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[12];
      System.setCurrentTimeMillis(2961L);
      nameFinderME0.find((String[]) null);
      doubleArray0[0] = 0.0;
      doubleArray0[2] = 0.0;
      System.setCurrentTimeMillis((-3185L));
      doubleArray0[3] = 2177.5502869;
      nameFinderME0.probs(doubleArray0);
      NameFinderME.extractNameType("<><o_*3H`{Gvau");
      nameFinderME0.clearAdaptiveData();
  }

  @Test(timeout = 4000)
  public void testFindTakingStringArrayThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn((List) null).when(sequence0).getOutcomes();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[12];
      double double0 = 0.0;
      System.setCurrentTimeMillis(2961L);
      // Undeclared exception!
      try { 
        nameFinderME0.find((String[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"java.util.List.toArray(Object[])\" because \"c\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testProbsTakingSpanArrayThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[9];
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(1867, 1867, "type must not be null", (-229.4915));
      spanArray0[0] = span0;
      // Undeclared exception!
      try { 
        nameFinderME0.probs(spanArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testFindTakingStringArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn((Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[9];
      double double0 = 0.0;
      // Undeclared exception!
      try { 
        nameFinderME0.find((String[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testFindTaking2Arguments()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn((Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[9];
      double double0 = 0.0;
      doubleArray0[0] = 0.0;
      double double1 = (-1.0);
      doubleArray0[2] = (-1.0);
      doubleArray0[3] = 0.0;
      double double2 = (-1227.59192803558);
      doubleArray0[4] = (-1227.59192803558);
      double double3 = 0.0;
      doubleArray0[5] = 0.0;
      double[] doubleArray1 = new double[9];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = 0.0;
      String[][] stringArray0 = new String[5][1];
      stringArray0[0] = null;
      String[] stringArray1 = new String[7];
      stringArray1[0] = "";
      stringArray1[1] = "";
      stringArray1[2] = "algorithmName must be MAXENT_QN";
      stringArray1[3] = "4;G}P!(~CbKsd6p";
      stringArray1[4] = "S=begin";
      stringArray1[5] = "O";
      stringArray1[6] = "\u0000-0";
      stringArray0[1] = stringArray1;
      stringArray0[2] = null;
      stringArray0[3] = null;
      stringArray0[4] = null;
      // Undeclared exception!
      try { 
        nameFinderME0.find((String[]) null, stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testCreatesNameFinderMEAndFindTakingStringArray1()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BioCodec bioCodec0 = new BioCodec();
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[0];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      Span[] spanArray0 = nameFinderME0.find((String[]) null);
      assertEquals(0, spanArray0.length);
  }

  @Test(timeout = 4000)
  public void testClearAdaptiveDataThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      // Undeclared exception!
      try { 
        nameFinderME0.probs(doubleArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs(double[])\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testProbsTakingDoubleArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 1.0;
      doubleArray0[2] = (-1.0);
      doubleArray0[3] = 2177.5502869;
      doubleArray0[4] = (-1227.59192803558);
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (-1386.880875030176);
      doubleArray0[7] = 0.0;
      doubleArray0[8] = 0.0;
      // Undeclared exception!
      try { 
        nameFinderME0.probs(doubleArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs(double[])\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testProbsTakingNoArgumentsThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      // Undeclared exception!
      try { 
        nameFinderME0.probs();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testProbsTakingNoArguments()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouNameFinderSequenceValidator bilouNameFinderSequenceValidator0 = new BilouNameFinderSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(bilouNameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      // Undeclared exception!
      try { 
        nameFinderME0.probs();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException0()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator) null).when(sequenceCodec0).createSequenceValidator();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn((NameContextGenerator) null).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn((SequenceClassificationModel) null).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.NameContextGenerator.addFeatureGenerator(opennlp.tools.util.featuregen.AdaptiveFeatureGenerator)\" because \"this.contextGenerator\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException1()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceCodec) null).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.SequenceCodec.createSequenceValidator()\" because \"this.seqCodec\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException2()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn((TokenNameFinderFactory) null).when(tokenNameFinderModel0).getFactory();
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderFactory.createSequenceCodec()\" because \"factory\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpansAndDropOverlappingSpans0()  throws Throwable  {
      Span span0 = new Span(12, 12, (-427.95790671609456));
      Span span1 = new Span(span0, 0.0);
      Span span2 = new Span(0, 1, "+&?X+T,>dp", 1);
      Span[] spanArray0 = new Span[8];
      spanArray0[0] = span0;
      spanArray0[1] = span1;
      spanArray0[2] = span2;
      spanArray0[3] = span1;
      spanArray0[4] = span2;
      spanArray0[5] = span2;
      spanArray0[6] = span1;
      spanArray0[7] = span1;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(2, spanArray1.length);
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpans0()  throws Throwable  {
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(1, 1, "", 1);
      spanArray0[0] = span0;
      Span span1 = new Span(515, 515);
      spanArray0[1] = span1;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(2, spanArray1.length);
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpans1()  throws Throwable  {
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(2387, 2387, 2387);
      spanArray0[0] = span0;
      spanArray0[1] = span0;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(1, spanArray1.length);
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpansReturningEmptyArray()  throws Throwable  {
      Span[] spanArray0 = new Span[0];
      NameFinderME.dropOverlappingSpans(spanArray0);
      LinkedList<NameSample> linkedList0 = new LinkedList<NameSample>();
      boolean boolean0 = false;
      NameSample nameSample0 = NameSample.parse("\u0000-0", "\u0000-0", false);
      linkedList0.add(nameSample0);
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedList0);
      CollectionObjectStream<NameSample> collectionObjectStream1 = new CollectionObjectStream<NameSample>(linkedList0);
      TrainingParameters trainingParameters0 = new TrainingParameters();
      String string0 = "\u0000-0";
      int int0 = (-4000);
      Context[] contextArray0 = new Context[5];
      int[] intArray0 = new int[1];
      intArray0[0] = (-4000);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) (-4000);
      doubleArray0[1] = (double) (-4000);
      doubleArray0[2] = (double) (-4000);
      doubleArray0[3] = (double) (-4000);
      doubleArray0[4] = (double) (-4000);
      doubleArray0[5] = (double) (-4000);
      doubleArray0[6] = (double) (-4000);
      Context context0 = new Context(intArray0, doubleArray0);
      contextArray0[0] = context0;
      Context context1 = new Context(intArray0, doubleArray0);
      contextArray0[1] = context1;
      Context context2 = new Context(intArray0, doubleArray0);
      contextArray0[2] = context2;
      Context context3 = new Context(intArray0, doubleArray0);
      contextArray0[3] = context3;
      Context context4 = new Context(intArray0, doubleArray0);
      contextArray0[4] = context4;
      String[] stringArray0 = new String[9];
      stringArray0[0] = "\u0000-0";
      stringArray0[1] = "\u0000-0";
      stringArray0[2] = "\u0000-0";
      stringArray0[3] = "\u0000-0";
      stringArray0[4] = "\u0000-0";
      stringArray0[5] = "\u0000-0";
      stringArray0[6] = "\u0000-0";
      stringArray0[7] = "\u0000-0";
      stringArray0[8] = "\u0000-0";
      NaiveBayesModel naiveBayesModel0 = null;
      try {
        naiveBayesModel0 = new NaiveBayesModel(contextArray0, stringArray0, stringArray0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 5 out of bounds for length 5
         //
         verifyException("opennlp.tools.ml.model.AbstractModel", e);
      }
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpansAndDropOverlappingSpans1()  throws Throwable  {
      TrainingParameters.defaultParams();
      Span[] spanArray0 = new Span[3];
      Span span0 = new Span(8, 8, 0.0);
      spanArray0[0] = span0;
      Span span1 = new Span(span0, (double) 8);
      spanArray0[1] = span1;
      Span span2 = new Span(1, 8, "<NAzuhj+,6", 1.0E-6);
      spanArray0[2] = span2;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(1, spanArray1.length);
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpans2()  throws Throwable  {
      Span[] spanArray0 = new Span[1];
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(1, spanArray1.length);
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpansAndDropOverlappingSpans2()  throws Throwable  {
      String string0 = "q#naX02/=D$4,R*/|m";
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(46, 2955);
      Span span1 = new Span(span0, (-540.712));
      spanArray0[0] = span1;
      NameFinderME.dropOverlappingSpans(spanArray0);
      LinkedList<NameSample> linkedList0 = new LinkedList<NameSample>();
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedList0);
      TrainingParameters.defaultParams();
      Dictionary dictionary0 = new Dictionary();
      char[] charArray0 = new char[6];
      charArray0[0] = 'a';
      charArray0[1] = 'S';
      charArray0[2] = 'i';
      charArray0[3] = 'Z';
      charArray0[4] = '/';
      charArray0[5] = 'm';
      SentenceDetectorFactory sentenceDetectorFactory0 = new SentenceDetectorFactory("", false, dictionary0, charArray0);
      Map<String, Object> map0 = sentenceDetectorFactory0.createArtifactMap();
      SequenceCodec<String> sequenceCodec0 = TokenNameFinderFactory.instantiateSequenceCodec((String) null);
      try { 
        TokenNameFinderFactory.create("l0@_N^zD(AKQ5`fS", (byte[]) null, map0, sequenceCodec0);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Could not instantiate the l0@_N^zD(AKQ5`fS. The initialization threw an exception.
         //
         verifyException("opennlp.tools.namefind.TokenNameFinderFactory", e);
      }
  }

  @Test(timeout = 4000)
  public void testDropOverlappingSpansThrowsNullPointerException()  throws Throwable  {
      NameFinderME.extractNameType(">V/CqTFQ{;m8mI{gDg");
      Span[] spanArray0 = null;
      // Undeclared exception!
      try { 
        NameFinderME.dropOverlappingSpans((Span[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot read the array length because \"spans\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractNameTypeThrowsIllegalStateException()  throws Throwable  {
      // Undeclared exception!
      try { 
        NameFinderME.extractNameType("\u0000-0");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test(timeout = 4000)
  public void testTrainThrowsIOException()  throws Throwable  {
      LinkedHashSet<NameSample> linkedHashSet0 = new LinkedHashSet<NameSample>();
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedHashSet0);
      String[] stringArray0 = new String[3];
      stringArray0[0] = "^5&00 ";
      String string0 = "";
      stringArray0[1] = "";
      stringArray0[2] = "(.+)-w+";
      TrainingParameters trainingParameters0 = TrainingParameters.setParams(stringArray0);
      linkedHashSet0.stream();
      trainingParameters0.put("^5&00 ", "(.+)-w+");
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      try { 
        NameFinderME.train("^5&00 ", "(.+)-w+", collectionObjectStream0, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Insufficient training data to create model.
         //
         verifyException("opennlp.tools.ml.model.AbstractDataIndexer", e);
      }
  }

  @Test(timeout = 4000)
  public void testTrainThrowsNullPointerException()  throws Throwable  {
      TrainingParameters trainingParameters0 = new TrainingParameters();
      // Undeclared exception!
      try { 
        NameFinderME.train("w2=eos", "w2=eos", (ObjectStream<NameSample>) null, trainingParameters0, (TokenNameFinderFactory) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderFactory.createContextGenerator()\" because \"factory\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractNameTypeAndExtractNameType()  throws Throwable  {
      String string0 = ",V\"?-y+|,R,Q\"$";
      NameFinderME.extractNameType(",V\"?-y+|,R,Q\"$");
      String[] stringArray0 = new String[8];
      stringArray0[0] = ",V\"?-y+|,R,Q\"$";
      stringArray0[1] = ",V\"?-y+|,R,Q\"$";
      stringArray0[2] = null;
      stringArray0[3] = ",V\"?-y+|,R,Q\"$";
      stringArray0[4] = null;
      stringArray0[5] = ",V\"?-y+|,R,Q\"$";
      stringArray0[6] = null;
      stringArray0[7] = null;
      PerceptronModel perceptronModel0 = null;
      try {
        perceptronModel0 = new PerceptronModel((Context[]) null, stringArray0, stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot load from object array because \"params\" is null
         //
         verifyException("opennlp.tools.ml.model.AbstractModel", e);
      }
  }

  @Test(timeout = 4000)
  public void testExtractNameType()  throws Throwable  {
      String string0 = NameFinderME.extractNameType("LID2`G1*TMkaTz8~jP");
      assertNull(string0);
  }

  @Test(timeout = 4000)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException3()  throws Throwable  {
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME((TokenNameFinderModel) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderModel.getFactory()\" because \"model\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }
}
