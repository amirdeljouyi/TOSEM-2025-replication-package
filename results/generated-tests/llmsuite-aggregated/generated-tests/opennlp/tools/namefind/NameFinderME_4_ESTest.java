/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 10:27:40 GMT 2025
 */

package opennlp.tools.namefind;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;
import opennlp.tools.lemmatizer.DefaultLemmatizerSequenceValidator;
import opennlp.tools.ml.model.SequenceClassificationModel;
import opennlp.tools.namefind.BilouCodec;
import opennlp.tools.namefind.BioCodec;
import opennlp.tools.namefind.NameContextGenerator;
import opennlp.tools.namefind.NameFinderME;
import opennlp.tools.namefind.NameSample;
import opennlp.tools.namefind.TokenNameFinderFactory;
import opennlp.tools.namefind.TokenNameFinderModel;
import opennlp.tools.util.CollectionObjectStream;
import opennlp.tools.util.ObjectStream;
import opennlp.tools.util.Sequence;
import opennlp.tools.util.SequenceCodec;
import opennlp.tools.util.SequenceValidator;
import opennlp.tools.util.Span;
import opennlp.tools.util.TrainingParameters;
import org.evosuite.runtime.EvoRunnerJUnit5;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.net.MockURL;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.jupiter.api.extension.RegisterExtension;

@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class NameFinderME_4_ESTest extends NameFinderME_4_ESTest_scaffolding {
@RegisterExtension
  static EvoRunnerJUnit5 runner = new EvoRunnerJUnit5(NameFinderME_4_ESTest.class);

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingSpanArrayReturningNonEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouCodec bilouCodec0 = new BilouCodec();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Stack<String> stack0 = new Stack<String>();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) null, (Object) null, (Object) null).when(sequence0).getProbs();
      FileSystemHandling.shouldAllThrowIOExceptions();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bilouCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      bilouCodec0.decode(stack0);
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[2];
      Span[] spanArray0 = nameFinderME0.find(stringArray0);
      nameFinderME0.probs(spanArray0);
      NameFinderME.dropOverlappingSpans(spanArray0);
      Span[] spanArray1 = new Span[4];
      Span span0 = new Span(300, 300);
      spanArray1[0] = span0;
      Span span1 = new Span(span0, (double) 300);
      spanArray1[1] = span1;
      Span span2 = new Span(span1, (-1829.5671202227434));
      spanArray1[2] = span2;
      Span span3 = new Span(300, 300, "V3hE2>`qn(ty");
      spanArray1[3] = span3;
      nameFinderME0.probs(spanArray1);
      TrainingParameters trainingParameters0 = TrainingParameters.defaultParams();
      String string0 = "Algorithm";
      trainingParameters0.put("Algorithm", "Algorithm");
      String string1 = "\u0000-0";
      LinkedList<NameSample> linkedList0 = new LinkedList<NameSample>();
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedList0);
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      // Undeclared exception!
      try { 
        NameFinderME.train("\u0000-0", "Algorithm", collectionObjectStream0, trainingParameters0, tokenNameFinderFactory1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Unexpected trainer type!
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayReturningNonEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      FileSystemHandling.shouldAllThrowIOExceptions();
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(136, 136, (-1818.8));
      spanArray0[0] = span0;
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(defaultLemmatizerSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Stack<String> stack0 = new Stack<String>();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((double[]) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0, (Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[8];
      stringArray0[0] = "\u0000-0";
      stringArray0[1] = "";
      stringArray0[2] = "Parse.insert: {} -> {}";
      stringArray0[3] = "%ieFb4'KPF=,A<";
      stringArray0[4] = "\u0000-0";
      stringArray0[5] = "cont";
      stringArray0[6] = "x#dM3yF<@Z\u0006&";
      stringArray0[7] = "n&4?tr6RHP?i^F5peQk";
      nameFinderME0.find(stringArray0, (String[][]) null);
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrainThrowsIllegalStateException()  throws Throwable  {
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TrainingParameters trainingParameters0 = TrainingParameters.defaultParams();
      trainingParameters0.put("Algorithm", "Algorithm");
      // Undeclared exception!
      try { 
        NameFinderME.train("Algorithm", "Algorithm", (ObjectStream<NameSample>) null, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Unexpected trainer type!
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayThrowsNullPointerException0()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouCodec bilouCodec0 = new BilouCodec();
      Stack<String> stack0 = new Stack<String>();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn((List) null).when(sequence0).getOutcomes();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bilouCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      // Undeclared exception!
      try { 
        nameFinderME0.find((String[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"java.util.List.toArray(Object[])\" because \"c\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayAndFindTakingStringArrayWithNull()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouCodec bilouCodec0 = new BilouCodec();
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 1558.7;
      doubleArray0[1] = (-1778.642149510089);
      doubleArray0[2] = 0.0;
      bilouCodec0.decode(stack0);
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0, (Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bilouCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      stack0.add("");
      stack0.add("default-unit");
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.find((String[]) null);
      // Undeclared exception!
      try { 
        nameFinderME0.find((String[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingNoArgumentsReturningNonEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      BilouCodec bilouCodec0 = new BilouCodec();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      bilouCodec0.createSequenceValidator();
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = 2.0;
      doubleArray0[1] = (-4124.0);
      doubleArray0[2] = 0.0;
      doubleArray0[3] = (-1405.066);
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) null, (Object) doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bilouCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      Span[] spanArray0 = nameFinderME0.find((String[]) null);
      nameFinderME0.probs();
      String string0 = ")d%";
      String string1 = "\u0000-0";
      String[][] stringArray0 = new String[2][8];
      stringArray0[0] = null;
      stringArray0[1] = null;
      NameSample nameSample0 = null;
      try {
        nameSample0 = new NameSample((String[]) null, spanArray0, stringArray0, false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // sentence must not be null
         //
         verifyException("java.util.Objects", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingNoArgumentsReturningEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      FileSystemHandling.shouldAllThrowIOExceptions();
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      Span[] spanArray0 = new Span[0];
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(defaultLemmatizerSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[0];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      stack0.add("H[(");
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[8];
      stringArray0[0] = "\u0000-0";
      stringArray0[1] = "";
      nameFinderME0.find(stringArray0);
      double[] doubleArray1 = nameFinderME0.probs();
      assertNull(doubleArray1);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayThrowsNullPointerException1()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      Span[] spanArray0 = new Span[1];
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(defaultLemmatizerSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      Stack<String> stack0 = new Stack<String>();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((double[]) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      // Undeclared exception!
      try { 
        nameFinderME0.find((String[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Span.getStart()\" because \"spans[...]\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingSpanArrayThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouCodec bilouCodec0 = new BilouCodec();
      Stack<String> stack0 = new Stack<String>();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) null, (Object) null, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bilouCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      Span[] spanArray0 = nameFinderME0.find((String[]) null);
      nameFinderME0.probs(spanArray0);
      Span[] spanArray1 = new Span[4];
      Span span0 = new Span(17, 17, "Unexpected trainer type!");
      spanArray1[0] = span0;
      Span span1 = new Span(3, 3);
      spanArray1[1] = span1;
      Span span2 = new Span(1, 3, 17);
      spanArray1[2] = span2;
      Span span3 = new Span(3, 2451);
      spanArray1[3] = span3;
      // Undeclared exception!
      try { 
        nameFinderME0.probs(spanArray1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot load from double array
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingNoArgumentsThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouCodec bilouCodec0 = new BilouCodec();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bilouCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      // Undeclared exception!
      try { 
        nameFinderME0.probs();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingNoArguments()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      FileSystemHandling.shouldAllThrowIOExceptions();
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      Span[] spanArray0 = new Span[0];
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(defaultLemmatizerSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Stack<String> stack0 = new Stack<String>();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) null, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[8];
      stringArray0[0] = "\u0000-0";
      stringArray0[1] = "";
      stringArray0[2] = "Parse.insert: {} -> {}";
      stringArray0[3] = "%ieFb4'KPF=,A<";
      stringArray0[4] = "\u0000-0";
      stringArray0[5] = "cont";
      stringArray0[6] = "x#dM3yF<@Z\u0006&";
      stringArray0[7] = "n&4?tr6RHP?i^F5peQk";
      nameFinderME0.find(stringArray0);
      double[] doubleArray0 = nameFinderME0.probs();
      assertNull(doubleArray0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingDoubleArrayThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouCodec bilouCodec0 = new BilouCodec();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bilouCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      // Undeclared exception!
      try { 
        nameFinderME0.probs((double[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs(double[])\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingDoubleArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      FileSystemHandling.shouldAllThrowIOExceptions();
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      Span[] spanArray0 = new Span[0];
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(defaultLemmatizerSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Stack<String> stack0 = new Stack<String>();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((double[]) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[8];
      stringArray0[0] = "\u0000-0";
      stringArray0[1] = "";
      stack0.add("\u0000-0");
      stringArray0[2] = "Parse.insert: {} -> {}";
      stringArray0[3] = "%ieFb4'KPF=,A<";
      stringArray0[4] = "\u0000-0";
      stringArray0[5] = "cont";
      stringArray0[6] = "x#dM3yF<@Z\u0006&";
      stringArray0[7] = "n&4?tr6RHP?i^F5peQk";
      nameFinderME0.find(stringArray0);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (-2519.53);
      doubleArray0[1] = 0.0;
      doubleArray0[2] = 0.0;
      nameFinderME0.probs(doubleArray0);
      assertEquals(3, doubleArray0.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayReturningEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      FileSystemHandling.shouldAllThrowIOExceptions();
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      Span[] spanArray0 = new Span[0];
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(defaultLemmatizerSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      List<String> list0 = List.of("", "", "", "", "cont", "");
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(list0).when(sequence0).getOutcomes();
      doReturn((double[]) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0, (Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[8];
      stringArray0[0] = "\u0000-0";
      stringArray0[1] = "";
      stringArray0[2] = "Parse.insert: {} -> {}";
      stringArray0[3] = "%ieFb4'KPF=,A<";
      stringArray0[4] = "\u0000-0";
      stringArray0[5] = "cont";
      stringArray0[6] = "x#dM3yF<@Z\u0006&";
      stringArray0[7] = "n&4?tr6RHP?i^F5peQk";
      nameFinderME0.find(stringArray0, (String[][]) null);
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTaking2ArgumentsThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      FileSystemHandling.shouldAllThrowIOExceptions();
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(defaultLemmatizerSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn((List) null).when(sequence0).getOutcomes();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[8];
      stringArray0[0] = "\u0000-0";
      stringArray0[1] = "";
      stringArray0[2] = "Parse.insert: {} -> {}";
      stringArray0[3] = "%ieFb4'KPF=,A<";
      stringArray0[4] = "\u0000-0";
      stringArray0[5] = "cont";
      stringArray0[6] = "x#dM3yF<@Z\u0006&";
      stringArray0[7] = "n&4?tr6RHP?i^F5peQk";
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0, (String[][]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"java.util.List.toArray(Object[])\" because \"c\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTaking2Arguments()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BioCodec bioCodec0 = new BioCodec();
      bioCodec0.createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn((Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[0];
      String[][] stringArray1 = new String[8][9];
      stringArray1[0] = stringArray0;
      stringArray1[1] = stringArray0;
      bioCodec0.areOutcomesCompatible(stringArray0);
      stringArray1[2] = stringArray0;
      stringArray1[3] = stringArray0;
      String[] stringArray2 = new String[9];
      stringArray2[0] = "";
      stringArray2[1] = "";
      stringArray2[2] = "";
      stringArray2[3] = "";
      stringArray2[4] = "z:/s3yi1jQ?D^dH%";
      stringArray2[5] = "";
      stringArray2[6] = "^[0-9a-z\u00E1\u00E9\u00ED\u00F3\u00FA\u00FC\u00FD\u00F1A-Z\u00C1\u00C9\u00CD\u00D3\u00DA\u00DD\u00D1]+$";
      stringArray2[7] = ":Cmt";
      stringArray2[8] = "";
      stringArray1[4] = stringArray2;
      stringArray1[5] = stringArray0;
      stringArray1[6] = stringArray0;
      stringArray1[7] = stringArray0;
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0, stringArray1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayAndClearAdaptiveData()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      FileSystemHandling.shouldAllThrowIOExceptions();
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(defaultLemmatizerSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn((Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[8];
      stringArray0[0] = "\u0000-0";
      stringArray0[1] = "";
      stringArray0[2] = "Parse.insert: {} -> {}";
      stringArray0[3] = "%ieFb4'KPF=,A<";
      stringArray0[4] = "\u0000-0";
      stringArray0[5] = "cont";
      stringArray0[6] = "x#dM3yF<@Z\u0006&";
      stringArray0[7] = "n&4?tr6RHP?i^F5peQk";
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayThrowsNullPointerException2()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BilouCodec bilouCodec0 = new BilouCodec();
      Stack<String> stack0 = new Stack<String>();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn((Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bilouCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      // Undeclared exception!
      try { 
        nameFinderME0.find((String[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClearAdaptiveDataAndClearAdaptiveData()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BioCodec bioCodec0 = new BioCodec();
      bioCodec0.createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClearAdaptiveData()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BioCodec bioCodec0 = new BioCodec();
      bioCodec0.createSequenceValidator();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException0()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator) null).when(sequenceCodec0).createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn((NameContextGenerator) null).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn((SequenceClassificationModel) null).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.NameContextGenerator.addFeatureGenerator(opennlp.tools.util.featuregen.AdaptiveFeatureGenerator)\" because \"this.contextGenerator\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException1()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceCodec) null).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.SequenceCodec.createSequenceValidator()\" because \"this.seqCodec\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException2()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn((TokenNameFinderFactory) null).when(tokenNameFinderModel0).getFactory();
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderFactory.createSequenceCodec()\" because \"factory\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractNameType()  throws Throwable  {
      NameFinderME.extractNameType("3gO0/n");
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(1124, 1124);
      spanArray0[0] = span0;
      Span span1 = new Span(span0, 1124);
      spanArray0[1] = span1;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(2, spanArray1.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpans0()  throws Throwable  {
      Span span0 = new Span(4711, 4711, "G9]V%x");
      Span[] spanArray0 = new Span[2];
      spanArray0[0] = span0;
      spanArray0[1] = span0;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(1, spanArray1.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractNameTypeThrowsIllegalStateException()  throws Throwable  {
      // Undeclared exception!
      try { 
        NameFinderME.extractNameType("\u0000-0");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrainThrowsIOException()  throws Throwable  {
      String string0 = "Iterations";
      String string1 = "Fn8[]8,;nB57~;,";
      LinkedHashSet<NameSample> linkedHashSet0 = new LinkedHashSet<NameSample>();
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedHashSet0);
      String[] stringArray0 = new String[0];
      TrainingParameters trainingParameters0 = TrainingParameters.setParams(stringArray0);
      collectionObjectStream0.reset();
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      try { 
        NameFinderME.train("Iterations", "Fn8[]8,;nB57~;,", collectionObjectStream0, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Insufficient training data to create model.
         //
         verifyException("opennlp.tools.ml.model.AbstractDataIndexer", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrain()  throws Throwable  {
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TrainingParameters trainingParameters0 = TrainingParameters.defaultParams();
      trainingParameters0.put("Algorithm", "gXFA>dwFI");
      // Undeclared exception!
      try { 
        NameFinderME.train("tzuY!Q7'GP:b&3Q", "tzuY!Q7'GP:b&3Q", (ObjectStream<NameSample>) null, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Unexpected trainer type!
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrainThrowsNullPointerExceptionAndTrain()  throws Throwable  {
      String string0 = "";
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)92;
      byteArray0[1] = (byte)101;
      byteArray0[2] = (byte)29;
      byteArray0[3] = (byte)6;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      TrainingParameters trainingParameters0 = new TrainingParameters(byteArrayInputStream0);
      // Undeclared exception!
      try { 
        NameFinderME.train("", "", (ObjectStream<NameSample>) null, trainingParameters0, (TokenNameFinderFactory) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderFactory.createContextGenerator()\" because \"factory\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrainThrowsNullPointerExceptionAndTrainWithNonNull()  throws Throwable  {
      TrainingParameters trainingParameters0 = new TrainingParameters();
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      // Undeclared exception!
      try { 
        NameFinderME.train("SBAR", "SBAR", (ObjectStream<NameSample>) null, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.ObjectStream.read()\" because \"this.samples\" is null
         //
         verifyException("opennlp.tools.util.AbstractEventStream", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException3()  throws Throwable  {
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME((TokenNameFinderModel) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderModel.getFactory()\" because \"model\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpansReturningEmptyArray()  throws Throwable  {
      Span[] spanArray0 = new Span[0];
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(0, spanArray1.length);
      
      String string0 = "4}kZa`}d~dD(sHCXG0";
      String string1 = "6V)i-ePq([C";
      LinkedList<NameSample> linkedList0 = new LinkedList<NameSample>();
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedList0);
      // Undeclared exception!
      try { 
        TrainingParameters.setParams((String[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot read the array length because \"args\" is null
         //
         verifyException("opennlp.tools.cmdline.CmdLineUtil", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpansAndDropOverlappingSpans0()  throws Throwable  {
      Span span0 = new Span(4711, 4711, "s'{FWu");
      Span[] spanArray0 = new Span[4];
      spanArray0[0] = span0;
      Span span1 = new Span(24, 332, "UJx#NBR~]h^u7", 24);
      spanArray0[1] = span1;
      spanArray0[2] = span0;
      spanArray0[3] = span0;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(2, spanArray1.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpans1()  throws Throwable  {
      Span[] spanArray0 = new Span[1];
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertNotSame(spanArray0, spanArray1);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpansAndDropOverlappingSpans1()  throws Throwable  {
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(913, 913, 0.0);
      spanArray0[0] = span0;
      NameFinderME.dropOverlappingSpans(spanArray0);
      URL uRL0 = MockURL.getFileExample();
      TokenNameFinderModel tokenNameFinderModel0 = null;
      try {
        tokenNameFinderModel0 = new TokenNameFinderModel(uRL0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"java.net.URLConnection.getInputStream()\" because the return value of \"java.net.URL.openConnection()\" is null
         //
         verifyException("java.net.URL", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractNameTypeReturningNull()  throws Throwable  {
      String string0 = "Unexpected trainer type!";
      NameFinderME.extractNameType("Unexpected trainer type!");
      File file0 = MockFile.createTempFile("Unexpected trainer type!", "Unexpected trainer type!");
      TokenNameFinderModel tokenNameFinderModel0 = null;
      try {
        tokenNameFinderModel0 = new TokenNameFinderModel(file0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"java.util.Properties.getProperty(String)\" because \"manifest\" is null
         //
         verifyException("opennlp.tools.util.model.BaseModel", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractNameTypeWithEmptyString()  throws Throwable  {
      String string0 = NameFinderME.extractNameType("");
      assertNull(string0);
  }
}
