/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 10:27:47 GMT 2025
 */

package opennlp.tools.namefind;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.FileDescriptor;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.Reader;
import java.net.URI;
import java.nio.charset.Charset;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.Stack;
import opennlp.tools.lemmatizer.DefaultLemmatizerSequenceValidator;
import opennlp.tools.ml.BeamSearch;
import opennlp.tools.ml.maxent.GISModel;
import opennlp.tools.ml.model.Context;
import opennlp.tools.ml.model.SequenceClassificationModel;
import opennlp.tools.ml.model.UniformPrior;
import opennlp.tools.namefind.NameContextGenerator;
import opennlp.tools.namefind.NameFinderME;
import opennlp.tools.namefind.NameSample;
import opennlp.tools.namefind.TokenNameFinderFactory;
import opennlp.tools.namefind.TokenNameFinderModel;
import opennlp.tools.parser.lang.en.HeadRules;
import opennlp.tools.postag.POSTaggerFactory;
import opennlp.tools.sentdetect.SentenceDetectorFactory;
import opennlp.tools.util.BeamSearchContextGenerator;
import opennlp.tools.util.CollectionObjectStream;
import opennlp.tools.util.ObjectStream;
import opennlp.tools.util.Sequence;
import opennlp.tools.util.SequenceCodec;
import opennlp.tools.util.SequenceValidator;
import opennlp.tools.util.Span;
import opennlp.tools.util.TrainingParameters;
import org.evosuite.runtime.EvoRunnerJUnit5;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFileInputStream;
import org.evosuite.runtime.mock.java.net.MockURI;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.EvoSuiteURL;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.testdata.NetworkHandling;
import org.junit.jupiter.api.extension.RegisterExtension;

@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class NameFinderME_2_ESTest extends NameFinderME_2_ESTest_scaffolding {
@RegisterExtension
  static EvoRunnerJUnit5 runner = new EvoRunnerJUnit5(NameFinderME_2_ESTest.class);

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrainThrowsIllegalStateException()  throws Throwable  {
      TrainingParameters trainingParameters0 = new TrainingParameters();
      trainingParameters0.put("Algorithm", "Algorithm");
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      // Undeclared exception!
      try { 
        NameFinderME.train("Algorithm", "Algorithm", (ObjectStream<NameSample>) null, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Unexpected trainer type!
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingNoArgumentsReturningEmptyArray()  throws Throwable  {
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      LinkedList<String> linkedList0 = new LinkedList<String>();
      double[] doubleArray0 = new double[10];
      doubleArray0[0] = 1160.166592004755;
      doubleArray0[1] = 0.1;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (-1768.0);
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (-1.0);
      double[] doubleArray1 = new double[0];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(linkedList0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) doubleArray0, (Object) doubleArray1).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[0];
      Span[] spanArray0 = nameFinderME0.find(stringArray0);
      nameFinderME0.probs(spanArray0);
      double[] doubleArray2 = nameFinderME0.probs();
      assertSame(doubleArray2, doubleArray1);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingNoArgumentsReturningNonEmptyArray()  throws Throwable  {
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      LinkedList<String> linkedList0 = new LinkedList<String>();
      double[] doubleArray0 = new double[10];
      doubleArray0[0] = 1188.0;
      doubleArray0[1] = 0.1;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (-1768.0);
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (-1.0);
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(linkedList0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) null, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[0];
      Span[] spanArray0 = nameFinderME0.find(stringArray0);
      nameFinderME0.probs(spanArray0);
      double[] doubleArray1 = nameFinderME0.probs();
      assertNull(doubleArray1);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingDoubleArrayAndFindTakingStringArray()  throws Throwable  {
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      LinkedHashSet<Locale.LanguageRange> linkedHashSet0 = new LinkedHashSet<Locale.LanguageRange>();
      LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>(linkedHashSet0);
      Charset charset0 = Charset.defaultCharset();
      Set<String> set0 = charset0.aliases();
      List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) set0);
      List<String> list1 = Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) list0);
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = 0.0;
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(list1).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[0];
      nameFinderME0.find(stringArray0);
      double[] doubleArray1 = new double[2];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      nameFinderME0.probs(doubleArray1);
      assertNotSame(doubleArray1, doubleArray0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingSpanArrayReturningEmptyArray()  throws Throwable  {
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      LinkedList<String> linkedList0 = new LinkedList<String>();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (-202.83);
      doubleArray0[1] = 0.0;
      doubleArray0[2] = (-637.007872753419);
      doubleArray0[3] = 0.0;
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(linkedList0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) null, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[0];
      Span[] spanArray0 = nameFinderME0.find(stringArray0);
      double[] doubleArray1 = nameFinderME0.probs(spanArray0);
      double[] doubleArray2 = nameFinderME0.probs(spanArray0);
      assertNotSame(doubleArray2, doubleArray1);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayReturningEmptyArray()  throws Throwable  {
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn((List) null).when(sequence0).getOutcomes();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"java.util.List.toArray(Object[])\" because \"c\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTaking2ArgumentsReturningEmptyArray()  throws Throwable  {
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Stack<Locale.LanguageRange> stack0 = new Stack<Locale.LanguageRange>();
      Reader reader0 = Reader.nullReader();
      HeadRules headRules0 = new HeadRules(reader0);
      Set<String> set0 = headRules0.getPunctuationTags();
      List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) stack0, (Collection<String>) set0);
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = 215.319;
      doubleArray0[1] = (-427.19);
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(list0).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0, (Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[0];
      nameFinderME0.find(stringArray0);
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0, (String[][]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingSpanArray()  throws Throwable  {
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      Span[] spanArray0 = new Span[1];
      // Undeclared exception!
      try { 
        nameFinderME0.probs(spanArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayThrowsNullPointerException0()  throws Throwable  {
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn((List) null).when(sequence0).getOutcomes();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"java.util.List.toArray(Object[])\" because \"c\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn((Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "");
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[3];
      Span[] spanArray0 = new Span[0];
      String[] stringArray0 = new String[4];
      stringArray0[0] = "";
      stringArray0[1] = "";
      nameFinderME0.clearAdaptiveData();
      stringArray0[2] = "";
      stringArray0[3] = "";
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTaking2ArgumentsThrowsIllegalArgumentException()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Context[] contextArray0 = new Context[9];
      int[] intArray0 = new int[4];
      intArray0[0] = 219;
      intArray0[1] = 219;
      intArray0[2] = 219;
      intArray0[3] = 219;
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = (double) 219;
      doubleArray0[1] = (double) 219;
      doubleArray0[2] = (double) 219;
      doubleArray0[3] = (double) 219;
      doubleArray0[4] = (double) 219;
      doubleArray0[5] = (double) 219;
      Context context0 = new Context(intArray0, doubleArray0);
      contextArray0[0] = context0;
      double[] doubleArray1 = new double[7];
      doubleArray1[0] = (double) 219;
      doubleArray1[1] = (double) 219;
      doubleArray1[2] = (double) 219;
      doubleArray1[3] = (double) 219;
      doubleArray1[4] = (double) 219;
      doubleArray1[5] = (double) 219;
      doubleArray1[6] = 0.0;
      Context context1 = new Context(intArray0, doubleArray1);
      contextArray0[1] = context1;
      Context context2 = new Context(intArray0, doubleArray0);
      contextArray0[2] = context2;
      int[] intArray1 = new int[9];
      intArray1[0] = 219;
      intArray1[1] = 219;
      intArray1[2] = 219;
      intArray1[3] = 219;
      intArray1[4] = 219;
      intArray1[5] = 219;
      intArray1[6] = 219;
      intArray1[7] = 219;
      intArray1[8] = (-306);
      Context context3 = new Context(intArray1, doubleArray0);
      contextArray0[3] = context3;
      Context context4 = new Context(intArray1, doubleArray1);
      contextArray0[4] = context4;
      Context context5 = new Context(intArray1, doubleArray1);
      contextArray0[5] = context5;
      double[] doubleArray2 = new double[7];
      doubleArray2[0] = 1.0;
      doubleArray2[1] = (double) 219;
      doubleArray2[2] = (double) 219;
      doubleArray2[3] = (double) 219;
      doubleArray2[4] = (double) 219;
      doubleArray2[5] = (double) 219;
      doubleArray2[6] = (double) 219;
      Context context6 = new Context(intArray0, doubleArray2);
      contextArray0[6] = context6;
      double[] doubleArray3 = new double[0];
      Context context7 = new Context(intArray0, doubleArray3);
      contextArray0[7] = context7;
      Context context8 = new Context(intArray0, doubleArray2);
      contextArray0[8] = context8;
      String[] stringArray0 = new String[8];
      stringArray0[0] = "\u0000-0";
      stringArray0[1] = "BhY-hB3_)&q";
      stringArray0[2] = ",wgSd?),hI?/g ]L";
      stringArray0[3] = "O";
      stringArray0[4] = "cN8zmmT4;P08";
      stringArray0[5] = "DwiW{";
      stringArray0[6] = "BeamSize";
      stringArray0[7] = "Ci";
      GISModel gISModel0 = new GISModel(contextArray0, stringArray0, stringArray0);
      BeamSearch<PipedInputStream> beamSearch0 = new BeamSearch<PipedInputStream>(219, gISModel0);
      PipedInputStream[] pipedInputStreamArray0 = new PipedInputStream[0];
      BeamSearchContextGenerator<PipedInputStream> beamSearchContextGenerator0 = (BeamSearchContextGenerator<PipedInputStream>) mock(BeamSearchContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceValidator<PipedInputStream> sequenceValidator1 = (SequenceValidator<PipedInputStream>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Sequence sequence0 = beamSearch0.bestSequence(pipedInputStreamArray0, contextArray0, beamSearchContextGenerator0, sequenceValidator1);
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "");
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      NameFinderME.extractNameType("");
      String[] stringArray1 = new String[6];
      stringArray1[0] = null;
      stringArray1[1] = "";
      stringArray1[2] = null;
      stringArray1[3] = "";
      stringArray1[4] = "";
      stringArray1[5] = "";
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray1, (String[][]) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The tokens and outcome arrays MUST have the same size!
         //
         verifyException("opennlp.tools.namefind.DefaultNameContextGenerator", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTaking2Arguments()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn((Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "");
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      NameFinderME.extractNameType("");
      String[] stringArray0 = new String[3];
      stringArray0[0] = "";
      stringArray0[1] = "";
      stringArray0[2] = "";
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0, (String[][]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayThrowsNullPointerException1()  throws Throwable  {
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn((Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[0];
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingNoArgumentsThrowsNullPointerException()  throws Throwable  {
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      // Undeclared exception!
      try { 
        nameFinderME0.probs();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingNoArguments()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "");
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "vg");
      double[] doubleArray0 = new double[3];
      byte[] byteArray0 = new byte[0];
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      // Undeclared exception!
      try { 
        nameFinderME0.probs();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingSpanArrayThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "");
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[3];
      Span[] spanArray0 = new Span[0];
      // Undeclared exception!
      try { 
        nameFinderME0.probs(spanArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingDoubleArrayThrowsNullPointerException()  throws Throwable  {
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[1];
      // Undeclared exception!
      try { 
        nameFinderME0.probs(doubleArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs(double[])\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingDoubleArrayAndProbsTakingDoubleArrayThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "");
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (-102.067608065406);
      doubleArray0[2] = (-4109.78261);
      // Undeclared exception!
      try { 
        nameFinderME0.probs(doubleArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs(double[])\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClearAdaptiveDataAndClearAdaptiveData()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn((SequenceClassificationModel) null).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClearAdaptiveData()  throws Throwable  {
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNameFinderME()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(defaultLemmatizerSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      Span[] spanArray0 = new Span[7];
      String string0 = "`]u5pp\"iS)ENkAWW4";
      Span span0 = new Span(0, 0, "`]u5pp\"iS)ENkAWW4");
      Span span1 = new Span(span0, 13);
      double double0 = 1467.6;
      Span span2 = new Span(span1, 1467.6);
      spanArray0[0] = span2;
      Span span3 = new Span(0, 688);
      spanArray0[1] = span3;
      int int0 = (-2156);
      Span span4 = null;
      try {
        span4 = new Span((-2156), (-2156), (-1388.757));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // start index must be zero or greater: -2156
         //
         verifyException("opennlp.tools.util.Span", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException0()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator) null).when(sequenceCodec0).createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn((NameContextGenerator) null).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn((SequenceClassificationModel) null).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.NameContextGenerator.addFeatureGenerator(opennlp.tools.util.featuregen.AdaptiveFeatureGenerator)\" because \"this.contextGenerator\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException1()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceCodec) null).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.SequenceCodec.createSequenceValidator()\" because \"this.seqCodec\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException2()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn((TokenNameFinderFactory) null).when(tokenNameFinderModel0).getFactory();
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderFactory.createSequenceCodec()\" because \"factory\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractNameTypeThrowsIllegalStateException()  throws Throwable  {
      // Undeclared exception!
      try { 
        NameFinderME.extractNameType("\u0000-0");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerExceptionAndDropOverlappingSpans()  throws Throwable  {
      Span[] spanArray0 = new Span[2];
      int int0 = 1375;
      double double0 = (-1716.364236721372);
      Span span0 = new Span(1375, 1375, (-1716.364236721372));
      spanArray0[0] = span0;
      Span span1 = new Span(1375, 1375, (-1716.364236721372));
      Span span2 = new Span(span1, 1375);
      Span[] spanArray1 = new Span[0];
      String[] stringArray0 = new String[0];
      Span.spansToStrings(spanArray1, stringArray0);
      spanArray0[1] = span0;
      NameFinderME.dropOverlappingSpans(spanArray0);
      URI uRI0 = MockURI.aFileURI;
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME((TokenNameFinderModel) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderModel.getFactory()\" because \"model\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpans0()  throws Throwable  {
      TrainingParameters.defaultParams();
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(8, 8, "begi+");
      spanArray0[0] = span0;
      Span span1 = new Span(span0, 8);
      spanArray0[1] = span1;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(2, spanArray1.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpans1()  throws Throwable  {
      TrainingParameters.defaultParams();
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(8, 8, "begi+");
      spanArray0[0] = span0;
      spanArray0[1] = span0;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(1, spanArray1.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpansReturningEmptyArray()  throws Throwable  {
      Span[] spanArray0 = new Span[0];
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(0, spanArray1.length);
      
      String string0 = "JC5?-$j+#";
      Context[] contextArray0 = new Context[7];
      int[] intArray0 = new int[9];
      intArray0[0] = 25;
      intArray0[1] = 1;
      intArray0[2] = 0;
      intArray0[3] = 3687;
      int int0 = (-100000);
      intArray0[4] = (-100000);
      intArray0[5] = 3775;
      intArray0[6] = 3750;
      intArray0[7] = 3282;
      intArray0[8] = 0;
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) 3750;
      doubleArray0[1] = (double) 3750;
      doubleArray0[2] = (double) 3750;
      doubleArray0[3] = (double) (-100000);
      doubleArray0[4] = (double) 3687;
      doubleArray0[5] = (double) 3687;
      doubleArray0[6] = (double) 3282;
      Context context0 = new Context(intArray0, doubleArray0);
      contextArray0[0] = context0;
      int[] intArray1 = new int[4];
      intArray1[0] = 25;
      intArray1[1] = (-100000);
      intArray1[2] = 0;
      intArray1[3] = 0;
      Context context1 = new Context(intArray1, doubleArray0);
      contextArray0[1] = context1;
      Context context2 = new Context(intArray1, doubleArray0);
      contextArray0[2] = context2;
      Context context3 = new Context(intArray1, doubleArray0);
      contextArray0[3] = context3;
      Context context4 = new Context(intArray0, doubleArray0);
      contextArray0[4] = context4;
      Context context5 = new Context(intArray1, doubleArray0);
      contextArray0[5] = context5;
      Context context6 = new Context(intArray1, doubleArray0);
      contextArray0[6] = context6;
      String[] stringArray0 = new String[8];
      stringArray0[0] = "JC5?-$j+#";
      stringArray0[1] = "JC5?-$j+#";
      stringArray0[2] = "JC5?-$j+#";
      stringArray0[3] = "JC5?-$j+#";
      stringArray0[4] = "";
      stringArray0[5] = "JC5?-$j+#";
      stringArray0[6] = "l1'1H?jS>Dt8s\"yK]";
      stringArray0[7] = "JC5?-$j+#";
      String[] stringArray1 = new String[9];
      stringArray1[0] = "JC5?-$j+#";
      stringArray1[1] = "l1'1H?jS>Dt8s\"yK]";
      stringArray1[2] = ";lF";
      stringArray1[3] = "l1'1H?jS>Dt8s\"yK]";
      stringArray1[4] = "";
      stringArray1[5] = "l1'1H?jS>Dt8s\"yK]";
      stringArray1[6] = "l1'1H?jS>Dt8s\"yK]";
      stringArray1[7] = "l1'1H?jS>Dt8s\"yK]";
      stringArray1[8] = "U*?";
      GISModel gISModel0 = null;
      try {
        gISModel0 = new GISModel(contextArray0, stringArray0, stringArray1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 7 out of bounds for length 7
         //
         verifyException("opennlp.tools.ml.model.AbstractModel", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException3()  throws Throwable  {
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME((TokenNameFinderModel) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderModel.getFactory()\" because \"model\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractNameTypeAndExtractNameTypeThrowsIllegalStateException()  throws Throwable  {
      String string0 = NameFinderME.OTHER;
      // Undeclared exception!
      try { 
        NameFinderME.extractNameType("\u0000-0");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractNameTypeReturningNull()  throws Throwable  {
      String string0 = "{}. ({}/{}) {}";
      NameFinderME.extractNameType("{}. ({}/{}) {}");
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      TokenNameFinderModel tokenNameFinderModel0 = null;
      try {
        tokenNameFinderModel0 = new TokenNameFinderModel(mockFileInputStream0);
        fail("Expecting exception: IOException");
      
      } catch(Throwable e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.mock.java.io.NativeMockedIO", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractNameType()  throws Throwable  {
      String string0 = NameFinderME.extractNameType("!1;^z:)eqhT");
      assertNull(string0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrain()  throws Throwable  {
      TrainingParameters trainingParameters0 = new TrainingParameters();
      trainingParameters0.put("Algorithm", "");
      trainingParameters0.getParameters("");
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      // Undeclared exception!
      try { 
        NameFinderME.train("PERCEPTRN", "PERCEPTRN", (ObjectStream<NameSample>) null, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Unexpected trainer type!
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsIOException()  throws Throwable  {
      String string0 = "6GW%,PB(C;-";
      LinkedHashSet<NameSample> linkedHashSet0 = new LinkedHashSet<NameSample>(11, 11);
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedHashSet0);
      TrainingParameters trainingParameters0 = TrainingParameters.defaultParams();
      collectionObjectStream0.reset();
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      try { 
        NameFinderME.train("6GW%,PB(C;-", "6GW%,PB(C;-", collectionObjectStream0, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Insufficient training data to create model.
         //
         verifyException("opennlp.tools.ml.model.AbstractDataIndexer", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrainThrowsNullPointerException()  throws Throwable  {
      TrainingParameters trainingParameters0 = new TrainingParameters();
      // Undeclared exception!
      try { 
        NameFinderME.train("TUn!eZ*/!&Y\rEhg", "TUn!eZ*/!&Y\rEhg", (ObjectStream<NameSample>) null, trainingParameters0, (TokenNameFinderFactory) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderFactory.createContextGenerator()\" because \"factory\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClearAdaptiveDataThrowsNoSuchFileException()  throws Throwable  {
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(1375, 1375, (-1716.364236721372));
      spanArray0[0] = span0;
      Span span1 = new Span(1375, 1375, (-1716.364236721372));
      Span span2 = new Span(span1, 1375);
      Span[] spanArray1 = new Span[0];
      String[] stringArray0 = new String[0];
      Span.spansToStrings(spanArray1, stringArray0);
      spanArray0[1] = span2;
      NameFinderME.dropOverlappingSpans(spanArray0);
      URI uRI0 = MockURI.aFileURI;
      Path path0 = Path.of(uRI0);
      TokenNameFinderModel tokenNameFinderModel0 = null;
      try {
        tokenNameFinderModel0 = new TokenNameFinderModel(path0);
        fail("Expecting exception: NoSuchFileException");
      
      } catch(Throwable e) {
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpans2()  throws Throwable  {
      Span[] spanArray0 = new Span[1];
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertNotSame(spanArray0, spanArray1);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpansAndDropOverlappingSpans()  throws Throwable  {
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(0, 0, 582.01);
      spanArray0[0] = span0;
      NameFinderME.dropOverlappingSpans(spanArray0);
      String string0 = "(.+)-\\w+";
      Context[] contextArray0 = new Context[6];
      int[] intArray0 = new int[6];
      intArray0[0] = 0;
      intArray0[1] = 0;
      intArray0[2] = 0;
      intArray0[3] = 0;
      intArray0[4] = 0;
      intArray0[5] = 0;
      double[] doubleArray0 = null;
      Context context0 = new Context(intArray0, (double[]) null);
      contextArray0[0] = context0;
      Context context1 = new Context(intArray0, (double[]) null);
      contextArray0[1] = context1;
      Context context2 = new Context(intArray0, (double[]) null);
      contextArray0[2] = context2;
      Context context3 = new Context(intArray0, (double[]) null);
      contextArray0[3] = context3;
      Context context4 = new Context(intArray0, (double[]) null);
      contextArray0[4] = context4;
      Context context5 = new Context(intArray0, (double[]) null);
      contextArray0[5] = context5;
      String[] stringArray0 = new String[1];
      stringArray0[0] = "(.+)-w+";
      UniformPrior uniformPrior0 = new UniformPrior();
      GISModel gISModel0 = new GISModel(contextArray0, stringArray0, stringArray0, uniformPrior0);
      byte[] byteArray0 = new byte[6];
      byteArray0[0] = (byte)0;
      byteArray0[1] = (byte)0;
      byteArray0[2] = (byte) (-1);
      byteArray0[3] = (byte)1;
      byteArray0[4] = (byte) (-4);
      byteArray0[5] = (byte)4;
      POSTaggerFactory pOSTaggerFactory0 = new POSTaggerFactory();
      pOSTaggerFactory0.createArtifactMap();
      SentenceDetectorFactory sentenceDetectorFactory0 = new SentenceDetectorFactory();
      // Undeclared exception!
      try { 
        sentenceDetectorFactory0.createManifestEntries();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"java.lang.Boolean.booleanValue()\" because \"this.useTokenEnd\" is null
         //
         verifyException("opennlp.tools.sentdetect.SentenceDetectorFactory", e);
      }
  }
}
