/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Sun Jul 13 10:27:29 GMT 2025
 */

package opennlp.tools.namefind;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.IOException;
import java.io.Reader;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import opennlp.tools.doccat.DoccatFactory;
import opennlp.tools.lemmatizer.DefaultLemmatizerSequenceValidator;
import opennlp.tools.ml.maxent.GISModel;
import opennlp.tools.ml.model.Context;
import opennlp.tools.ml.model.SequenceClassificationModel;
import opennlp.tools.ml.model.UniformPrior;
import opennlp.tools.ml.perceptron.PerceptronModel;
import opennlp.tools.namefind.BilouCodec;
import opennlp.tools.namefind.BioCodec;
import opennlp.tools.namefind.NameContextGenerator;
import opennlp.tools.namefind.NameFinderME;
import opennlp.tools.namefind.NameFinderSequenceValidator;
import opennlp.tools.namefind.NameSample;
import opennlp.tools.namefind.TokenNameFinderFactory;
import opennlp.tools.namefind.TokenNameFinderModel;
import opennlp.tools.parser.lang.en.HeadRules;
import opennlp.tools.postag.DefaultPOSSequenceValidator;
import opennlp.tools.postag.POSDictionary;
import opennlp.tools.tokenize.TokenizerFactory;
import opennlp.tools.util.CollectionObjectStream;
import opennlp.tools.util.ObjectStream;
import opennlp.tools.util.Sequence;
import opennlp.tools.util.SequenceCodec;
import opennlp.tools.util.SequenceValidator;
import opennlp.tools.util.Span;
import opennlp.tools.util.TrainingParameters;
import org.evosuite.runtime.EvoRunnerJUnit5;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.jupiter.api.extension.RegisterExtension;

@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, separateClassLoader = true) 
public class NameFinderME_1_ESTest extends NameFinderME_1_ESTest_scaffolding {
@RegisterExtension
  static EvoRunnerJUnit5 runner = new EvoRunnerJUnit5(NameFinderME_1_ESTest.class);

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTaking2ArgumentsAndFindTakingStringArray()  throws Throwable  {
      Context[] contextArray0 = new Context[2];
      int[] intArray0 = new int[8];
      intArray0[0] = 2147483645;
      intArray0[1] = 2147483645;
      intArray0[2] = 8;
      intArray0[3] = 1079;
      intArray0[4] = (-2118);
      intArray0[5] = 1153;
      intArray0[7] = 3;
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 1153;
      doubleArray0[1] = (double) 2147483645;
      Context context0 = new Context(intArray0, doubleArray0);
      contextArray0[0] = context0;
      Context context1 = new Context(intArray0, doubleArray0);
      contextArray0[1] = context1;
      String[] stringArray0 = new String[1];
      stringArray0[0] = "start";
      UniformPrior uniformPrior0 = new UniformPrior();
      GISModel gISModel0 = new GISModel(contextArray0, stringArray0, stringArray0, uniformPrior0);
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      Map<String, Object> map0 = tokenNameFinderFactory0.createArtifactMap();
      DoccatFactory doccatFactory0 = new DoccatFactory();
      Map<String, String> map1 = doccatFactory0.createManifestEntries();
      TokenNameFinderModel tokenNameFinderModel0 = new TokenNameFinderModel("start", gISModel0, map0, map1);
      tokenNameFinderFactory0.createArtifactSerializersMap();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.find(stringArray0);
      System.setCurrentTimeMillis(1079);
      String[][] stringArray1 = new String[8][2];
      stringArray1[0] = stringArray0;
      stringArray1[1] = stringArray0;
      stringArray1[2] = stringArray0;
      stringArray1[3] = stringArray0;
      stringArray1[4] = stringArray0;
      stringArray1[5] = stringArray0;
      stringArray1[6] = stringArray0;
      stringArray1[7] = stringArray0;
      Span[] spanArray0 = nameFinderME0.find(stringArray0, stringArray1);
      assertEquals(1, spanArray0.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingNoArgumentsReturningNull()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[0];
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator<String>) null).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      double[] doubleArray0 = new double[1];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(linkedList0).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      Sequence sequence1 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn((List) null).when(sequence1).getOutcomes();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0, sequence1).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      linkedList0.add("I");
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[1];
      nameFinderME0.find(stringArray0);
      LinkedList<NameSample> linkedList1 = new LinkedList<NameSample>();
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedList1);
      HashMap<String, Object> hashMap0 = new HashMap<String, Object>();
      int int0 = 40;
      hashMap0.put("Algorithm", "F|R");
      Span span0 = new Span(40, 40, "start");
      Span span1 = new Span(span0, (double) 40);
      TrainingParameters trainingParameters0 = new TrainingParameters(hashMap0);
      trainingParameters0.putIfAbsent("I", 40);
      trainingParameters0.put("b.GL#)n_$}%0", "F|R", 0.0);
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"java.util.List.toArray(Object[])\" because \"c\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrain()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[0];
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator<String>) null).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      double[] doubleArray0 = new double[1];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(linkedList0).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0, (Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      linkedList0.add("I");
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[1];
      nameFinderME0.find(stringArray0);
      LinkedList<NameSample> linkedList1 = new LinkedList<NameSample>();
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedList1);
      HashMap<String, Object> hashMap0 = new HashMap<String, Object>();
      hashMap0.put("Algorithm", "F|R");
      Span span0 = new Span(40, 40, "start");
      Span span1 = new Span(span0, (double) 40);
      TrainingParameters trainingParameters0 = new TrainingParameters(hashMap0);
      trainingParameters0.putIfAbsent("I", 40);
      trainingParameters0.put("b.GL#)n_$}%0", "F|R", 0.0);
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrainThrowsIllegalStateException()  throws Throwable  {
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      TrainingParameters trainingParameters0 = new TrainingParameters();
      trainingParameters0.put("Algorithm", "Algorithm");
      // Undeclared exception!
      try { 
        NameFinderME.train("Algorithm", "Algorithm", (ObjectStream<NameSample>) null, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Unexpected trainer type!
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrainThrowsConcurrentModificationException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[0];
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator<String>) null).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      DefaultLemmatizerSequenceValidator defaultLemmatizerSequenceValidator0 = new DefaultLemmatizerSequenceValidator();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      double[] doubleArray0 = new double[1];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(linkedList0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      String string0 = "I";
      linkedList0.add("I");
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[1];
      nameFinderME0.find(stringArray0);
      LinkedList<NameSample> linkedList1 = new LinkedList<NameSample>();
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedList1);
      HashMap<String, Object> hashMap0 = new HashMap<String, Object>();
      NameSample nameSample0 = NameSample.parse("I", true);
      NameSample.parse("F|R", false);
      linkedList1.offerFirst(nameSample0);
      TrainingParameters trainingParameters0 = new TrainingParameters(hashMap0);
      trainingParameters0.put("cont", "I", (-3077));
      nameFinderME0.probs();
      trainingParameters0.putIfAbsent("F|R", (-780));
      TokenNameFinderFactory tokenNameFinderFactory1 = new TokenNameFinderFactory();
      // Undeclared exception!
      try { 
        NameFinderME.train("I", "F|R", collectionObjectStream0, trainingParameters0, tokenNameFinderFactory1);
        fail("Expecting exception: ConcurrentModificationException");
      
      } catch(ConcurrentModificationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.LinkedList$ListItr", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingNoArgumentsReturningEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[0];
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator<String>) null).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      LinkedList<String> linkedList0 = new LinkedList<String>();
      double[] doubleArray0 = new double[0];
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(linkedList0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0, (Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[1];
      nameFinderME0.find(stringArray0);
      nameFinderME0.probs();
      String[][] stringArray1 = new String[7][1];
      stringArray1[0] = stringArray0;
      stringArray1[1] = stringArray0;
      stringArray1[2] = stringArray0;
      stringArray1[3] = stringArray0;
      stringArray1[4] = stringArray0;
      stringArray1[5] = stringArray0;
      String[] stringArray2 = new String[4];
      stringArray2[0] = "^+W@(zS)r";
      stringArray2[1] = "mRpt2V;";
      stringArray2[2] = "";
      stringArray2[3] = "RN";
      stringArray1[6] = stringArray2;
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0, stringArray1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingSpanArrayReturningNonEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(8, 8, "OnePassRealValue");
      spanArray0[0] = span0;
      BioCodec bioCodec0 = new BioCodec();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Stack<String> stack0 = new Stack<String>();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 8;
      doubleArray0[1] = (double) 8;
      doubleArray0[2] = (double) 8;
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(stack0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[9];
      stringArray0[0] = "RD5IC(ht,=# b";
      stringArray0[1] = "RD5IC(ht,=# b";
      stringArray0[2] = "~5@a";
      stringArray0[3] = "RD5IC(ht,=# b";
      stringArray0[4] = "BeamSize";
      String[] stringArray1 = new String[1];
      stringArray1[0] = "-HGI#";
      nameFinderME0.find(stringArray1);
      double[] doubleArray1 = nameFinderME0.probs(spanArray0);
      assertArrayEquals(new double[] {Double.NaN}, doubleArray1, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingSpanArrayReturningEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(8, 1079, "OnePassRealValue");
      spanArray0[0] = span0;
      BioCodec bioCodec0 = new BioCodec();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      List<String> list0 = List.of();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 1079;
      doubleArray0[1] = (double) 8;
      doubleArray0[2] = (double) 8;
      doubleArray0[3] = (double) 1079;
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(list0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[9];
      stringArray0[0] = "RD5IC(ht,=# b";
      stringArray0[1] = "RD5IC(ht,=# b";
      stringArray0[2] = "~5@a";
      stringArray0[3] = "RD5IC(ht,=# b";
      stringArray0[4] = "BeamSize";
      stringArray0[5] = "RD5IC(ht,=# b";
      stringArray0[6] = "RD5IC(ht,=# b";
      stringArray0[7] = "RD5IC(ht,=# b";
      stringArray0[8] = "start";
      Span[] spanArray1 = nameFinderME0.find(stringArray0);
      Span[] spanArray2 = new Span[2];
      spanArray2[0] = span0;
      spanArray2[1] = span0;
      double[] doubleArray1 = nameFinderME0.probs(spanArray1);
      assertArrayEquals(new double[] {}, doubleArray1, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTaking2ArgumentsReturningEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(8, 1079, "OnePassRealValue");
      spanArray0[0] = span0;
      BioCodec bioCodec0 = new BioCodec();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      List<String> list0 = List.of();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 1079;
      doubleArray0[1] = (double) 8;
      doubleArray0[2] = (double) 8;
      doubleArray0[3] = (double) 1079;
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(list0).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0, (Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[9];
      stringArray0[0] = "RD5IC(ht,=# b";
      stringArray0[1] = "RD5IC(ht,=# b";
      stringArray0[2] = "~5@a";
      stringArray0[3] = "RD5IC(ht,=# b";
      stringArray0[4] = "BeamSize";
      stringArray0[5] = "RD5IC(ht,=# b";
      stringArray0[6] = "RD5IC(ht,=# b";
      stringArray0[7] = "RD5IC(ht,=# b";
      stringArray0[8] = "-HGI#";
      nameFinderME0.find(stringArray0);
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingDoubleArrayAndFindTakingStringArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(8, 1079, "OnePassRealValue");
      spanArray0[0] = span0;
      BioCodec bioCodec0 = new BioCodec();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      List<String> list0 = List.of();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 1079;
      doubleArray0[1] = (double) 8;
      doubleArray0[2] = (double) 8;
      doubleArray0[3] = (double) 1079;
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(list0).when(sequence0).getOutcomes();
      doReturn(doubleArray0).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[9];
      stringArray0[0] = "RD5IC(ht,=# b";
      stringArray0[1] = "RD5IC(ht,=# b";
      stringArray0[2] = "~5@a";
      stringArray0[3] = "RD5IC(ht,=# b";
      stringArray0[4] = "BeamSize";
      stringArray0[5] = "RD5IC(ht,=# b";
      stringArray0[6] = "RD5IC(ht,=# b";
      stringArray0[7] = "RD5IC(ht,=# b";
      stringArray0[8] = "-HGI#";
      nameFinderME0.find(stringArray0);
      nameFinderME0.probs(doubleArray0);
      assertArrayEquals(new double[] {1079.0, 8.0, 8.0, 1079.0}, doubleArray0, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingSpanArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator<String>) null).when(sequenceCodec0).createSequenceValidator();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      Span[] spanArray0 = new Span[1];
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)3;
      byteArray0[1] = (byte)37;
      byteArray0[2] = (byte)13;
      byteArray0[3] = (byte) (-97);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      Span span0 = new Span(2295, 2295, "", 2295);
      // Undeclared exception!
      try { 
        nameFinderME0.probs(spanArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayAndProbsTakingSpanArrayThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(8, 1079, "OnePassRealValue");
      spanArray0[0] = span0;
      BioCodec bioCodec0 = new BioCodec();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      List<String> list0 = List.of();
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (double) 1079;
      doubleArray0[1] = (double) 8;
      doubleArray0[2] = (double) 8;
      doubleArray0[3] = (double) 1079;
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(list0).when(sequence0).getOutcomes();
      doReturn((Object) doubleArray0, (Object) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[9];
      stringArray0[0] = "RD5IC(ht,=# b";
      stringArray0[1] = "RD5IC(ht,=# b";
      stringArray0[2] = "~5@a";
      stringArray0[3] = "RD5IC(ht,=# b";
      stringArray0[4] = "BeamSize";
      stringArray0[5] = "RD5IC(ht,=# b";
      stringArray0[6] = "RD5IC(ht,=# b";
      stringArray0[7] = "RD5IC(ht,=# b";
      stringArray0[8] = "-HGI#";
      nameFinderME0.find(stringArray0);
      Span[] spanArray1 = new Span[3];
      spanArray1[0] = span0;
      spanArray1[1] = span0;
      spanArray1[2] = span0;
      // Undeclared exception!
      try { 
        nameFinderME0.probs(spanArray1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot load from double array
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayReturningNonEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[3];
      Span span0 = new Span(99999, 99999, "Z!&7v#oR~", (-713.291003152));
      spanArray0[0] = span0;
      Span span1 = new Span(99999, 99999);
      spanArray0[1] = span1;
      Span span2 = new Span(0, 0, "Z!&7v#oR~");
      spanArray0[2] = span2;
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator<String>) null).when(sequenceCodec0).createSequenceValidator();
      doReturn(spanArray0).when(sequenceCodec0).decode(anyList());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Stack<Locale.LanguageRange> stack0 = new Stack<Locale.LanguageRange>();
      Reader reader0 = Reader.nullReader();
      HeadRules headRules0 = new HeadRules(reader0);
      Set<String> set0 = headRules0.getPunctuationTags();
      List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) stack0, (Collection<String>) set0);
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(list0).when(sequence0).getOutcomes();
      doReturn((double[]) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[9];
      stringArray0[0] = "RD5IC(ht,=# b";
      stringArray0[1] = "(<>m}0?6JD$7`m";
      stringArray0[2] = "~5@a";
      stringArray0[3] = "RD5IC(ht,=# b";
      stringArray0[4] = "BeamSize";
      stringArray0[5] = "RD5IC(ht,=# b";
      stringArray0[6] = "RD5IC(ht,=# b";
      stringArray0[7] = "RD5IC(ht,=# b";
      stringArray0[8] = "-HGI#";
      nameFinderME0.find(stringArray0);
      String string0 = NameFinderME.extractNameType("~5@a");
      assertNull(string0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayReturningEmptyArray()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(8, 1079, "OnePassRealValue");
      spanArray0[0] = span0;
      SequenceCodec<String> sequenceCodec0 = new BioCodec();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      List<String> list0 = List.of();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn(list0).when(sequence0).getOutcomes();
      doReturn((double[]) null).when(sequence0).getProbs();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[9];
      stringArray0[0] = "RD5IC(ht,=# b";
      stringArray0[1] = "RD5IC(ht,=# b";
      stringArray0[2] = "~5@a";
      stringArray0[3] = "RD5IC(ht,=# b";
      stringArray0[4] = "BeamSize";
      stringArray0[5] = "RD5IC(ht,=# b";
      stringArray0[6] = "RD5IC(ht,=# b";
      stringArray0[7] = "RD5IC(ht,=# b";
      stringArray0[8] = "-HGI#";
      nameFinderME0.find(stringArray0);
      Span span1 = null;
      try {
        span1 = new Span(2147483645, (-37));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // end index must be zero or greater: -37
         //
         verifyException("opennlp.tools.util.Span", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator<String>) null).when(sequenceCodec0).createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      doReturn((List) null).when(sequence0).getOutcomes();
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn(sequence0).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      String[] stringArray0 = new String[9];
      stringArray0[0] = "RD5IC(ht,=# b";
      stringArray0[1] = "(<>m}0?6JD$7`m";
      stringArray0[2] = "~5@a";
      stringArray0[3] = "RD5IC(ht,=# b";
      stringArray0[4] = "BeamSize";
      stringArray0[5] = "RD5IC(ht,=# b";
      stringArray0[6] = "RD5IC(ht,=# b";
      stringArray0[7] = "RD5IC(ht,=# b";
      stringArray0[8] = "-HGI#";
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"java.util.List.toArray(Object[])\" because \"c\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTaking2ArgumentsAndFindTaking2ArgumentsThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      NameFinderSequenceValidator nameFinderSequenceValidator0 = new NameFinderSequenceValidator();
      BilouCodec bilouCodec0 = new BilouCodec();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn((Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bilouCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      String[] stringArray0 = new String[0];
      String[][] stringArray1 = new String[7][4];
      stringArray1[0] = stringArray0;
      String[] stringArray2 = new String[8];
      stringArray2[0] = "QY";
      stringArray2[1] = "\u0000-0";
      stringArray2[2] = "";
      stringArray2[3] = "\u0000-0";
      stringArray2[4] = "LQ<xo%^wL";
      stringArray2[5] = "'/T5xc";
      stringArray2[6] = "FyR~ynJ$5cV)";
      stringArray2[7] = "";
      stringArray1[1] = stringArray2;
      stringArray1[2] = stringArray0;
      String[] stringArray3 = new String[1];
      stringArray3[0] = "'/T5xc";
      stringArray1[3] = stringArray3;
      String[] stringArray4 = new String[4];
      stringArray4[0] = "";
      stringArray4[1] = "FyR~ynJ$5cV)";
      stringArray4[2] = "";
      stringArray4[3] = "\u0000-0";
      stringArray1[4] = stringArray4;
      stringArray1[5] = stringArray0;
      stringArray1[6] = stringArray0;
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0, stringArray1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFindTakingStringArrayAndFindTakingStringArrayThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator<String>) null).when(sequenceCodec0).createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      doReturn((Sequence) null).when(sequenceClassificationModel0).bestSequence(any(java.lang.String[].class) , any(java.lang.Object[].class) , any(opennlp.tools.util.BeamSearchContextGenerator.class) , any(opennlp.tools.util.SequenceValidator.class));
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      Span[] spanArray0 = new Span[1];
      String[] stringArray0 = new String[5];
      String string0 = "RD5IC(ht,=# b";
      stringArray0[0] = "RD5IC(ht,=# b";
      stringArray0[1] = "Cutoff";
      stringArray0[2] = "BeamSize";
      stringArray0[3] = "(<>m}0?6JD$7`m";
      stringArray0[4] = "~5@a";
      // Undeclared exception!
      try { 
        nameFinderME0.find(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getOutcomes()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingNoArgumentsThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      BioCodec bioCodec0 = new BioCodec();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      Sequence sequence0 = mock(Sequence.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bioCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      // Undeclared exception!
      try { 
        nameFinderME0.probs();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingNoArguments()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator<String>) null).when(sequenceCodec0).createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      // Undeclared exception!
      try { 
        nameFinderME0.probs();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClearAdaptiveDataAndProbsTakingSpanArrayThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator<String>) null).when(sequenceCodec0).createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      Span[] spanArray0 = new Span[1];
      Span span0 = new Span(2147483645, 2147483645);
      spanArray0[0] = span0;
      // Undeclared exception!
      try { 
        nameFinderME0.probs(spanArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs()\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingDoubleArrayThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      NameFinderSequenceValidator nameFinderSequenceValidator0 = new NameFinderSequenceValidator();
      BilouCodec bilouCodec0 = new BilouCodec();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(bilouCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[9];
      // Undeclared exception!
      try { 
        nameFinderME0.probs(doubleArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs(double[])\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbsTakingDoubleArrayAndProbsTakingDoubleArrayThrowsNullPointerException()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      NameFinderSequenceValidator nameFinderSequenceValidator0 = new NameFinderSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = new BilouCodec();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = (-1302.6639168502);
      doubleArray0[1] = (-3230.8636);
      doubleArray0[2] = (-1.0);
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 1606.0;
      doubleArray0[5] = (-2086.5053904378024);
      doubleArray0[6] = 0.1;
      doubleArray0[7] = 0.0;
      doubleArray0[8] = 2781.7581122983706;
      // Undeclared exception!
      try { 
        nameFinderME0.probs(doubleArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.Sequence.getProbs(double[])\" because \"this.bestSequence\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClearAdaptiveDataAndClearAdaptiveData()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      NameFinderSequenceValidator nameFinderSequenceValidator0 = new NameFinderSequenceValidator();
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(nameFinderSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      nameFinderME0.clearAdaptiveData();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNameFinderME()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      POSDictionary pOSDictionary0 = new POSDictionary(true);
      DefaultPOSSequenceValidator defaultPOSSequenceValidator0 = new DefaultPOSSequenceValidator(pOSDictionary0);
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn(defaultPOSSequenceValidator0).when(sequenceCodec0).createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn(nameContextGenerator0).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn(sequenceClassificationModel0).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = 2272.5;
      doubleArray0[1] = 1.0E-7;
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[4] = 2.0;
      String string0 = "PERCEPTRON";
      String[] stringArray0 = new String[4];
      stringArray0[0] = "PERCEPTRON";
      stringArray0[1] = "PERCEPTRON";
      stringArray0[2] = "PERCEPTRON";
      stringArray0[3] = "PERCEPTRON";
      GISModel gISModel0 = null;
      try {
        gISModel0 = new GISModel((Context[]) null, stringArray0, stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot load from object array because \"params\" is null
         //
         verifyException("opennlp.tools.ml.model.AbstractModel", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException0()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceValidator) null).when(sequenceCodec0).createSequenceValidator();
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn((NameContextGenerator) null).when(tokenNameFinderFactory0).createContextGenerator();
      doReturn(sequenceCodec0).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      doReturn((SequenceClassificationModel) null).when(tokenNameFinderModel0).getNameFinderSequenceModel();
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.NameContextGenerator.addFeatureGenerator(opennlp.tools.util.featuregen.AdaptiveFeatureGenerator)\" because \"this.contextGenerator\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException1()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      doReturn((SequenceCodec) null).when(tokenNameFinderFactory0).createSequenceCodec();
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn(tokenNameFinderFactory0).when(tokenNameFinderModel0).getFactory();
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.SequenceCodec.createSequenceValidator()\" because \"this.seqCodec\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException2()  throws Throwable  {
      NameContextGenerator nameContextGenerator0 = mock(NameContextGenerator.class, new ViolatedAssumptionAnswer());
      SequenceCodec<String> sequenceCodec0 = (SequenceCodec<String>) mock(SequenceCodec.class, new ViolatedAssumptionAnswer());
      SequenceValidator<String> sequenceValidator0 = (SequenceValidator<String>) mock(SequenceValidator.class, new ViolatedAssumptionAnswer());
      SequenceClassificationModel<String> sequenceClassificationModel0 = (SequenceClassificationModel<String>) mock(SequenceClassificationModel.class, new ViolatedAssumptionAnswer());
      TokenNameFinderFactory tokenNameFinderFactory0 = mock(TokenNameFinderFactory.class, new ViolatedAssumptionAnswer());
      TokenNameFinderModel tokenNameFinderModel0 = mock(TokenNameFinderModel.class, new ViolatedAssumptionAnswer());
      doReturn((TokenNameFinderFactory) null).when(tokenNameFinderModel0).getFactory();
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME(tokenNameFinderModel0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderFactory.createSequenceCodec()\" because \"factory\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpansAndDropOverlappingSpans0()  throws Throwable  {
      Span[] spanArray0 = new Span[4];
      String string0 = "X:`]`?\"V{He4;sB";
      Span span0 = new Span(3239, 3239, "X:`]`?\"V{He4;sB");
      spanArray0[0] = span0;
      Span span1 = new Span(span0, 3239);
      spanArray0[1] = span1;
      span1.toString();
      Span span2 = new Span(3239, 3239);
      spanArray0[2] = span2;
      Span span3 = new Span(span2, 3239);
      spanArray0[3] = span3;
      NameFinderME.dropOverlappingSpans(spanArray0);
      String string1 = "sR2!vatm";
      Context[] contextArray0 = new Context[5];
      int[] intArray0 = new int[7];
      intArray0[0] = 3239;
      intArray0[1] = 3239;
      intArray0[2] = 3239;
      intArray0[3] = 3239;
      intArray0[4] = 3239;
      intArray0[5] = 3239;
      intArray0[6] = 3239;
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = 0.0;
      doubleArray0[1] = (double) 3239;
      doubleArray0[2] = (double) 3239;
      doubleArray0[3] = (double) 3239;
      doubleArray0[4] = (double) 3239;
      doubleArray0[5] = (double) 3239;
      Context context0 = new Context(intArray0, doubleArray0);
      contextArray0[0] = context0;
      Context context1 = new Context(intArray0, doubleArray0);
      contextArray0[1] = context1;
      Context context2 = new Context(intArray0, doubleArray0);
      contextArray0[2] = context2;
      Context context3 = new Context(intArray0, doubleArray0);
      contextArray0[3] = context3;
      Context context4 = new Context(intArray0, doubleArray0);
      contextArray0[4] = context4;
      String[] stringArray0 = new String[6];
      stringArray0[0] = "sR2!vatm";
      stringArray0[1] = "X:`]`?\"V{He4;sB";
      stringArray0[2] = "X:`]`?\"V{He4;sB";
      stringArray0[3] = "X:`]`?\"V{He4;sB";
      stringArray0[4] = "X:`]`?\"V{He4;sB";
      stringArray0[5] = "X:`]`?\"V{He4;sB";
      PerceptronModel perceptronModel0 = null;
      try {
        perceptronModel0 = new PerceptronModel(contextArray0, stringArray0, stringArray0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 5 out of bounds for length 5
         //
         verifyException("opennlp.tools.ml.model.AbstractModel", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractNameTypeAndDropOverlappingSpans()  throws Throwable  {
      NameFinderME.extractNameType("Unexpected trainer type!");
      Span[] spanArray0 = new Span[3];
      Span span0 = new Span(327, 327, (String) null, 327);
      spanArray0[0] = span0;
      spanArray0[1] = span0;
      Span span1 = new Span(span0, 327);
      spanArray0[2] = span1;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(2, spanArray1.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpans0()  throws Throwable  {
      Span[] spanArray0 = new Span[2];
      Span span0 = new Span(752757853, 752757853);
      spanArray0[0] = span0;
      Span span1 = new Span(span0, (double) 752757853);
      spanArray0[1] = span1;
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(1, spanArray1.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpansAndDropOverlappingSpans1()  throws Throwable  {
      byte[] byteArray0 = new byte[0];
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      System.setCurrentTimeMillis((-1716L));
      Span[] spanArray0 = new Span[1];
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertNotSame(spanArray1, spanArray0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpans1()  throws Throwable  {
      Span[] spanArray0 = new Span[1];
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertNotSame(spanArray0, spanArray1);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpansWithEmptyArray()  throws Throwable  {
      Span[] spanArray0 = new Span[0];
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(0, spanArray1.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpansReturningEmptyArray()  throws Throwable  {
      System.setCurrentTimeMillis((-1716L));
      System.setCurrentTimeMillis(0L);
      Span[] spanArray0 = new Span[0];
      Span[] spanArray1 = NameFinderME.dropOverlappingSpans(spanArray0);
      assertEquals(0, spanArray1.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDropOverlappingSpansThrowsNullPointerException()  throws Throwable  {
      String string0 = NameFinderME.extractNameType("");
      assertNull(string0);
      
      // Undeclared exception!
      try { 
        NameFinderME.dropOverlappingSpans((Span[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot read the array length because \"spans\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractNameTypeThrowsIllegalStateException()  throws Throwable  {
      // Undeclared exception!
      try { 
        NameFinderME.extractNameType("\u0000-0");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrainThrowsIOException()  throws Throwable  {
      LinkedHashSet<NameSample> linkedHashSet0 = new LinkedHashSet<NameSample>();
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedHashSet0);
      String[] stringArray0 = new String[2];
      stringArray0[0] = "";
      stringArray0[1] = "";
      TrainingParameters trainingParameters0 = TrainingParameters.setParams(stringArray0);
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      try { 
        NameFinderME.train("", "", collectionObjectStream0, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Insufficient training data to create model.
         //
         verifyException("opennlp.tools.ml.model.AbstractDataIndexer", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateNameFinderMEThrowsNullPointerException3()  throws Throwable  {
      NameFinderME nameFinderME0 = null;
      try {
        nameFinderME0 = new NameFinderME((TokenNameFinderModel) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.namefind.TokenNameFinderModel.getFactory()\" because \"model\" is null
         //
         verifyException("opennlp.tools.namefind.NameFinderME", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrainThrowsRuntimeException()  throws Throwable  {
      LinkedHashSet<NameSample> linkedHashSet0 = new LinkedHashSet<NameSample>();
      CollectionObjectStream<NameSample> collectionObjectStream0 = new CollectionObjectStream<NameSample>(linkedHashSet0);
      TokenizerFactory tokenizerFactory0 = new TokenizerFactory();
      Map<String, Object> map0 = tokenizerFactory0.createArtifactMap();
      TrainingParameters trainingParameters0 = new TrainingParameters(map0);
      byte[] byteArray0 = new byte[2];
      byteArray0[0] = (byte)0;
      byteArray0[1] = (byte)3;
      BioCodec bioCodec0 = new BioCodec();
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory(byteArray0, map0, bioCodec0);
      // Undeclared exception!
      try { 
        NameFinderME.train("i!px`d6%}{", "PERCEPTRON", collectionObjectStream0, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // org.evosuite.runtime.mock.java.lang.MockThrowable: Descriptor is not valid XML!
         //
         verifyException("opennlp.tools.namefind.TokenNameFinderFactory", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrainThrowsNullPointerException()  throws Throwable  {
      TrainingParameters trainingParameters0 = new TrainingParameters();
      TokenNameFinderFactory tokenNameFinderFactory0 = new TokenNameFinderFactory();
      // Undeclared exception!
      try { 
        NameFinderME.train("", "", (ObjectStream<NameSample>) null, trainingParameters0, tokenNameFinderFactory0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"opennlp.tools.util.ObjectStream.read()\" because \"this.samples\" is null
         //
         verifyException("opennlp.tools.util.AbstractEventStream", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractNameTypeAndExtractNameTypeThrowsIllegalStateException()  throws Throwable  {
      String string0 = "\u0000-0";
      // Undeclared exception!
      try { 
        NameFinderME.extractNameType("\u0000-0");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No match found
         //
         verifyException("java.util.regex.Matcher", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractNameTypeReturningNull()  throws Throwable  {
      NameFinderME.extractNameType("");
      String string0 = "";
      Context[] contextArray0 = new Context[4];
      int[] intArray0 = new int[8];
      intArray0[0] = 0;
      intArray0[1] = (-2226);
      intArray0[2] = 22;
      intArray0[3] = 973;
      intArray0[4] = 0;
      intArray0[5] = 0;
      intArray0[6] = 0;
      intArray0[7] = 0;
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = 1.0E-5;
      doubleArray0[2] = (double) 0;
      doubleArray0[3] = 192.261649;
      doubleArray0[4] = (double) 0;
      doubleArray0[5] = 0.0;
      doubleArray0[6] = (double) 0;
      doubleArray0[7] = (double) 0;
      doubleArray0[8] = (double) 0;
      Context context0 = new Context(intArray0, doubleArray0);
      contextArray0[0] = context0;
      int[] intArray1 = new int[0];
      Context context1 = new Context(intArray1, doubleArray0);
      contextArray0[1] = context1;
      Context context2 = new Context(intArray1, doubleArray0);
      contextArray0[2] = context2;
      Context context3 = new Context(intArray0, doubleArray0);
      contextArray0[3] = context3;
      String[] stringArray0 = new String[9];
      stringArray0[0] = "";
      stringArray0[1] = "";
      stringArray0[2] = "";
      stringArray0[3] = "";
      stringArray0[4] = null;
      stringArray0[5] = "";
      stringArray0[6] = "";
      stringArray0[7] = "";
      stringArray0[8] = "";
      PerceptronModel perceptronModel0 = null;
      try {
        perceptronModel0 = new PerceptronModel(contextArray0, stringArray0, stringArray0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // Index 4 out of bounds for length 4
         //
         verifyException("opennlp.tools.ml.model.AbstractModel", e);
      }
  }
}
